{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "CodeGenerator",
      "right" : "CodeGenerator",
      "info" : "TypeDeclaration[1035-36353]:TypeDeclaration[1035-36397]"
    }, {
      "left" : "private static final char[] HEX_CHARS\n      = { '0', '1', '2', '3', '4', '5', '6', '7',\n          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };",
      "right" : "private static final char[] HEX_CHARS\n      = { '0', '1', '2', '3', '4', '5', '6', '7',\n          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };",
      "info" : "FieldDeclaration[1168-1307]:FieldDeclaration[1168-1307]"
    }, {
      "left" : "private final CodeConsumer cc;",
      "right" : "private final CodeConsumer cc;",
      "info" : "FieldDeclaration[1311-1341]:FieldDeclaration[1311-1341]"
    }, {
      "left" : "private final CharsetEncoder outputCharsetEncoder;",
      "right" : "private final CharsetEncoder outputCharsetEncoder;",
      "info" : "FieldDeclaration[1345-1395]:FieldDeclaration[1345-1395]"
    }, {
      "left" : "CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset)",
      "right" : "CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset)",
      "info" : "MethodDeclaration[1399-1959]:MethodDeclaration[1399-1959]"
    }, {
      "left" : "CodeGenerator(CodeConsumer consumer)",
      "right" : "CodeGenerator(CodeConsumer consumer)",
      "info" : "MethodDeclaration[1963-2031]:MethodDeclaration[1963-2031]"
    }, {
      "left" : "public void tagAsStrict()",
      "right" : "public void tagAsStrict()",
      "info" : "MethodDeclaration[2035-2150]:MethodDeclaration[2035-2150]"
    }, {
      "left" : "void add(String str)",
      "right" : "void add(String str)",
      "info" : "MethodDeclaration[2154-2197]:MethodDeclaration[2154-2197]"
    }, {
      "left" : "private void addIdentifier(String identifier)",
      "right" : "private void addIdentifier(String identifier)",
      "info" : "MethodDeclaration[2201-2304]:MethodDeclaration[2201-2304]"
    }, {
      "left" : "void add(Node n)",
      "right" : "void add(Node n)",
      "info" : "MethodDeclaration[2308-2357]:MethodDeclaration[2308-2357]"
    }, {
      "left" : "void add(Node n, Context context)",
      "right" : "void add(Node n, Context context)",
      "info" : "MethodDeclaration[2361-21529]:MethodDeclaration[2361-21529]"
    }, {
      "left" : "private boolean isIndirectEval(Node n)",
      "right" : "private boolean isIndirectEval(Node n)",
      "info" : "MethodDeclaration[21533-21757]:MethodDeclaration[21533-21757]"
    }, {
      "left" : "private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild)",
      "right" : "private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild)",
      "info" : "MethodDeclaration[21761-23917]:MethodDeclaration[21761-23917]"
    }, {
      "left" : "private boolean isOneExactlyFunctionOrDo(Node n)",
      "right" : "private boolean isOneExactlyFunctionOrDo(Node n)",
      "info" : "MethodDeclaration[23921-24836]:MethodDeclaration[23921-24836]"
    }, {
      "left" : "void addLeftExpr(Node n, int minPrecedence, Context context)",
      "right" : "void addLeftExpr(Node n, int minPrecedence, Context context)",
      "info" : "MethodDeclaration[24840-25380]:MethodDeclaration[24840-25380]"
    }, {
      "left" : "void addExpr(Node n, int minPrecedence)",
      "right" : "void addExpr(Node n, int minPrecedence)",
      "info" : "MethodDeclaration[25384-25475]:MethodDeclaration[25384-25475]"
    }, {
      "left" : "private void addExpr(Node n, int minPrecedence, Context context)",
      "right" : "private void addExpr(Node n, int minPrecedence, Context context)",
      "info" : "MethodDeclaration[25479-25826]:MethodDeclaration[25479-25826]"
    }, {
      "left" : "void addList(Node firstInList)",
      "right" : "void addList(Node firstInList)",
      "info" : "MethodDeclaration[25830-25913]:MethodDeclaration[25830-25913]"
    }, {
      "left" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument)",
      "right" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument)",
      "info" : "MethodDeclaration[25917-26056]:MethodDeclaration[25917-26056]"
    }, {
      "left" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext)",
      "right" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext)",
      "info" : "MethodDeclaration[26060-26473]:MethodDeclaration[26060-26473]"
    }, {
      "left" : "void addArrayList(Node firstInList)",
      "right" : "void addArrayList(Node firstInList)",
      "info" : "MethodDeclaration[26477-27163]:MethodDeclaration[26477-27163]"
    }, {
      "left" : "void addCaseBody(Node caseBody)",
      "right" : "void addCaseBody(Node caseBody)",
      "info" : "MethodDeclaration[27167-27269]:MethodDeclaration[27167-27269]"
    }, {
      "left" : "void addAllSiblings(Node n)",
      "right" : "void addAllSiblings(Node n)",
      "info" : "MethodDeclaration[27273-27377]:MethodDeclaration[27273-27377]"
    }, {
      "left" : "static String jsString(String s, CharsetEncoder outputCharsetEncoder)",
      "right" : "static String jsString(String s, CharsetEncoder outputCharsetEncoder)",
      "info" : "MethodDeclaration[27381-28250]:MethodDeclaration[27381-28250]"
    }, {
      "left" : "static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder)",
      "right" : "static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder)",
      "info" : "MethodDeclaration[28254-28438]:MethodDeclaration[28254-28438]"
    }, {
      "left" : "static String escapeToDoubleQuotedJsString(String s)",
      "right" : "static String escapeToDoubleQuotedJsString(String s)",
      "info" : "MethodDeclaration[28442-28647]:MethodDeclaration[28442-28647]"
    }, {
      "left" : "static String regexpEscape(String s)",
      "right" : "static String regexpEscape(String s)",
      "info" : "MethodDeclaration[28776-28852]:MethodDeclaration[28776-28852]"
    }, {
      "left" : "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder)",
      "right" : "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder)",
      "info" : "MethodDeclaration[28856-31677]:MethodDeclaration[28856-31721]"
    }, {
      "left" : "static String identifierEscape(String s)",
      "right" : "static String identifierEscape(String s)",
      "info" : "MethodDeclaration[31681-32371]:MethodDeclaration[31725-32415]"
    }, {
      "left" : "private static int getNonEmptyChildCount(Node n, int maxCount)",
      "right" : "private static int getNonEmptyChildCount(Node n, int maxCount)",
      "info" : "MethodDeclaration[32374-32891]:MethodDeclaration[32418-32935]"
    }, {
      "left" : "private static Node getFirstNonEmptyChild(Node n)",
      "right" : "private static Node getFirstNonEmptyChild(Node n)",
      "info" : "MethodDeclaration[32895-33325]:MethodDeclaration[32939-33369]"
    }, {
      "left" : "enum : Context",
      "right" : "enum : Context",
      "info" : "EnumDeclaration[33530-33932]:EnumDeclaration[33574-33976]"
    }, {
      "left" : "private Context getContextForNonEmptyExpression(Context currentContext)",
      "right" : "private Context getContextForNonEmptyExpression(Context currentContext)",
      "info" : "MethodDeclaration[33936-34127]:MethodDeclaration[33980-34171]"
    }, {
      "left" : "private  Context getContextForNoInOperator(Context context)",
      "right" : "private  Context getContextForNoInOperator(Context context)",
      "info" : "MethodDeclaration[34131-34466]:MethodDeclaration[34175-34510]"
    }, {
      "left" : "private  Context clearContextForNoInOperator(Context context)",
      "right" : "private  Context clearContextForNoInOperator(Context context)",
      "info" : "MethodDeclaration[34470-34907]:MethodDeclaration[34514-34951]"
    }, {
      "left" : "private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c)",
      "right" : "private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c)",
      "info" : "MethodDeclaration[34911-35261]:MethodDeclaration[34955-35305]"
    }, {
      "left" : "private static void appendHexJavaScriptRepresentation(\n      int codePoint, Appendable out)\n      throws IOException",
      "right" : "private static void appendHexJavaScriptRepresentation(\n      int codePoint, Appendable out)\n      throws IOException",
      "info" : "MethodDeclaration[35265-36351]:MethodDeclaration[35309-36395]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1466-1959]:Block[1466-1959]"
    }, {
      "left" : "cc = consumer;",
      "right" : "cc = consumer;",
      "info" : "ExpressionStatement[1472-1486]:ExpressionStatement[1472-1486]"
    }, {
      "left" : "if (outputCharset == null || outputCharset == Charsets.US_ASCII)",
      "right" : "if (outputCharset == null || outputCharset == Charsets.US_ASCII)",
      "info" : "IfStatement[1491-1955]:IfStatement[1491-1955]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1556-1880]:Block[1556-1880]"
    }, {
      "left" : "this.outputCharsetEncoder = null;",
      "right" : "this.outputCharsetEncoder = null;",
      "info" : "ExpressionStatement[1841-1874]:ExpressionStatement[1841-1874]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1886-1955]:Block[1886-1955]"
    }, {
      "left" : "this.outputCharsetEncoder = outputCharset.newEncoder();",
      "right" : "this.outputCharsetEncoder = outputCharset.newEncoder();",
      "info" : "ExpressionStatement[1894-1949]:ExpressionStatement[1894-1949]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2000-2031]:Block[2000-2031]"
    }, {
      "left" : "this(consumer, null);",
      "right" : "this(consumer, null);",
      "info" : "ConstructorInvocation[2006-2027]:ConstructorInvocation[2006-2027]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2119-2150]:Block[2119-2150]"
    }, {
      "left" : "add(\"'use strict';\");",
      "right" : "add(\"'use strict';\");",
      "info" : "ExpressionStatement[2125-2146]:ExpressionStatement[2125-2146]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2175-2197]:Block[2175-2197]"
    }, {
      "left" : "cc.add(str);",
      "right" : "cc.add(str);",
      "info" : "ExpressionStatement[2181-2193]:ExpressionStatement[2181-2193]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2247-2304]:Block[2247-2304]"
    }, {
      "left" : "cc.addIdentifier(identifierEscape(identifier));",
      "right" : "cc.addIdentifier(identifierEscape(identifier));",
      "info" : "ExpressionStatement[2253-2300]:ExpressionStatement[2253-2300]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2325-2357]:Block[2325-2357]"
    }, {
      "left" : "add(n, Context.OTHER);",
      "right" : "add(n, Context.OTHER);",
      "info" : "ExpressionStatement[2331-2353]:ExpressionStatement[2331-2353]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2395-21529]:Block[2395-21529]"
    }, {
      "left" : "if (!cc.continueProcessing())",
      "right" : "if (!cc.continueProcessing())",
      "info" : "IfStatement[2401-2452]:IfStatement[2401-2452]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2431-2452]:Block[2431-2452]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[2439-2446]:ReturnStatement[2439-2446]"
    }, {
      "left" : "int type = n.getType();",
      "right" : "int type = n.getType();",
      "info" : "VariableDeclarationStatement[2458-2481]:VariableDeclarationStatement[2458-2481]"
    }, {
      "left" : "String opstr = NodeUtil.opToStr(type);",
      "right" : "String opstr = NodeUtil.opToStr(type);",
      "info" : "VariableDeclarationStatement[2486-2524]:VariableDeclarationStatement[2486-2524]"
    }, {
      "left" : "int childCount = n.getChildCount();",
      "right" : "int childCount = n.getChildCount();",
      "info" : "VariableDeclarationStatement[2529-2564]:VariableDeclarationStatement[2529-2564]"
    }, {
      "left" : "Node first = n.getFirstChild();",
      "right" : "Node first = n.getFirstChild();",
      "info" : "VariableDeclarationStatement[2569-2600]:VariableDeclarationStatement[2569-2600]"
    }, {
      "left" : "Node last = n.getLastChild();",
      "right" : "Node last = n.getLastChild();",
      "info" : "VariableDeclarationStatement[2605-2634]:VariableDeclarationStatement[2605-2634]"
    }, {
      "left" : "if (opstr != null && first != last)",
      "right" : "if (opstr != null && first != last)",
      "info" : "IfStatement[2675-3666]:IfStatement[2675-3666]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2711-3666]:Block[2711-3666]"
    }, {
      "left" : "Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);",
      "right" : "Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);",
      "info" : "ExpressionStatement[2719-2874]:ExpressionStatement[2719-2874]"
    }, {
      "left" : "int p = NodeUtil.precedence(type);",
      "right" : "int p = NodeUtil.precedence(type);",
      "info" : "VariableDeclarationStatement[2881-2915]:VariableDeclarationStatement[2881-2915]"
    }, {
      "left" : "addLeftExpr(first, p, context);",
      "right" : "addLeftExpr(first, p, context);",
      "info" : "ExpressionStatement[2922-2953]:ExpressionStatement[2922-2953]"
    }, {
      "left" : "cc.addOp(opstr, true);",
      "right" : "cc.addOp(opstr, true);",
      "info" : "ExpressionStatement[2960-2982]:ExpressionStatement[2960-2982]"
    }, {
      "left" : "Context rhsContext = getContextForNoInOperator(context);",
      "right" : "Context rhsContext = getContextForNoInOperator(context);",
      "info" : "VariableDeclarationStatement[3097-3153]:VariableDeclarationStatement[3097-3153]"
    }, {
      "left" : "if (last.getType() == type &&\n          NodeUtil.isAssociative(type))",
      "right" : "if (last.getType() == type &&\n          NodeUtil.isAssociative(type))",
      "info" : "IfStatement[3283-3646]:IfStatement[3283-3646]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3353-3400]:Block[3353-3400]"
    }, {
      "left" : "addExpr(last, p, rhsContext);",
      "right" : "addExpr(last, p, rhsContext);",
      "info" : "ExpressionStatement[3363-3392]:ExpressionStatement[3363-3392]"
    }, {
      "left" : "if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last))",
      "right" : "if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last))",
      "info" : "IfStatement[3406-3646]:IfStatement[3406-3646]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3471-3589]:Block[3471-3589]"
    }, {
      "left" : "addExpr(last, p, rhsContext);",
      "right" : "addExpr(last, p, rhsContext);",
      "info" : "ExpressionStatement[3552-3581]:ExpressionStatement[3552-3581]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3595-3646]:Block[3595-3646]"
    }, {
      "left" : "addExpr(last, p + 1, rhsContext);",
      "right" : "addExpr(last, p + 1, rhsContext);",
      "info" : "ExpressionStatement[3605-3638]:ExpressionStatement[3605-3638]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[3653-3660]:ReturnStatement[3653-3660]"
    }, {
      "left" : "cc.startSourceMapping(n);",
      "right" : "cc.startSourceMapping(n);",
      "info" : "ExpressionStatement[3672-3697]:ExpressionStatement[3672-3697]"
    }, {
      "left" : "switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(\n            childCount ==\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          add(jsString(n.getString(), outputCharsetEncoder));\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            // Object literal property names don't have to be quoted if they are\n            // not JavaScript keywords\n            if (c.getType() == Token.STRING &&\n                !c.isQuotedString() &&\n                !TokenStream.isKeyword(c.getString()) &&\n                TokenStream.isJSIdentifier(c.getString()) &&\n                // do not encode literally any non-literal characters that were\n                // unicode escaped.\n                NodeUtil.isLatin(c.getString())) {\n              add(c.getString());\n            } else {\n              addExpr(c, 1);\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }",
      "right" : "switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(\n            childCount ==\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          add(jsString(n.getString(), outputCharsetEncoder));\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            // Object literal property names don't have to be quoted if they are\n            // not JavaScript keywords\n            if (c.getType() == Token.STRING &&\n                !c.isQuotedString() &&\n                !TokenStream.isKeyword(c.getString()) &&\n                TokenStream.isJSIdentifier(c.getString()) &&\n                // do not encode literally any non-literal characters that were\n                // unicode escaped.\n                NodeUtil.isLatin(c.getString())) {\n              add(c.getString());\n            } else {\n              addExpr(c, 1);\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }",
      "info" : "SwitchStatement[3703-21496]:SwitchStatement[3703-21496]"
    }, {
      "left" : "case Token.TRY:",
      "right" : "case Token.TRY:",
      "info" : "SwitchCase[3725-3740]:SwitchCase[3725-3740]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3741-4379]:Block[3741-4379]"
    }, {
      "left" : "Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());",
      "right" : "Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());",
      "info" : "ExpressionStatement[3751-3876]:ExpressionStatement[3751-3876]"
    }, {
      "left" : "Preconditions.checkState(childCount >= 2 && childCount <= 3);",
      "right" : "Preconditions.checkState(childCount >= 2 && childCount <= 3);",
      "info" : "ExpressionStatement[3885-3946]:ExpressionStatement[3885-3946]"
    }, {
      "left" : "add(\"try\");",
      "right" : "add(\"try\");",
      "info" : "ExpressionStatement[3956-3967]:ExpressionStatement[3956-3967]"
    }, {
      "left" : "add(first, Context.PRESERVE_BLOCK);",
      "right" : "add(first, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[3976-4011]:ExpressionStatement[3976-4011]"
    }, {
      "left" : "Node catchblock = first.getNext().getFirstChild();",
      "right" : "Node catchblock = first.getNext().getFirstChild();",
      "info" : "VariableDeclarationStatement[4122-4172]:VariableDeclarationStatement[4122-4172]"
    }, {
      "left" : "if (catchblock != null)",
      "right" : "if (catchblock != null)",
      "info" : "IfStatement[4181-4243]:IfStatement[4181-4243]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4205-4243]:Block[4205-4243]"
    }, {
      "left" : "add(catchblock);",
      "right" : "add(catchblock);",
      "info" : "ExpressionStatement[4217-4233]:ExpressionStatement[4217-4233]"
    }, {
      "left" : "if (childCount == 3)",
      "right" : "if (childCount == 3)",
      "info" : "IfStatement[4253-4356]:IfStatement[4253-4356]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4274-4356]:Block[4274-4356]"
    }, {
      "left" : "add(\"finally\");",
      "right" : "add(\"finally\");",
      "info" : "ExpressionStatement[4286-4301]:ExpressionStatement[4286-4301]"
    }, {
      "left" : "add(last, Context.PRESERVE_BLOCK);",
      "right" : "add(last, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[4312-4346]:ExpressionStatement[4312-4346]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4365-4371]:BreakStatement[4365-4371]"
    }, {
      "left" : "case Token.CATCH:",
      "right" : "case Token.CATCH:",
      "info" : "SwitchCase[4387-4404]:SwitchCase[4387-4404]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[4413-4455]:ExpressionStatement[4413-4455]"
    }, {
      "left" : "add(\"catch(\");",
      "right" : "add(\"catch(\");",
      "info" : "ExpressionStatement[4464-4478]:ExpressionStatement[4464-4478]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[4487-4498]:ExpressionStatement[4487-4498]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[4507-4516]:ExpressionStatement[4507-4516]"
    }, {
      "left" : "add(last, Context.PRESERVE_BLOCK);",
      "right" : "add(last, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[4525-4559]:ExpressionStatement[4525-4559]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4568-4574]:BreakStatement[4568-4574]"
    }, {
      "left" : "case Token.THROW:",
      "right" : "case Token.THROW:",
      "info" : "SwitchCase[4582-4599]:SwitchCase[4582-4599]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[4608-4650]:ExpressionStatement[4608-4650]"
    }, {
      "left" : "add(\"throw\");",
      "right" : "add(\"throw\");",
      "info" : "ExpressionStatement[4659-4672]:ExpressionStatement[4659-4672]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[4681-4692]:ExpressionStatement[4681-4692]"
    }, {
      "left" : "cc.endStatement(true);",
      "right" : "cc.endStatement(true);",
      "info" : "ExpressionStatement[4800-4822]:ExpressionStatement[4800-4822]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4831-4837]:BreakStatement[4831-4837]"
    }, {
      "left" : "case Token.RETURN:",
      "right" : "case Token.RETURN:",
      "info" : "SwitchCase[4845-4863]:SwitchCase[4845-4863]"
    }, {
      "left" : "add(\"return\");",
      "right" : "add(\"return\");",
      "info" : "ExpressionStatement[4872-4886]:ExpressionStatement[4872-4886]"
    }, {
      "left" : "if (childCount == 1)",
      "right" : "if (childCount == 1)",
      "info" : "IfStatement[4895-5019]:IfStatement[4895-5019]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4916-4949]:Block[4916-4949]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[4928-4939]:ExpressionStatement[4928-4939]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4955-5019]:Block[4955-5019]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[4967-5009]:ExpressionStatement[4967-5009]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[5028-5046]:ExpressionStatement[5028-5046]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5055-5061]:BreakStatement[5055-5061]"
    }, {
      "left" : "case Token.VAR:",
      "right" : "case Token.VAR:",
      "info" : "SwitchCase[5069-5084]:SwitchCase[5069-5084]"
    }, {
      "left" : "if (first != null)",
      "right" : "if (first != null)",
      "info" : "IfStatement[5093-5215]:IfStatement[5093-5215]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5112-5215]:Block[5112-5215]"
    }, {
      "left" : "add(\"var \");",
      "right" : "add(\"var \");",
      "info" : "ExpressionStatement[5124-5136]:ExpressionStatement[5124-5136]"
    }, {
      "left" : "addList(first, false, getContextForNoInOperator(context));",
      "right" : "addList(first, false, getContextForNoInOperator(context));",
      "info" : "ExpressionStatement[5147-5205]:ExpressionStatement[5147-5205]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5224-5230]:BreakStatement[5224-5230]"
    }, {
      "left" : "case Token.LABEL_NAME:",
      "right" : "case Token.LABEL_NAME:",
      "info" : "SwitchCase[5238-5260]:SwitchCase[5238-5260]"
    }, {
      "left" : "Preconditions.checkState(!n.getString().isEmpty());",
      "right" : "Preconditions.checkState(!n.getString().isEmpty());",
      "info" : "ExpressionStatement[5269-5320]:ExpressionStatement[5269-5320]"
    }, {
      "left" : "addIdentifier(n.getString());",
      "right" : "addIdentifier(n.getString());",
      "info" : "ExpressionStatement[5329-5358]:ExpressionStatement[5329-5358]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5367-5373]:BreakStatement[5367-5373]"
    }, {
      "left" : "case Token.NAME:",
      "right" : "case Token.NAME:",
      "info" : "SwitchCase[5381-5397]:SwitchCase[5381-5397]"
    }, {
      "left" : "if (first == null || first.getType() == Token.EMPTY)",
      "right" : "if (first == null || first.getType() == Token.EMPTY)",
      "info" : "IfStatement[5406-5958]:IfStatement[5406-5958]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5459-5510]:Block[5459-5510]"
    }, {
      "left" : "addIdentifier(n.getString());",
      "right" : "addIdentifier(n.getString());",
      "info" : "ExpressionStatement[5471-5500]:ExpressionStatement[5471-5500]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5516-5958]:Block[5516-5958]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[5528-5570]:ExpressionStatement[5528-5570]"
    }, {
      "left" : "addIdentifier(n.getString());",
      "right" : "addIdentifier(n.getString());",
      "info" : "ExpressionStatement[5581-5610]:ExpressionStatement[5581-5610]"
    }, {
      "left" : "cc.addOp(\"=\", true);",
      "right" : "cc.addOp(\"=\", true);",
      "info" : "ExpressionStatement[5621-5641]:ExpressionStatement[5621-5641]"
    }, {
      "left" : "if (first.getType() == Token.COMMA)",
      "right" : "if (first.getType() == Token.COMMA)",
      "info" : "IfStatement[5652-5948]:IfStatement[5652-5948]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5688-5764]:Block[5688-5764]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(Token.ASSIGN));",
      "right" : "addExpr(first, NodeUtil.precedence(Token.ASSIGN));",
      "info" : "ExpressionStatement[5702-5752]:ExpressionStatement[5702-5752]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5770-5948]:Block[5770-5948]"
    }, {
      "left" : "addExpr(first, 0, getContextForNoInOperator(context));",
      "right" : "addExpr(first, 0, getContextForNoInOperator(context));",
      "info" : "ExpressionStatement[5882-5936]:ExpressionStatement[5882-5936]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5967-5973]:BreakStatement[5967-5973]"
    }, {
      "left" : "case Token.ARRAYLIT:",
      "right" : "case Token.ARRAYLIT:",
      "info" : "SwitchCase[5981-6001]:SwitchCase[5981-6001]"
    }, {
      "left" : "add(\"[\");",
      "right" : "add(\"[\");",
      "info" : "ExpressionStatement[6010-6019]:ExpressionStatement[6010-6019]"
    }, {
      "left" : "addArrayList(first);",
      "right" : "addArrayList(first);",
      "info" : "ExpressionStatement[6028-6048]:ExpressionStatement[6028-6048]"
    }, {
      "left" : "add(\"]\");",
      "right" : "add(\"]\");",
      "info" : "ExpressionStatement[6057-6066]:ExpressionStatement[6057-6066]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6075-6081]:BreakStatement[6075-6081]"
    }, {
      "left" : "case Token.LP:",
      "right" : "case Token.LP:",
      "info" : "SwitchCase[6089-6103]:SwitchCase[6089-6103]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[6112-6121]:ExpressionStatement[6112-6121]"
    }, {
      "left" : "addList(first);",
      "right" : "addList(first);",
      "info" : "ExpressionStatement[6130-6145]:ExpressionStatement[6130-6145]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[6154-6163]:ExpressionStatement[6154-6163]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6172-6178]:BreakStatement[6172-6178]"
    }, {
      "left" : "case Token.COMMA:",
      "right" : "case Token.COMMA:",
      "info" : "SwitchCase[6186-6203]:SwitchCase[6186-6203]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[6212-6254]:ExpressionStatement[6212-6254]"
    }, {
      "left" : "addList(first, false, context);",
      "right" : "addList(first, false, context);",
      "info" : "ExpressionStatement[6263-6294]:ExpressionStatement[6263-6294]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6303-6309]:BreakStatement[6303-6309]"
    }, {
      "left" : "case Token.NUMBER:",
      "right" : "case Token.NUMBER:",
      "info" : "SwitchCase[6317-6335]:SwitchCase[6317-6335]"
    }, {
      "left" : "Preconditions.checkState(\n            childCount ==\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));",
      "right" : "Preconditions.checkState(\n            childCount ==\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));",
      "info" : "ExpressionStatement[6344-6503]:ExpressionStatement[6344-6503]"
    }, {
      "left" : "cc.addNumber(n.getDouble());",
      "right" : "cc.addNumber(n.getDouble());",
      "info" : "ExpressionStatement[6512-6540]:ExpressionStatement[6512-6540]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6549-6555]:BreakStatement[6549-6555]"
    }, {
      "left" : "case Token.TYPEOF:",
      "right" : "case Token.TYPEOF:",
      "info" : "SwitchCase[6563-6581]:SwitchCase[6563-6581]"
    }, {
      "left" : "case Token.VOID:",
      "right" : "case Token.VOID:",
      "info" : "SwitchCase[6588-6604]:SwitchCase[6588-6604]"
    }, {
      "left" : "case Token.NOT:",
      "right" : "case Token.NOT:",
      "info" : "SwitchCase[6611-6626]:SwitchCase[6611-6626]"
    }, {
      "left" : "case Token.BITNOT:",
      "right" : "case Token.BITNOT:",
      "info" : "SwitchCase[6633-6651]:SwitchCase[6633-6651]"
    }, {
      "left" : "case Token.POS:",
      "right" : "case Token.POS:",
      "info" : "SwitchCase[6658-6673]:SwitchCase[6658-6673]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6674-6917]:Block[6674-6917]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[6746-6788]:ExpressionStatement[6746-6788]"
    }, {
      "left" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "right" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "info" : "ExpressionStatement[6797-6843]:ExpressionStatement[6797-6843]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(type));",
      "right" : "addExpr(first, NodeUtil.precedence(type));",
      "info" : "ExpressionStatement[6852-6894]:ExpressionStatement[6852-6894]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6903-6909]:BreakStatement[6903-6909]"
    }, {
      "left" : "case Token.NEG:",
      "right" : "case Token.NEG:",
      "info" : "SwitchCase[6925-6940]:SwitchCase[6925-6940]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6941-7468]:Block[6941-7468]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[6951-6993]:ExpressionStatement[6951-6993]"
    }, {
      "left" : "if (n.getFirstChild().getType() == Token.NUMBER)",
      "right" : "if (n.getFirstChild().getType() == Token.NUMBER)",
      "info" : "IfStatement[7201-7444]:IfStatement[7201-7444]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7250-7317]:Block[7250-7317]"
    }, {
      "left" : "cc.addNumber(-n.getFirstChild().getDouble());",
      "right" : "cc.addNumber(-n.getFirstChild().getDouble());",
      "info" : "ExpressionStatement[7262-7307]:ExpressionStatement[7262-7307]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7323-7444]:Block[7323-7444]"
    }, {
      "left" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "right" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "info" : "ExpressionStatement[7335-7381]:ExpressionStatement[7335-7381]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(type));",
      "right" : "addExpr(first, NodeUtil.precedence(type));",
      "info" : "ExpressionStatement[7392-7434]:ExpressionStatement[7392-7434]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[7454-7460]:BreakStatement[7454-7460]"
    }, {
      "left" : "case Token.HOOK:",
      "right" : "case Token.HOOK:",
      "info" : "SwitchCase[7476-7492]:SwitchCase[7476-7492]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7493-7776]:Block[7493-7776]"
    }, {
      "left" : "Preconditions.checkState(childCount == 3);",
      "right" : "Preconditions.checkState(childCount == 3);",
      "info" : "ExpressionStatement[7503-7545]:ExpressionStatement[7503-7545]"
    }, {
      "left" : "int p = NodeUtil.precedence(type);",
      "right" : "int p = NodeUtil.precedence(type);",
      "info" : "VariableDeclarationStatement[7554-7588]:VariableDeclarationStatement[7554-7588]"
    }, {
      "left" : "addLeftExpr(first, p + 1, context);",
      "right" : "addLeftExpr(first, p + 1, context);",
      "info" : "ExpressionStatement[7597-7632]:ExpressionStatement[7597-7632]"
    }, {
      "left" : "cc.addOp(\"?\", true);",
      "right" : "cc.addOp(\"?\", true);",
      "info" : "ExpressionStatement[7641-7661]:ExpressionStatement[7641-7661]"
    }, {
      "left" : "addExpr(first.getNext(), 1);",
      "right" : "addExpr(first.getNext(), 1);",
      "info" : "ExpressionStatement[7670-7698]:ExpressionStatement[7670-7698]"
    }, {
      "left" : "cc.addOp(\":\", true);",
      "right" : "cc.addOp(\":\", true);",
      "info" : "ExpressionStatement[7707-7727]:ExpressionStatement[7707-7727]"
    }, {
      "left" : "addExpr(last, 1);",
      "right" : "addExpr(last, 1);",
      "info" : "ExpressionStatement[7736-7753]:ExpressionStatement[7736-7753]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[7762-7768]:BreakStatement[7762-7768]"
    }, {
      "left" : "case Token.REGEXP:",
      "right" : "case Token.REGEXP:",
      "info" : "SwitchCase[7784-7802]:SwitchCase[7784-7802]"
    }, {
      "left" : "if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING)",
      "right" : "if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING)",
      "info" : "IfStatement[7811-7967]:IfStatement[7811-7967]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7894-7967]:Block[7894-7967]"
    }, {
      "left" : "throw new Error(\"Expected children to be strings\");",
      "right" : "throw new Error(\"Expected children to be strings\");",
      "info" : "ThrowStatement[7906-7957]:ThrowStatement[7906-7957]"
    }, {
      "left" : "String regexp = regexpEscape(first.getString(), outputCharsetEncoder);",
      "right" : "String regexp = regexpEscape(first.getString(), outputCharsetEncoder);",
      "info" : "VariableDeclarationStatement[7977-8047]:VariableDeclarationStatement[7977-8047]"
    }, {
      "left" : "if (childCount == 2)",
      "right" : "if (childCount == 2)",
      "info" : "IfStatement[8115-8282]:IfStatement[8115-8282]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8136-8189]:Block[8136-8189]"
    }, {
      "left" : "add(regexp + last.getString());",
      "right" : "add(regexp + last.getString());",
      "info" : "ExpressionStatement[8148-8179]:ExpressionStatement[8148-8179]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8195-8282]:Block[8195-8282]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[8207-8249]:ExpressionStatement[8207-8249]"
    }, {
      "left" : "add(regexp);",
      "right" : "add(regexp);",
      "info" : "ExpressionStatement[8260-8272]:ExpressionStatement[8260-8272]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8291-8297]:BreakStatement[8291-8297]"
    }, {
      "left" : "case Token.GET_REF:",
      "right" : "case Token.GET_REF:",
      "info" : "SwitchCase[8305-8324]:SwitchCase[8305-8324]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[8333-8344]:ExpressionStatement[8333-8344]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8353-8359]:BreakStatement[8353-8359]"
    }, {
      "left" : "case Token.REF_SPECIAL:",
      "right" : "case Token.REF_SPECIAL:",
      "info" : "SwitchCase[8367-8390]:SwitchCase[8367-8390]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[8399-8441]:ExpressionStatement[8399-8441]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[8450-8461]:ExpressionStatement[8450-8461]"
    }, {
      "left" : "add(\".\");",
      "right" : "add(\".\");",
      "info" : "ExpressionStatement[8470-8479]:ExpressionStatement[8470-8479]"
    }, {
      "left" : "add((String) n.getProp(Node.NAME_PROP));",
      "right" : "add((String) n.getProp(Node.NAME_PROP));",
      "info" : "ExpressionStatement[8488-8528]:ExpressionStatement[8488-8528]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8537-8543]:BreakStatement[8537-8543]"
    }, {
      "left" : "case Token.FUNCTION:",
      "right" : "case Token.FUNCTION:",
      "info" : "SwitchCase[8551-8571]:SwitchCase[8551-8571]"
    }, {
      "left" : "if (n.getClass() != Node.class)",
      "right" : "if (n.getClass() != Node.class)",
      "info" : "IfStatement[8580-8679]:IfStatement[8580-8679]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8612-8679]:Block[8612-8679]"
    }, {
      "left" : "throw new Error(\"Unexpected Node subclass.\");",
      "right" : "throw new Error(\"Unexpected Node subclass.\");",
      "info" : "ThrowStatement[8624-8669]:ThrowStatement[8624-8669]"
    }, {
      "left" : "Preconditions.checkState(childCount == 3);",
      "right" : "Preconditions.checkState(childCount == 3);",
      "info" : "ExpressionStatement[8688-8730]:ExpressionStatement[8688-8730]"
    }, {
      "left" : "boolean funcNeedsParens = (context == Context.START_OF_EXPR);",
      "right" : "boolean funcNeedsParens = (context == Context.START_OF_EXPR);",
      "info" : "VariableDeclarationStatement[8739-8800]:VariableDeclarationStatement[8739-8800]"
    }, {
      "left" : "if (funcNeedsParens)",
      "right" : "if (funcNeedsParens)",
      "info" : "IfStatement[8809-8861]:IfStatement[8809-8861]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8830-8861]:Block[8830-8861]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[8842-8851]:ExpressionStatement[8842-8851]"
    }, {
      "left" : "add(\"function\");",
      "right" : "add(\"function\");",
      "info" : "ExpressionStatement[8871-8887]:ExpressionStatement[8871-8887]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[8896-8907]:ExpressionStatement[8896-8907]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[8917-8938]:ExpressionStatement[8917-8938]"
    }, {
      "left" : "add(last, Context.PRESERVE_BLOCK);",
      "right" : "add(last, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[8947-8981]:ExpressionStatement[8947-8981]"
    }, {
      "left" : "cc.endFunction(context == Context.STATEMENT);",
      "right" : "cc.endFunction(context == Context.STATEMENT);",
      "info" : "ExpressionStatement[8990-9035]:ExpressionStatement[8990-9035]"
    }, {
      "left" : "if (funcNeedsParens)",
      "right" : "if (funcNeedsParens)",
      "info" : "IfStatement[9045-9097]:IfStatement[9045-9097]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9066-9097]:Block[9066-9097]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[9078-9087]:ExpressionStatement[9078-9087]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[9106-9112]:BreakStatement[9106-9112]"
    }, {
      "left" : "case Token.GET:",
      "right" : "case Token.GET:",
      "info" : "SwitchCase[9120-9135]:SwitchCase[9120-9135]"
    }, {
      "left" : "case Token.SET:",
      "right" : "case Token.SET:",
      "info" : "SwitchCase[9142-9157]:SwitchCase[9142-9157]"
    }, {
      "left" : "Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);",
      "right" : "Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);",
      "info" : "ExpressionStatement[9166-9235]:ExpressionStatement[9166-9235]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[9244-9286]:ExpressionStatement[9244-9286]"
    }, {
      "left" : "Preconditions.checkState(first.getType() == Token.FUNCTION);",
      "right" : "Preconditions.checkState(first.getType() == Token.FUNCTION);",
      "info" : "ExpressionStatement[9295-9355]:ExpressionStatement[9295-9355]"
    }, {
      "left" : "Preconditions.checkState(first.getFirstChild().getString().isEmpty());",
      "right" : "Preconditions.checkState(first.getFirstChild().getString().isEmpty());",
      "info" : "ExpressionStatement[9400-9470]:ExpressionStatement[9400-9470]"
    }, {
      "left" : "if (type == Token.GET)",
      "right" : "if (type == Token.GET)",
      "info" : "IfStatement[9479-9819]:IfStatement[9479-9819]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9502-9658]:Block[9502-9658]"
    }, {
      "left" : "Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());",
      "right" : "Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());",
      "info" : "ExpressionStatement[9559-9625]:ExpressionStatement[9559-9625]"
    }, {
      "left" : "add(\"get \");",
      "right" : "add(\"get \");",
      "info" : "ExpressionStatement[9636-9648]:ExpressionStatement[9636-9648]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9664-9819]:Block[9664-9819]"
    }, {
      "left" : "Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());",
      "right" : "Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());",
      "info" : "ExpressionStatement[9721-9786]:ExpressionStatement[9721-9786]"
    }, {
      "left" : "add(\"set \");",
      "right" : "add(\"set \");",
      "info" : "ExpressionStatement[9797-9809]:ExpressionStatement[9797-9809]"
    }, {
      "left" : "String name = n.getString();",
      "right" : "String name = n.getString();",
      "info" : "VariableDeclarationStatement[9876-9904]:VariableDeclarationStatement[9876-9904]"
    }, {
      "left" : "Node fn = first;",
      "right" : "Node fn = first;",
      "info" : "VariableDeclarationStatement[9913-9929]:VariableDeclarationStatement[9913-9929]"
    }, {
      "left" : "Node parameters = fn.getChildAtIndex(1);",
      "right" : "Node parameters = fn.getChildAtIndex(1);",
      "info" : "VariableDeclarationStatement[9938-9978]:VariableDeclarationStatement[9938-9978]"
    }, {
      "left" : "Node body = fn.getLastChild();",
      "right" : "Node body = fn.getLastChild();",
      "info" : "VariableDeclarationStatement[9987-10017]:VariableDeclarationStatement[9987-10017]"
    }, {
      "left" : "if (TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name))",
      "right" : "if (TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name))",
      "info" : "IfStatement[10061-10356]:IfStatement[10061-10356]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10245-10277]:Block[10245-10277]"
    }, {
      "left" : "add(name);",
      "right" : "add(name);",
      "info" : "ExpressionStatement[10257-10267]:ExpressionStatement[10257-10267]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10283-10356]:Block[10283-10356]"
    }, {
      "left" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "right" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "info" : "ExpressionStatement[10295-10346]:ExpressionStatement[10295-10346]"
    }, {
      "left" : "add(parameters);",
      "right" : "add(parameters);",
      "info" : "ExpressionStatement[10366-10382]:ExpressionStatement[10366-10382]"
    }, {
      "left" : "add(body, Context.PRESERVE_BLOCK);",
      "right" : "add(body, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[10391-10425]:ExpressionStatement[10391-10425]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[10434-10440]:BreakStatement[10434-10440]"
    }, {
      "left" : "case Token.SCRIPT:",
      "right" : "case Token.SCRIPT:",
      "info" : "SwitchCase[10448-10466]:SwitchCase[10448-10466]"
    }, {
      "left" : "case Token.BLOCK:",
      "right" : "case Token.BLOCK:",
      "info" : "SwitchCase[10473-10490]:SwitchCase[10473-10490]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10491-11690]:Block[10491-11690]"
    }, {
      "left" : "if (n.getClass() != Node.class)",
      "right" : "if (n.getClass() != Node.class)",
      "info" : "IfStatement[10501-10600]:IfStatement[10501-10600]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10533-10600]:Block[10533-10600]"
    }, {
      "left" : "throw new Error(\"Unexpected Node subclass.\");",
      "right" : "throw new Error(\"Unexpected Node subclass.\");",
      "info" : "ThrowStatement[10545-10590]:ThrowStatement[10545-10590]"
    }, {
      "left" : "boolean preserveBlock = context == Context.PRESERVE_BLOCK;",
      "right" : "boolean preserveBlock = context == Context.PRESERVE_BLOCK;",
      "info" : "VariableDeclarationStatement[10609-10667]:VariableDeclarationStatement[10609-10667]"
    }, {
      "left" : "if (preserveBlock)",
      "right" : "if (preserveBlock)",
      "info" : "IfStatement[10676-10733]:IfStatement[10676-10733]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10695-10733]:Block[10695-10733]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[10707-10723]:ExpressionStatement[10707-10723]"
    }, {
      "left" : "boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);",
      "right" : "boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);",
      "info" : "VariableDeclarationStatement[10743-10974]:VariableDeclarationStatement[10743-10974]"
    }, {
      "left" : "for (Node c = first; c != null; c = c.getNext())",
      "right" : "for (Node c = first; c != null; c = c.getNext())",
      "info" : "ForStatement[10983-11549]:ForStatement[10983-11549]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11032-11549]:Block[11032-11549]"
    }, {
      "left" : "add(c, Context.STATEMENT);",
      "right" : "add(c, Context.STATEMENT);",
      "info" : "ExpressionStatement[11044-11070]:ExpressionStatement[11044-11070]"
    }, {
      "left" : "if (c.getType() == Token.VAR)",
      "right" : "if (c.getType() == Token.VAR)",
      "info" : "IfStatement[11153-11227]:IfStatement[11153-11227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11183-11227]:Block[11183-11227]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[11197-11215]:ExpressionStatement[11197-11215]"
    }, {
      "left" : "if (c.getType() == Token.FUNCTION)",
      "right" : "if (c.getType() == Token.FUNCTION)",
      "info" : "IfStatement[11239-11320]:IfStatement[11239-11320]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11274-11320]:Block[11274-11320]"
    }, {
      "left" : "cc.maybeLineBreak();",
      "right" : "cc.maybeLineBreak();",
      "info" : "ExpressionStatement[11288-11308]:ExpressionStatement[11288-11308]"
    }, {
      "left" : "if (preferLineBreaks)",
      "right" : "if (preferLineBreaks)",
      "info" : "IfStatement[11463-11539]:IfStatement[11463-11539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11485-11539]:Block[11485-11539]"
    }, {
      "left" : "cc.notePreferredLineBreak();",
      "right" : "cc.notePreferredLineBreak();",
      "info" : "ExpressionStatement[11499-11527]:ExpressionStatement[11499-11527]"
    }, {
      "left" : "if (preserveBlock)",
      "right" : "if (preserveBlock)",
      "info" : "IfStatement[11558-11667]:IfStatement[11558-11667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11577-11667]:Block[11577-11667]"
    }, {
      "left" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "right" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "info" : "ExpressionStatement[11589-11657]:ExpressionStatement[11589-11657]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[11676-11682]:BreakStatement[11676-11682]"
    }, {
      "left" : "case Token.FOR:",
      "right" : "case Token.FOR:",
      "info" : "SwitchCase[11698-11713]:SwitchCase[11698-11713]"
    }, {
      "left" : "if (childCount == 4)",
      "right" : "if (childCount == 4)",
      "info" : "IfStatement[11722-12491]:IfStatement[11722-12491]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11743-12201]:Block[11743-12201]"
    }, {
      "left" : "add(\"for(\");",
      "right" : "add(\"for(\");",
      "info" : "ExpressionStatement[11755-11767]:ExpressionStatement[11755-11767]"
    }, {
      "left" : "if (first.getType() == Token.VAR)",
      "right" : "if (first.getType() == Token.VAR)",
      "info" : "IfStatement[11778-11955]:IfStatement[11778-11955]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11812-11877]:Block[11812-11877]"
    }, {
      "left" : "add(first, Context.IN_FOR_INIT_CLAUSE);",
      "right" : "add(first, Context.IN_FOR_INIT_CLAUSE);",
      "info" : "ExpressionStatement[11826-11865]:ExpressionStatement[11826-11865]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11883-11955]:Block[11883-11955]"
    }, {
      "left" : "addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);",
      "right" : "addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);",
      "info" : "ExpressionStatement[11897-11943]:ExpressionStatement[11897-11943]"
    }, {
      "left" : "add(\";\");",
      "right" : "add(\";\");",
      "info" : "ExpressionStatement[11966-11975]:ExpressionStatement[11966-11975]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[11986-12007]:ExpressionStatement[11986-12007]"
    }, {
      "left" : "add(\";\");",
      "right" : "add(\";\");",
      "info" : "ExpressionStatement[12018-12027]:ExpressionStatement[12018-12027]"
    }, {
      "left" : "add(first.getNext().getNext());",
      "right" : "add(first.getNext().getNext());",
      "info" : "ExpressionStatement[12038-12069]:ExpressionStatement[12038-12069]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[12080-12089]:ExpressionStatement[12080-12089]"
    }, {
      "left" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[12100-12191]:ExpressionStatement[12100-12191]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12207-12491]:Block[12207-12491]"
    }, {
      "left" : "Preconditions.checkState(childCount == 3);",
      "right" : "Preconditions.checkState(childCount == 3);",
      "info" : "ExpressionStatement[12219-12261]:ExpressionStatement[12219-12261]"
    }, {
      "left" : "add(\"for(\");",
      "right" : "add(\"for(\");",
      "info" : "ExpressionStatement[12272-12284]:ExpressionStatement[12272-12284]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[12295-12306]:ExpressionStatement[12295-12306]"
    }, {
      "left" : "add(\"in\");",
      "right" : "add(\"in\");",
      "info" : "ExpressionStatement[12317-12327]:ExpressionStatement[12317-12327]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[12338-12359]:ExpressionStatement[12338-12359]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[12370-12379]:ExpressionStatement[12370-12379]"
    }, {
      "left" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[12390-12481]:ExpressionStatement[12390-12481]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[12500-12506]:BreakStatement[12500-12506]"
    }, {
      "left" : "case Token.DO:",
      "right" : "case Token.DO:",
      "info" : "SwitchCase[12514-12528]:SwitchCase[12514-12528]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[12537-12579]:ExpressionStatement[12537-12579]"
    }, {
      "left" : "add(\"do\");",
      "right" : "add(\"do\");",
      "info" : "ExpressionStatement[12588-12598]:ExpressionStatement[12588-12598]"
    }, {
      "left" : "addNonEmptyStatement(first, Context.OTHER, false);",
      "right" : "addNonEmptyStatement(first, Context.OTHER, false);",
      "info" : "ExpressionStatement[12607-12657]:ExpressionStatement[12607-12657]"
    }, {
      "left" : "add(\"while(\");",
      "right" : "add(\"while(\");",
      "info" : "ExpressionStatement[12666-12680]:ExpressionStatement[12666-12680]"
    }, {
      "left" : "add(last);",
      "right" : "add(last);",
      "info" : "ExpressionStatement[12689-12699]:ExpressionStatement[12689-12699]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[12708-12717]:ExpressionStatement[12708-12717]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[12726-12744]:ExpressionStatement[12726-12744]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[12753-12759]:BreakStatement[12753-12759]"
    }, {
      "left" : "case Token.WHILE:",
      "right" : "case Token.WHILE:",
      "info" : "SwitchCase[12767-12784]:SwitchCase[12767-12784]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[12793-12835]:ExpressionStatement[12793-12835]"
    }, {
      "left" : "add(\"while(\");",
      "right" : "add(\"while(\");",
      "info" : "ExpressionStatement[12844-12858]:ExpressionStatement[12844-12858]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[12867-12878]:ExpressionStatement[12867-12878]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[12887-12896]:ExpressionStatement[12887-12896]"
    }, {
      "left" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[12905-12994]:ExpressionStatement[12905-12994]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[13003-13009]:BreakStatement[13003-13009]"
    }, {
      "left" : "case Token.EMPTY:",
      "right" : "case Token.EMPTY:",
      "info" : "SwitchCase[13017-13034]:SwitchCase[13017-13034]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[13043-13085]:ExpressionStatement[13043-13085]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[13094-13100]:BreakStatement[13094-13100]"
    }, {
      "left" : "case Token.GETPROP:",
      "right" : "case Token.GETPROP:",
      "info" : "SwitchCase[13108-13127]:SwitchCase[13108-13127]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13128-13718]:Block[13128-13718]"
    }, {
      "left" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);",
      "right" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);",
      "info" : "ExpressionStatement[13138-13265]:ExpressionStatement[13138-13265]"
    }, {
      "left" : "Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");",
      "right" : "Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");",
      "info" : "ExpressionStatement[13274-13393]:ExpressionStatement[13274-13393]"
    }, {
      "left" : "boolean needsParens = (first.getType() == Token.NUMBER);",
      "right" : "boolean needsParens = (first.getType() == Token.NUMBER);",
      "info" : "VariableDeclarationStatement[13402-13458]:VariableDeclarationStatement[13402-13458]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[13467-13515]:IfStatement[13467-13515]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13484-13515]:Block[13484-13515]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[13496-13505]:ExpressionStatement[13496-13505]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[13524-13579]:ExpressionStatement[13524-13579]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[13588-13636]:IfStatement[13588-13636]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13605-13636]:Block[13605-13636]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[13617-13626]:ExpressionStatement[13617-13626]"
    }, {
      "left" : "add(\".\");",
      "right" : "add(\".\");",
      "info" : "ExpressionStatement[13645-13654]:ExpressionStatement[13645-13654]"
    }, {
      "left" : "addIdentifier(last.getString());",
      "right" : "addIdentifier(last.getString());",
      "info" : "ExpressionStatement[13663-13695]:ExpressionStatement[13663-13695]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[13704-13710]:BreakStatement[13704-13710]"
    }, {
      "left" : "case Token.GETELEM:",
      "right" : "case Token.GETELEM:",
      "info" : "SwitchCase[13726-13745]:SwitchCase[13726-13745]"
    }, {
      "left" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);",
      "right" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);",
      "info" : "ExpressionStatement[13754-13880]:ExpressionStatement[13754-13880]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[13889-13944]:ExpressionStatement[13889-13944]"
    }, {
      "left" : "add(\"[\");",
      "right" : "add(\"[\");",
      "info" : "ExpressionStatement[13953-13962]:ExpressionStatement[13953-13962]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[13971-13992]:ExpressionStatement[13971-13992]"
    }, {
      "left" : "add(\"]\");",
      "right" : "add(\"]\");",
      "info" : "ExpressionStatement[14001-14010]:ExpressionStatement[14001-14010]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[14019-14025]:BreakStatement[14019-14025]"
    }, {
      "left" : "case Token.WITH:",
      "right" : "case Token.WITH:",
      "info" : "SwitchCase[14033-14049]:SwitchCase[14033-14049]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[14058-14100]:ExpressionStatement[14058-14100]"
    }, {
      "left" : "add(\"with(\");",
      "right" : "add(\"with(\");",
      "info" : "ExpressionStatement[14109-14122]:ExpressionStatement[14109-14122]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[14131-14142]:ExpressionStatement[14131-14142]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[14151-14160]:ExpressionStatement[14151-14160]"
    }, {
      "left" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[14169-14258]:ExpressionStatement[14169-14258]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[14267-14273]:BreakStatement[14267-14273]"
    }, {
      "left" : "case Token.INC:",
      "right" : "case Token.INC:",
      "info" : "SwitchCase[14281-14296]:SwitchCase[14281-14296]"
    }, {
      "left" : "case Token.DEC:",
      "right" : "case Token.DEC:",
      "info" : "SwitchCase[14303-14318]:SwitchCase[14303-14318]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14319-14816]:Block[14319-14816]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[14329-14371]:ExpressionStatement[14329-14371]"
    }, {
      "left" : "String o = type == Token.INC ? \"++\" : \"--\";",
      "right" : "String o = type == Token.INC ? \"++\" : \"--\";",
      "info" : "VariableDeclarationStatement[14380-14423]:VariableDeclarationStatement[14380-14423]"
    }, {
      "left" : "int postProp = n.getIntProp(Node.INCRDECR_PROP);",
      "right" : "int postProp = n.getIntProp(Node.INCRDECR_PROP);",
      "info" : "VariableDeclarationStatement[14432-14480]:VariableDeclarationStatement[14432-14480]"
    }, {
      "left" : "if (postProp != 0)",
      "right" : "if (postProp != 0)",
      "info" : "IfStatement[14598-14793]:IfStatement[14598-14793]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14617-14724]:Block[14617-14724]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[14629-14684]:ExpressionStatement[14629-14684]"
    }, {
      "left" : "cc.addOp(o, false);",
      "right" : "cc.addOp(o, false);",
      "info" : "ExpressionStatement[14695-14714]:ExpressionStatement[14695-14714]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14730-14793]:Block[14730-14793]"
    }, {
      "left" : "cc.addOp(o, false);",
      "right" : "cc.addOp(o, false);",
      "info" : "ExpressionStatement[14742-14761]:ExpressionStatement[14742-14761]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[14772-14783]:ExpressionStatement[14772-14783]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[14802-14808]:BreakStatement[14802-14808]"
    }, {
      "left" : "case Token.CALL:",
      "right" : "case Token.CALL:",
      "info" : "SwitchCase[14824-14840]:SwitchCase[14824-14840]"
    }, {
      "left" : "if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))",
      "right" : "if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))",
      "info" : "IfStatement[15425-15721]:IfStatement[15425-15721]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15525-15638]:Block[15525-15638]"
    }, {
      "left" : "add(\"(0,\");",
      "right" : "add(\"(0,\");",
      "info" : "ExpressionStatement[15537-15548]:ExpressionStatement[15537-15548]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(Token.COMMA));",
      "right" : "addExpr(first, NodeUtil.precedence(Token.COMMA));",
      "info" : "ExpressionStatement[15559-15608]:ExpressionStatement[15559-15608]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[15619-15628]:ExpressionStatement[15619-15628]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15644-15721]:Block[15644-15721]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[15656-15711]:ExpressionStatement[15656-15711]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[15730-15739]:ExpressionStatement[15730-15739]"
    }, {
      "left" : "addList(first.getNext());",
      "right" : "addList(first.getNext());",
      "info" : "ExpressionStatement[15748-15773]:ExpressionStatement[15748-15773]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[15782-15791]:ExpressionStatement[15782-15791]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[15800-15806]:BreakStatement[15800-15806]"
    }, {
      "left" : "case Token.IF:",
      "right" : "case Token.IF:",
      "info" : "SwitchCase[15814-15828]:SwitchCase[15814-15828]"
    }, {
      "left" : "boolean hasElse = childCount == 3;",
      "right" : "boolean hasElse = childCount == 3;",
      "info" : "VariableDeclarationStatement[15837-15871]:VariableDeclarationStatement[15837-15871]"
    }, {
      "left" : "boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;",
      "right" : "boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;",
      "info" : "VariableDeclarationStatement[15880-15974]:VariableDeclarationStatement[15880-15974]"
    }, {
      "left" : "if (ambiguousElseClause)",
      "right" : "if (ambiguousElseClause)",
      "info" : "IfStatement[15983-16046]:IfStatement[15983-16046]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16008-16046]:Block[16008-16046]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[16020-16036]:ExpressionStatement[16020-16036]"
    }, {
      "left" : "add(\"if(\");",
      "right" : "add(\"if(\");",
      "info" : "ExpressionStatement[16056-16067]:ExpressionStatement[16056-16067]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[16076-16087]:ExpressionStatement[16076-16087]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[16096-16105]:ExpressionStatement[16096-16105]"
    }, {
      "left" : "if (hasElse)",
      "right" : "if (hasElse)",
      "info" : "IfStatement[16115-16506]:IfStatement[16115-16506]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16128-16365]:Block[16128-16365]"
    }, {
      "left" : "addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);",
      "right" : "addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);",
      "info" : "ExpressionStatement[16140-16230]:ExpressionStatement[16140-16230]"
    }, {
      "left" : "add(\"else\");",
      "right" : "add(\"else\");",
      "info" : "ExpressionStatement[16241-16253]:ExpressionStatement[16241-16253]"
    }, {
      "left" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[16264-16355]:ExpressionStatement[16264-16355]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16371-16506]:Block[16371-16506]"
    }, {
      "left" : "addNonEmptyStatement(first.getNext(), Context.OTHER, false);",
      "right" : "addNonEmptyStatement(first.getNext(), Context.OTHER, false);",
      "info" : "ExpressionStatement[16383-16443]:ExpressionStatement[16383-16443]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[16454-16496]:ExpressionStatement[16454-16496]"
    }, {
      "left" : "if (ambiguousElseClause)",
      "right" : "if (ambiguousElseClause)",
      "info" : "IfStatement[16516-16577]:IfStatement[16516-16577]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16541-16577]:Block[16541-16577]"
    }, {
      "left" : "cc.endBlock();",
      "right" : "cc.endBlock();",
      "info" : "ExpressionStatement[16553-16567]:ExpressionStatement[16553-16567]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16586-16592]:BreakStatement[16586-16592]"
    }, {
      "left" : "case Token.NULL:",
      "right" : "case Token.NULL:",
      "info" : "SwitchCase[16600-16616]:SwitchCase[16600-16616]"
    }, {
      "left" : "case Token.THIS:",
      "right" : "case Token.THIS:",
      "info" : "SwitchCase[16623-16639]:SwitchCase[16623-16639]"
    }, {
      "left" : "case Token.FALSE:",
      "right" : "case Token.FALSE:",
      "info" : "SwitchCase[16646-16663]:SwitchCase[16646-16663]"
    }, {
      "left" : "case Token.TRUE:",
      "right" : "case Token.TRUE:",
      "info" : "SwitchCase[16670-16686]:SwitchCase[16670-16686]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[16695-16737]:ExpressionStatement[16695-16737]"
    }, {
      "left" : "add(Node.tokenToName(type));",
      "right" : "add(Node.tokenToName(type));",
      "info" : "ExpressionStatement[16746-16774]:ExpressionStatement[16746-16774]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16783-16789]:BreakStatement[16783-16789]"
    }, {
      "left" : "case Token.CONTINUE:",
      "right" : "case Token.CONTINUE:",
      "info" : "SwitchCase[16797-16817]:SwitchCase[16797-16817]"
    }, {
      "left" : "Preconditions.checkState(childCount <= 1);",
      "right" : "Preconditions.checkState(childCount <= 1);",
      "info" : "ExpressionStatement[16826-16868]:ExpressionStatement[16826-16868]"
    }, {
      "left" : "add(\"continue\");",
      "right" : "add(\"continue\");",
      "info" : "ExpressionStatement[16877-16893]:ExpressionStatement[16877-16893]"
    }, {
      "left" : "if (childCount == 1)",
      "right" : "if (childCount == 1)",
      "info" : "IfStatement[16902-17118]:IfStatement[16902-17118]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16923-17118]:Block[16923-17118]"
    }, {
      "left" : "if (first.getType() != Token.LABEL_NAME)",
      "right" : "if (first.getType() != Token.LABEL_NAME)",
      "info" : "IfStatement[16935-17066]:IfStatement[16935-17066]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16976-17066]:Block[16976-17066]"
    }, {
      "left" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "right" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "info" : "ThrowStatement[16990-17054]:ThrowStatement[16990-17054]"
    }, {
      "left" : "add(\" \");",
      "right" : "add(\" \");",
      "info" : "ExpressionStatement[17077-17086]:ExpressionStatement[17077-17086]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[17097-17108]:ExpressionStatement[17097-17108]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[17127-17145]:ExpressionStatement[17127-17145]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17154-17160]:BreakStatement[17154-17160]"
    }, {
      "left" : "case Token.DEBUGGER:",
      "right" : "case Token.DEBUGGER:",
      "info" : "SwitchCase[17168-17188]:SwitchCase[17168-17188]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[17197-17239]:ExpressionStatement[17197-17239]"
    }, {
      "left" : "add(\"debugger\");",
      "right" : "add(\"debugger\");",
      "info" : "ExpressionStatement[17248-17264]:ExpressionStatement[17248-17264]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[17273-17291]:ExpressionStatement[17273-17291]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17300-17306]:BreakStatement[17300-17306]"
    }, {
      "left" : "case Token.BREAK:",
      "right" : "case Token.BREAK:",
      "info" : "SwitchCase[17314-17331]:SwitchCase[17314-17331]"
    }, {
      "left" : "Preconditions.checkState(childCount <= 1);",
      "right" : "Preconditions.checkState(childCount <= 1);",
      "info" : "ExpressionStatement[17340-17382]:ExpressionStatement[17340-17382]"
    }, {
      "left" : "add(\"break\");",
      "right" : "add(\"break\");",
      "info" : "ExpressionStatement[17391-17404]:ExpressionStatement[17391-17404]"
    }, {
      "left" : "if (childCount == 1)",
      "right" : "if (childCount == 1)",
      "info" : "IfStatement[17413-17629]:IfStatement[17413-17629]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17434-17629]:Block[17434-17629]"
    }, {
      "left" : "if (first.getType() != Token.LABEL_NAME)",
      "right" : "if (first.getType() != Token.LABEL_NAME)",
      "info" : "IfStatement[17446-17577]:IfStatement[17446-17577]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17487-17577]:Block[17487-17577]"
    }, {
      "left" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "right" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "info" : "ThrowStatement[17501-17565]:ThrowStatement[17501-17565]"
    }, {
      "left" : "add(\" \");",
      "right" : "add(\" \");",
      "info" : "ExpressionStatement[17588-17597]:ExpressionStatement[17588-17597]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[17608-17619]:ExpressionStatement[17608-17619]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[17638-17656]:ExpressionStatement[17638-17656]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17665-17671]:BreakStatement[17665-17671]"
    }, {
      "left" : "case Token.EXPR_VOID:",
      "right" : "case Token.EXPR_VOID:",
      "info" : "SwitchCase[17679-17700]:SwitchCase[17679-17700]"
    }, {
      "left" : "throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");",
      "right" : "throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");",
      "info" : "ThrowStatement[17709-17773]:ThrowStatement[17709-17773]"
    }, {
      "left" : "case Token.EXPR_RESULT:",
      "right" : "case Token.EXPR_RESULT:",
      "info" : "SwitchCase[17781-17804]:SwitchCase[17781-17804]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[17813-17855]:ExpressionStatement[17813-17855]"
    }, {
      "left" : "add(first, Context.START_OF_EXPR);",
      "right" : "add(first, Context.START_OF_EXPR);",
      "info" : "ExpressionStatement[17864-17898]:ExpressionStatement[17864-17898]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[17907-17925]:ExpressionStatement[17907-17925]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17934-17940]:BreakStatement[17934-17940]"
    }, {
      "left" : "case Token.NEW:",
      "right" : "case Token.NEW:",
      "info" : "SwitchCase[17948-17963]:SwitchCase[17948-17963]"
    }, {
      "left" : "add(\"new \");",
      "right" : "add(\"new \");",
      "info" : "ExpressionStatement[17972-17984]:ExpressionStatement[17972-17984]"
    }, {
      "left" : "int precedence = NodeUtil.precedence(type);",
      "right" : "int precedence = NodeUtil.precedence(type);",
      "info" : "VariableDeclarationStatement[17993-18036]:VariableDeclarationStatement[17993-18036]"
    }, {
      "left" : "if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction()))",
      "right" : "if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction()))",
      "info" : "IfStatement[18269-18415]:IfStatement[18269-18415]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18339-18415]:Block[18339-18415]"
    }, {
      "left" : "precedence = NodeUtil.precedence(first.getType()) + 1;",
      "right" : "precedence = NodeUtil.precedence(first.getType()) + 1;",
      "info" : "ExpressionStatement[18351-18405]:ExpressionStatement[18351-18405]"
    }, {
      "left" : "addExpr(first, precedence);",
      "right" : "addExpr(first, precedence);",
      "info" : "ExpressionStatement[18424-18451]:ExpressionStatement[18424-18451]"
    }, {
      "left" : "Node next = first.getNext();",
      "right" : "Node next = first.getNext();",
      "info" : "VariableDeclarationStatement[18519-18547]:VariableDeclarationStatement[18519-18547]"
    }, {
      "left" : "if (next != null)",
      "right" : "if (next != null)",
      "info" : "IfStatement[18556-18650]:IfStatement[18556-18650]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18574-18650]:Block[18574-18650]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[18586-18595]:ExpressionStatement[18586-18595]"
    }, {
      "left" : "addList(next);",
      "right" : "addList(next);",
      "info" : "ExpressionStatement[18606-18620]:ExpressionStatement[18606-18620]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[18631-18640]:ExpressionStatement[18631-18640]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[18659-18665]:BreakStatement[18659-18665]"
    }, {
      "left" : "case Token.STRING:",
      "right" : "case Token.STRING:",
      "info" : "SwitchCase[18673-18691]:SwitchCase[18673-18691]"
    }, {
      "left" : "if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0))",
      "right" : "if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0))",
      "info" : "IfStatement[18700-18957]:IfStatement[18700-18957]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18825-18957]:Block[18825-18957]"
    }, {
      "left" : "throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());",
      "right" : "throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());",
      "info" : "ThrowStatement[18837-18947]:ThrowStatement[18837-18947]"
    }, {
      "left" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "right" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "info" : "ExpressionStatement[18966-19017]:ExpressionStatement[18966-19017]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[19026-19032]:BreakStatement[19026-19032]"
    }, {
      "left" : "case Token.DELPROP:",
      "right" : "case Token.DELPROP:",
      "info" : "SwitchCase[19040-19059]:SwitchCase[19040-19059]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[19068-19110]:ExpressionStatement[19068-19110]"
    }, {
      "left" : "add(\"delete \");",
      "right" : "add(\"delete \");",
      "info" : "ExpressionStatement[19119-19134]:ExpressionStatement[19119-19134]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[19143-19154]:ExpressionStatement[19143-19154]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[19163-19169]:BreakStatement[19163-19169]"
    }, {
      "left" : "case Token.OBJECTLIT:",
      "right" : "case Token.OBJECTLIT:",
      "info" : "SwitchCase[19177-19198]:SwitchCase[19177-19198]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19199-20356]:Block[19199-20356]"
    }, {
      "left" : "boolean needsParens = (context == Context.START_OF_EXPR);",
      "right" : "boolean needsParens = (context == Context.START_OF_EXPR);",
      "info" : "VariableDeclarationStatement[19209-19266]:VariableDeclarationStatement[19209-19266]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[19275-19323]:IfStatement[19275-19323]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19292-19323]:Block[19292-19323]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[19304-19313]:ExpressionStatement[19304-19313]"
    }, {
      "left" : "add(\"{\");",
      "right" : "add(\"{\");",
      "info" : "ExpressionStatement[19332-19341]:ExpressionStatement[19332-19341]"
    }, {
      "left" : "for (Node c = first; c != null; c = c.getNext())",
      "right" : "for (Node c = first; c != null; c = c.getNext())",
      "info" : "ForStatement[19350-20258]:ForStatement[19350-20258]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19399-20258]:Block[19399-20258]"
    }, {
      "left" : "if (c != first)",
      "right" : "if (c != first)",
      "info" : "IfStatement[19411-19472]:IfStatement[19411-19472]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19427-19472]:Block[19427-19472]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[19441-19460]:ExpressionStatement[19441-19460]"
    }, {
      "left" : "if (c.getType() == Token.GET || c.getType() == Token.SET)",
      "right" : "if (c.getType() == Token.GET || c.getType() == Token.SET)",
      "info" : "IfStatement[19484-20248]:IfStatement[19484-20248]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19542-19575]:Block[19542-19575]"
    }, {
      "left" : "add(c);",
      "right" : "add(c);",
      "info" : "ExpressionStatement[19556-19563]:ExpressionStatement[19556-19563]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19581-20248]:Block[19581-20248]"
    }, {
      "left" : "if (c.getType() == Token.STRING &&\n                !c.isQuotedString() &&\n                !TokenStream.isKeyword(c.getString()) &&\n                TokenStream.isJSIdentifier(c.getString()) &&\n                // do not encode literally any non-literal characters that were\n                // unicode escaped.\n                NodeUtil.isLatin(c.getString()))",
      "right" : "if (c.getType() == Token.STRING &&\n                !c.isQuotedString() &&\n                !TokenStream.isKeyword(c.getString()) &&\n                TokenStream.isJSIdentifier(c.getString()) &&\n                // do not encode literally any non-literal characters that were\n                // unicode escaped.\n                NodeUtil.isLatin(c.getString()))",
      "info" : "IfStatement[19715-20171]:IfStatement[19715-20171]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20072-20121]:Block[20072-20121]"
    }, {
      "left" : "add(c.getString());",
      "right" : "add(c.getString());",
      "info" : "ExpressionStatement[20088-20107]:ExpressionStatement[20088-20107]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20127-20171]:Block[20127-20171]"
    }, {
      "left" : "addExpr(c, 1);",
      "right" : "addExpr(c, 1);",
      "info" : "ExpressionStatement[20143-20157]:ExpressionStatement[20143-20157]"
    }, {
      "left" : "add(\":\");",
      "right" : "add(\":\");",
      "info" : "ExpressionStatement[20184-20193]:ExpressionStatement[20184-20193]"
    }, {
      "left" : "addExpr(c.getFirstChild(), 1);",
      "right" : "addExpr(c.getFirstChild(), 1);",
      "info" : "ExpressionStatement[20206-20236]:ExpressionStatement[20206-20236]"
    }, {
      "left" : "add(\"}\");",
      "right" : "add(\"}\");",
      "info" : "ExpressionStatement[20267-20276]:ExpressionStatement[20267-20276]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[20285-20333]:IfStatement[20285-20333]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20302-20333]:Block[20302-20333]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[20314-20323]:ExpressionStatement[20314-20323]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[20342-20348]:BreakStatement[20342-20348]"
    }, {
      "left" : "case Token.SWITCH:",
      "right" : "case Token.SWITCH:",
      "info" : "SwitchCase[20364-20382]:SwitchCase[20364-20382]"
    }, {
      "left" : "add(\"switch(\");",
      "right" : "add(\"switch(\");",
      "info" : "ExpressionStatement[20391-20406]:ExpressionStatement[20391-20406]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[20415-20426]:ExpressionStatement[20415-20426]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[20435-20444]:ExpressionStatement[20435-20444]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[20453-20469]:ExpressionStatement[20453-20469]"
    }, {
      "left" : "addAllSiblings(first.getNext());",
      "right" : "addAllSiblings(first.getNext());",
      "info" : "ExpressionStatement[20478-20510]:ExpressionStatement[20478-20510]"
    }, {
      "left" : "cc.endBlock(context == Context.STATEMENT);",
      "right" : "cc.endBlock(context == Context.STATEMENT);",
      "info" : "ExpressionStatement[20519-20561]:ExpressionStatement[20519-20561]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[20570-20576]:BreakStatement[20570-20576]"
    }, {
      "left" : "case Token.CASE:",
      "right" : "case Token.CASE:",
      "info" : "SwitchCase[20584-20600]:SwitchCase[20584-20600]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[20609-20651]:ExpressionStatement[20609-20651]"
    }, {
      "left" : "add(\"case \");",
      "right" : "add(\"case \");",
      "info" : "ExpressionStatement[20660-20673]:ExpressionStatement[20660-20673]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[20682-20693]:ExpressionStatement[20682-20693]"
    }, {
      "left" : "addCaseBody(last);",
      "right" : "addCaseBody(last);",
      "info" : "ExpressionStatement[20702-20720]:ExpressionStatement[20702-20720]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[20729-20735]:BreakStatement[20729-20735]"
    }, {
      "left" : "case Token.DEFAULT:",
      "right" : "case Token.DEFAULT:",
      "info" : "SwitchCase[20743-20762]:SwitchCase[20743-20762]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[20771-20813]:ExpressionStatement[20771-20813]"
    }, {
      "left" : "add(\"default\");",
      "right" : "add(\"default\");",
      "info" : "ExpressionStatement[20822-20837]:ExpressionStatement[20822-20837]"
    }, {
      "left" : "addCaseBody(first);",
      "right" : "addCaseBody(first);",
      "info" : "ExpressionStatement[20846-20865]:ExpressionStatement[20846-20865]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[20874-20880]:BreakStatement[20874-20880]"
    }, {
      "left" : "case Token.LABEL:",
      "right" : "case Token.LABEL:",
      "info" : "SwitchCase[20888-20905]:SwitchCase[20888-20905]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[20914-20956]:ExpressionStatement[20914-20956]"
    }, {
      "left" : "if (first.getType() != Token.LABEL_NAME)",
      "right" : "if (first.getType() != Token.LABEL_NAME)",
      "info" : "IfStatement[20965-21092]:IfStatement[20965-21092]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21006-21092]:Block[21006-21092]"
    }, {
      "left" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "right" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "info" : "ThrowStatement[21018-21082]:ThrowStatement[21018-21082]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[21101-21112]:ExpressionStatement[21101-21112]"
    }, {
      "left" : "add(\":\");",
      "right" : "add(\":\");",
      "info" : "ExpressionStatement[21121-21130]:ExpressionStatement[21121-21130]"
    }, {
      "left" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);",
      "right" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);",
      "info" : "ExpressionStatement[21139-21227]:ExpressionStatement[21139-21227]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[21236-21242]:BreakStatement[21236-21242]"
    }, {
      "left" : "case Token.SETNAME:",
      "right" : "case Token.SETNAME:",
      "info" : "SwitchCase[21365-21384]:SwitchCase[21365-21384]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[21393-21399]:BreakStatement[21393-21399]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[21407-21415]:SwitchCase[21407-21415]"
    }, {
      "left" : "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());",
      "right" : "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());",
      "info" : "ThrowStatement[21424-21490]:ThrowStatement[21424-21490]"
    }, {
      "left" : "cc.endSourceMapping(n);",
      "right" : "cc.endSourceMapping(n);",
      "info" : "ExpressionStatement[21502-21525]:ExpressionStatement[21502-21525]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21635-21757]:Block[21635-21757]"
    }, {
      "left" : "return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);",
      "right" : "return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);",
      "info" : "ReturnStatement[21641-21753]:ReturnStatement[21641-21753]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22128-23917]:Block[22128-23917]"
    }, {
      "left" : "Node nodeToProcess = n;",
      "right" : "Node nodeToProcess = n;",
      "info" : "VariableDeclarationStatement[22134-22157]:VariableDeclarationStatement[22134-22157]"
    }, {
      "left" : "if (!allowNonBlockChild && n.getType() != Token.BLOCK)",
      "right" : "if (!allowNonBlockChild && n.getType() != Token.BLOCK)",
      "info" : "IfStatement[22163-22272]:IfStatement[22163-22272]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22218-22272]:Block[22218-22272]"
    }, {
      "left" : "throw new Error(\"Missing BLOCK child.\");",
      "right" : "throw new Error(\"Missing BLOCK child.\");",
      "info" : "ThrowStatement[22226-22266]:ThrowStatement[22226-22266]"
    }, {
      "left" : "if (n.getType() == Token.BLOCK)",
      "right" : "if (n.getType() == Token.BLOCK)",
      "info" : "IfStatement[22403-23544]:IfStatement[22403-23544]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22435-23544]:Block[22435-23544]"
    }, {
      "left" : "int count = getNonEmptyChildCount(n, 2);",
      "right" : "int count = getNonEmptyChildCount(n, 2);",
      "info" : "VariableDeclarationStatement[22443-22483]:VariableDeclarationStatement[22443-22483]"
    }, {
      "left" : "if (count == 0)",
      "right" : "if (count == 0)",
      "info" : "IfStatement[22490-22743]:IfStatement[22490-22743]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22506-22743]:Block[22506-22743]"
    }, {
      "left" : "if (cc.shouldPreserveExtraBlocks())",
      "right" : "if (cc.shouldPreserveExtraBlocks())",
      "info" : "IfStatement[22516-22719]:IfStatement[22516-22719]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22552-22669]:Block[22552-22669]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[22564-22580]:ExpressionStatement[22564-22580]"
    }, {
      "left" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "right" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "info" : "ExpressionStatement[22591-22659]:ExpressionStatement[22591-22659]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22675-22719]:Block[22675-22719]"
    }, {
      "left" : "cc.endStatement(true);",
      "right" : "cc.endStatement(true);",
      "info" : "ExpressionStatement[22687-22709]:ExpressionStatement[22687-22709]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[22728-22735]:ReturnStatement[22728-22735]"
    }, {
      "left" : "if (count == 1)",
      "right" : "if (count == 1)",
      "info" : "IfStatement[22751-23464]:IfStatement[22751-23464]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22767-23464]:Block[22767-23464]"
    }, {
      "left" : "Node firstAndOnlyChild = getFirstNonEmptyChild(n);",
      "right" : "Node firstAndOnlyChild = getFirstNonEmptyChild(n);",
      "info" : "VariableDeclarationStatement[22935-22985]:VariableDeclarationStatement[22935-22985]"
    }, {
      "left" : "boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();",
      "right" : "boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();",
      "info" : "VariableDeclarationStatement[22994-23053]:VariableDeclarationStatement[22994-23053]"
    }, {
      "left" : "if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild))",
      "right" : "if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild))",
      "info" : "IfStatement[23062-23456]:IfStatement[23062-23456]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23132-23351]:Block[23132-23351]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[23144-23160]:ExpressionStatement[23144-23160]"
    }, {
      "left" : "add(firstAndOnlyChild, Context.STATEMENT);",
      "right" : "add(firstAndOnlyChild, Context.STATEMENT);",
      "info" : "ExpressionStatement[23171-23213]:ExpressionStatement[23171-23213]"
    }, {
      "left" : "cc.maybeLineBreak();",
      "right" : "cc.maybeLineBreak();",
      "info" : "ExpressionStatement[23224-23244]:ExpressionStatement[23224-23244]"
    }, {
      "left" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "right" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "info" : "ExpressionStatement[23255-23323]:ExpressionStatement[23255-23323]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[23334-23341]:ReturnStatement[23334-23341]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23357-23456]:Block[23357-23456]"
    }, {
      "left" : "nodeToProcess = firstAndOnlyChild;",
      "right" : "nodeToProcess = firstAndOnlyChild;",
      "info" : "ExpressionStatement[23412-23446]:ExpressionStatement[23412-23446]"
    }, {
      "left" : "if (count > 1)",
      "right" : "if (count > 1)",
      "info" : "IfStatement[23472-23538]:IfStatement[23472-23538]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23487-23538]:Block[23487-23538]"
    }, {
      "left" : "context = Context.PRESERVE_BLOCK;",
      "right" : "context = Context.PRESERVE_BLOCK;",
      "info" : "ExpressionStatement[23497-23530]:ExpressionStatement[23497-23530]"
    }, {
      "left" : "if (nodeToProcess.getType() == Token.EMPTY)",
      "right" : "if (nodeToProcess.getType() == Token.EMPTY)",
      "info" : "IfStatement[23550-23913]:IfStatement[23550-23913]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23594-23630]:Block[23594-23630]"
    }, {
      "left" : "cc.endStatement(true);",
      "right" : "cc.endStatement(true);",
      "info" : "ExpressionStatement[23602-23624]:ExpressionStatement[23602-23624]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23636-23913]:Block[23636-23913]"
    }, {
      "left" : "add(nodeToProcess, context);",
      "right" : "add(nodeToProcess, context);",
      "info" : "ExpressionStatement[23644-23672]:ExpressionStatement[23644-23672]"
    }, {
      "left" : "if (nodeToProcess.getType() == Token.VAR)",
      "right" : "if (nodeToProcess.getType() == Token.VAR)",
      "info" : "IfStatement[23829-23907]:IfStatement[23829-23907]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23871-23907]:Block[23871-23907]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[23881-23899]:ExpressionStatement[23881-23899]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24063-24836]:Block[24063-24836]"
    }, {
      "left" : "if (n.getType() == Token.LABEL)",
      "right" : "if (n.getType() == Token.LABEL)",
      "info" : "IfStatement[24069-24832]:IfStatement[24069-24832]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24101-24746]:Block[24101-24746]"
    }, {
      "left" : "Node labeledStatement = n.getLastChild();",
      "right" : "Node labeledStatement = n.getLastChild();",
      "info" : "VariableDeclarationStatement[24109-24150]:VariableDeclarationStatement[24109-24150]"
    }, {
      "left" : "if (labeledStatement.getType() != Token.BLOCK)",
      "right" : "if (labeledStatement.getType() != Token.BLOCK)",
      "info" : "IfStatement[24157-24740]:IfStatement[24157-24740]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24204-24272]:Block[24204-24272]"
    }, {
      "left" : "return isOneExactlyFunctionOrDo(labeledStatement);",
      "right" : "return isOneExactlyFunctionOrDo(labeledStatement);",
      "info" : "ReturnStatement[24214-24264]:ReturnStatement[24214-24264]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24278-24740]:Block[24278-24740]"
    }, {
      "left" : "if (getNonEmptyChildCount(n, 2) == 1)",
      "right" : "if (getNonEmptyChildCount(n, 2) == 1)",
      "info" : "IfStatement[24453-24732]:IfStatement[24453-24732]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24491-24571]:Block[24491-24571]"
    }, {
      "left" : "return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));",
      "right" : "return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));",
      "info" : "ReturnStatement[24503-24561]:ReturnStatement[24503-24561]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24577-24732]:Block[24577-24732]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[24709-24722]:ReturnStatement[24709-24722]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24752-24832]:Block[24752-24832]"
    }, {
      "left" : "return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);",
      "right" : "return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);",
      "info" : "ReturnStatement[24760-24826]:ReturnStatement[24760-24826]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25335-25380]:Block[25335-25380]"
    }, {
      "left" : "addExpr(n, minPrecedence, context);",
      "right" : "addExpr(n, minPrecedence, context);",
      "info" : "ExpressionStatement[25341-25376]:ExpressionStatement[25341-25376]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25424-25475]:Block[25424-25475]"
    }, {
      "left" : "addExpr(n, minPrecedence, Context.OTHER);",
      "right" : "addExpr(n, minPrecedence, Context.OTHER);",
      "info" : "ExpressionStatement[25430-25471]:ExpressionStatement[25430-25471]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25544-25826]:Block[25544-25826]"
    }, {
      "left" : "if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\n        (n.getType() == Token.IN)))",
      "right" : "if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\n        (n.getType() == Token.IN)))",
      "info" : "IfStatement[25550-25822]:IfStatement[25550-25822]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25695-25786]:Block[25695-25786]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[25703-25712]:ExpressionStatement[25703-25712]"
    }, {
      "left" : "add(n, clearContextForNoInOperator(context));",
      "right" : "add(n, clearContextForNoInOperator(context));",
      "info" : "ExpressionStatement[25719-25764]:ExpressionStatement[25719-25764]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[25771-25780]:ExpressionStatement[25771-25780]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25792-25822]:Block[25792-25822]"
    }, {
      "left" : "add(n, context);",
      "right" : "add(n, context);",
      "info" : "ExpressionStatement[25800-25816]:ExpressionStatement[25800-25816]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25861-25913]:Block[25861-25913]"
    }, {
      "left" : "addList(firstInList, true, Context.OTHER);",
      "right" : "addList(firstInList, true, Context.OTHER);",
      "info" : "ExpressionStatement[25867-25909]:ExpressionStatement[25867-25909]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25983-26056]:Block[25983-26056]"
    }, {
      "left" : "addList(firstInList, isArrayOrFunctionArgument, Context.OTHER);",
      "right" : "addList(firstInList, isArrayOrFunctionArgument, Context.OTHER);",
      "info" : "ExpressionStatement[25989-26052]:ExpressionStatement[25989-26052]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26161-26473]:Block[26161-26473]"
    }, {
      "left" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "right" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "info" : "ForStatement[26167-26469]:ForStatement[26167-26469]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26222-26469]:Block[26222-26469]"
    }, {
      "left" : "boolean isFirst = n == firstInList;",
      "right" : "boolean isFirst = n == firstInList;",
      "info" : "VariableDeclarationStatement[26230-26265]:VariableDeclarationStatement[26230-26265]"
    }, {
      "left" : "if (isFirst)",
      "right" : "if (isFirst)",
      "info" : "IfStatement[26272-26463]:IfStatement[26272-26463]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26285-26365]:Block[26285-26365]"
    }, {
      "left" : "addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);",
      "right" : "addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);",
      "info" : "ExpressionStatement[26295-26357]:ExpressionStatement[26295-26357]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26371-26463]:Block[26371-26463]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[26381-26400]:ExpressionStatement[26381-26400]"
    }, {
      "left" : "addExpr(n, isArrayOrFunctionArgument ? 1 : 0);",
      "right" : "addExpr(n, isArrayOrFunctionArgument ? 1 : 0);",
      "info" : "ExpressionStatement[26409-26455]:ExpressionStatement[26409-26455]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26864-27163]:Block[26864-27163]"
    }, {
      "left" : "boolean lastWasEmpty = false;",
      "right" : "boolean lastWasEmpty = false;",
      "info" : "VariableDeclarationStatement[26870-26899]:VariableDeclarationStatement[26870-26899]"
    }, {
      "left" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "right" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "info" : "ForStatement[26904-27102]:ForStatement[26904-27102]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26959-27102]:Block[26959-27102]"
    }, {
      "left" : "if (n != firstInList)",
      "right" : "if (n != firstInList)",
      "info" : "IfStatement[26967-27026]:IfStatement[26967-27026]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26989-27026]:Block[26989-27026]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[26999-27018]:ExpressionStatement[26999-27018]"
    }, {
      "left" : "addExpr(n, 1);",
      "right" : "addExpr(n, 1);",
      "info" : "ExpressionStatement[27033-27047]:ExpressionStatement[27033-27047]"
    }, {
      "left" : "lastWasEmpty = n.getType() == Token.EMPTY;",
      "right" : "lastWasEmpty = n.getType() == Token.EMPTY;",
      "info" : "ExpressionStatement[27054-27096]:ExpressionStatement[27054-27096]"
    }, {
      "left" : "if (lastWasEmpty)",
      "right" : "if (lastWasEmpty)",
      "info" : "IfStatement[27108-27159]:IfStatement[27108-27159]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27126-27159]:Block[27126-27159]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[27134-27153]:ExpressionStatement[27134-27153]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27199-27269]:Block[27199-27269]"
    }, {
      "left" : "cc.beginCaseBody();",
      "right" : "cc.beginCaseBody();",
      "info" : "ExpressionStatement[27205-27224]:ExpressionStatement[27205-27224]"
    }, {
      "left" : "add(caseBody);",
      "right" : "add(caseBody);",
      "info" : "ExpressionStatement[27229-27243]:ExpressionStatement[27229-27243]"
    }, {
      "left" : "cc.endCaseBody();",
      "right" : "cc.endCaseBody();",
      "info" : "ExpressionStatement[27248-27265]:ExpressionStatement[27248-27265]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27301-27377]:Block[27301-27377]"
    }, {
      "left" : "for (Node c = n; c != null; c = c.getNext())",
      "right" : "for (Node c = n; c != null; c = c.getNext())",
      "info" : "ForStatement[27307-27373]:ForStatement[27307-27373]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27352-27373]:Block[27352-27373]"
    }, {
      "left" : "add(c);",
      "right" : "add(c);",
      "info" : "ExpressionStatement[27360-27367]:ExpressionStatement[27360-27367]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27531-28250]:Block[27531-28250]"
    }, {
      "left" : "int singleq = 0, doubleq = 0;",
      "right" : "int singleq = 0, doubleq = 0;",
      "info" : "VariableDeclarationStatement[27537-27566]:VariableDeclarationStatement[27537-27566]"
    }, {
      "left" : "for (int i = 0; i < s.length(); i++)",
      "right" : "for (int i = 0; i < s.length(); i++)",
      "info" : "ForStatement[27639-27793]:ForStatement[27639-27793]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27676-27793]:Block[27676-27793]"
    }, {
      "left" : "switch (s.charAt(i)) {\n        case '\"': doubleq++; break;\n        case '\\'': singleq++; break;\n      }",
      "right" : "switch (s.charAt(i)) {\n        case '\"': doubleq++; break;\n        case '\\'': singleq++; break;\n      }",
      "info" : "SwitchStatement[27684-27787]:SwitchStatement[27684-27787]"
    }, {
      "left" : "case '\"':",
      "right" : "case '\"':",
      "info" : "SwitchCase[27715-27724]:SwitchCase[27715-27724]"
    }, {
      "left" : "doubleq++;",
      "right" : "doubleq++;",
      "info" : "ExpressionStatement[27725-27735]:ExpressionStatement[27725-27735]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[27736-27742]:BreakStatement[27736-27742]"
    }, {
      "left" : "case '\\'':",
      "right" : "case '\\'':",
      "info" : "SwitchCase[27751-27761]:SwitchCase[27751-27761]"
    }, {
      "left" : "singleq++;",
      "right" : "singleq++;",
      "info" : "ExpressionStatement[27762-27772]:ExpressionStatement[27762-27772]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[27773-27779]:BreakStatement[27773-27779]"
    }, {
      "left" : "String doublequote, singlequote;",
      "right" : "String doublequote, singlequote;",
      "info" : "VariableDeclarationStatement[27799-27831]:VariableDeclarationStatement[27799-27831]"
    }, {
      "left" : "char quote;",
      "right" : "char quote;",
      "info" : "VariableDeclarationStatement[27836-27847]:VariableDeclarationStatement[27836-27847]"
    }, {
      "left" : "if (singleq < doubleq)",
      "right" : "if (singleq < doubleq)",
      "info" : "IfStatement[27852-28149]:IfStatement[27852-28149]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27875-28012]:Block[27875-28012]"
    }, {
      "left" : "quote = '\\'';",
      "right" : "quote = '\\'';",
      "info" : "ExpressionStatement[27939-27952]:ExpressionStatement[27939-27952]"
    }, {
      "left" : "doublequote = \"\\\"\";",
      "right" : "doublequote = \"\\\"\";",
      "info" : "ExpressionStatement[27959-27978]:ExpressionStatement[27959-27978]"
    }, {
      "left" : "singlequote = \"\\\\\\'\";",
      "right" : "singlequote = \"\\\\\\'\";",
      "info" : "ExpressionStatement[27985-28006]:ExpressionStatement[27985-28006]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28018-28149]:Block[28018-28149]"
    }, {
      "left" : "quote = '\\\"';",
      "right" : "quote = '\\\"';",
      "info" : "ExpressionStatement[28076-28089]:ExpressionStatement[28076-28089]"
    }, {
      "left" : "doublequote = \"\\\\\\\"\";",
      "right" : "doublequote = \"\\\\\\\"\";",
      "info" : "ExpressionStatement[28096-28117]:ExpressionStatement[28096-28117]"
    }, {
      "left" : "singlequote = \"\\'\";",
      "right" : "singlequote = \"\\'\";",
      "info" : "ExpressionStatement[28124-28143]:ExpressionStatement[28124-28143]"
    }, {
      "left" : "return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n        outputCharsetEncoder);",
      "right" : "return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n        outputCharsetEncoder);",
      "info" : "ReturnStatement[28155-28246]:ReturnStatement[28155-28246]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28364-28438]:Block[28364-28438]"
    }, {
      "left" : "return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);",
      "right" : "return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);",
      "info" : "ReturnStatement[28370-28434]:ReturnStatement[28370-28434]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28583-28647]:Block[28583-28647]"
    }, {
      "left" : "return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);",
      "right" : "return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);",
      "info" : "ReturnStatement[28589-28643]:ReturnStatement[28589-28643]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28813-28852]:Block[28813-28852]"
    }, {
      "left" : "return regexpEscape(s, null);",
      "right" : "return regexpEscape(s, null);",
      "info" : "ReturnStatement[28819-28848]:ReturnStatement[28819-28848]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29193-31677]:Block[29193-31721]"
    }, {
      "left" : "StringBuilder sb = new StringBuilder(s.length() + 2);",
      "right" : "StringBuilder sb = new StringBuilder(s.length() + 2);",
      "info" : "VariableDeclarationStatement[29199-29252]:VariableDeclarationStatement[29199-29252]"
    }, {
      "left" : "sb.append(quote);",
      "right" : "sb.append(quote);",
      "info" : "ExpressionStatement[29257-29274]:ExpressionStatement[29257-29274]"
    }, {
      "left" : "for (int i = 0; i < s.length(); i++)",
      "right" : "for (int i = 0; i < s.length(); i++)",
      "info" : "ForStatement[29279-31625]:ForStatement[29279-31669]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29316-31625]:Block[29316-31669]"
    }, {
      "left" : "char c = s.charAt(i);",
      "right" : "char c = s.charAt(i);",
      "info" : "VariableDeclarationStatement[29324-29345]:VariableDeclarationStatement[29324-29345]"
    }, {
      "left" : "switch (c) {\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }",
      "right" : "switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }",
      "info" : "SwitchStatement[29352-31619]:SwitchStatement[29352-31663]"
    }, {
      "left" : "case '\\n':",
      "right" : "case '\\n':",
      "info" : "SwitchCase[29373-29383]:SwitchCase[29417-29427]"
    }, {
      "left" : "sb.append(\"\\\\n\");",
      "right" : "sb.append(\"\\\\n\");",
      "info" : "ExpressionStatement[29384-29401]:ExpressionStatement[29428-29445]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[29402-29408]:BreakStatement[29402-29408]"
    }, {
      "left" : "case '\\r':",
      "right" : "case '\\r':",
      "info" : "SwitchCase[29417-29427]:SwitchCase[29461-29471]"
    }, {
      "left" : "sb.append(\"\\\\r\");",
      "right" : "sb.append(\"\\\\r\");",
      "info" : "ExpressionStatement[29428-29445]:ExpressionStatement[29472-29489]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[29446-29452]:BreakStatement[29446-29452]"
    }, {
      "left" : "case '\\t':",
      "right" : "case '\\t':",
      "info" : "SwitchCase[29461-29471]:SwitchCase[29505-29515]"
    }, {
      "left" : "sb.append(\"\\\\t\");",
      "right" : "sb.append(\"\\\\t\");",
      "info" : "ExpressionStatement[29472-29489]:ExpressionStatement[29516-29533]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[29490-29496]:BreakStatement[29490-29496]"
    }, {
      "left" : "case '\\\\':",
      "right" : "case '\\\\':",
      "info" : "SwitchCase[29505-29515]:SwitchCase[29549-29559]"
    }, {
      "left" : "sb.append(backslashEscape);",
      "right" : "sb.append(backslashEscape);",
      "info" : "ExpressionStatement[29516-29543]:ExpressionStatement[29560-29587]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[29544-29550]:BreakStatement[29534-29540]"
    }, {
      "left" : "case '\\\"':",
      "right" : "case '\\\"':",
      "info" : "SwitchCase[29559-29569]:SwitchCase[29603-29613]"
    }, {
      "left" : "sb.append(doublequoteEscape);",
      "right" : "sb.append(doublequoteEscape);",
      "info" : "ExpressionStatement[29570-29599]:ExpressionStatement[29614-29643]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[29600-29606]:BreakStatement[29588-29594]"
    }, {
      "left" : "case '\\'':",
      "right" : "case '\\'':",
      "info" : "SwitchCase[29615-29625]:SwitchCase[29659-29669]"
    }, {
      "left" : "sb.append(singlequoteEscape);",
      "right" : "sb.append(singlequoteEscape);",
      "info" : "ExpressionStatement[29626-29655]:ExpressionStatement[29670-29699]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[29656-29662]:BreakStatement[29644-29650]"
    }, {
      "left" : "case '>':",
      "right" : "case '>':",
      "info" : "SwitchCase[29671-29680]:SwitchCase[29715-29724]"
    }, {
      "left" : "if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']')))",
      "right" : "if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']')))",
      "info" : "IfStatement[29753-29992]:IfStatement[29797-30036]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29904-29947]:Block[29948-29991]"
    }, {
      "left" : "sb.append(\"\\\\>\");",
      "right" : "sb.append(\"\\\\>\");",
      "info" : "ExpressionStatement[29918-29935]:ExpressionStatement[29962-29979]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29953-29992]:Block[29997-30036]"
    }, {
      "left" : "sb.append(c);",
      "right" : "sb.append(c);",
      "info" : "ExpressionStatement[29967-29980]:ExpressionStatement[30011-30024]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[30003-30009]:BreakStatement[29700-29706]"
    }, {
      "left" : "case '<':",
      "right" : "case '<':",
      "info" : "SwitchCase[30018-30027]:SwitchCase[30062-30071]"
    }, {
      "left" : "final String END_SCRIPT = \"/script\";",
      "right" : "final String END_SCRIPT = \"/script\";",
      "info" : "VariableDeclarationStatement[30081-30117]:VariableDeclarationStatement[30125-30161]"
    }, {
      "left" : "final String START_COMMENT = \"!--\";",
      "right" : "final String START_COMMENT = \"!--\";",
      "info" : "VariableDeclarationStatement[30164-30199]:VariableDeclarationStatement[30208-30243]"
    }, {
      "left" : "if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length()))",
      "right" : "if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length()))",
      "info" : "IfStatement[30211-30562]:IfStatement[30255-30606]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30311-30354]:Block[30355-30398]"
    }, {
      "left" : "sb.append(\"<\\\\\");",
      "right" : "sb.append(\"<\\\\\");",
      "info" : "ExpressionStatement[30325-30342]:ExpressionStatement[30369-30386]"
    }, {
      "left" : "if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length()))",
      "right" : "if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length()))",
      "info" : "IfStatement[30360-30562]:IfStatement[30404-30606]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30474-30517]:Block[30518-30561]"
    }, {
      "left" : "sb.append(\"<\\\\\");",
      "right" : "sb.append(\"<\\\\\");",
      "info" : "ExpressionStatement[30488-30505]:ExpressionStatement[30532-30549]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30523-30562]:Block[30567-30606]"
    }, {
      "left" : "sb.append(c);",
      "right" : "sb.append(c);",
      "info" : "ExpressionStatement[30537-30550]:ExpressionStatement[30581-30594]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[30573-30579]:BreakStatement[30047-30053]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[30588-30596]:SwitchCase[30632-30640]"
    }, {
      "left" : "if (outputCharsetEncoder != null)",
      "right" : "if (outputCharsetEncoder != null)",
      "info" : "IfStatement[30744-31611]:IfStatement[30788-31655]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30778-31010]:Block[30822-31054]"
    }, {
      "left" : "if (outputCharsetEncoder.canEncode(c))",
      "right" : "if (outputCharsetEncoder.canEncode(c))",
      "info" : "IfStatement[30792-30998]:IfStatement[30836-31042]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30831-30874]:Block[30875-30918]"
    }, {
      "left" : "sb.append(c);",
      "right" : "sb.append(c);",
      "info" : "ExpressionStatement[30847-30860]:ExpressionStatement[30891-30904]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30880-30998]:Block[30924-31042]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(sb, c);",
      "right" : "appendHexJavaScriptRepresentation(sb, c);",
      "info" : "ExpressionStatement[30943-30984]:ExpressionStatement[30987-31028]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31016-31611]:Block[31060-31655]"
    }, {
      "left" : "if (c > 0x1f && c <= 0x7f)",
      "right" : "if (c > 0x1f && c <= 0x7f)",
      "info" : "IfStatement[31253-31599]:IfStatement[31297-31643]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31280-31323]:Block[31324-31367]"
    }, {
      "left" : "sb.append(c);",
      "right" : "sb.append(c);",
      "info" : "ExpressionStatement[31296-31309]:ExpressionStatement[31340-31353]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31329-31599]:Block[31373-31643]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(sb, c);",
      "right" : "appendHexJavaScriptRepresentation(sb, c);",
      "info" : "ExpressionStatement[31544-31585]:ExpressionStatement[31588-31629]"
    }, {
      "left" : "sb.append(quote);",
      "right" : "sb.append(quote);",
      "info" : "ExpressionStatement[31630-31647]:ExpressionStatement[31674-31691]"
    }, {
      "left" : "return sb.toString();",
      "right" : "return sb.toString();",
      "info" : "ReturnStatement[31652-31673]:ReturnStatement[31696-31717]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31722-32371]:Block[31766-32415]"
    }, {
      "left" : "if (NodeUtil.isLatin(s))",
      "right" : "if (NodeUtil.isLatin(s))",
      "info" : "IfStatement[31803-31851]:IfStatement[31847-31895]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31828-31851]:Block[31872-31895]"
    }, {
      "left" : "return s;",
      "right" : "return s;",
      "info" : "ReturnStatement[31836-31845]:ReturnStatement[31880-31889]"
    }, {
      "left" : "StringBuilder sb = new StringBuilder();",
      "right" : "StringBuilder sb = new StringBuilder();",
      "info" : "VariableDeclarationStatement[31935-31974]:VariableDeclarationStatement[31979-32018]"
    }, {
      "left" : "for (int i = 0; i < s.length(); i++)",
      "right" : "for (int i = 0; i < s.length(); i++)",
      "info" : "ForStatement[31979-32341]:ForStatement[32023-32385]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32016-32341]:Block[32060-32385]"
    }, {
      "left" : "char c = s.charAt(i);",
      "right" : "char c = s.charAt(i);",
      "info" : "VariableDeclarationStatement[32024-32045]:VariableDeclarationStatement[32068-32089]"
    }, {
      "left" : "if (c > 0x1F && c < 0x7F)",
      "right" : "if (c > 0x1F && c < 0x7F)",
      "info" : "IfStatement[32213-32335]:IfStatement[32257-32379]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32239-32270]:Block[32283-32314]"
    }, {
      "left" : "sb.append(c);",
      "right" : "sb.append(c);",
      "info" : "ExpressionStatement[32249-32262]:ExpressionStatement[32293-32306]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32276-32335]:Block[32320-32379]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(sb, c);",
      "right" : "appendHexJavaScriptRepresentation(sb, c);",
      "info" : "ExpressionStatement[32286-32327]:ExpressionStatement[32330-32371]"
    }, {
      "left" : "return sb.toString();",
      "right" : "return sb.toString();",
      "info" : "ReturnStatement[32346-32367]:ReturnStatement[32390-32411]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32603-32891]:Block[32647-32935]"
    }, {
      "left" : "int i = 0;",
      "right" : "int i = 0;",
      "info" : "VariableDeclarationStatement[32609-32619]:VariableDeclarationStatement[32653-32663]"
    }, {
      "left" : "Node c = n.getFirstChild();",
      "right" : "Node c = n.getFirstChild();",
      "info" : "VariableDeclarationStatement[32624-32651]:VariableDeclarationStatement[32668-32695]"
    }, {
      "left" : "for (; c != null && i < maxCount; c = c.getNext())",
      "right" : "for (; c != null && i < maxCount; c = c.getNext())",
      "info" : "ForStatement[32656-32873]:ForStatement[32700-32917]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32707-32873]:Block[32751-32917]"
    }, {
      "left" : "if (c.getType() == Token.BLOCK)",
      "right" : "if (c.getType() == Token.BLOCK)",
      "info" : "IfStatement[32715-32867]:IfStatement[32759-32911]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32747-32807]:Block[32791-32851]"
    }, {
      "left" : "i += getNonEmptyChildCount(c, maxCount-i);",
      "right" : "i += getNonEmptyChildCount(c, maxCount-i);",
      "info" : "ExpressionStatement[32757-32799]:ExpressionStatement[32801-32843]"
    }, {
      "left" : "if (c.getType() != Token.EMPTY)",
      "right" : "if (c.getType() != Token.EMPTY)",
      "info" : "IfStatement[32813-32867]:IfStatement[32857-32911]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32845-32867]:Block[32889-32911]"
    }, {
      "left" : "i++;",
      "right" : "i++;",
      "info" : "ExpressionStatement[32855-32859]:ExpressionStatement[32899-32903]"
    }, {
      "left" : "return i;",
      "right" : "return i;",
      "info" : "ReturnStatement[32878-32887]:ReturnStatement[32922-32931]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33004-33325]:Block[33048-33369]"
    }, {
      "left" : "for (Node c = n.getFirstChild(); c != null; c = c.getNext())",
      "right" : "for (Node c = n.getFirstChild(); c != null; c = c.getNext())",
      "info" : "ForStatement[33010-33304]:ForStatement[33054-33348]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33071-33304]:Block[33115-33348]"
    }, {
      "left" : "if (c.getType() == Token.BLOCK)",
      "right" : "if (c.getType() == Token.BLOCK)",
      "info" : "IfStatement[33079-33298]:IfStatement[33123-33342]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33111-33233]:Block[33155-33277]"
    }, {
      "left" : "Node result = getFirstNonEmptyChild(c);",
      "right" : "Node result = getFirstNonEmptyChild(c);",
      "info" : "VariableDeclarationStatement[33121-33160]:VariableDeclarationStatement[33165-33204]"
    }, {
      "left" : "if (result != null)",
      "right" : "if (result != null)",
      "info" : "IfStatement[33169-33225]:IfStatement[33213-33269]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33189-33225]:Block[33233-33269]"
    }, {
      "left" : "return result;",
      "right" : "return result;",
      "info" : "ReturnStatement[33201-33215]:ReturnStatement[33245-33259]"
    }, {
      "left" : "if (c.getType() != Token.EMPTY)",
      "right" : "if (c.getType() != Token.EMPTY)",
      "info" : "IfStatement[33239-33298]:IfStatement[33283-33342]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33271-33298]:Block[33315-33342]"
    }, {
      "left" : "return c;",
      "right" : "return c;",
      "info" : "ReturnStatement[33281-33290]:ReturnStatement[33325-33334]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[33309-33321]:ReturnStatement[33353-33365]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34008-34127]:Block[34052-34171]"
    }, {
      "left" : "return currentContext == Context.BEFORE_DANGLING_ELSE ?\n        Context.BEFORE_DANGLING_ELSE : Context.OTHER;",
      "right" : "return currentContext == Context.BEFORE_DANGLING_ELSE ?\n        Context.BEFORE_DANGLING_ELSE : Context.OTHER;",
      "info" : "ReturnStatement[34014-34123]:ReturnStatement[34058-34167]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34356-34466]:Block[34400-34510]"
    }, {
      "left" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);",
      "right" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);",
      "info" : "ReturnStatement[34362-34462]:ReturnStatement[34406-34506]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34816-34907]:Block[34860-34951]"
    }, {
      "left" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.OTHER : context);",
      "right" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.OTHER : context);",
      "info" : "ReturnStatement[34822-34903]:ReturnStatement[34866-34947]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35072-35261]:Block[35116-35305]"
    }, {
      "left" : "try{...}",
      "right" : "try{...}",
      "info" : "TryStatement[35078-35257]:TryStatement[35122-35301]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35082-35137]:Block[35126-35181]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(c, sb);",
      "right" : "appendHexJavaScriptRepresentation(c, sb);",
      "info" : "ExpressionStatement[35090-35131]:ExpressionStatement[35134-35175]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35161-35257]:Block[35205-35301]"
    }, {
      "left" : "throw new RuntimeException(ex);",
      "right" : "throw new RuntimeException(ex);",
      "info" : "ThrowStatement[35220-35251]:ThrowStatement[35264-35295]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35613-36351]:Block[35657-36395]"
    }, {
      "left" : "if (Character.isSupplementaryCodePoint(codePoint))",
      "right" : "if (Character.isSupplementaryCodePoint(codePoint))",
      "info" : "IfStatement[35619-36123]:IfStatement[35663-36167]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35670-36123]:Block[35714-36167]"
    }, {
      "left" : "char[] surrogates = Character.toChars(codePoint);",
      "right" : "char[] surrogates = Character.toChars(codePoint);",
      "info" : "VariableDeclarationStatement[35932-35981]:VariableDeclarationStatement[35976-36025]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(surrogates[0], out);",
      "right" : "appendHexJavaScriptRepresentation(surrogates[0], out);",
      "info" : "ExpressionStatement[35988-36042]:ExpressionStatement[36032-36086]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(surrogates[1], out);",
      "right" : "appendHexJavaScriptRepresentation(surrogates[1], out);",
      "info" : "ExpressionStatement[36049-36103]:ExpressionStatement[36093-36147]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[36110-36117]:ReturnStatement[36154-36161]"
    }, {
      "left" : "out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);",
      "right" : "out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);",
      "info" : "ExpressionStatement[36128-36347]:ExpressionStatement[36172-36391]"
    } ]
  },
  "interFileMappings" : { }
}