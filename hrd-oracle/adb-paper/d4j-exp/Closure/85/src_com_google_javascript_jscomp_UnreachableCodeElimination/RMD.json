{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "UnreachableCodeElimination",
      "right" : "UnreachableCodeElimination",
      "info" : "TypeDeclaration[1315-8283]:TypeDeclaration[1315-7931]"
    }, {
      "left" : "private static final Logger logger =\n    Logger.getLogger(UnreachableCodeElimination.class.getName());",
      "right" : "private static final Logger logger =\n    Logger.getLogger(UnreachableCodeElimination.class.getName());",
      "info" : "FieldDeclaration[1987-2089]:FieldDeclaration[1987-2089]"
    }, {
      "left" : "private final AbstractCompiler compiler;",
      "right" : "private final AbstractCompiler compiler;",
      "info" : "FieldDeclaration[2093-2133]:FieldDeclaration[2093-2133]"
    }, {
      "left" : "private final boolean removeNoOpStatements;",
      "right" : "private final boolean removeNoOpStatements;",
      "info" : "FieldDeclaration[2136-2179]:FieldDeclaration[2136-2179]"
    }, {
      "left" : "Deque<ControlFlowGraph<Node>> cfgStack =\n      new LinkedList<ControlFlowGraph<Node>>();",
      "right" : "Deque<ControlFlowGraph<Node>> cfgStack =\n      new LinkedList<ControlFlowGraph<Node>>();",
      "info" : "FieldDeclaration[2183-2271]:FieldDeclaration[2183-2271]"
    }, {
      "left" : "ControlFlowGraph<Node> curCfg = null;",
      "right" : "ControlFlowGraph<Node> curCfg = null;",
      "info" : "FieldDeclaration[2275-2312]:FieldDeclaration[2275-2312]"
    }, {
      "left" : "UnreachableCodeElimination(AbstractCompiler compiler,\n      boolean removeNoOpStatements)",
      "right" : "UnreachableCodeElimination(AbstractCompiler compiler,\n      boolean removeNoOpStatements)",
      "info" : "MethodDeclaration[2316-2495]:MethodDeclaration[2316-2495]"
    }, {
      "left" : "public void enterScope(NodeTraversal t)",
      "right" : "public void enterScope(NodeTraversal t)",
      "info" : "MethodDeclaration[2499-2920]:MethodDeclaration[2499-2920]"
    }, {
      "left" : "public void exitScope(NodeTraversal t)",
      "right" : "public void exitScope(NodeTraversal t)",
      "info" : "MethodDeclaration[2924-3009]:MethodDeclaration[2924-3009]"
    }, {
      "left" : "public void process(Node externs, Node root)",
      "right" : "public void process(Node externs, Node root)",
      "info" : "MethodDeclaration[3013-3125]:MethodDeclaration[3013-3125]"
    }, {
      "left" : "public void visit(NodeTraversal t, Node n, Node parent)",
      "right" : "public void visit(NodeTraversal t, Node n, Node parent)",
      "info" : "MethodDeclaration[3129-3705]:MethodDeclaration[3129-3705]"
    }, {
      "left" : "private Node tryRemoveUnconditionalBranching(Node n)",
      "right" : "private Node tryRemoveUnconditionalBranching(Node n)",
      "info" : "MethodDeclaration[3709-6958]:MethodDeclaration[3709-6409]"
    }, {
      "left" : "private Node computeFollowing(Node n)",
      "right" : "private Node computeFollowing(Node n)",
      "info" : "MethodDeclaration[6962-7080]:MethodDeclaration[6413-6728]"
    }, {
      "left" : "private void removeDeadExprStatementSafely(Node n)",
      "right" : "private void removeDeadExprStatementSafely(Node n)",
      "info" : "MethodDeclaration[7084-8281]:MethodDeclaration[6732-7929]"
    } ],
    "mappings" : [
 {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[1871-1876]:TYPE_DECLARATION_KIND[1871-1876]"
    }, {
      "left" : "UnreachableCodeElimination",
      "right" : "UnreachableCodeElimination",
      "info" : "SimpleName[1877-1903]:SimpleName[1877-1903]"
    }, {
      "left" : "AbstractPostOrderCallback",
      "right" : "AbstractPostOrderCallback",
      "info" : "SimpleType[1912-1937]:SimpleType[1912-1937]"
    }, {
      "left" : "CompilerPass",
      "right" : "CompilerPass",
      "info" : "SimpleType[1953-1965]:SimpleType[1953-1965]"
    }, {
      "left" : "ScopedCallback",
      "right" : "ScopedCallback",
      "info" : "SimpleType[1967-1981]:SimpleType[1967-1981]"
    }, {
      "left" : "UnreachableCodeElimination",
      "right" : "UnreachableCodeElimination",
      "info" : "SimpleName[2316-2342]:SimpleName[2316-2342]"
    }, {
      "left" : "AbstractCompiler compiler",
      "right" : "AbstractCompiler compiler",
      "info" : "SingleVariableDeclaration[2343-2368]:SingleVariableDeclaration[2343-2368]"
    }, {
      "left" : "boolean removeNoOpStatements",
      "right" : "boolean removeNoOpStatements",
      "info" : "SingleVariableDeclaration[2376-2404]:SingleVariableDeclaration[2376-2404]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2406-2495]:Block[2406-2495]"
    }, {
      "left" : "this.compiler = compiler;",
      "right" : "this.compiler = compiler;",
      "info" : "ExpressionStatement[2412-2437]:ExpressionStatement[2412-2437]"
    }, {
      "left" : "this.removeNoOpStatements = removeNoOpStatements;",
      "right" : "this.removeNoOpStatements = removeNoOpStatements;",
      "info" : "ExpressionStatement[2442-2491]:ExpressionStatement[2442-2491]"
    }, {
      "left" : "@Override",
      "right" : "@Override",
      "info" : "MarkerAnnotation[2499-2508]:MarkerAnnotation[2499-2508]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[2511-2517]:Modifier[2511-2517]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[2518-2522]:PrimitiveType[2518-2522]"
    }, {
      "left" : "enterScope",
      "right" : "enterScope",
      "info" : "SimpleName[2523-2533]:SimpleName[2523-2533]"
    }, {
      "left" : "NodeTraversal t",
      "right" : "NodeTraversal t",
      "info" : "SingleVariableDeclaration[2534-2549]:SingleVariableDeclaration[2534-2549]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2551-2920]:Block[2551-2920]"
    }, {
      "left" : "Scope scope = t.getScope();",
      "right" : "Scope scope = t.getScope();",
      "info" : "VariableDeclarationStatement[2557-2584]:VariableDeclarationStatement[2557-2584]"
    }, {
      "left" : "ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);",
      "right" : "ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);",
      "info" : "VariableDeclarationStatement[2630-2704]:VariableDeclarationStatement[2630-2704]"
    }, {
      "left" : "cfa.process(null, scope.getRootNode());",
      "right" : "cfa.process(null, scope.getRootNode());",
      "info" : "ExpressionStatement[2709-2748]:ExpressionStatement[2709-2748]"
    }, {
      "left" : "cfgStack.push(curCfg);",
      "right" : "cfgStack.push(curCfg);",
      "info" : "ExpressionStatement[2753-2775]:ExpressionStatement[2753-2775]"
    }, {
      "left" : "curCfg = cfa.getCfg();",
      "right" : "curCfg = cfa.getCfg();",
      "info" : "ExpressionStatement[2780-2802]:ExpressionStatement[2780-2802]"
    }, {
      "left" : "new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)\n        .compute(curCfg.getEntry().getValue());",
      "right" : "new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)\n        .compute(curCfg.getEntry().getValue());",
      "info" : "ExpressionStatement[2808-2916]:ExpressionStatement[2808-2916]"
    }, {
      "left" : "@Override",
      "right" : "@Override",
      "info" : "MarkerAnnotation[2924-2933]:MarkerAnnotation[2924-2933]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[2936-2942]:Modifier[2936-2942]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[2943-2947]:PrimitiveType[2943-2947]"
    }, {
      "left" : "exitScope",
      "right" : "exitScope",
      "info" : "SimpleName[2948-2957]:SimpleName[2948-2957]"
    }, {
      "left" : "NodeTraversal t",
      "right" : "NodeTraversal t",
      "info" : "SingleVariableDeclaration[2958-2973]:SingleVariableDeclaration[2958-2973]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2975-3009]:Block[2975-3009]"
    }, {
      "left" : "curCfg = cfgStack.pop();",
      "right" : "curCfg = cfgStack.pop();",
      "info" : "ExpressionStatement[2981-3005]:ExpressionStatement[2981-3005]"
    }, {
      "left" : "@Override",
      "right" : "@Override",
      "info" : "MarkerAnnotation[3013-3022]:MarkerAnnotation[3013-3022]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[3025-3031]:Modifier[3025-3031]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[3032-3036]:PrimitiveType[3032-3036]"
    }, {
      "left" : "process",
      "right" : "process",
      "info" : "SimpleName[3037-3044]:SimpleName[3037-3044]"
    }, {
      "left" : "Node externs",
      "right" : "Node externs",
      "info" : "SingleVariableDeclaration[3045-3057]:SingleVariableDeclaration[3045-3057]"
    }, {
      "left" : "Node root",
      "right" : "Node root",
      "info" : "SingleVariableDeclaration[3059-3068]:SingleVariableDeclaration[3059-3068]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3070-3125]:Block[3070-3125]"
    }, {
      "left" : "NodeTraversal.traverse(compiler, root, this);",
      "right" : "NodeTraversal.traverse(compiler, root, this);",
      "info" : "ExpressionStatement[3076-3121]:ExpressionStatement[3076-3121]"
    }, {
      "left" : "@Override",
      "right" : "@Override",
      "info" : "MarkerAnnotation[3129-3138]:MarkerAnnotation[3129-3138]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[3141-3147]:Modifier[3141-3147]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[3148-3152]:PrimitiveType[3148-3152]"
    }, {
      "left" : "visit",
      "right" : "visit",
      "info" : "SimpleName[3153-3158]:SimpleName[3153-3158]"
    }, {
      "left" : "NodeTraversal t",
      "right" : "NodeTraversal t",
      "info" : "SingleVariableDeclaration[3159-3174]:SingleVariableDeclaration[3159-3174]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[3176-3182]:SingleVariableDeclaration[3176-3182]"
    }, {
      "left" : "Node parent",
      "right" : "Node parent",
      "info" : "SingleVariableDeclaration[3184-3195]:SingleVariableDeclaration[3184-3195]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3197-3705]:Block[3197-3705]"
    }, {
      "left" : "if (parent == null)",
      "right" : "if (parent == null)",
      "info" : "IfStatement[3203-3244]:IfStatement[3203-3244]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3223-3244]:Block[3223-3244]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[3231-3238]:ReturnStatement[3231-3238]"
    }, {
      "left" : "if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT)",
      "right" : "if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT)",
      "info" : "IfStatement[3249-3336]:IfStatement[3249-3336]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3315-3336]:Block[3315-3336]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[3323-3330]:ReturnStatement[3323-3330]"
    }, {
      "left" : "DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);",
      "right" : "DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);",
      "info" : "VariableDeclarationStatement[3342-3407]:VariableDeclarationStatement[3342-3407]"
    }, {
      "left" : "if (gNode == null)",
      "right" : "if (gNode == null)",
      "info" : "IfStatement[3412-3467]:IfStatement[3412-3467]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3431-3467]:Block[3431-3467]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[3454-3461]:ReturnStatement[3454-3461]"
    }, {
      "left" : "if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))",
      "right" : "if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))",
      "info" : "IfStatement[3472-3660]:IfStatement[3472-3660]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3599-3660]:Block[3599-3660]"
    }, {
      "left" : "removeDeadExprStatementSafely(n);",
      "right" : "removeDeadExprStatementSafely(n);",
      "info" : "ExpressionStatement[3607-3640]:ExpressionStatement[3607-3640]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[3647-3654]:ReturnStatement[3647-3654]"
    }, {
      "left" : "tryRemoveUnconditionalBranching(n);",
      "right" : "tryRemoveUnconditionalBranching(n);",
      "info" : "ExpressionStatement[3666-3701]:ExpressionStatement[3666-3701]"
    }, {
      "left" : "@SuppressWarnings(\"fallthrough\")",
      "right" : "@SuppressWarnings(\"fallthrough\")",
      "info" : "SingleMemberAnnotation[4634-4666]:SingleMemberAnnotation[4634-4666]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[4669-4676]:Modifier[4669-4676]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[4677-4681]:SimpleType[4677-4681]"
    }, {
      "left" : "tryRemoveUnconditionalBranching",
      "right" : "tryRemoveUnconditionalBranching",
      "info" : "SimpleName[4682-4713]:SimpleName[4682-4713]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[4714-4720]:SingleVariableDeclaration[4714-4720]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4722-6958]:Block[4722-6409]"
    }, {
      "left" : "if (n == null)",
      "right" : "if (n == null)",
      "info" : "IfStatement[5230-5269]:IfStatement[5230-5269]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5245-5269]:Block[5245-5269]"
    }, {
      "left" : "return n;",
      "right" : "return n;",
      "info" : "ReturnStatement[5254-5263]:ReturnStatement[5254-5263]"
    }, {
      "left" : "DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);",
      "right" : "DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);",
      "info" : "VariableDeclarationStatement[5275-5340]:VariableDeclarationStatement[5275-5340]"
    }, {
      "left" : "if (gNode == null)",
      "right" : "if (gNode == null)",
      "info" : "IfStatement[5346-5388]:IfStatement[5346-5388]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5365-5388]:Block[5365-5388]"
    }, {
      "left" : "return n;",
      "right" : "return n;",
      "info" : "ReturnStatement[5373-5382]:ReturnStatement[5373-5382]"
    }, {
      "left" : "switch (n.getType()) {\n      case Token.BLOCK:\n        if (n.hasChildren()) {\n          Node first = n.getFirstChild();\n          return tryRemoveUnconditionalBranching(first);\n        } else {\n          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n        }\n      case Token.RETURN:\n        if (n.hasChildren()) {\n          break;\n        }\n      case Token.BREAK:\n      case Token.CONTINUE:\n\n        // We are looking for a control flow changing statement that always\n        // branches to the same node. If removing it the control flow still\n        // branches to that same node. It is safe to remove it.\n        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n        if (outEdges.size() == 1 &&\n            // If there is a next node, there is no chance this jump is useless.\n            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n\n          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n          Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n          if (nextCfgNode == fallThrough) {\n            removeDeadExprStatementSafely(n);\n            return fallThrough;\n          }\n        }\n    }",
      "right" : "switch (n.getType()) {\n      case Token.RETURN:\n        if (n.hasChildren()) {\n          break;\n        }\n      case Token.BREAK:\n      case Token.CONTINUE:\n\n        // We are looking for a control flow changing statement that always\n        // branches to the same node. If removing it the control flow still\n        // branches to that same node. It is safe to remove it.\n        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n        if (outEdges.size() == 1 &&\n            // If there is a next node, there is no chance this jump is useless.\n            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n\n          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = computeFollowing(n);\n          Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n          if (nextCfgNode == fallThrough) {\n            removeDeadExprStatementSafely(n);\n            return fallThrough;\n          }\n        }\n    }",
      "info" : "SwitchStatement[5637-6940]:SwitchStatement[5394-6391]"
    }, {
      "left" : "case Token.RETURN:",
      "right" : "case Token.RETURN:",
      "info" : "SwitchCase[5939-5957]:SwitchCase[5423-5441]"
    }, {
      "left" : "if (n.hasChildren())",
      "right" : "if (n.hasChildren())",
      "info" : "IfStatement[5966-6015]:IfStatement[5450-5499]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5987-6015]:Block[5471-5499]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5999-6005]:BreakStatement[5483-5489]"
    }, {
      "left" : "case Token.BREAK:",
      "right" : "case Token.BREAK:",
      "info" : "SwitchCase[6022-6039]:SwitchCase[5506-5523]"
    }, {
      "left" : "case Token.CONTINUE:",
      "right" : "case Token.CONTINUE:",
      "info" : "SwitchCase[6046-6066]:SwitchCase[5530-5550]"
    }, {
      "left" : "List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();",
      "right" : "List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();",
      "info" : "VariableDeclarationStatement[6292-6354]:VariableDeclarationStatement[5776-5838]"
    }, {
      "left" : "if (outEdges.size() == 1 &&\n            // If there is a next node, there is no chance this jump is useless.\n            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION))",
      "right" : "if (outEdges.size() == 1 &&\n            // If there is a next node, there is no chance this jump is useless.\n            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION))",
      "info" : "IfStatement[6363-6934]:IfStatement[5847-6385]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6550-6934]:Block[6034-6385]"
    }, {
      "left" : "Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);",
      "right" : "Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);",
      "info" : "ExpressionStatement[6563-6633]:ExpressionStatement[6047-6117]"
    }, {
      "left" : "Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));",
      "right" : "Node fallThrough = computeFollowing(n);",
      "info" : "VariableDeclarationStatement[6644-6716]:VariableDeclarationStatement[6128-6167]"
    }, {
      "left" : "computeFollowing(n)",
      "right" : "computeFollowing(n)",
      "info" : "MethodInvocation[6695-6714]:MethodInvocation[6147-6166]"
    }, {
      "left" : "Node nextCfgNode = outEdges.get(0).getDestination().getValue();",
      "right" : "Node nextCfgNode = outEdges.get(0).getDestination().getValue();",
      "info" : "VariableDeclarationStatement[6727-6790]:VariableDeclarationStatement[6178-6241]"
    }, {
      "left" : "if (nextCfgNode == fallThrough)",
      "right" : "if (nextCfgNode == fallThrough)",
      "info" : "IfStatement[6801-6924]:IfStatement[6252-6375]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6833-6924]:Block[6284-6375]"
    }, {
      "left" : "removeDeadExprStatementSafely(n);",
      "right" : "removeDeadExprStatementSafely(n);",
      "info" : "ExpressionStatement[6847-6880]:ExpressionStatement[6298-6331]"
    }, {
      "left" : "return fallThrough;",
      "right" : "return fallThrough;",
      "info" : "ReturnStatement[6893-6912]:ReturnStatement[6344-6363]"
    }, {
      "left" : "return n;",
      "right" : "return n;",
      "info" : "ReturnStatement[6945-6954]:ReturnStatement[6396-6405]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[6962-6969]:Modifier[6413-6420]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[6970-6974]:SimpleType[6421-6425]"
    }, {
      "left" : "computeFollowing",
      "right" : "computeFollowing",
      "info" : "SimpleName[6975-6991]:SimpleName[6426-6442]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[6992-6998]:SingleVariableDeclaration[6443-6449]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7000-7080]:Block[6451-6728]"
    }, {
      "left" : "Node next = ControlFlowAnalysis.computeFollowNode(n);",
      "right" : "Node next = ControlFlowAnalysis.computeFollowNode(n);",
      "info" : "VariableDeclarationStatement[7006-7059]:VariableDeclarationStatement[6457-6510]"
    }, {
      "left" : "return next;",
      "right" : "return next;",
      "info" : "ReturnStatement[7064-7076]:ReturnStatement[6712-6724]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[7084-7091]:Modifier[6732-6739]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[7092-7096]:PrimitiveType[6740-6744]"
    }, {
      "left" : "removeDeadExprStatementSafely",
      "right" : "removeDeadExprStatementSafely",
      "info" : "SimpleName[7097-7126]:SimpleName[6745-6774]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[7127-7133]:SingleVariableDeclaration[6775-6781]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7135-8281]:Block[6783-7929]"
    }, {
      "left" : "Node parent = n.getParent();",
      "right" : "Node parent = n.getParent();",
      "info" : "VariableDeclarationStatement[7141-7169]:VariableDeclarationStatement[6789-6817]"
    }, {
      "left" : "if (n.getType() == Token.EMPTY ||\n        (n.getType() == Token.BLOCK && !n.hasChildren()))",
      "right" : "if (n.getType() == Token.EMPTY ||\n        (n.getType() == Token.BLOCK && !n.hasChildren()))",
      "info" : "IfStatement[7174-7365]:IfStatement[6822-7013]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7266-7365]:Block[6914-7013]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[7352-7359]:ReturnStatement[7000-7007]"
    }, {
      "left" : "switch (n.getType()) {\n      // Removing an unreachable DO node is messy because it means we still have\n      // to execute one iteration. If the DO's body has breaks in the middle, it\n      // can get even more trickier and code size might actually increase.\n      case Token.DO:\n        return;\n\n      case Token.BLOCK:\n        // BLOCKs are used in several ways including wrapping CATCH blocks in TRYs\n        if (parent.getType() == Token.TRY) {\n          if (NodeUtil.isTryCatchNodeContainer(n)) {\n            return;\n          }\n        }\n        break;\n\n      case Token.CATCH:\n        Node tryNode = parent.getParent();\n        NodeUtil.maybeAddFinally(tryNode);\n        break;\n    }",
      "right" : "switch (n.getType()) {\n      // Removing an unreachable DO node is messy because it means we still have\n      // to execute one iteration. If the DO's body has breaks in the middle, it\n      // can get even more trickier and code size might actually increase.\n      case Token.DO:\n        return;\n\n      case Token.BLOCK:\n        // BLOCKs are used in several ways including wrapping CATCH blocks in TRYs\n        if (parent.getType() == Token.TRY) {\n          if (NodeUtil.isTryCatchNodeContainer(n)) {\n            return;\n          }\n        }\n        break;\n\n      case Token.CATCH:\n        Node tryNode = parent.getParent();\n        NodeUtil.maybeAddFinally(tryNode);\n        break;\n    }",
      "info" : "SwitchStatement[7371-8062]:SwitchStatement[7019-7710]"
    }, {
      "left" : "case Token.DO:",
      "right" : "case Token.DO:",
      "info" : "SwitchCase[7637-7651]:SwitchCase[7285-7299]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[7660-7667]:ReturnStatement[7308-7315]"
    }, {
      "left" : "case Token.BLOCK:",
      "right" : "case Token.BLOCK:",
      "info" : "SwitchCase[7675-7692]:SwitchCase[7323-7340]"
    }, {
      "left" : "if (parent.getType() == Token.TRY)",
      "right" : "if (parent.getType() == Token.TRY)",
      "info" : "IfStatement[7784-7915]:IfStatement[7432-7563]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7819-7915]:Block[7467-7563]"
    }, {
      "left" : "if (NodeUtil.isTryCatchNodeContainer(n))",
      "right" : "if (NodeUtil.isTryCatchNodeContainer(n))",
      "info" : "IfStatement[7831-7905]:IfStatement[7479-7553]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7872-7905]:Block[7520-7553]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[7886-7893]:ReturnStatement[7534-7541]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[7924-7930]:BreakStatement[7572-7578]"
    }, {
      "left" : "case Token.CATCH:",
      "right" : "case Token.CATCH:",
      "info" : "SwitchCase[7938-7955]:SwitchCase[7586-7603]"
    }, {
      "left" : "Node tryNode = parent.getParent();",
      "right" : "Node tryNode = parent.getParent();",
      "info" : "VariableDeclarationStatement[7964-7998]:VariableDeclarationStatement[7612-7646]"
    }, {
      "left" : "NodeUtil.maybeAddFinally(tryNode);",
      "right" : "NodeUtil.maybeAddFinally(tryNode);",
      "info" : "ExpressionStatement[8007-8041]:ExpressionStatement[7655-7689]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8050-8056]:BreakStatement[7698-7704]"
    }, {
      "left" : "NodeUtil.redeclareVarsInsideBranch(n);",
      "right" : "NodeUtil.redeclareVarsInsideBranch(n);",
      "info" : "ExpressionStatement[8068-8106]:ExpressionStatement[7716-7754]"
    }, {
      "left" : "compiler.reportCodeChange();",
      "right" : "compiler.reportCodeChange();",
      "info" : "ExpressionStatement[8111-8139]:ExpressionStatement[7759-7787]"
    }, {
      "left" : "if (logger.isLoggable(Level.FINE))",
      "right" : "if (logger.isLoggable(Level.FINE))",
      "info" : "IfStatement[8144-8233]:IfStatement[7792-7881]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8179-8233]:Block[7827-7881]"
    }, {
      "left" : "logger.fine(\"Removing \" + n.toString());",
      "right" : "logger.fine(\"Removing \" + n.toString());",
      "info" : "ExpressionStatement[8187-8227]:ExpressionStatement[7835-7875]"
    }, {
      "left" : "NodeUtil.removeChild(n.getParent(), n);",
      "right" : "NodeUtil.removeChild(n.getParent(), n);",
      "info" : "ExpressionStatement[8238-8277]:ExpressionStatement[7886-7925]"
    } ]
  },
  "interFileMappings" : { }
}