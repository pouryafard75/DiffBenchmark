{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "JsDocInfoParser",
      "right" : "JsDocInfoParser",
      "info" : "TypeDeclaration[1581-79463]:TypeDeclaration[1581-79498]"
    }, {
      "left" : "private final JsDocTokenStream stream;",
      "right" : "private final JsDocTokenStream stream;",
      "info" : "FieldDeclaration[1786-1824]:FieldDeclaration[1786-1824]"
    }, {
      "left" : "private final JSDocInfoBuilder jsdocBuilder;",
      "right" : "private final JSDocInfoBuilder jsdocBuilder;",
      "info" : "FieldDeclaration[1827-1871]:FieldDeclaration[1827-1871]"
    }, {
      "left" : "private final StaticSourceFile sourceFile;",
      "right" : "private final StaticSourceFile sourceFile;",
      "info" : "FieldDeclaration[1874-1916]:FieldDeclaration[1874-1916]"
    }, {
      "left" : "private final Node associatedNode;",
      "right" : "private final Node associatedNode;",
      "info" : "FieldDeclaration[1919-1953]:FieldDeclaration[1919-1953]"
    }, {
      "left" : "private final ErrorReporter errorReporter;",
      "right" : "private final ErrorReporter errorReporter;",
      "info" : "FieldDeclaration[1956-1998]:FieldDeclaration[1956-1998]"
    }, {
      "left" : "private final ErrorReporterParser parser = new ErrorReporterParser();",
      "right" : "private final ErrorReporterParser parser = new ErrorReporterParser();",
      "info" : "FieldDeclaration[2001-2070]:FieldDeclaration[2001-2070]"
    }, {
      "left" : "private final Node templateNode;",
      "right" : "private final Node templateNode;",
      "info" : "FieldDeclaration[2215-2247]:FieldDeclaration[2215-2247]"
    }, {
      "left" : "ErrorReporterParser",
      "right" : "ErrorReporterParser",
      "info" : "TypeDeclaration[2251-3241]:TypeDeclaration[2251-3241]"
    }, {
      "left" : "void addParserWarning(String messageId, String messageArg, int lineno,\n        int charno)",
      "right" : "void addParserWarning(String messageId, String messageArg, int lineno,\n        int charno)",
      "info" : "MethodDeclaration[2291-2517]:MethodDeclaration[2291-2517]"
    }, {
      "left" : "void addParserWarning(String messageId, int lineno, int charno)",
      "right" : "void addParserWarning(String messageId, int lineno, int charno)",
      "info" : "MethodDeclaration[2523-2710]:MethodDeclaration[2523-2710]"
    }, {
      "left" : "void addTypeWarning(String messageId, String messageArg, int lineno,\n                    int charno)",
      "right" : "void addTypeWarning(String messageId, String messageArg, int lineno,\n                    int charno)",
      "info" : "MethodDeclaration[2716-2999]:MethodDeclaration[2716-2999]"
    }, {
      "left" : "void addTypeWarning(String messageId, int lineno, int charno)",
      "right" : "void addTypeWarning(String messageId, int lineno, int charno)",
      "info" : "MethodDeclaration[3005-3237]:MethodDeclaration[3005-3237]"
    }, {
      "left" : "private JSDocInfo fileOverviewJSDocInfo = null;",
      "right" : "private JSDocInfo fileOverviewJSDocInfo = null;",
      "info" : "FieldDeclaration[3308-3355]:FieldDeclaration[3308-3355]"
    }, {
      "left" : "private State state;",
      "right" : "private State state;",
      "info" : "FieldDeclaration[3358-3378]:FieldDeclaration[3358-3378]"
    }, {
      "left" : "private final Map<String, Annotation> annotationNames;",
      "right" : "private final Map<String, Annotation> annotationNames;",
      "info" : "FieldDeclaration[3382-3436]:FieldDeclaration[3382-3436]"
    }, {
      "left" : "private final Set<String> suppressionNames;",
      "right" : "private final Set<String> suppressionNames;",
      "info" : "FieldDeclaration[3439-3482]:FieldDeclaration[3439-3482]"
    }, {
      "left" : "static private final Set<String> modifiesAnnotationKeywords =\n      ImmutableSet.<String>of(\"this\", \"arguments\");",
      "right" : "static private final Set<String> modifiesAnnotationKeywords =\n      ImmutableSet.<String>of(\"this\", \"arguments\");",
      "info" : "FieldDeclaration[3485-3598]:FieldDeclaration[3485-3598]"
    }, {
      "left" : "private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;",
      "right" : "private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;",
      "info" : "FieldDeclaration[3602-3659]:FieldDeclaration[3602-3659]"
    }, {
      "left" : "void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder)",
      "right" : "void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder)",
      "info" : "MethodDeclaration[3663-4041]:MethodDeclaration[3663-4041]"
    }, {
      "left" : "void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo)",
      "right" : "void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo)",
      "info" : "MethodDeclaration[4045-4298]:MethodDeclaration[4045-4298]"
    }, {
      "left" : "enum : State",
      "right" : "enum : State",
      "info" : "EnumDeclaration[4302-4398]:EnumDeclaration[4302-4398]"
    }, {
      "left" : "JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  Node associatedNode,\n                  Config config,\n                  ErrorReporter errorReporter)",
      "right" : "JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  Node associatedNode,\n                  Config config,\n                  ErrorReporter errorReporter)",
      "info" : "MethodDeclaration[4402-5209]:MethodDeclaration[4402-5209]"
    }, {
      "left" : "private String getSourceName()",
      "right" : "private String getSourceName()",
      "info" : "MethodDeclaration[5213-5310]:MethodDeclaration[5213-5310]"
    }, {
      "left" : "public JSDocInfo parseInlineTypeDoc()",
      "right" : "public JSDocInfo parseInlineTypeDoc()",
      "info" : "MethodDeclaration[5314-5601]:MethodDeclaration[5314-5601]"
    }, {
      "left" : "public static Node parseTypeString(String typeString)",
      "right" : "public static Node parseTypeString(String typeString)",
      "info" : "MethodDeclaration[5605-6221]:MethodDeclaration[5605-6221]"
    }, {
      "left" : "boolean parse()",
      "right" : "boolean parse()",
      "info" : "MethodDeclaration[6225-39919]:MethodDeclaration[6225-39919]"
    }, {
      "left" : "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes)",
      "right" : "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes)",
      "info" : "MethodDeclaration[39923-40561]:MethodDeclaration[39923-40561]"
    }, {
      "left" : "private JsDocToken parseSuppressTag(JsDocToken token)",
      "right" : "private JsDocToken parseSuppressTag(JsDocToken token)",
      "info" : "MethodDeclaration[40565-41925]:MethodDeclaration[40565-41925]"
    }, {
      "left" : "private JsDocToken parseModifiesTag(JsDocToken token)",
      "right" : "private JsDocToken parseModifiesTag(JsDocToken token)",
      "info" : "MethodDeclaration[41929-43340]:MethodDeclaration[41929-43340]"
    }, {
      "left" : "Node parseAndRecordTypeNode(JsDocToken token)",
      "right" : "Node parseAndRecordTypeNode(JsDocToken token)",
      "info" : "MethodDeclaration[43344-43694]:MethodDeclaration[43344-43694]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC)",
      "info" : "MethodDeclaration[43698-44189]:MethodDeclaration[43698-44189]"
    }, {
      "left" : "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC)",
      "right" : "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC)",
      "info" : "MethodDeclaration[44193-44863]:MethodDeclaration[44193-44863]"
    }, {
      "left" : "private Node parseAndRecordParamTypeNode(JsDocToken token)",
      "right" : "private Node parseAndRecordParamTypeNode(JsDocToken token)",
      "info" : "MethodDeclaration[44867-45829]:MethodDeclaration[44867-45829]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames)",
      "info" : "MethodDeclaration[45833-47139]:MethodDeclaration[45833-47139]"
    }, {
      "left" : "private String toString(JsDocToken token)",
      "right" : "private String toString(JsDocToken token)",
      "info" : "MethodDeclaration[47143-48085]:MethodDeclaration[47143-48085]"
    }, {
      "left" : "JSTypeExpression createJSTypeExpression(Node n)",
      "right" : "JSTypeExpression createJSTypeExpression(Node n)",
      "info" : "MethodDeclaration[48089-48317]:MethodDeclaration[48089-48317]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "TypeDeclaration[48321-48698]:TypeDeclaration[48321-48698]"
    }, {
      "left" : "private final String string;",
      "right" : "private final String string;",
      "info" : "FieldDeclaration[48508-48536]:FieldDeclaration[48508-48536]"
    }, {
      "left" : "private final JsDocToken token;",
      "right" : "private final JsDocToken token;",
      "info" : "FieldDeclaration[48541-48572]:FieldDeclaration[48541-48572]"
    }, {
      "left" : "public ExtractionInfo(String string, JsDocToken token)",
      "right" : "public ExtractionInfo(String string, JsDocToken token)",
      "info" : "MethodDeclaration[48578-48694]:MethodDeclaration[48578-48694]"
    }, {
      "left" : "ExtendedTypeInfo",
      "right" : "ExtendedTypeInfo",
      "info" : "TypeDeclaration[48702-49038]:TypeDeclaration[48702-49038]"
    }, {
      "left" : "final JSTypeExpression type;",
      "right" : "final JSTypeExpression type;",
      "info" : "FieldDeclaration[48798-48826]:FieldDeclaration[48798-48826]"
    }, {
      "left" : "final int lineno;",
      "right" : "final int lineno;",
      "info" : "FieldDeclaration[48831-48848]:FieldDeclaration[48831-48848]"
    }, {
      "left" : "final int charno;",
      "right" : "final int charno;",
      "info" : "FieldDeclaration[48853-48870]:FieldDeclaration[48853-48870]"
    }, {
      "left" : "public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno)",
      "right" : "public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno)",
      "info" : "MethodDeclaration[48876-49034]:MethodDeclaration[48876-49034]"
    }, {
      "left" : "private ExtractionInfo extractSingleLineBlock()",
      "right" : "private ExtractionInfo extractSingleLineBlock()",
      "info" : "MethodDeclaration[49042-49770]:MethodDeclaration[49042-49770]"
    }, {
      "left" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token)",
      "right" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token)",
      "info" : "MethodDeclaration[49774-49927]:MethodDeclaration[49774-49927]"
    }, {
      "left" : "enum : WhitespaceOption",
      "right" : "enum : WhitespaceOption",
      "info" : "EnumDeclaration[49931-50257]:EnumDeclaration[49931-50257]"
    }, {
      "left" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option)",
      "right" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option)",
      "info" : "MethodDeclaration[50261-54222]:MethodDeclaration[50261-54222]"
    }, {
      "left" : "private ExtractionInfo extractBlockComment(JsDocToken token)",
      "right" : "private ExtractionInfo extractBlockComment(JsDocToken token)",
      "info" : "MethodDeclaration[54227-55717]:MethodDeclaration[54227-55717]"
    }, {
      "left" : "private static String trimEnd(String s)",
      "right" : "private static String trimEnd(String s)",
      "info" : "MethodDeclaration[55721-56483]:MethodDeclaration[55721-56483]"
    }, {
      "left" : "private Node parseTypeExpressionAnnotation(JsDocToken token)",
      "right" : "private Node parseTypeExpressionAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[56903-57465]:MethodDeclaration[56903-57465]"
    }, {
      "left" : "private Node parseParamTypeExpressionAnnotation(JsDocToken token)",
      "right" : "private Node parseParamTypeExpressionAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[57469-58644]:MethodDeclaration[57469-58644]"
    }, {
      "left" : "private Node parseTypeNameAnnotation(JsDocToken token)",
      "right" : "private Node parseTypeNameAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[58648-59149]:MethodDeclaration[58648-59149]"
    }, {
      "left" : "private Node parseTopLevelTypeExpression(JsDocToken token)",
      "right" : "private Node parseTopLevelTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[59153-59811]:MethodDeclaration[59153-59811]"
    }, {
      "left" : "private Node parseTypeExpressionList(JsDocToken token)",
      "right" : "private Node parseTypeExpressionList(JsDocToken token)",
      "info" : "MethodDeclaration[59815-60425]:MethodDeclaration[59815-60425]"
    }, {
      "left" : "private Node parseTypeExpression(JsDocToken token)",
      "right" : "private Node parseTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[60429-62243]:MethodDeclaration[60429-62243]"
    }, {
      "left" : "private Node parseBasicTypeExpression(JsDocToken token)",
      "right" : "private Node parseBasicTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[62247-63245]:MethodDeclaration[62247-63245]"
    }, {
      "left" : "private Node parseTypeName(JsDocToken token)",
      "right" : "private Node parseTypeName(JsDocToken token)",
      "info" : "MethodDeclaration[63249-64315]:MethodDeclaration[63249-64315]"
    }, {
      "left" : "private Node parseFunctionType(JsDocToken token)",
      "right" : "private Node parseFunctionType(JsDocToken token)",
      "info" : "MethodDeclaration[64319-66397]:MethodDeclaration[64319-66397]"
    }, {
      "left" : "// NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token)",
      "right" : "// NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token)",
      "info" : "MethodDeclaration[66401-69496]:MethodDeclaration[66401-69496]"
    }, {
      "left" : "private Node parseResultType(JsDocToken token)",
      "right" : "private Node parseResultType(JsDocToken token)",
      "info" : "MethodDeclaration[69500-69935]:MethodDeclaration[69500-69935]"
    }, {
      "left" : "private Node parseUnionType(JsDocToken token)",
      "right" : "private Node parseUnionType(JsDocToken token)",
      "info" : "MethodDeclaration[69939-70213]:MethodDeclaration[69939-70213]"
    }, {
      "left" : "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate)",
      "right" : "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate)",
      "info" : "MethodDeclaration[70217-71417]:MethodDeclaration[70217-71417]"
    }, {
      "left" : "private Node parseArrayType(JsDocToken token)",
      "right" : "private Node parseArrayType(JsDocToken token)",
      "info" : "MethodDeclaration[71421-72364]:MethodDeclaration[71421-72364]"
    }, {
      "left" : "private Node parseRecordType(JsDocToken token)",
      "right" : "private Node parseRecordType(JsDocToken token)",
      "info" : "MethodDeclaration[72368-72854]:MethodDeclaration[72368-72854]"
    }, {
      "left" : "private Node parseFieldTypeList(JsDocToken token)",
      "right" : "private Node parseFieldTypeList(JsDocToken token)",
      "info" : "MethodDeclaration[72858-73458]:MethodDeclaration[72858-73458]"
    }, {
      "left" : "private Node parseFieldType(JsDocToken token)",
      "right" : "private Node parseFieldType(JsDocToken token)",
      "info" : "MethodDeclaration[73462-74169]:MethodDeclaration[73462-74169]"
    }, {
      "left" : "private Node parseFieldName(JsDocToken token)",
      "right" : "private Node parseFieldName(JsDocToken token)",
      "info" : "MethodDeclaration[74173-74492]:MethodDeclaration[74173-74492]"
    }, {
      "left" : "private Node wrapNode(int type, Node n)",
      "right" : "private Node wrapNode(int type, Node n)",
      "info" : "MethodDeclaration[74496-74679]:MethodDeclaration[74496-74679]"
    }, {
      "left" : "private Node newNode(int type)",
      "right" : "private Node newNode(int type)",
      "info" : "MethodDeclaration[74683-74823]:MethodDeclaration[74683-74823]"
    }, {
      "left" : "private Node newStringNode(String s)",
      "right" : "private Node newStringNode(String s)",
      "info" : "MethodDeclaration[74827-74938]:MethodDeclaration[74827-74938]"
    }, {
      "left" : "private Node newStringNode(String s, int lineno, int charno)",
      "right" : "private Node newStringNode(String s, int lineno, int charno)",
      "info" : "MethodDeclaration[74942-75128]:MethodDeclaration[74942-75128]"
    }, {
      "left" : "private Node createTemplateNode()",
      "right" : "private Node createTemplateNode()",
      "info" : "MethodDeclaration[75250-75530]:MethodDeclaration[75250-75530]"
    }, {
      "left" : "private Node reportTypeSyntaxWarning(String warning)",
      "right" : "private Node reportTypeSyntaxWarning(String warning)",
      "info" : "MethodDeclaration[75534-75685]:MethodDeclaration[75534-75685]"
    }, {
      "left" : "private Node reportGenericTypeSyntaxWarning()",
      "right" : "private Node reportGenericTypeSyntaxWarning()",
      "info" : "MethodDeclaration[75689-75801]:MethodDeclaration[75689-75801]"
    }, {
      "left" : "private JsDocToken eatTokensUntilEOL()",
      "right" : "private JsDocToken eatTokensUntilEOL()",
      "info" : "MethodDeclaration[75805-76027]:MethodDeclaration[75805-76027]"
    }, {
      "left" : "private JsDocToken eatTokensUntilEOL(JsDocToken token)",
      "right" : "private JsDocToken eatTokensUntilEOL(JsDocToken token)",
      "info" : "MethodDeclaration[76031-76457]:MethodDeclaration[76031-76457]"
    }, {
      "left" : "private static final JsDocToken NO_UNREAD_TOKEN = null;",
      "right" : "private static final JsDocToken NO_UNREAD_TOKEN = null;",
      "info" : "FieldDeclaration[76461-76608]:FieldDeclaration[76461-76608]"
    }, {
      "left" : "private JsDocToken unreadToken = NO_UNREAD_TOKEN;",
      "right" : "private JsDocToken unreadToken = NO_UNREAD_TOKEN;",
      "info" : "FieldDeclaration[76612-76696]:FieldDeclaration[76612-76696]"
    }, {
      "left" : "private void restoreLookAhead(JsDocToken token)",
      "right" : "private void restoreLookAhead(JsDocToken token)",
      "info" : "MethodDeclaration[76700-76836]:MethodDeclaration[76700-76836]"
    }, {
      "left" : "private boolean match(JsDocToken token)",
      "right" : "private boolean match(JsDocToken token)",
      "info" : "MethodDeclaration[76840-77044]:MethodDeclaration[76840-77044]"
    }, {
      "left" : "private boolean match(JsDocToken token1, JsDocToken token2)",
      "right" : "private boolean match(JsDocToken token1, JsDocToken token2)",
      "info" : "MethodDeclaration[77048-77304]:MethodDeclaration[77048-77304]"
    }, {
      "left" : "private JsDocToken next()",
      "right" : "private JsDocToken next()",
      "info" : "MethodDeclaration[77308-77580]:MethodDeclaration[77308-77580]"
    }, {
      "left" : "private JsDocToken current()",
      "right" : "private JsDocToken current()",
      "info" : "MethodDeclaration[77584-77772]:MethodDeclaration[77584-77772]"
    }, {
      "left" : "private void skipEOLs()",
      "right" : "private void skipEOLs()",
      "info" : "MethodDeclaration[77776-78061]:MethodDeclaration[77776-78061]"
    }, {
      "left" : "private String getRemainingJSDocLine()",
      "right" : "private String getRemainingJSDocLine()",
      "info" : "MethodDeclaration[78065-78232]:MethodDeclaration[78065-78267]"
    }, {
      "left" : "private boolean hasParsedFileOverviewDocInfo()",
      "right" : "private boolean hasParsedFileOverviewDocInfo()",
      "info" : "MethodDeclaration[78236-78452]:MethodDeclaration[78271-78487]"
    }, {
      "left" : "boolean hasParsedJSDocInfo()",
      "right" : "boolean hasParsedJSDocInfo()",
      "info" : "MethodDeclaration[78456-78529]:MethodDeclaration[78491-78564]"
    }, {
      "left" : "JSDocInfo retrieveAndResetParsedJSDocInfo()",
      "right" : "JSDocInfo retrieveAndResetParsedJSDocInfo()",
      "info" : "MethodDeclaration[78533-78629]:MethodDeclaration[78568-78664]"
    }, {
      "left" : "JSDocInfo getFileOverviewJSDocInfo()",
      "right" : "JSDocInfo getFileOverviewJSDocInfo()",
      "info" : "MethodDeclaration[78633-78767]:MethodDeclaration[78668-78802]"
    }, {
      "left" : "private boolean lookAheadForTypeAnnotation()",
      "right" : "private boolean lookAheadForTypeAnnotation()",
      "info" : "MethodDeclaration[78771-79461]:MethodDeclaration[78806-79496]"
    } ],
    "mappings" : [
 {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[1746-1752]:Modifier[1746-1752]"
    }, {
      "left" : "final",
      "right" : "final",
      "info" : "Modifier[1753-1758]:Modifier[1753-1758]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[1759-1764]:TYPE_DECLARATION_KIND[1759-1764]"
    }, {
      "left" : "JsDocInfoParser",
      "right" : "JsDocInfoParser",
      "info" : "SimpleName[1765-1780]:SimpleName[1765-1780]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[2251-2258]:Modifier[2251-2258]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[2259-2264]:TYPE_DECLARATION_KIND[2259-2264]"
    }, {
      "left" : "ErrorReporterParser",
      "right" : "ErrorReporterParser",
      "info" : "SimpleName[2265-2284]:SimpleName[2265-2284]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[2291-2295]:PrimitiveType[2291-2295]"
    }, {
      "left" : "addParserWarning",
      "right" : "addParserWarning",
      "info" : "SimpleName[2296-2312]:SimpleName[2296-2312]"
    }, {
      "left" : "String messageId",
      "right" : "String messageId",
      "info" : "SingleVariableDeclaration[2313-2329]:SingleVariableDeclaration[2313-2329]"
    }, {
      "left" : "String messageArg",
      "right" : "String messageArg",
      "info" : "SingleVariableDeclaration[2331-2348]:SingleVariableDeclaration[2331-2348]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[2350-2360]:SingleVariableDeclaration[2350-2360]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[2370-2380]:SingleVariableDeclaration[2370-2380]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2382-2517]:Block[2382-2517]"
    }, {
      "left" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
      "right" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
      "info" : "ExpressionStatement[2390-2511]:ExpressionStatement[2390-2511]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[2523-2527]:PrimitiveType[2523-2527]"
    }, {
      "left" : "addParserWarning",
      "right" : "addParserWarning",
      "info" : "SimpleName[2528-2544]:SimpleName[2528-2544]"
    }, {
      "left" : "String messageId",
      "right" : "String messageId",
      "info" : "SingleVariableDeclaration[2545-2561]:SingleVariableDeclaration[2545-2561]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[2563-2573]:SingleVariableDeclaration[2563-2573]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[2575-2585]:SingleVariableDeclaration[2575-2585]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2587-2710]:Block[2587-2710]"
    }, {
      "left" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
      "right" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
      "info" : "ExpressionStatement[2595-2704]:ExpressionStatement[2595-2704]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[2716-2720]:PrimitiveType[2716-2720]"
    }, {
      "left" : "addTypeWarning",
      "right" : "addTypeWarning",
      "info" : "SimpleName[2721-2735]:SimpleName[2721-2735]"
    }, {
      "left" : "String messageId",
      "right" : "String messageId",
      "info" : "SingleVariableDeclaration[2736-2752]:SingleVariableDeclaration[2736-2752]"
    }, {
      "left" : "String messageArg",
      "right" : "String messageArg",
      "info" : "SingleVariableDeclaration[2754-2771]:SingleVariableDeclaration[2754-2771]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[2773-2783]:SingleVariableDeclaration[2773-2783]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[2805-2815]:SingleVariableDeclaration[2805-2815]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2817-2999]:Block[2817-2999]"
    }, {
      "left" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
      "right" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
      "info" : "ExpressionStatement[2825-2993]:ExpressionStatement[2825-2993]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[3005-3009]:PrimitiveType[3005-3009]"
    }, {
      "left" : "addTypeWarning",
      "right" : "addTypeWarning",
      "info" : "SimpleName[3010-3024]:SimpleName[3010-3024]"
    }, {
      "left" : "String messageId",
      "right" : "String messageId",
      "info" : "SingleVariableDeclaration[3025-3041]:SingleVariableDeclaration[3025-3041]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[3043-3053]:SingleVariableDeclaration[3043-3053]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[3055-3065]:SingleVariableDeclaration[3055-3065]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3067-3237]:Block[3067-3237]"
    }, {
      "left" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
      "right" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
      "info" : "ExpressionStatement[3075-3231]:ExpressionStatement[3075-3231]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[3893-3897]:PrimitiveType[3893-3897]"
    }, {
      "left" : "setFileLevelJsDocBuilder",
      "right" : "setFileLevelJsDocBuilder",
      "info" : "SimpleName[3898-3922]:SimpleName[3898-3922]"
    }, {
      "left" : "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder",
      "right" : "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder",
      "info" : "SingleVariableDeclaration[3930-3978]:SingleVariableDeclaration[3930-3978]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3980-4041]:Block[3980-4041]"
    }, {
      "left" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
      "right" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
      "info" : "ExpressionStatement[3986-4037]:ExpressionStatement[3986-4037]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[4174-4178]:PrimitiveType[4174-4178]"
    }, {
      "left" : "setFileOverviewJSDocInfo",
      "right" : "setFileOverviewJSDocInfo",
      "info" : "SimpleName[4179-4203]:SimpleName[4179-4203]"
    }, {
      "left" : "JSDocInfo fileOverviewJSDocInfo",
      "right" : "JSDocInfo fileOverviewJSDocInfo",
      "info" : "SingleVariableDeclaration[4204-4235]:SingleVariableDeclaration[4204-4235]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4237-4298]:Block[4237-4298]"
    }, {
      "left" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
      "right" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
      "info" : "ExpressionStatement[4243-4294]:ExpressionStatement[4243-4294]"
    }, {
      "left" : "JsDocInfoParser",
      "right" : "JsDocInfoParser",
      "info" : "SimpleName[4402-4417]:SimpleName[4402-4417]"
    }, {
      "left" : "JsDocTokenStream stream",
      "right" : "JsDocTokenStream stream",
      "info" : "SingleVariableDeclaration[4418-4441]:SingleVariableDeclaration[4418-4441]"
    }, {
      "left" : "Comment commentNode",
      "right" : "Comment commentNode",
      "info" : "SingleVariableDeclaration[4461-4480]:SingleVariableDeclaration[4461-4480]"
    }, {
      "left" : "Node associatedNode",
      "right" : "Node associatedNode",
      "info" : "SingleVariableDeclaration[4500-4519]:SingleVariableDeclaration[4500-4519]"
    }, {
      "left" : "Config config",
      "right" : "Config config",
      "info" : "SingleVariableDeclaration[4539-4552]:SingleVariableDeclaration[4539-4552]"
    }, {
      "left" : "ErrorReporter errorReporter",
      "right" : "ErrorReporter errorReporter",
      "info" : "SingleVariableDeclaration[4572-4599]:SingleVariableDeclaration[4572-4599]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4601-5209]:Block[4601-5209]"
    }, {
      "left" : "this.stream = stream;",
      "right" : "this.stream = stream;",
      "info" : "ExpressionStatement[4607-4628]:ExpressionStatement[4607-4628]"
    }, {
      "left" : "this.associatedNode = associatedNode;",
      "right" : "this.associatedNode = associatedNode;",
      "info" : "ExpressionStatement[4633-4670]:ExpressionStatement[4633-4670]"
    }, {
      "left" : "this.sourceFile = associatedNode == null\n        ? null : associatedNode.getStaticSourceFile();",
      "right" : "this.sourceFile = associatedNode == null\n        ? null : associatedNode.getStaticSourceFile();",
      "info" : "ExpressionStatement[4721-4816]:ExpressionStatement[4721-4816]"
    }, {
      "left" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
      "right" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
      "info" : "ExpressionStatement[4822-4895]:ExpressionStatement[4822-4895]"
    }, {
      "left" : "if (commentNode != null)",
      "right" : "if (commentNode != null)",
      "info" : "IfStatement[4900-5009]:IfStatement[4900-5009]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4925-5009]:Block[4925-5009]"
    }, {
      "left" : "this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());",
      "right" : "this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());",
      "info" : "ExpressionStatement[4933-5003]:ExpressionStatement[4933-5003]"
    }, {
      "left" : "this.annotationNames = config.annotationNames;",
      "right" : "this.annotationNames = config.annotationNames;",
      "info" : "ExpressionStatement[5014-5060]:ExpressionStatement[5014-5060]"
    }, {
      "left" : "this.suppressionNames = config.suppressionNames;",
      "right" : "this.suppressionNames = config.suppressionNames;",
      "info" : "ExpressionStatement[5065-5113]:ExpressionStatement[5065-5113]"
    }, {
      "left" : "this.errorReporter = errorReporter;",
      "right" : "this.errorReporter = errorReporter;",
      "info" : "ExpressionStatement[5119-5154]:ExpressionStatement[5119-5154]"
    }, {
      "left" : "this.templateNode = this.createTemplateNode();",
      "right" : "this.templateNode = this.createTemplateNode();",
      "info" : "ExpressionStatement[5159-5205]:ExpressionStatement[5159-5205]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[5213-5220]:Modifier[5213-5220]"
    }, {
      "left" : "String",
      "right" : "String",
      "info" : "SimpleType[5221-5227]:SimpleType[5221-5227]"
    }, {
      "left" : "getSourceName",
      "right" : "getSourceName",
      "info" : "SimpleName[5228-5241]:SimpleName[5228-5241]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5244-5310]:Block[5244-5310]"
    }, {
      "left" : "return sourceFile == null ? null : sourceFile.getName();",
      "right" : "return sourceFile == null ? null : sourceFile.getName();",
      "info" : "ReturnStatement[5250-5306]:ReturnStatement[5250-5306]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[5314-5320]:Modifier[5314-5320]"
    }, {
      "left" : "JSDocInfo",
      "right" : "JSDocInfo",
      "info" : "SimpleType[5321-5330]:SimpleType[5321-5330]"
    }, {
      "left" : "parseInlineTypeDoc",
      "right" : "parseInlineTypeDoc",
      "info" : "SimpleName[5331-5349]:SimpleName[5331-5349]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5352-5601]:Block[5352-5601]"
    }, {
      "left" : "Node typeAst = parseAndRecordTypeNode(next());",
      "right" : "Node typeAst = parseAndRecordTypeNode(next());",
      "info" : "VariableDeclarationStatement[5358-5404]:VariableDeclarationStatement[5358-5404]"
    }, {
      "left" : "JSTypeExpression expr = createJSTypeExpression(typeAst);",
      "right" : "JSTypeExpression expr = createJSTypeExpression(typeAst);",
      "info" : "VariableDeclarationStatement[5409-5465]:VariableDeclarationStatement[5409-5465]"
    }, {
      "left" : "if (expr != null)",
      "right" : "if (expr != null)",
      "info" : "IfStatement[5470-5580]:IfStatement[5470-5580]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5488-5580]:Block[5488-5580]"
    }, {
      "left" : "jsdocBuilder.recordType(expr);",
      "right" : "jsdocBuilder.recordType(expr);",
      "info" : "ExpressionStatement[5496-5526]:ExpressionStatement[5496-5526]"
    }, {
      "left" : "return retrieveAndResetParsedJSDocInfo();",
      "right" : "return retrieveAndResetParsedJSDocInfo();",
      "info" : "ReturnStatement[5533-5574]:ReturnStatement[5533-5574]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[5585-5597]:ReturnStatement[5585-5597]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[5754-5760]:Modifier[5754-5760]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[5761-5767]:Modifier[5761-5767]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[5768-5772]:SimpleType[5768-5772]"
    }, {
      "left" : "parseTypeString",
      "right" : "parseTypeString",
      "info" : "SimpleName[5773-5788]:SimpleName[5773-5788]"
    }, {
      "left" : "String typeString",
      "right" : "String typeString",
      "info" : "SingleVariableDeclaration[5789-5806]:SingleVariableDeclaration[5789-5806]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5808-6221]:Block[5808-6221]"
    }, {
      "left" : "Config config = new Config(\n        Sets.<String>newHashSet(),\n        Sets.<String>newHashSet(),\n        false,\n        LanguageMode.ECMASCRIPT3,\n        false);",
      "right" : "Config config = new Config(\n        Sets.<String>newHashSet(),\n        Sets.<String>newHashSet(),\n        false,\n        LanguageMode.ECMASCRIPT3,\n        false);",
      "info" : "VariableDeclarationStatement[5814-5976]:VariableDeclarationStatement[5814-5976]"
    }, {
      "left" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        null,\n        null,\n        config,\n        NullErrorReporter.forNewRhino());",
      "right" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        null,\n        null,\n        config,\n        NullErrorReporter.forNewRhino());",
      "info" : "VariableDeclarationStatement[5981-6154]:VariableDeclarationStatement[5981-6154]"
    }, {
      "left" : "return parser.parseTopLevelTypeExpression(parser.next());",
      "right" : "return parser.parseTopLevelTypeExpression(parser.next());",
      "info" : "ReturnStatement[6160-6217]:ReturnStatement[6160-6217]"
    }, {
      "left" : "@SuppressWarnings(\"incomplete-switch\")",
      "right" : "@SuppressWarnings(\"incomplete-switch\")",
      "info" : "SingleMemberAnnotation[6541-6579]:SingleMemberAnnotation[6541-6579]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[6582-6589]:PrimitiveType[6582-6589]"
    }, {
      "left" : "parse",
      "right" : "parse",
      "info" : "SimpleName[6590-6595]:SimpleName[6590-6595]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6598-39919]:Block[6598-39919]"
    }, {
      "left" : "int lineno;",
      "right" : "int lineno;",
      "info" : "VariableDeclarationStatement[6604-6615]:VariableDeclarationStatement[6604-6615]"
    }, {
      "left" : "int charno;",
      "right" : "int charno;",
      "info" : "VariableDeclarationStatement[6620-6631]:VariableDeclarationStatement[6620-6631]"
    }, {
      "left" : "JSTypeExpression type;",
      "right" : "JSTypeExpression type;",
      "info" : "VariableDeclarationStatement[6713-6735]:VariableDeclarationStatement[6713-6735]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[6741-6776]:ExpressionStatement[6741-6776]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[6781-6792]:ExpressionStatement[6781-6792]"
    }, {
      "left" : "JsDocToken token = next();",
      "right" : "JsDocToken token = next();",
      "info" : "VariableDeclarationStatement[6798-6824]:VariableDeclarationStatement[6798-6824]"
    }, {
      "left" : "List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();",
      "right" : "List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();",
      "info" : "VariableDeclarationStatement[6830-6890]:VariableDeclarationStatement[6830-6890]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[6941-7443]:IfStatement[6941-7443]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6986-7197]:Block[6986-7197]"
    }, {
      "left" : "ExtractionInfo blockInfo = extractBlockComment(token);",
      "right" : "ExtractionInfo blockInfo = extractBlockComment(token);",
      "info" : "VariableDeclarationStatement[6994-7048]:VariableDeclarationStatement[6994-7048]"
    }, {
      "left" : "token = blockInfo.token;",
      "right" : "token = blockInfo.token;",
      "info" : "ExpressionStatement[7055-7079]:ExpressionStatement[7055-7079]"
    }, {
      "left" : "if (!blockInfo.string.isEmpty())",
      "right" : "if (!blockInfo.string.isEmpty())",
      "info" : "IfStatement[7086-7191]:IfStatement[7086-7191]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7119-7191]:Block[7119-7191]"
    }, {
      "left" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
      "right" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
      "info" : "ExpressionStatement[7129-7183]:ExpressionStatement[7129-7183]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7203-7443]:Block[7203-7443]"
    }, {
      "left" : "if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC)",
      "info" : "IfStatement[7211-7437]:IfStatement[7211-7437]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7284-7437]:Block[7284-7437]"
    }, {
      "left" : "jsdocBuilder.recordBlockDescription(\"\");",
      "right" : "jsdocBuilder.recordBlockDescription(\"\");",
      "info" : "ExpressionStatement[7389-7429]:ExpressionStatement[7389-7429]"
    }, {
      "left" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
      "right" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
      "info" : "LabeledStatement[7480-39915]:LabeledStatement[7480-39915]"
    }, {
      "left" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
      "right" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
      "info" : "ForStatement[7487-39915]:ForStatement[7487-39915]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7496-39915]:Block[7496-39915]"
    }, {
      "left" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
      "right" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
      "info" : "SwitchStatement[7504-39866]:SwitchStatement[7504-39866]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[7529-7545]:SwitchCase[7529-7545]"
    }, {
      "left" : "if (state == State.SEARCHING_ANNOTATION)",
      "right" : "if (state == State.SEARCHING_ANNOTATION)",
      "info" : "IfStatement[7556-38858]:IfStatement[7556-38858]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7597-38858]:Block[7597-38858]"
    }, {
      "left" : "state = State.SEARCHING_NEWLINE;",
      "right" : "state = State.SEARCHING_NEWLINE;",
      "info" : "ExpressionStatement[7611-7643]:ExpressionStatement[7611-7643]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[7656-7684]:ExpressionStatement[7656-7684]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[7697-7725]:ExpressionStatement[7697-7725]"
    }, {
      "left" : "String annotationName = stream.getString();",
      "right" : "String annotationName = stream.getString();",
      "info" : "VariableDeclarationStatement[7739-7782]:VariableDeclarationStatement[7739-7782]"
    }, {
      "left" : "Annotation annotation = annotationNames.get(annotationName);",
      "right" : "Annotation annotation = annotationNames.get(annotationName);",
      "info" : "VariableDeclarationStatement[7795-7855]:VariableDeclarationStatement[7795-7855]"
    }, {
      "left" : "if (annotation == null)",
      "right" : "if (annotation == null)",
      "info" : "IfStatement[7868-38846]:IfStatement[7868-38846]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7892-8041]:Block[7892-8041]"
    }, {
      "left" : "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[7908-8027]:ExpressionStatement[7908-8027]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8047-38846]:Block[8047-38846]"
    }, {
      "left" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
      "right" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
      "info" : "ExpressionStatement[8118-8178]:ExpressionStatement[8118-8178]"
    }, {
      "left" : "switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }",
      "right" : "switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }",
      "info" : "SwitchStatement[8194-38832]:SwitchStatement[8194-38832]"
    }, {
      "left" : "case NG_INJECT:",
      "right" : "case NG_INJECT:",
      "info" : "SwitchCase[8232-8247]:SwitchCase[8232-8247]"
    }, {
      "left" : "if (jsdocBuilder.isNgInjectRecorded())",
      "right" : "if (jsdocBuilder.isNgInjectRecorded())",
      "info" : "IfStatement[8266-8543]:IfStatement[8266-8543]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8305-8461]:Block[8305-8461]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8327-8441]:ExpressionStatement[8327-8441]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8467-8543]:Block[8467-8543]"
    }, {
      "left" : "jsdocBuilder.recordNgInject(true);",
      "right" : "jsdocBuilder.recordNgInject(true);",
      "info" : "ExpressionStatement[8489-8523]:ExpressionStatement[8489-8523]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[8562-8590]:ExpressionStatement[8562-8590]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[8609-8624]:ContinueStatement[8609-8624]"
    }, {
      "left" : "case AUTHOR:",
      "right" : "case AUTHOR:",
      "info" : "SwitchCase[8642-8654]:SwitchCase[8642-8654]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[8673-9289]:IfStatement[8673-9289]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8718-9208]:Block[8718-9208]"
    }, {
      "left" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[8740-8793]:VariableDeclarationStatement[8740-8793]"
    }, {
      "left" : "String author = authorInfo.string;",
      "right" : "String author = authorInfo.string;",
      "info" : "VariableDeclarationStatement[8814-8848]:VariableDeclarationStatement[8814-8848]"
    }, {
      "left" : "if (author.length() == 0)",
      "right" : "if (author.length() == 0)",
      "info" : "IfStatement[8870-9142]:IfStatement[8870-9142]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8896-9059]:Block[8896-9059]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8920-9037]:ExpressionStatement[8920-9037]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9065-9142]:Block[9065-9142]"
    }, {
      "left" : "jsdocBuilder.addAuthor(author);",
      "right" : "jsdocBuilder.addAuthor(author);",
      "info" : "ExpressionStatement[9089-9120]:ExpressionStatement[9089-9120]"
    }, {
      "left" : "token = authorInfo.token;",
      "right" : "token = authorInfo.token;",
      "info" : "ExpressionStatement[9163-9188]:ExpressionStatement[9163-9188]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9214-9289]:Block[9214-9289]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[9236-9269]:ExpressionStatement[9236-9269]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[9308-9323]:ContinueStatement[9308-9323]"
    }, {
      "left" : "case CONSISTENTIDGENERATOR:",
      "right" : "case CONSISTENTIDGENERATOR:",
      "info" : "SwitchCase[9341-9368]:SwitchCase[9341-9368]"
    }, {
      "left" : "if (!jsdocBuilder.recordConsistentIdGenerator())",
      "right" : "if (!jsdocBuilder.recordConsistentIdGenerator())",
      "info" : "IfStatement[9387-9590]:IfStatement[9387-9590]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9436-9590]:Block[9436-9590]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[9458-9570]:ExpressionStatement[9458-9570]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[9609-9637]:ExpressionStatement[9609-9637]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[9656-9671]:ContinueStatement[9656-9671]"
    }, {
      "left" : "case STRUCT:",
      "right" : "case STRUCT:",
      "info" : "SwitchCase[9689-9701]:SwitchCase[9689-9701]"
    }, {
      "left" : "if (!jsdocBuilder.recordStruct())",
      "right" : "if (!jsdocBuilder.recordStruct())",
      "info" : "IfStatement[9720-9969]:IfStatement[9720-9969]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9754-9969]:Block[9754-9969]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());",
      "info" : "ExpressionStatement[9776-9949]:ExpressionStatement[9776-9949]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[9988-10016]:ExpressionStatement[9988-10016]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[10035-10050]:ContinueStatement[10035-10050]"
    }, {
      "left" : "case DICT:",
      "right" : "case DICT:",
      "info" : "SwitchCase[10068-10078]:SwitchCase[10068-10078]"
    }, {
      "left" : "if (!jsdocBuilder.recordDict())",
      "right" : "if (!jsdocBuilder.recordDict())",
      "info" : "IfStatement[10097-10344]:IfStatement[10097-10344]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10129-10344]:Block[10129-10344]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());",
      "info" : "ExpressionStatement[10151-10324]:ExpressionStatement[10151-10324]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[10363-10391]:ExpressionStatement[10363-10391]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[10410-10425]:ContinueStatement[10410-10425]"
    }, {
      "left" : "case CONSTRUCTOR:",
      "right" : "case CONSTRUCTOR:",
      "info" : "SwitchCase[10443-10460]:SwitchCase[10443-10460]"
    }, {
      "left" : "if (!jsdocBuilder.recordConstructor())",
      "right" : "if (!jsdocBuilder.recordConstructor())",
      "info" : "IfStatement[10479-10936]:IfStatement[10479-10936]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10518-10936]:Block[10518-10936]"
    }, {
      "left" : "if (jsdocBuilder.isInterfaceRecorded())",
      "right" : "if (jsdocBuilder.isInterfaceRecorded())",
      "info" : "IfStatement[10540-10916]:IfStatement[10540-10916]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10580-10749]:Block[10580-10749]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[10604-10727]:ExpressionStatement[10604-10727]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10755-10916]:Block[10755-10916]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[10779-10894]:ExpressionStatement[10779-10894]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[10955-10983]:ExpressionStatement[10955-10983]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[11002-11017]:ContinueStatement[11002-11017]"
    }, {
      "left" : "case DEPRECATED:",
      "right" : "case DEPRECATED:",
      "info" : "SwitchCase[11035-11051]:SwitchCase[11035-11051]"
    }, {
      "left" : "if (!jsdocBuilder.recordDeprecated())",
      "right" : "if (!jsdocBuilder.recordDeprecated())",
      "info" : "IfStatement[11070-11262]:IfStatement[11070-11262]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11108-11262]:Block[11108-11262]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[11130-11242]:ExpressionStatement[11130-11242]"
    }, {
      "left" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[11340-11426]:VariableDeclarationStatement[11340-11426]"
    }, {
      "left" : "String reason = reasonInfo.string;",
      "right" : "String reason = reasonInfo.string;",
      "info" : "VariableDeclarationStatement[11446-11480]:VariableDeclarationStatement[11446-11480]"
    }, {
      "left" : "if (reason.length() > 0)",
      "right" : "if (reason.length() > 0)",
      "info" : "IfStatement[11500-11612]:IfStatement[11500-11612]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11525-11612]:Block[11525-11612]"
    }, {
      "left" : "jsdocBuilder.recordDeprecationReason(reason);",
      "right" : "jsdocBuilder.recordDeprecationReason(reason);",
      "info" : "ExpressionStatement[11547-11592]:ExpressionStatement[11547-11592]"
    }, {
      "left" : "token = reasonInfo.token;",
      "right" : "token = reasonInfo.token;",
      "info" : "ExpressionStatement[11632-11657]:ExpressionStatement[11632-11657]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[11676-11691]:ContinueStatement[11676-11691]"
    }, {
      "left" : "case INTERFACE:",
      "right" : "case INTERFACE:",
      "info" : "SwitchCase[11709-11724]:SwitchCase[11709-11724]"
    }, {
      "left" : "if (!jsdocBuilder.recordInterface())",
      "right" : "if (!jsdocBuilder.recordInterface())",
      "info" : "IfStatement[11743-12200]:IfStatement[11743-12200]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11780-12200]:Block[11780-12200]"
    }, {
      "left" : "if (jsdocBuilder.isConstructorRecorded())",
      "right" : "if (jsdocBuilder.isConstructorRecorded())",
      "info" : "IfStatement[11802-12180]:IfStatement[11802-12180]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11844-12013]:Block[11844-12013]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[11868-11991]:ExpressionStatement[11868-11991]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12019-12180]:Block[12019-12180]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[12043-12158]:ExpressionStatement[12043-12158]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[12219-12247]:ExpressionStatement[12219-12247]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[12266-12281]:ContinueStatement[12266-12281]"
    }, {
      "left" : "case DESC:",
      "right" : "case DESC:",
      "info" : "SwitchCase[12299-12309]:SwitchCase[12299-12309]"
    }, {
      "left" : "if (jsdocBuilder.isDescriptionRecorded())",
      "right" : "if (jsdocBuilder.isDescriptionRecorded())",
      "info" : "IfStatement[12328-12969]:IfStatement[12328-12969]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12370-12609]:Block[12370-12609]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[12392-12504]:ExpressionStatement[12392-12504]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[12525-12553]:ExpressionStatement[12525-12553]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[12574-12589]:ContinueStatement[12574-12589]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12615-12969]:Block[12615-12969]"
    }, {
      "left" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[12637-12730]:VariableDeclarationStatement[12637-12730]"
    }, {
      "left" : "String description = descriptionInfo.string;",
      "right" : "String description = descriptionInfo.string;",
      "info" : "VariableDeclarationStatement[12752-12796]:VariableDeclarationStatement[12752-12796]"
    }, {
      "left" : "jsdocBuilder.recordDescription(description);",
      "right" : "jsdocBuilder.recordDescription(description);",
      "info" : "ExpressionStatement[12818-12862]:ExpressionStatement[12818-12862]"
    }, {
      "left" : "token = descriptionInfo.token;",
      "right" : "token = descriptionInfo.token;",
      "info" : "ExpressionStatement[12883-12913]:ExpressionStatement[12883-12913]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[12934-12949]:ContinueStatement[12934-12949]"
    }, {
      "left" : "case FILE_OVERVIEW:",
      "right" : "case FILE_OVERVIEW:",
      "info" : "SwitchCase[12987-13006]:SwitchCase[12987-13006]"
    }, {
      "left" : "String fileOverview = \"\";",
      "right" : "String fileOverview = \"\";",
      "info" : "VariableDeclarationStatement[13025-13050]:VariableDeclarationStatement[13025-13050]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[13069-13496]:IfStatement[13069-13496]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13114-13415]:Block[13114-13415]"
    }, {
      "left" : "ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);",
      "right" : "ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);",
      "info" : "VariableDeclarationStatement[13136-13281]:VariableDeclarationStatement[13136-13281]"
    }, {
      "left" : "fileOverview = fileOverviewInfo.string;",
      "right" : "fileOverview = fileOverviewInfo.string;",
      "info" : "ExpressionStatement[13303-13342]:ExpressionStatement[13303-13342]"
    }, {
      "left" : "token = fileOverviewInfo.token;",
      "right" : "token = fileOverviewInfo.token;",
      "info" : "ExpressionStatement[13364-13395]:ExpressionStatement[13364-13395]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13421-13496]:Block[13421-13496]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[13443-13476]:ExpressionStatement[13443-13476]"
    }, {
      "left" : "if (!jsdocBuilder.recordFileOverview(fileOverview))",
      "right" : "if (!jsdocBuilder.recordFileOverview(fileOverview))",
      "info" : "IfStatement[13516-13730]:IfStatement[13516-13730]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13568-13730]:Block[13568-13730]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[13590-13710]:ExpressionStatement[13590-13710]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[13749-13764]:ContinueStatement[13749-13764]"
    }, {
      "left" : "case LICENSE:",
      "right" : "case LICENSE:",
      "info" : "SwitchCase[13782-13795]:SwitchCase[13782-13795]"
    }, {
      "left" : "case PRESERVE:",
      "right" : "case PRESERVE:",
      "info" : "SwitchCase[13812-13826]:SwitchCase[13812-13826]"
    }, {
      "left" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
      "right" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
      "info" : "VariableDeclarationStatement[13845-14011]:VariableDeclarationStatement[13845-14011]"
    }, {
      "left" : "String preserve = preserveInfo.string;",
      "right" : "String preserve = preserveInfo.string;",
      "info" : "VariableDeclarationStatement[14031-14069]:VariableDeclarationStatement[14031-14069]"
    }, {
      "left" : "if (preserve.length() > 0)",
      "right" : "if (preserve.length() > 0)",
      "info" : "IfStatement[14089-14278]:IfStatement[14089-14278]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14116-14278]:Block[14116-14278]"
    }, {
      "left" : "if (fileLevelJsDocBuilder != null)",
      "right" : "if (fileLevelJsDocBuilder != null)",
      "info" : "IfStatement[14138-14258]:IfStatement[14138-14258]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14173-14258]:Block[14173-14258]"
    }, {
      "left" : "fileLevelJsDocBuilder.append(preserve);",
      "right" : "fileLevelJsDocBuilder.append(preserve);",
      "info" : "ExpressionStatement[14197-14236]:ExpressionStatement[14197-14236]"
    }, {
      "left" : "token = preserveInfo.token;",
      "right" : "token = preserveInfo.token;",
      "info" : "ExpressionStatement[14298-14325]:ExpressionStatement[14298-14325]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[14344-14359]:ContinueStatement[14344-14359]"
    }, {
      "left" : "case ENUM:",
      "right" : "case ENUM:",
      "info" : "SwitchCase[14377-14387]:SwitchCase[14377-14387]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[14406-14421]:ExpressionStatement[14406-14421]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[14440-14468]:ExpressionStatement[14440-14468]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[14487-14515]:ExpressionStatement[14487-14515]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[14535-14547]:ExpressionStatement[14535-14547]"
    }, {
      "left" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
      "info" : "IfStatement[14566-14750]:IfStatement[14566-14750]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14622-14750]:Block[14622-14750]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "info" : "ExpressionStatement[14644-14730]:ExpressionStatement[14644-14730]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[14770-14885]:IfStatement[14770-14885]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14788-14885]:Block[14788-14885]"
    }, {
      "left" : "type = createJSTypeExpression(newStringNode(\"number\"));",
      "right" : "type = createJSTypeExpression(newStringNode(\"number\"));",
      "info" : "ExpressionStatement[14810-14865]:ExpressionStatement[14810-14865]"
    }, {
      "left" : "if (!jsdocBuilder.recordEnumParameterType(type))",
      "right" : "if (!jsdocBuilder.recordEnumParameterType(type))",
      "info" : "IfStatement[14904-15085]:IfStatement[14904-15085]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14953-15085]:Block[14953-15085]"
    }, {
      "left" : "parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[14975-15065]:ExpressionStatement[14975-15065]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[15104-15137]:ExpressionStatement[15104-15137]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[15156-15171]:ContinueStatement[15156-15171]"
    }, {
      "left" : "case EXPORT:",
      "right" : "case EXPORT:",
      "info" : "SwitchCase[15189-15201]:SwitchCase[15189-15201]"
    }, {
      "left" : "if (!jsdocBuilder.recordExport())",
      "right" : "if (!jsdocBuilder.recordExport())",
      "info" : "IfStatement[15220-15404]:IfStatement[15220-15404]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15254-15404]:Block[15254-15404]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[15276-15384]:ExpressionStatement[15276-15384]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[15423-15451]:ExpressionStatement[15423-15451]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[15470-15485]:ContinueStatement[15470-15485]"
    }, {
      "left" : "case EXPOSE:",
      "right" : "case EXPOSE:",
      "info" : "SwitchCase[15503-15515]:SwitchCase[15503-15515]"
    }, {
      "left" : "if (!jsdocBuilder.recordExpose())",
      "right" : "if (!jsdocBuilder.recordExpose())",
      "info" : "IfStatement[15534-15718]:IfStatement[15534-15718]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15568-15718]:Block[15568-15718]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[15590-15698]:ExpressionStatement[15590-15698]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[15737-15765]:ExpressionStatement[15737-15765]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[15784-15799]:ContinueStatement[15784-15799]"
    }, {
      "left" : "case EXTERNS:",
      "right" : "case EXTERNS:",
      "info" : "SwitchCase[15817-15830]:SwitchCase[15817-15830]"
    }, {
      "left" : "if (!jsdocBuilder.recordExterns())",
      "right" : "if (!jsdocBuilder.recordExterns())",
      "info" : "IfStatement[15849-16035]:IfStatement[15849-16035]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15884-16035]:Block[15884-16035]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[15906-16015]:ExpressionStatement[15906-16015]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[16054-16082]:ExpressionStatement[16054-16082]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[16101-16116]:ContinueStatement[16101-16116]"
    }, {
      "left" : "case JAVA_DISPATCH:",
      "right" : "case JAVA_DISPATCH:",
      "info" : "SwitchCase[16134-16153]:SwitchCase[16134-16153]"
    }, {
      "left" : "if (!jsdocBuilder.recordJavaDispatch())",
      "right" : "if (!jsdocBuilder.recordJavaDispatch())",
      "info" : "IfStatement[16172-16368]:IfStatement[16172-16368]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16212-16368]:Block[16212-16368]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[16234-16348]:ExpressionStatement[16234-16348]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[16387-16415]:ExpressionStatement[16387-16415]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[16434-16449]:ContinueStatement[16434-16449]"
    }, {
      "left" : "case EXTENDS:",
      "right" : "case EXTENDS:",
      "info" : "SwitchCase[16467-16480]:SwitchCase[16467-16480]"
    }, {
      "left" : "case IMPLEMENTS:",
      "right" : "case IMPLEMENTS:",
      "info" : "SwitchCase[16497-16513]:SwitchCase[16497-16513]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[16532-16543]:ExpressionStatement[16532-16543]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[16562-16577]:ExpressionStatement[16562-16577]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[16596-16624]:ExpressionStatement[16596-16624]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[16643-16671]:ExpressionStatement[16643-16671]"
    }, {
      "left" : "boolean matchingRc = false;",
      "right" : "boolean matchingRc = false;",
      "info" : "VariableDeclarationStatement[16690-16717]:VariableDeclarationStatement[16690-16717]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[16737-16861]:IfStatement[16737-16861]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16765-16861]:Block[16765-16861]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[16787-16802]:ExpressionStatement[16787-16802]"
    }, {
      "left" : "matchingRc = true;",
      "right" : "matchingRc = true;",
      "info" : "ExpressionStatement[16823-16841]:ExpressionStatement[16823-16841]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[16881-18625]:IfStatement[16881-18625]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16913-18519]:Block[16913-18519]"
    }, {
      "left" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
      "right" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
      "info" : "VariableDeclarationStatement[16935-17038]:VariableDeclarationStatement[16935-17038]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[17060-17088]:ExpressionStatement[17060-17088]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[17109-17137]:ExpressionStatement[17109-17137]"
    }, {
      "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "info" : "ExpressionStatement[17159-17201]:ExpressionStatement[17159-17201]"
    }, {
      "left" : "type = createJSTypeExpression(typeNode);",
      "right" : "type = createJSTypeExpression(typeNode);",
      "info" : "ExpressionStatement[17222-17262]:ExpressionStatement[17222-17262]"
    }, {
      "left" : "if (annotation == Annotation.EXTENDS)",
      "right" : "if (annotation == Annotation.EXTENDS)",
      "info" : "IfStatement[17284-17910]:IfStatement[17284-17910]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17322-17544]:Block[17322-17544]"
    }, {
      "left" : "extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));",
      "right" : "extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));",
      "info" : "ExpressionStatement[17409-17522]:ExpressionStatement[17409-17522]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17550-17910]:Block[17550-17910]"
    }, {
      "left" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
      "right" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
      "info" : "ExpressionStatement[17574-17663]:ExpressionStatement[17574-17663]"
    }, {
      "left" : "if (!jsdocBuilder.recordImplementedInterface(type))",
      "right" : "if (!jsdocBuilder.recordImplementedInterface(type))",
      "info" : "IfStatement[17686-17888]:IfStatement[17686-17888]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17738-17888]:Block[17738-17888]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
      "info" : "ExpressionStatement[17764-17864]:ExpressionStatement[17764-17864]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[17931-17946]:ExpressionStatement[17931-17946]"
    }, {
      "left" : "if (matchingRc)",
      "right" : "if (matchingRc)",
      "info" : "IfStatement[17967-18499]:IfStatement[17967-18499]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17983-18221]:Block[17983-18221]"
    }, {
      "left" : "if (token != JsDocToken.RC)",
      "right" : "if (token != JsDocToken.RC)",
      "info" : "IfStatement[18007-18199]:IfStatement[18007-18199]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18035-18199]:Block[18035-18199]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[18061-18175]:ExpressionStatement[18061-18175]"
    }, {
      "left" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
      "info" : "IfStatement[18227-18499]:IfStatement[18227-18499]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18334-18499]:Block[18334-18499]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[18358-18477]:ExpressionStatement[18358-18477]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18525-18625]:Block[18525-18625]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);",
      "info" : "ExpressionStatement[18547-18605]:ExpressionStatement[18547-18605]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[18644-18677]:ExpressionStatement[18644-18677]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[18696-18711]:ContinueStatement[18696-18711]"
    }, {
      "left" : "case HIDDEN:",
      "right" : "case HIDDEN:",
      "info" : "SwitchCase[18729-18741]:SwitchCase[18729-18741]"
    }, {
      "left" : "if (!jsdocBuilder.recordHiddenness())",
      "right" : "if (!jsdocBuilder.recordHiddenness())",
      "info" : "IfStatement[18760-18948]:IfStatement[18760-18948]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18798-18948]:Block[18798-18948]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[18820-18928]:ExpressionStatement[18820-18928]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[18967-18995]:ExpressionStatement[18967-18995]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[19014-19029]:ContinueStatement[19014-19029]"
    }, {
      "left" : "case LENDS:",
      "right" : "case LENDS:",
      "info" : "SwitchCase[19047-19058]:SwitchCase[19047-19058]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[19077-19088]:ExpressionStatement[19077-19088]"
    }, {
      "left" : "matchingRc = false;",
      "right" : "matchingRc = false;",
      "info" : "ExpressionStatement[19108-19127]:ExpressionStatement[19108-19127]"
    }, {
      "left" : "if (match(JsDocToken.LC))",
      "right" : "if (match(JsDocToken.LC))",
      "info" : "IfStatement[19146-19268]:IfStatement[19146-19268]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19172-19268]:Block[19172-19268]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[19194-19209]:ExpressionStatement[19194-19209]"
    }, {
      "left" : "matchingRc = true;",
      "right" : "matchingRc = true;",
      "info" : "ExpressionStatement[19230-19248]:ExpressionStatement[19230-19248]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[19288-19774]:IfStatement[19288-19774]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19318-19613]:Block[19318-19613]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[19340-19355]:ExpressionStatement[19340-19355]"
    }, {
      "left" : "if (!jsdocBuilder.recordLends(stream.getString()))",
      "right" : "if (!jsdocBuilder.recordLends(stream.getString()))",
      "info" : "IfStatement[19376-19593]:IfStatement[19376-19593]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19427-19593]:Block[19427-19593]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[19451-19571]:ExpressionStatement[19451-19571]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19619-19774]:Block[19619-19774]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[19641-19754]:ExpressionStatement[19641-19754]"
    }, {
      "left" : "if (matchingRc && !match(JsDocToken.RC))",
      "right" : "if (matchingRc && !match(JsDocToken.RC))",
      "info" : "IfStatement[19794-19987]:IfStatement[19794-19987]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19835-19987]:Block[19835-19987]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[19857-19967]:ExpressionStatement[19857-19967]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[20006-20034]:ExpressionStatement[20006-20034]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[20053-20068]:ContinueStatement[20053-20068]"
    }, {
      "left" : "case MEANING:",
      "right" : "case MEANING:",
      "info" : "SwitchCase[20086-20099]:SwitchCase[20086-20099]"
    }, {
      "left" : "ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[20118-20205]:VariableDeclarationStatement[20118-20205]"
    }, {
      "left" : "String meaning = meaningInfo.string;",
      "right" : "String meaning = meaningInfo.string;",
      "info" : "VariableDeclarationStatement[20224-20260]:VariableDeclarationStatement[20224-20260]"
    }, {
      "left" : "token = meaningInfo.token;",
      "right" : "token = meaningInfo.token;",
      "info" : "ExpressionStatement[20279-20305]:ExpressionStatement[20279-20305]"
    }, {
      "left" : "if (!jsdocBuilder.recordMeaning(meaning))",
      "right" : "if (!jsdocBuilder.recordMeaning(meaning))",
      "info" : "IfStatement[20324-20523]:IfStatement[20324-20523]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20366-20523]:Block[20366-20523]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[20388-20503]:ExpressionStatement[20388-20503]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[20542-20557]:ContinueStatement[20542-20557]"
    }, {
      "left" : "case NO_ALIAS:",
      "right" : "case NO_ALIAS:",
      "info" : "SwitchCase[20575-20589]:SwitchCase[20575-20589]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoAlias())",
      "right" : "if (!jsdocBuilder.recordNoAlias())",
      "info" : "IfStatement[20608-20794]:IfStatement[20608-20794]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20643-20794]:Block[20643-20794]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[20665-20774]:ExpressionStatement[20665-20774]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[20813-20841]:ExpressionStatement[20813-20841]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[20860-20875]:ContinueStatement[20860-20875]"
    }, {
      "left" : "case NO_COMPILE:",
      "right" : "case NO_COMPILE:",
      "info" : "SwitchCase[20893-20909]:SwitchCase[20893-20909]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoCompile())",
      "right" : "if (!jsdocBuilder.recordNoCompile())",
      "info" : "IfStatement[20928-21118]:IfStatement[20928-21118]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20965-21118]:Block[20965-21118]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[20987-21098]:ExpressionStatement[20987-21098]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[21137-21165]:ExpressionStatement[21137-21165]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21184-21199]:ContinueStatement[21184-21199]"
    }, {
      "left" : "case NO_TYPE_CHECK:",
      "right" : "case NO_TYPE_CHECK:",
      "info" : "SwitchCase[21217-21236]:SwitchCase[21217-21236]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoTypeCheck())",
      "right" : "if (!jsdocBuilder.recordNoTypeCheck())",
      "info" : "IfStatement[21255-21445]:IfStatement[21255-21445]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21294-21445]:Block[21294-21445]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[21316-21425]:ExpressionStatement[21316-21425]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[21464-21492]:ExpressionStatement[21464-21492]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21511-21526]:ContinueStatement[21511-21526]"
    }, {
      "left" : "case NOT_IMPLEMENTED:",
      "right" : "case NOT_IMPLEMENTED:",
      "info" : "SwitchCase[21544-21565]:SwitchCase[21544-21565]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[21584-21612]:ExpressionStatement[21584-21612]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21631-21646]:ContinueStatement[21631-21646]"
    }, {
      "left" : "case INHERIT_DOC:",
      "right" : "case INHERIT_DOC:",
      "info" : "SwitchCase[21664-21681]:SwitchCase[21664-21681]"
    }, {
      "left" : "case OVERRIDE:",
      "right" : "case OVERRIDE:",
      "info" : "SwitchCase[21698-21712]:SwitchCase[21698-21712]"
    }, {
      "left" : "if (!jsdocBuilder.recordOverride())",
      "right" : "if (!jsdocBuilder.recordOverride())",
      "info" : "IfStatement[21731-21917]:IfStatement[21731-21917]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21767-21917]:Block[21767-21917]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[21789-21897]:ExpressionStatement[21789-21897]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[21936-21964]:ExpressionStatement[21936-21964]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21983-21998]:ContinueStatement[21983-21998]"
    }, {
      "left" : "case THROWS:",
      "right" : "case THROWS:",
      "info" : "SwitchCase[22016-22028]:SwitchCase[22016-22028]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[22047-22058]:ExpressionStatement[22047-22058]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[22077-22092]:ExpressionStatement[22077-22092]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[22111-22139]:ExpressionStatement[22111-22139]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[22158-22186]:ExpressionStatement[22158-22186]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[22205-22217]:ExpressionStatement[22205-22217]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[22237-22662]:IfStatement[22237-22662]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22265-22662]:Block[22265-22662]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "info" : "ExpressionStatement[22287-22373]:ExpressionStatement[22287-22373]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[22395-22642]:IfStatement[22395-22642]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22413-22642]:Block[22413-22642]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[22554-22582]:ExpressionStatement[22554-22582]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[22605-22620]:ContinueStatement[22605-22620]"
    }, {
      "left" : "token = current();",
      "right" : "token = current();",
      "info" : "ExpressionStatement[22757-22775]:ExpressionStatement[22757-22775]"
    }, {
      "left" : "jsdocBuilder.recordThrowType(type);",
      "right" : "jsdocBuilder.recordThrowType(type);",
      "info" : "ExpressionStatement[22837-22872]:ExpressionStatement[22837-22872]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[22959-23491]:IfStatement[22959-23491]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23004-23410]:Block[23004-23410]"
    }, {
      "left" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[23026-23119]:VariableDeclarationStatement[23026-23119]"
    }, {
      "left" : "String description = descriptionInfo.string;",
      "right" : "String description = descriptionInfo.string;",
      "info" : "VariableDeclarationStatement[23141-23185]:VariableDeclarationStatement[23141-23185]"
    }, {
      "left" : "if (description.length() > 0)",
      "right" : "if (description.length() > 0)",
      "info" : "IfStatement[23207-23338]:IfStatement[23207-23338]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23237-23338]:Block[23237-23338]"
    }, {
      "left" : "jsdocBuilder.recordThrowDescription(type, description);",
      "right" : "jsdocBuilder.recordThrowDescription(type, description);",
      "info" : "ExpressionStatement[23261-23316]:ExpressionStatement[23261-23316]"
    }, {
      "left" : "token = descriptionInfo.token;",
      "right" : "token = descriptionInfo.token;",
      "info" : "ExpressionStatement[23360-23390]:ExpressionStatement[23360-23390]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23416-23491]:Block[23416-23491]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[23438-23471]:ExpressionStatement[23438-23471]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[23510-23525]:ContinueStatement[23510-23525]"
    }, {
      "left" : "case PARAM:",
      "right" : "case PARAM:",
      "info" : "SwitchCase[23543-23554]:SwitchCase[23543-23554]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[23573-23584]:ExpressionStatement[23573-23584]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[23603-23618]:ExpressionStatement[23603-23618]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[23637-23665]:ExpressionStatement[23637-23665]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[23684-23712]:ExpressionStatement[23684-23712]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[23731-23743]:ExpressionStatement[23731-23743]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[23763-24359]:IfStatement[23763-24359]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23791-24359]:Block[23791-24359]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
      "info" : "ExpressionStatement[23813-23904]:ExpressionStatement[23813-23904]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[23926-24173]:IfStatement[23926-24173]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23944-24173]:Block[23944-24173]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[24085-24113]:ExpressionStatement[24085-24113]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[24136-24151]:ContinueStatement[24136-24151]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[24194-24205]:ExpressionStatement[24194-24205]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[24226-24241]:ExpressionStatement[24226-24241]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[24262-24290]:ExpressionStatement[24262-24290]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[24311-24339]:ExpressionStatement[24311-24339]"
    }, {
      "left" : "String name = null;",
      "right" : "String name = null;",
      "info" : "VariableDeclarationStatement[24379-24398]:VariableDeclarationStatement[24379-24398]"
    }, {
      "left" : "boolean isBracketedParam = JsDocToken.LB == token;",
      "right" : "boolean isBracketedParam = JsDocToken.LB == token;",
      "info" : "VariableDeclarationStatement[24417-24467]:VariableDeclarationStatement[24417-24467]"
    }, {
      "left" : "if (isBracketedParam)",
      "right" : "if (isBracketedParam)",
      "info" : "IfStatement[24486-24565]:IfStatement[24486-24565]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24508-24565]:Block[24508-24565]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[24530-24545]:ExpressionStatement[24530-24545]"
    }, {
      "left" : "if (JsDocToken.STRING != token)",
      "right" : "if (JsDocToken.STRING != token)",
      "info" : "IfStatement[24585-26483]:IfStatement[24585-26483]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24617-24750]:Block[24617-24750]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
      "info" : "ExpressionStatement[24639-24730]:ExpressionStatement[24639-24730]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24756-26483]:Block[24756-26483]"
    }, {
      "left" : "name = stream.getString();",
      "right" : "name = stream.getString();",
      "info" : "ExpressionStatement[24778-24804]:ExpressionStatement[24778-24804]"
    }, {
      "left" : "if (isBracketedParam)",
      "right" : "if (isBracketedParam)",
      "info" : "IfStatement[24826-25710]:IfStatement[24826-25710]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24848-25710]:Block[24848-25710]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[24872-24887]:ExpressionStatement[24872-24887]"
    }, {
      "left" : "if (JsDocToken.EQUALS == token)",
      "right" : "if (JsDocToken.EQUALS == token)",
      "info" : "IfStatement[25085-25308]:IfStatement[25085-25308]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25117-25308]:Block[25117-25308]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[25143-25158]:ExpressionStatement[25143-25158]"
    }, {
      "left" : "if (JsDocToken.STRING == token)",
      "right" : "if (JsDocToken.STRING == token)",
      "info" : "IfStatement[25183-25284]:IfStatement[25183-25284]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25215-25284]:Block[25215-25284]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[25243-25258]:ExpressionStatement[25243-25258]"
    }, {
      "left" : "if (JsDocToken.RB != token)",
      "right" : "if (JsDocToken.RB != token)",
      "info" : "IfStatement[25332-25688]:IfStatement[25332-25688]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25360-25458]:Block[25360-25458]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ExpressionStatement[25386-25434]:ExpressionStatement[25386-25434]"
    }, {
      "left" : "if (type != null)",
      "right" : "if (type != null)",
      "info" : "IfStatement[25464-25688]:IfStatement[25464-25688]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25482-25688]:Block[25482-25688]"
    }, {
      "left" : "type = JSTypeExpression.makeOptionalArg(type);",
      "right" : "type = JSTypeExpression.makeOptionalArg(type);",
      "info" : "ExpressionStatement[25618-25664]:ExpressionStatement[25618-25664]"
    }, {
      "left" : "if (name.indexOf('.') > -1)",
      "right" : "if (name.indexOf('.') > -1)",
      "info" : "IfStatement[25939-26463]:IfStatement[25939-26463]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25967-26025]:Block[25967-26025]"
    }, {
      "left" : "name = null;",
      "right" : "name = null;",
      "info" : "ExpressionStatement[25991-26003]:ExpressionStatement[25991-26003]"
    }, {
      "left" : "if (!jsdocBuilder.recordParameter(name, type))",
      "right" : "if (!jsdocBuilder.recordParameter(name, type))",
      "info" : "IfStatement[26031-26463]:IfStatement[26031-26463]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26078-26463]:Block[26078-26463]"
    }, {
      "left" : "if (jsdocBuilder.hasParameter(name))",
      "right" : "if (jsdocBuilder.hasParameter(name))",
      "info" : "IfStatement[26102-26441]:IfStatement[26102-26441]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26139-26286]:Block[26139-26286]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
      "info" : "ExpressionStatement[26165-26262]:ExpressionStatement[26165-26262]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26292-26441]:Block[26292-26441]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
      "info" : "ExpressionStatement[26318-26417]:ExpressionStatement[26318-26417]"
    }, {
      "left" : "if (name == null)",
      "right" : "if (name == null)",
      "info" : "IfStatement[26503-26632]:IfStatement[26503-26632]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26521-26632]:Block[26521-26632]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[26543-26576]:ExpressionStatement[26543-26576]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[26597-26612]:ContinueStatement[26597-26612]"
    }, {
      "left" : "jsdocBuilder.markName(name, sourceFile, lineno, charno);",
      "right" : "jsdocBuilder.markName(name, sourceFile, lineno, charno);",
      "info" : "ExpressionStatement[26652-26708]:ExpressionStatement[26652-26708]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[26799-27391]:IfStatement[26799-27391]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26844-27310]:Block[26844-27310]"
    }, {
      "left" : "ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[26866-26964]:VariableDeclarationStatement[26866-26964]"
    }, {
      "left" : "String paramDescription = paramDescriptionInfo.string;",
      "right" : "String paramDescription = paramDescriptionInfo.string;",
      "info" : "VariableDeclarationStatement[26986-27040]:VariableDeclarationStatement[26986-27040]"
    }, {
      "left" : "if (paramDescription.length() > 0)",
      "right" : "if (paramDescription.length() > 0)",
      "info" : "IfStatement[27062-27233]:IfStatement[27062-27233]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27097-27233]:Block[27097-27233]"
    }, {
      "left" : "jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);",
      "right" : "jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);",
      "info" : "ExpressionStatement[27121-27211]:ExpressionStatement[27121-27211]"
    }, {
      "left" : "token = paramDescriptionInfo.token;",
      "right" : "token = paramDescriptionInfo.token;",
      "info" : "ExpressionStatement[27255-27290]:ExpressionStatement[27255-27290]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27316-27391]:Block[27316-27391]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[27338-27371]:ExpressionStatement[27338-27371]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[27410-27425]:ContinueStatement[27410-27425]"
    }, {
      "left" : "case PRESERVE_TRY:",
      "right" : "case PRESERVE_TRY:",
      "info" : "SwitchCase[27443-27461]:SwitchCase[27443-27461]"
    }, {
      "left" : "if (!jsdocBuilder.recordPreserveTry())",
      "right" : "if (!jsdocBuilder.recordPreserveTry())",
      "info" : "IfStatement[27480-27675]:IfStatement[27480-27675]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27519-27675]:Block[27519-27675]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[27541-27655]:ExpressionStatement[27541-27655]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[27694-27722]:ExpressionStatement[27694-27722]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[27741-27756]:ContinueStatement[27741-27756]"
    }, {
      "left" : "case NO_SHADOW:",
      "right" : "case NO_SHADOW:",
      "info" : "SwitchCase[27774-27789]:SwitchCase[27774-27789]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoShadow())",
      "right" : "if (!jsdocBuilder.recordNoShadow())",
      "info" : "IfStatement[27808-27996]:IfStatement[27808-27996]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27844-27996]:Block[27844-27996]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[27866-27976]:ExpressionStatement[27866-27976]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[28015-28043]:ExpressionStatement[28015-28043]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[28062-28077]:ContinueStatement[28062-28077]"
    }, {
      "left" : "case NO_SIDE_EFFECTS:",
      "right" : "case NO_SIDE_EFFECTS:",
      "info" : "SwitchCase[28095-28116]:SwitchCase[28095-28116]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoSideEffects())",
      "right" : "if (!jsdocBuilder.recordNoSideEffects())",
      "info" : "IfStatement[28135-28333]:IfStatement[28135-28333]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28176-28333]:Block[28176-28333]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[28198-28313]:ExpressionStatement[28198-28313]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[28352-28380]:ExpressionStatement[28352-28380]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[28399-28414]:ContinueStatement[28399-28414]"
    }, {
      "left" : "case MODIFIES:",
      "right" : "case MODIFIES:",
      "info" : "SwitchCase[28432-28446]:SwitchCase[28432-28446]"
    }, {
      "left" : "token = parseModifiesTag(next());",
      "right" : "token = parseModifiesTag(next());",
      "info" : "ExpressionStatement[28465-28498]:ExpressionStatement[28465-28498]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[28517-28532]:ContinueStatement[28517-28532]"
    }, {
      "left" : "case IMPLICIT_CAST:",
      "right" : "case IMPLICIT_CAST:",
      "info" : "SwitchCase[28550-28569]:SwitchCase[28550-28569]"
    }, {
      "left" : "if (!jsdocBuilder.recordImplicitCast())",
      "right" : "if (!jsdocBuilder.recordImplicitCast())",
      "info" : "IfStatement[28588-28782]:IfStatement[28588-28782]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28628-28782]:Block[28628-28782]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[28650-28762]:ExpressionStatement[28650-28762]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[28801-28829]:ExpressionStatement[28801-28829]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[28848-28863]:ContinueStatement[28848-28863]"
    }, {
      "left" : "case SEE:",
      "right" : "case SEE:",
      "info" : "SwitchCase[28881-28890]:SwitchCase[28881-28890]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[28909-29544]:IfStatement[28909-29544]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28954-29463]:Block[28954-29463]"
    }, {
      "left" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[28976-29032]:VariableDeclarationStatement[28976-29032]"
    }, {
      "left" : "String reference = referenceInfo.string;",
      "right" : "String reference = referenceInfo.string;",
      "info" : "VariableDeclarationStatement[29053-29093]:VariableDeclarationStatement[29053-29093]"
    }, {
      "left" : "if (reference.length() == 0)",
      "right" : "if (reference.length() == 0)",
      "info" : "IfStatement[29115-29393]:IfStatement[29115-29393]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29144-29304]:Block[29144-29304]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[29168-29282]:ExpressionStatement[29168-29282]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29310-29393]:Block[29310-29393]"
    }, {
      "left" : "jsdocBuilder.addReference(reference);",
      "right" : "jsdocBuilder.addReference(reference);",
      "info" : "ExpressionStatement[29334-29371]:ExpressionStatement[29334-29371]"
    }, {
      "left" : "token = referenceInfo.token;",
      "right" : "token = referenceInfo.token;",
      "info" : "ExpressionStatement[29415-29443]:ExpressionStatement[29415-29443]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29469-29544]:Block[29469-29544]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[29491-29524]:ExpressionStatement[29491-29524]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[29563-29578]:ContinueStatement[29563-29578]"
    }, {
      "left" : "case STABLEIDGENERATOR:",
      "right" : "case STABLEIDGENERATOR:",
      "info" : "SwitchCase[29596-29619]:SwitchCase[29596-29619]"
    }, {
      "left" : "if (!jsdocBuilder.recordStableIdGenerator())",
      "right" : "if (!jsdocBuilder.recordStableIdGenerator())",
      "info" : "IfStatement[29638-29836]:IfStatement[29638-29836]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29683-29836]:Block[29683-29836]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[29705-29816]:ExpressionStatement[29705-29816]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[29855-29883]:ExpressionStatement[29855-29883]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[29902-29917]:ContinueStatement[29902-29917]"
    }, {
      "left" : "case SUPPRESS:",
      "right" : "case SUPPRESS:",
      "info" : "SwitchCase[29935-29949]:SwitchCase[29935-29949]"
    }, {
      "left" : "token = parseSuppressTag(next());",
      "right" : "token = parseSuppressTag(next());",
      "info" : "ExpressionStatement[29968-30001]:ExpressionStatement[29968-30001]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[30020-30035]:ContinueStatement[30020-30035]"
    }, {
      "left" : "case TEMPLATE:",
      "right" : "case TEMPLATE:",
      "info" : "SwitchCase[30053-30067]:SwitchCase[30053-30067]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30068-30888]:Block[30068-30888]"
    }, {
      "left" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[30088-30143]:VariableDeclarationStatement[30088-30143]"
    }, {
      "left" : "List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));",
      "right" : "List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));",
      "info" : "VariableDeclarationStatement[30162-30338]:VariableDeclarationStatement[30162-30338]"
    }, {
      "left" : "if (names.size() == 0 || names.get(0).length() == 0)",
      "right" : "if (names.size() == 0 || names.get(0).length() == 0)",
      "info" : "IfStatement[30358-30789]:IfStatement[30358-30789]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30411-30570]:Block[30411-30570]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[30433-30550]:ExpressionStatement[30433-30550]"
    }, {
      "left" : "if (!jsdocBuilder.recordTemplateTypeNames(names))",
      "right" : "if (!jsdocBuilder.recordTemplateTypeNames(names))",
      "info" : "IfStatement[30576-30789]:IfStatement[30576-30789]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30626-30789]:Block[30626-30789]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[30648-30769]:ExpressionStatement[30648-30769]"
    }, {
      "left" : "token = templateInfo.token;",
      "right" : "token = templateInfo.token;",
      "info" : "ExpressionStatement[30809-30836]:ExpressionStatement[30809-30836]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[30855-30870]:ContinueStatement[30855-30870]"
    }, {
      "left" : "case CLASS_TEMPLATE:",
      "right" : "case CLASS_TEMPLATE:",
      "info" : "SwitchCase[30906-30926]:SwitchCase[30906-30926]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30927-31836]:Block[30927-31836]"
    }, {
      "left" : "ExtractionInfo classTemplateInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo classTemplateInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[30947-31007]:VariableDeclarationStatement[30947-31007]"
    }, {
      "left" : "List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));",
      "right" : "List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));",
      "info" : "VariableDeclarationStatement[31026-31207]:VariableDeclarationStatement[31026-31207]"
    }, {
      "left" : "if (names.size() == 0 || names.get(0).length() == 0)",
      "right" : "if (names.size() == 0 || names.get(0).length() == 0)",
      "info" : "IfStatement[31227-31732]:IfStatement[31227-31732]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31280-31478]:Block[31280-31478]"
    }, {
      "left" : "parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[31302-31458]:ExpressionStatement[31302-31458]"
    }, {
      "left" : "if (!jsdocBuilder.recordClassTemplateTypeNames(names))",
      "right" : "if (!jsdocBuilder.recordClassTemplateTypeNames(names))",
      "info" : "IfStatement[31484-31732]:IfStatement[31484-31732]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31539-31732]:Block[31539-31732]"
    }, {
      "left" : "parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[31561-31712]:ExpressionStatement[31561-31712]"
    }, {
      "left" : "token = classTemplateInfo.token;",
      "right" : "token = classTemplateInfo.token;",
      "info" : "ExpressionStatement[31752-31784]:ExpressionStatement[31752-31784]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[31803-31818]:ContinueStatement[31803-31818]"
    }, {
      "left" : "case IDGENERATOR:",
      "right" : "case IDGENERATOR:",
      "info" : "SwitchCase[31854-31871]:SwitchCase[31854-31871]"
    }, {
      "left" : "if (!jsdocBuilder.recordIdGenerator())",
      "right" : "if (!jsdocBuilder.recordIdGenerator())",
      "info" : "IfStatement[31890-32076]:IfStatement[31890-32076]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31929-32076]:Block[31929-32076]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[31951-32056]:ExpressionStatement[31951-32056]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[32095-32123]:ExpressionStatement[32095-32123]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[32142-32157]:ContinueStatement[32142-32157]"
    }, {
      "left" : "case VERSION:",
      "right" : "case VERSION:",
      "info" : "SwitchCase[32175-32188]:SwitchCase[32175-32188]"
    }, {
      "left" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[32207-32261]:VariableDeclarationStatement[32207-32261]"
    }, {
      "left" : "String version = versionInfo.string;",
      "right" : "String version = versionInfo.string;",
      "info" : "VariableDeclarationStatement[32280-32316]:VariableDeclarationStatement[32280-32316]"
    }, {
      "left" : "if (version.length() == 0)",
      "right" : "if (version.length() == 0)",
      "info" : "IfStatement[32336-32776]:IfStatement[32336-32776]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32363-32523]:Block[32363-32523]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[32385-32503]:ExpressionStatement[32385-32503]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32529-32776]:Block[32529-32776]"
    }, {
      "left" : "if (!jsdocBuilder.recordVersion(version))",
      "right" : "if (!jsdocBuilder.recordVersion(version))",
      "info" : "IfStatement[32551-32756]:IfStatement[32551-32756]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32593-32756]:Block[32593-32756]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[32618-32734]:ExpressionStatement[32618-32734]"
    }, {
      "left" : "token = versionInfo.token;",
      "right" : "token = versionInfo.token;",
      "info" : "ExpressionStatement[32796-32822]:ExpressionStatement[32796-32822]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[32841-32856]:ContinueStatement[32841-32856]"
    }, {
      "left" : "case CONSTANT:",
      "right" : "case CONSTANT:",
      "info" : "SwitchCase[32874-32888]:SwitchCase[32874-32888]"
    }, {
      "left" : "case DEFINE:",
      "right" : "case DEFINE:",
      "info" : "SwitchCase[32905-32917]:SwitchCase[32905-32917]"
    }, {
      "left" : "case RETURN:",
      "right" : "case RETURN:",
      "info" : "SwitchCase[32934-32946]:SwitchCase[32934-32946]"
    }, {
      "left" : "case PRIVATE:",
      "right" : "case PRIVATE:",
      "info" : "SwitchCase[32963-32976]:SwitchCase[32963-32976]"
    }, {
      "left" : "case PROTECTED:",
      "right" : "case PROTECTED:",
      "info" : "SwitchCase[32993-33008]:SwitchCase[32993-33008]"
    }, {
      "left" : "case PUBLIC:",
      "right" : "case PUBLIC:",
      "info" : "SwitchCase[33025-33037]:SwitchCase[33025-33037]"
    }, {
      "left" : "case THIS:",
      "right" : "case THIS:",
      "info" : "SwitchCase[33054-33064]:SwitchCase[33054-33064]"
    }, {
      "left" : "case TYPE:",
      "right" : "case TYPE:",
      "info" : "SwitchCase[33081-33091]:SwitchCase[33081-33091]"
    }, {
      "left" : "case TYPEDEF:",
      "right" : "case TYPEDEF:",
      "info" : "SwitchCase[33108-33121]:SwitchCase[33108-33121]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[33140-33168]:ExpressionStatement[33140-33168]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[33187-33215]:ExpressionStatement[33187-33215]"
    }, {
      "left" : "Node typeNode = null;",
      "right" : "Node typeNode = null;",
      "info" : "VariableDeclarationStatement[33235-33256]:VariableDeclarationStatement[33235-33256]"
    }, {
      "left" : "boolean hasType = lookAheadForTypeAnnotation();",
      "right" : "boolean hasType = lookAheadForTypeAnnotation();",
      "info" : "VariableDeclarationStatement[33275-33322]:VariableDeclarationStatement[33275-33322]"
    }, {
      "left" : "boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);",
      "right" : "boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);",
      "info" : "VariableDeclarationStatement[33341-33613]:VariableDeclarationStatement[33341-33613]"
    }, {
      "left" : "boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);",
      "right" : "boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);",
      "info" : "VariableDeclarationStatement[33632-33772]:VariableDeclarationStatement[33632-33772]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[33791-33803]:ExpressionStatement[33791-33803]"
    }, {
      "left" : "if (hasType || !canSkipTypeAnnotation)",
      "right" : "if (hasType || !canSkipTypeAnnotation)",
      "info" : "IfStatement[33822-34218]:IfStatement[33822-34218]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33861-34218]:Block[33861-34218]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[33883-33894]:ExpressionStatement[33883-33894]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[33915-33930]:ExpressionStatement[33915-33930]"
    }, {
      "left" : "typeNode = parseAndRecordTypeNode(token);",
      "right" : "typeNode = parseAndRecordTypeNode(token);",
      "info" : "ExpressionStatement[33951-33992]:ExpressionStatement[33951-33992]"
    }, {
      "left" : "if (annotation == Annotation.THIS)",
      "right" : "if (annotation == Annotation.THIS)",
      "info" : "IfStatement[34014-34137]:IfStatement[34014-34137]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34049-34137]:Block[34049-34137]"
    }, {
      "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "info" : "ExpressionStatement[34073-34115]:ExpressionStatement[34073-34115]"
    }, {
      "left" : "type = createJSTypeExpression(typeNode);",
      "right" : "type = createJSTypeExpression(typeNode);",
      "info" : "ExpressionStatement[34158-34198]:ExpressionStatement[34158-34198]"
    }, {
      "left" : "boolean hasError = type == null && !canSkipTypeAnnotation;",
      "right" : "boolean hasError = type == null && !canSkipTypeAnnotation;",
      "info" : "VariableDeclarationStatement[34347-34405]:VariableDeclarationStatement[34347-34405]"
    }, {
      "left" : "if (!hasError)",
      "right" : "if (!hasError)",
      "info" : "IfStatement[34424-38734]:IfStatement[34424-38734]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34439-38734]:Block[34439-38734]"
    }, {
      "left" : "if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE)",
      "right" : "if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE)",
      "info" : "IfStatement[34907-35239]:IfStatement[34907-35239]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35013-35239]:Block[35013-35239]"
    }, {
      "left" : "if (!jsdocBuilder.recordType(type))",
      "right" : "if (!jsdocBuilder.recordType(type))",
      "info" : "IfStatement[35037-35217]:IfStatement[35037-35217]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35073-35217]:Block[35073-35217]"
    }, {
      "left" : "parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[35099-35193]:ExpressionStatement[35099-35193]"
    }, {
      "left" : "switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
      "right" : "switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
      "info" : "SwitchStatement[35261-38714]:SwitchStatement[35261-38714]"
    }, {
      "left" : "case CONSTANT:",
      "right" : "case CONSTANT:",
      "info" : "SwitchCase[35305-35319]:SwitchCase[35305-35319]"
    }, {
      "left" : "if (!jsdocBuilder.recordConstancy())",
      "right" : "if (!jsdocBuilder.recordConstancy())",
      "info" : "IfStatement[35344-35548]:IfStatement[35344-35548]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35381-35548]:Block[35381-35548]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[35409-35522]:ExpressionStatement[35409-35522]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[35573-35579]:BreakStatement[35573-35579]"
    }, {
      "left" : "case DEFINE:",
      "right" : "case DEFINE:",
      "info" : "SwitchCase[35603-35615]:SwitchCase[35603-35615]"
    }, {
      "left" : "if (!jsdocBuilder.recordDefineType(type))",
      "right" : "if (!jsdocBuilder.recordDefineType(type))",
      "info" : "IfStatement[35640-35826]:IfStatement[35640-35826]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35682-35826]:Block[35682-35826]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
      "right" : "parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
      "info" : "ExpressionStatement[35710-35800]:ExpressionStatement[35710-35800]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[35851-35857]:BreakStatement[35851-35857]"
    }, {
      "left" : "case PRIVATE:",
      "right" : "case PRIVATE:",
      "info" : "SwitchCase[35881-35894]:SwitchCase[35881-35894]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
      "info" : "IfStatement[35919-36162]:IfStatement[35919-36162]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35975-36162]:Block[35975-36162]"
    }, {
      "left" : "parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);",
      "right" : "parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);",
      "info" : "ExpressionStatement[36003-36136]:ExpressionStatement[36003-36136]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[36187-36193]:BreakStatement[36187-36193]"
    }, {
      "left" : "case PROTECTED:",
      "right" : "case PROTECTED:",
      "info" : "SwitchCase[36217-36232]:SwitchCase[36217-36232]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
      "info" : "IfStatement[36257-36504]:IfStatement[36257-36504]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36315-36504]:Block[36315-36504]"
    }, {
      "left" : "parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);",
      "right" : "parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);",
      "info" : "ExpressionStatement[36343-36478]:ExpressionStatement[36343-36478]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[36529-36535]:BreakStatement[36529-36535]"
    }, {
      "left" : "case PUBLIC:",
      "right" : "case PUBLIC:",
      "info" : "SwitchCase[36559-36571]:SwitchCase[36559-36571]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
      "info" : "IfStatement[36596-36837]:IfStatement[36596-36837]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36651-36837]:Block[36651-36837]"
    }, {
      "left" : "parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);",
      "right" : "parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);",
      "info" : "ExpressionStatement[36679-36811]:ExpressionStatement[36679-36811]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[36862-36868]:BreakStatement[36862-36868]"
    }, {
      "left" : "case RETURN:",
      "right" : "case RETURN:",
      "info" : "SwitchCase[36892-36904]:SwitchCase[36892-36904]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[36929-37053]:IfStatement[36929-37053]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36947-37053]:Block[36947-37053]"
    }, {
      "left" : "type = createJSTypeExpression(newNode(Token.QMARK));",
      "right" : "type = createJSTypeExpression(newNode(Token.QMARK));",
      "info" : "ExpressionStatement[36975-37027]:ExpressionStatement[36975-37027]"
    }, {
      "left" : "if (!jsdocBuilder.recordReturnType(type))",
      "right" : "if (!jsdocBuilder.recordReturnType(type))",
      "info" : "IfStatement[37079-37304]:IfStatement[37079-37304]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37121-37304]:Block[37121-37304]"
    }, {
      "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[37149-37245]:ExpressionStatement[37149-37245]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[37272-37278]:BreakStatement[37272-37278]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[37404-38090]:IfStatement[37404-38090]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37449-37997]:Block[37449-37997]"
    }, {
      "left" : "ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[37477-37582]:VariableDeclarationStatement[37477-37582]"
    }, {
      "left" : "String returnDescription =\n                              returnDescriptionInfo.string;",
      "right" : "String returnDescription =\n                              returnDescriptionInfo.string;",
      "info" : "VariableDeclarationStatement[37610-37696]:VariableDeclarationStatement[37610-37696]"
    }, {
      "left" : "if (returnDescription.length() > 0)",
      "right" : "if (returnDescription.length() > 0)",
      "info" : "IfStatement[37724-37907]:IfStatement[37724-37907]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37760-37907]:Block[37760-37907]"
    }, {
      "left" : "jsdocBuilder.recordReturnDescription(\n                                returnDescription);",
      "right" : "jsdocBuilder.recordReturnDescription(\n                                returnDescription);",
      "info" : "ExpressionStatement[37790-37879]:ExpressionStatement[37790-37879]"
    }, {
      "left" : "token = returnDescriptionInfo.token;",
      "right" : "token = returnDescriptionInfo.token;",
      "info" : "ExpressionStatement[37935-37971]:ExpressionStatement[37935-37971]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38003-38090]:Block[38003-38090]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[38031-38064]:ExpressionStatement[38031-38064]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[38115-38130]:ContinueStatement[38115-38130]"
    }, {
      "left" : "case THIS:",
      "right" : "case THIS:",
      "info" : "SwitchCase[38154-38164]:SwitchCase[38154-38164]"
    }, {
      "left" : "if (!jsdocBuilder.recordThisType(type))",
      "right" : "if (!jsdocBuilder.recordThisType(type))",
      "info" : "IfStatement[38189-38379]:IfStatement[38189-38379]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38229-38379]:Block[38229-38379]"
    }, {
      "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[38257-38353]:ExpressionStatement[38257-38353]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[38404-38410]:BreakStatement[38404-38410]"
    }, {
      "left" : "case TYPEDEF:",
      "right" : "case TYPEDEF:",
      "info" : "SwitchCase[38434-38447]:SwitchCase[38434-38447]"
    }, {
      "left" : "if (!jsdocBuilder.recordTypedef(type))",
      "right" : "if (!jsdocBuilder.recordTypedef(type))",
      "info" : "IfStatement[38472-38661]:IfStatement[38472-38661]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38511-38661]:Block[38511-38661]"
    }, {
      "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[38539-38635]:ExpressionStatement[38539-38635]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[38686-38692]:BreakStatement[38686-38692]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[38754-38782]:ExpressionStatement[38754-38782]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[38801-38816]:ContinueStatement[38801-38816]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[38869-38875]:BreakStatement[38869-38875]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[38885-38894]:SwitchCase[38885-38894]"
    }, {
      "left" : "if (hasParsedFileOverviewDocInfo())",
      "right" : "if (hasParsedFileOverviewDocInfo())",
      "info" : "IfStatement[38905-39025]:IfStatement[38905-39025]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38941-39025]:Block[38941-39025]"
    }, {
      "left" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
      "right" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
      "info" : "ExpressionStatement[38955-39013]:ExpressionStatement[38955-39013]"
    }, {
      "left" : "checkExtendedTypes(extendedTypes);",
      "right" : "checkExtendedTypes(extendedTypes);",
      "info" : "ExpressionStatement[39036-39070]:ExpressionStatement[39036-39070]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[39081-39093]:ReturnStatement[39081-39093]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[39103-39112]:SwitchCase[39103-39112]"
    }, {
      "left" : "jsdocBuilder.build(null);",
      "right" : "jsdocBuilder.build(null);",
      "info" : "ExpressionStatement[39172-39197]:ExpressionStatement[39172-39197]"
    }, {
      "left" : "parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[39208-39308]:ExpressionStatement[39208-39308]"
    }, {
      "left" : "checkExtendedTypes(extendedTypes);",
      "right" : "checkExtendedTypes(extendedTypes);",
      "info" : "ExpressionStatement[39319-39353]:ExpressionStatement[39319-39353]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[39364-39377]:ReturnStatement[39364-39377]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[39387-39396]:SwitchCase[39387-39396]"
    }, {
      "left" : "if (state == State.SEARCHING_NEWLINE)",
      "right" : "if (state == State.SEARCHING_NEWLINE)",
      "info" : "IfStatement[39407-39506]:IfStatement[39407-39506]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39445-39506]:Block[39445-39506]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[39459-39494]:ExpressionStatement[39459-39494]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[39517-39532]:ExpressionStatement[39517-39532]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[39543-39558]:ContinueStatement[39543-39558]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[39568-39576]:SwitchCase[39568-39576]"
    }, {
      "left" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
      "right" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
      "info" : "IfStatement[39587-39858]:IfStatement[39587-39858]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39656-39725]:Block[39656-39725]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[39670-39685]:ExpressionStatement[39670-39685]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[39698-39713]:ContinueStatement[39698-39713]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39731-39858]:Block[39731-39858]"
    }, {
      "left" : "state = State.SEARCHING_NEWLINE;",
      "right" : "state = State.SEARCHING_NEWLINE;",
      "info" : "ExpressionStatement[39745-39777]:ExpressionStatement[39745-39777]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[39790-39818]:ExpressionStatement[39790-39818]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[39831-39846]:ContinueStatement[39831-39846]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[39894-39909]:ExpressionStatement[39894-39909]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[39923-39930]:Modifier[39923-39930]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[39931-39935]:PrimitiveType[39931-39935]"
    }, {
      "left" : "checkExtendedTypes",
      "right" : "checkExtendedTypes",
      "info" : "SimpleName[39936-39954]:SimpleName[39936-39954]"
    }, {
      "left" : "List<ExtendedTypeInfo> extendedTypes",
      "right" : "List<ExtendedTypeInfo> extendedTypes",
      "info" : "SingleVariableDeclaration[39955-39991]:SingleVariableDeclaration[39955-39991]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39993-40561]:Block[39993-40561]"
    }, {
      "left" : "for (ExtendedTypeInfo typeInfo : extendedTypes)",
      "right" : "for (ExtendedTypeInfo typeInfo : extendedTypes)",
      "info" : "EnhancedForStatement[39999-40557]:EnhancedForStatement[39999-40557]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40047-40557]:Block[40047-40557]"
    }, {
      "left" : "if (jsdocBuilder.isInterfaceRecorded())",
      "right" : "if (jsdocBuilder.isInterfaceRecorded())",
      "info" : "IfStatement[40118-40551]:IfStatement[40118-40551]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40158-40359]:Block[40158-40359]"
    }, {
      "left" : "if (!jsdocBuilder.recordExtendedInterface(typeInfo.type))",
      "right" : "if (!jsdocBuilder.recordExtendedInterface(typeInfo.type))",
      "info" : "IfStatement[40168-40351]:IfStatement[40168-40351]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40226-40351]:Block[40226-40351]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);",
      "right" : "parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);",
      "info" : "ExpressionStatement[40238-40341]:ExpressionStatement[40238-40341]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40365-40551]:Block[40365-40551]"
    }, {
      "left" : "if (!jsdocBuilder.recordBaseType(typeInfo.type))",
      "right" : "if (!jsdocBuilder.recordBaseType(typeInfo.type))",
      "info" : "IfStatement[40375-40543]:IfStatement[40375-40543]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40424-40543]:Block[40424-40543]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);",
      "info" : "ExpressionStatement[40436-40533]:ExpressionStatement[40436-40533]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[40719-40726]:Modifier[40719-40726]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[40727-40737]:SimpleType[40727-40737]"
    }, {
      "left" : "parseSuppressTag",
      "right" : "parseSuppressTag",
      "info" : "SimpleName[40738-40754]:SimpleName[40738-40754]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[40755-40771]:SingleVariableDeclaration[40755-40771]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40773-41925]:Block[40773-41925]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[40779-41903]:IfStatement[40779-41903]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40807-41903]:Block[40807-41903]"
    }, {
      "left" : "Set<String> suppressions = new HashSet<String>();",
      "right" : "Set<String> suppressions = new HashSet<String>();",
      "info" : "VariableDeclarationStatement[40815-40864]:VariableDeclarationStatement[40815-40864]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[40871-41514]:WhileStatement[40871-41514]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40884-41514]:Block[40884-41514]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[40894-41397]:IfStatement[40894-41397]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40924-41245]:Block[40924-41245]"
    }, {
      "left" : "String name = stream.getString();",
      "right" : "String name = stream.getString();",
      "info" : "VariableDeclarationStatement[40936-40969]:VariableDeclarationStatement[40936-40969]"
    }, {
      "left" : "if (!suppressionNames.contains(name))",
      "right" : "if (!suppressionNames.contains(name))",
      "info" : "IfStatement[40980-41160]:IfStatement[40980-41160]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41018-41160]:Block[41018-41160]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[41032-41148]:ExpressionStatement[41032-41148]"
    }, {
      "left" : "suppressions.add(stream.getString());",
      "right" : "suppressions.add(stream.getString());",
      "info" : "ExpressionStatement[41172-41209]:ExpressionStatement[41172-41209]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[41220-41235]:ExpressionStatement[41220-41235]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41251-41397]:Block[41251-41397]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[41263-41363]:ExpressionStatement[41263-41363]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[41374-41387]:ReturnStatement[41374-41387]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[41407-41506]:IfStatement[41407-41506]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41435-41472]:Block[41435-41472]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[41447-41462]:ExpressionStatement[41447-41462]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41478-41506]:Block[41478-41506]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[41490-41496]:BreakStatement[41490-41496]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[41522-41897]:IfStatement[41522-41897]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41549-41665]:Block[41549-41665]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[41559-41657]:ExpressionStatement[41559-41657]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41671-41897]:Block[41671-41897]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[41681-41696]:ExpressionStatement[41681-41696]"
    }, {
      "left" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
      "right" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
      "info" : "IfStatement[41705-41889]:IfStatement[41705-41889]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41757-41889]:Block[41757-41889]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[41769-41879]:ExpressionStatement[41769-41879]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[41908-41921]:ReturnStatement[41908-41921]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[42086-42093]:Modifier[42086-42093]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[42094-42104]:SimpleType[42094-42104]"
    }, {
      "left" : "parseModifiesTag",
      "right" : "parseModifiesTag",
      "info" : "SimpleName[42105-42121]:SimpleName[42105-42121]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[42122-42138]:SingleVariableDeclaration[42122-42138]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42140-43340]:Block[42140-43340]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[42146-43318]:IfStatement[42146-43318]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42174-43318]:Block[42174-43318]"
    }, {
      "left" : "Set<String> modifies = new HashSet<String>();",
      "right" : "Set<String> modifies = new HashSet<String>();",
      "info" : "VariableDeclarationStatement[42182-42227]:VariableDeclarationStatement[42182-42227]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[42234-42937]:WhileStatement[42234-42937]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42247-42937]:Block[42247-42937]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[42257-42820]:IfStatement[42257-42820]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42287-42668]:Block[42287-42668]"
    }, {
      "left" : "String name = stream.getString();",
      "right" : "String name = stream.getString();",
      "info" : "VariableDeclarationStatement[42299-42332]:VariableDeclarationStatement[42299-42332]"
    }, {
      "left" : "if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name))",
      "right" : "if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name))",
      "info" : "IfStatement[42343-42587]:IfStatement[42343-42587]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42441-42587]:Block[42441-42587]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[42457-42575]:ExpressionStatement[42457-42575]"
    }, {
      "left" : "modifies.add(stream.getString());",
      "right" : "modifies.add(stream.getString());",
      "info" : "ExpressionStatement[42599-42632]:ExpressionStatement[42599-42632]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[42643-42658]:ExpressionStatement[42643-42658]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42674-42820]:Block[42674-42820]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[42686-42786]:ExpressionStatement[42686-42786]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[42797-42810]:ReturnStatement[42797-42810]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[42830-42929]:IfStatement[42830-42929]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42858-42895]:Block[42858-42895]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[42870-42885]:ExpressionStatement[42870-42885]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42901-42929]:Block[42901-42929]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[42913-42919]:BreakStatement[42913-42919]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[42945-43312]:IfStatement[42945-43312]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42972-43088]:Block[42972-43088]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[42982-43080]:ExpressionStatement[42982-43080]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43094-43312]:Block[43094-43312]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[43104-43119]:ExpressionStatement[43104-43119]"
    }, {
      "left" : "if (!jsdocBuilder.recordModifies(modifies))",
      "right" : "if (!jsdocBuilder.recordModifies(modifies))",
      "info" : "IfStatement[43128-43304]:IfStatement[43128-43304]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43172-43304]:Block[43172-43304]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[43184-43294]:ExpressionStatement[43184-43294]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[43323-43336]:ReturnStatement[43323-43336]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[43577-43581]:SimpleType[43577-43581]"
    }, {
      "left" : "parseAndRecordTypeNode",
      "right" : "parseAndRecordTypeNode",
      "info" : "SimpleName[43582-43604]:SimpleName[43582-43604]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[43605-43621]:SingleVariableDeclaration[43605-43621]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43623-43694]:Block[43623-43694]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
      "right" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
      "info" : "ReturnStatement[43629-43690]:ReturnStatement[43629-43690]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[44001-44008]:Modifier[44001-44008]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[44009-44013]:SimpleType[44009-44013]"
    }, {
      "left" : "parseAndRecordTypeNode",
      "right" : "parseAndRecordTypeNode",
      "info" : "SimpleName[44014-44036]:SimpleName[44014-44036]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[44037-44053]:SingleVariableDeclaration[44037-44053]"
    }, {
      "left" : "boolean matchingLC",
      "right" : "boolean matchingLC",
      "info" : "SingleVariableDeclaration[44055-44073]:SingleVariableDeclaration[44055-44073]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44075-44189]:Block[44075-44189]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
      "right" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
      "info" : "ReturnStatement[44081-44185]:ReturnStatement[44081-44185]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[44628-44635]:Modifier[44628-44635]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[44636-44640]:SimpleType[44636-44640]"
    }, {
      "left" : "parseAndRecordTypeNameNode",
      "right" : "parseAndRecordTypeNameNode",
      "info" : "SimpleName[44641-44667]:SimpleName[44641-44667]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[44668-44684]:SingleVariableDeclaration[44668-44684]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[44686-44696]:SingleVariableDeclaration[44686-44696]"
    }, {
      "left" : "int startCharno",
      "right" : "int startCharno",
      "info" : "SingleVariableDeclaration[44740-44755]:SingleVariableDeclaration[44740-44755]"
    }, {
      "left" : "boolean matchingLC",
      "right" : "boolean matchingLC",
      "info" : "SingleVariableDeclaration[44757-44775]:SingleVariableDeclaration[44757-44775]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44777-44863]:Block[44777-44863]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
      "right" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
      "info" : "ReturnStatement[44783-44859]:ReturnStatement[44783-44859]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[45323-45330]:Modifier[45323-45330]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[45331-45335]:SimpleType[45331-45335]"
    }, {
      "left" : "parseAndRecordParamTypeNode",
      "right" : "parseAndRecordParamTypeNode",
      "info" : "SimpleName[45336-45363]:SimpleName[45336-45363]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[45364-45380]:SingleVariableDeclaration[45364-45380]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45382-45829]:Block[45382-45829]"
    }, {
      "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "info" : "ExpressionStatement[45388-45440]:ExpressionStatement[45388-45440]"
    }, {
      "left" : "int lineno = stream.getLineno();",
      "right" : "int lineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[45445-45477]:VariableDeclarationStatement[45445-45477]"
    }, {
      "left" : "int startCharno = stream.getCharno();",
      "right" : "int startCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[45482-45519]:VariableDeclarationStatement[45482-45519]"
    }, {
      "left" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
      "right" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
      "info" : "VariableDeclarationStatement[45525-45583]:VariableDeclarationStatement[45525-45583]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[45588-45804]:IfStatement[45588-45804]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45610-45804]:Block[45610-45804]"
    }, {
      "left" : "int endLineno = stream.getLineno();",
      "right" : "int endLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[45618-45653]:VariableDeclarationStatement[45618-45653]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[45660-45695]:VariableDeclarationStatement[45660-45695]"
    }, {
      "left" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n          endLineno, endCharno, true);",
      "right" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n          endLineno, endCharno, true);",
      "info" : "ExpressionStatement[45703-45798]:ExpressionStatement[45703-45798]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[45809-45825]:ReturnStatement[45809-45825]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[46454-46461]:Modifier[46454-46461]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[46462-46466]:SimpleType[46462-46466]"
    }, {
      "left" : "parseAndRecordTypeNode",
      "right" : "parseAndRecordTypeNode",
      "info" : "SimpleName[46467-46489]:SimpleName[46467-46489]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[46490-46506]:SingleVariableDeclaration[46490-46506]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[46508-46518]:SingleVariableDeclaration[46508-46518]"
    }, {
      "left" : "int startCharno",
      "right" : "int startCharno",
      "info" : "SingleVariableDeclaration[46558-46573]:SingleVariableDeclaration[46558-46573]"
    }, {
      "left" : "boolean matchingLC",
      "right" : "boolean matchingLC",
      "info" : "SingleVariableDeclaration[46613-46631]:SingleVariableDeclaration[46613-46631]"
    }, {
      "left" : "boolean onlyParseSimpleNames",
      "right" : "boolean onlyParseSimpleNames",
      "info" : "SingleVariableDeclaration[46671-46699]:SingleVariableDeclaration[46671-46699]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46701-47139]:Block[46701-47139]"
    }, {
      "left" : "Node typeNode = null;",
      "right" : "Node typeNode = null;",
      "info" : "VariableDeclarationStatement[46707-46728]:VariableDeclarationStatement[46707-46728]"
    }, {
      "left" : "if (onlyParseSimpleNames)",
      "right" : "if (onlyParseSimpleNames)",
      "info" : "IfStatement[46734-46884]:IfStatement[46734-46884]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46760-46816]:Block[46760-46816]"
    }, {
      "left" : "typeNode = parseTypeNameAnnotation(token);",
      "right" : "typeNode = parseTypeNameAnnotation(token);",
      "info" : "ExpressionStatement[46768-46810]:ExpressionStatement[46768-46810]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46822-46884]:Block[46822-46884]"
    }, {
      "left" : "typeNode = parseTypeExpressionAnnotation(token);",
      "right" : "typeNode = parseTypeExpressionAnnotation(token);",
      "info" : "ExpressionStatement[46830-46878]:ExpressionStatement[46830-46878]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[46890-47113]:IfStatement[46890-47113]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46912-47113]:Block[46912-47113]"
    }, {
      "left" : "int endLineno = stream.getLineno();",
      "right" : "int endLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[46920-46955]:VariableDeclarationStatement[46920-46955]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[46962-46997]:VariableDeclarationStatement[46962-46997]"
    }, {
      "left" : "jsdocBuilder.markTypeNode(\n          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);",
      "right" : "jsdocBuilder.markTypeNode(\n          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);",
      "info" : "ExpressionStatement[47005-47107]:ExpressionStatement[47005-47107]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[47119-47135]:ReturnStatement[47119-47135]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[47213-47220]:Modifier[47213-47220]"
    }, {
      "left" : "String",
      "right" : "String",
      "info" : "SimpleType[47221-47227]:SimpleType[47221-47227]"
    }, {
      "left" : "toString",
      "right" : "toString",
      "info" : "SimpleName[47228-47236]:SimpleName[47228-47236]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[47237-47253]:SingleVariableDeclaration[47237-47253]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47255-48085]:Block[47255-48085]"
    }, {
      "left" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
      "right" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
      "info" : "SwitchStatement[47261-48081]:SwitchStatement[47261-48081]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[47284-47300]:SwitchCase[47284-47300]"
    }, {
      "left" : "return \"@\" + stream.getString();",
      "right" : "return \"@\" + stream.getString();",
      "info" : "ReturnStatement[47309-47341]:ReturnStatement[47309-47341]"
    }, {
      "left" : "case BANG:",
      "right" : "case BANG:",
      "info" : "SwitchCase[47349-47359]:SwitchCase[47349-47359]"
    }, {
      "left" : "return \"!\";",
      "right" : "return \"!\";",
      "info" : "ReturnStatement[47368-47379]:ReturnStatement[47368-47379]"
    }, {
      "left" : "case COMMA:",
      "right" : "case COMMA:",
      "info" : "SwitchCase[47387-47398]:SwitchCase[47387-47398]"
    }, {
      "left" : "return \",\";",
      "right" : "return \",\";",
      "info" : "ReturnStatement[47407-47418]:ReturnStatement[47407-47418]"
    }, {
      "left" : "case COLON:",
      "right" : "case COLON:",
      "info" : "SwitchCase[47426-47437]:SwitchCase[47426-47437]"
    }, {
      "left" : "return \":\";",
      "right" : "return \":\";",
      "info" : "ReturnStatement[47446-47457]:ReturnStatement[47446-47457]"
    }, {
      "left" : "case GT:",
      "right" : "case GT:",
      "info" : "SwitchCase[47465-47473]:SwitchCase[47465-47473]"
    }, {
      "left" : "return \">\";",
      "right" : "return \">\";",
      "info" : "ReturnStatement[47482-47493]:ReturnStatement[47482-47493]"
    }, {
      "left" : "case LB:",
      "right" : "case LB:",
      "info" : "SwitchCase[47501-47509]:SwitchCase[47501-47509]"
    }, {
      "left" : "return \"[\";",
      "right" : "return \"[\";",
      "info" : "ReturnStatement[47518-47529]:ReturnStatement[47518-47529]"
    }, {
      "left" : "case LC:",
      "right" : "case LC:",
      "info" : "SwitchCase[47537-47545]:SwitchCase[47537-47545]"
    }, {
      "left" : "return \"{\";",
      "right" : "return \"{\";",
      "info" : "ReturnStatement[47554-47565]:ReturnStatement[47554-47565]"
    }, {
      "left" : "case LP:",
      "right" : "case LP:",
      "info" : "SwitchCase[47573-47581]:SwitchCase[47573-47581]"
    }, {
      "left" : "return \"(\";",
      "right" : "return \"(\";",
      "info" : "ReturnStatement[47590-47601]:ReturnStatement[47590-47601]"
    }, {
      "left" : "case LT:",
      "right" : "case LT:",
      "info" : "SwitchCase[47609-47617]:SwitchCase[47609-47617]"
    }, {
      "left" : "return \".<\";",
      "right" : "return \".<\";",
      "info" : "ReturnStatement[47626-47638]:ReturnStatement[47626-47638]"
    }, {
      "left" : "case QMARK:",
      "right" : "case QMARK:",
      "info" : "SwitchCase[47646-47657]:SwitchCase[47646-47657]"
    }, {
      "left" : "return \"?\";",
      "right" : "return \"?\";",
      "info" : "ReturnStatement[47666-47677]:ReturnStatement[47666-47677]"
    }, {
      "left" : "case PIPE:",
      "right" : "case PIPE:",
      "info" : "SwitchCase[47685-47695]:SwitchCase[47685-47695]"
    }, {
      "left" : "return \"|\";",
      "right" : "return \"|\";",
      "info" : "ReturnStatement[47704-47715]:ReturnStatement[47704-47715]"
    }, {
      "left" : "case RB:",
      "right" : "case RB:",
      "info" : "SwitchCase[47723-47731]:SwitchCase[47723-47731]"
    }, {
      "left" : "return \"]\";",
      "right" : "return \"]\";",
      "info" : "ReturnStatement[47740-47751]:ReturnStatement[47740-47751]"
    }, {
      "left" : "case RC:",
      "right" : "case RC:",
      "info" : "SwitchCase[47759-47767]:SwitchCase[47759-47767]"
    }, {
      "left" : "return \"}\";",
      "right" : "return \"}\";",
      "info" : "ReturnStatement[47776-47787]:ReturnStatement[47776-47787]"
    }, {
      "left" : "case RP:",
      "right" : "case RP:",
      "info" : "SwitchCase[47795-47803]:SwitchCase[47795-47803]"
    }, {
      "left" : "return \")\";",
      "right" : "return \")\";",
      "info" : "ReturnStatement[47812-47823]:ReturnStatement[47812-47823]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[47831-47841]:SwitchCase[47831-47841]"
    }, {
      "left" : "return \"*\";",
      "right" : "return \"*\";",
      "info" : "ReturnStatement[47850-47861]:ReturnStatement[47850-47861]"
    }, {
      "left" : "case ELLIPSIS:",
      "right" : "case ELLIPSIS:",
      "info" : "SwitchCase[47869-47883]:SwitchCase[47869-47883]"
    }, {
      "left" : "return \"...\";",
      "right" : "return \"...\";",
      "info" : "ReturnStatement[47892-47905]:ReturnStatement[47892-47905]"
    }, {
      "left" : "case EQUALS:",
      "right" : "case EQUALS:",
      "info" : "SwitchCase[47913-47925]:SwitchCase[47913-47925]"
    }, {
      "left" : "return \"=\";",
      "right" : "return \"=\";",
      "info" : "ReturnStatement[47934-47945]:ReturnStatement[47934-47945]"
    }, {
      "left" : "case STRING:",
      "right" : "case STRING:",
      "info" : "SwitchCase[47953-47965]:SwitchCase[47953-47965]"
    }, {
      "left" : "return stream.getString();",
      "right" : "return stream.getString();",
      "info" : "ReturnStatement[47974-48000]:ReturnStatement[47974-48000]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[48008-48016]:SwitchCase[48008-48016]"
    }, {
      "left" : "throw new IllegalStateException(token.toString());",
      "right" : "throw new IllegalStateException(token.toString());",
      "info" : "ThrowStatement[48025-48075]:ThrowStatement[48025-48075]"
    }, {
      "left" : "JSTypeExpression",
      "right" : "JSTypeExpression",
      "info" : "SimpleType[48184-48200]:SimpleType[48184-48200]"
    }, {
      "left" : "createJSTypeExpression",
      "right" : "createJSTypeExpression",
      "info" : "SimpleName[48201-48223]:SimpleName[48201-48223]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[48224-48230]:SingleVariableDeclaration[48224-48230]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48232-48317]:Block[48232-48317]"
    }, {
      "left" : "return n == null ? null :\n        new JSTypeExpression(n, getSourceName());",
      "right" : "return n == null ? null :\n        new JSTypeExpression(n, getSourceName());",
      "info" : "ReturnStatement[48238-48313]:ReturnStatement[48238-48313]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[48466-48473]:Modifier[48466-48473]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[48474-48480]:Modifier[48474-48480]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[48481-48486]:TYPE_DECLARATION_KIND[48481-48486]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleName[48487-48501]:SimpleName[48487-48501]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[48578-48584]:Modifier[48578-48584]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleName[48585-48599]:SimpleName[48585-48599]"
    }, {
      "left" : "String string",
      "right" : "String string",
      "info" : "SingleVariableDeclaration[48600-48613]:SingleVariableDeclaration[48600-48613]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[48615-48631]:SingleVariableDeclaration[48615-48631]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48633-48694]:Block[48633-48694]"
    }, {
      "left" : "this.string = string;",
      "right" : "this.string = string;",
      "info" : "ExpressionStatement[48641-48662]:ExpressionStatement[48641-48662]"
    }, {
      "left" : "this.token = token;",
      "right" : "this.token = token;",
      "info" : "ExpressionStatement[48669-48688]:ExpressionStatement[48669-48688]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[48754-48761]:Modifier[48754-48761]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[48762-48768]:Modifier[48762-48768]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[48769-48774]:TYPE_DECLARATION_KIND[48769-48774]"
    }, {
      "left" : "ExtendedTypeInfo",
      "right" : "ExtendedTypeInfo",
      "info" : "SimpleName[48775-48791]:SimpleName[48775-48791]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[48876-48882]:Modifier[48876-48882]"
    }, {
      "left" : "ExtendedTypeInfo",
      "right" : "ExtendedTypeInfo",
      "info" : "SimpleName[48883-48899]:SimpleName[48883-48899]"
    }, {
      "left" : "JSTypeExpression type",
      "right" : "JSTypeExpression type",
      "info" : "SingleVariableDeclaration[48900-48921]:SingleVariableDeclaration[48900-48921]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[48923-48933]:SingleVariableDeclaration[48923-48933]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[48935-48945]:SingleVariableDeclaration[48935-48945]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48947-49034]:Block[48947-49034]"
    }, {
      "left" : "this.type = type;",
      "right" : "this.type = type;",
      "info" : "ExpressionStatement[48955-48972]:ExpressionStatement[48955-48972]"
    }, {
      "left" : "this.lineno = lineno;",
      "right" : "this.lineno = lineno;",
      "info" : "ExpressionStatement[48979-49000]:ExpressionStatement[48979-49000]"
    }, {
      "left" : "this.charno = charno;",
      "right" : "this.charno = charno;",
      "info" : "ExpressionStatement[49007-49028]:ExpressionStatement[49007-49028]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[49295-49302]:Modifier[49295-49302]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[49303-49317]:SimpleType[49303-49317]"
    }, {
      "left" : "extractSingleLineBlock",
      "right" : "extractSingleLineBlock",
      "info" : "SimpleName[49318-49340]:SimpleName[49318-49340]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49343-49770]:Block[49343-49770]"
    }, {
      "left" : "stream.update();",
      "right" : "stream.update();",
      "info" : "ExpressionStatement[49389-49405]:ExpressionStatement[49389-49405]"
    }, {
      "left" : "int lineno = stream.getLineno();",
      "right" : "int lineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[49410-49442]:VariableDeclarationStatement[49410-49442]"
    }, {
      "left" : "int charno = stream.getCharno() + 1;",
      "right" : "int charno = stream.getCharno() + 1;",
      "info" : "VariableDeclarationStatement[49447-49483]:VariableDeclarationStatement[49447-49483]"
    }, {
      "left" : "String line = getRemainingJSDocLine().trim();",
      "right" : "String line = getRemainingJSDocLine().trim();",
      "info" : "VariableDeclarationStatement[49489-49534]:VariableDeclarationStatement[49489-49534]"
    }, {
      "left" : "if (line.length() > 0)",
      "right" : "if (line.length() > 0)",
      "info" : "IfStatement[49579-49720]:IfStatement[49579-49720]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49602-49720]:Block[49602-49720]"
    }, {
      "left" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
      "right" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
      "info" : "ExpressionStatement[49610-49714]:ExpressionStatement[49610-49714]"
    }, {
      "left" : "return new ExtractionInfo(line, next());",
      "right" : "return new ExtractionInfo(line, next());",
      "info" : "ReturnStatement[49726-49766]:ReturnStatement[49726-49766]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[49774-49781]:Modifier[49774-49781]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[49782-49796]:SimpleType[49782-49796]"
    }, {
      "left" : "extractMultilineTextualBlock",
      "right" : "extractMultilineTextualBlock",
      "info" : "SimpleName[49797-49825]:SimpleName[49797-49825]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[49826-49842]:SingleVariableDeclaration[49826-49842]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49844-49927]:Block[49844-49927]"
    }, {
      "left" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
      "right" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
      "info" : "ReturnStatement[49850-49923]:ReturnStatement[49850-49923]"
    }, {
      "left" : "@SuppressWarnings(\"fallthrough\")",
      "right" : "@SuppressWarnings(\"fallthrough\")",
      "info" : "SingleMemberAnnotation[50836-50868]:SingleMemberAnnotation[50836-50868]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[50871-50878]:Modifier[50871-50878]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[50879-50893]:SimpleType[50879-50893]"
    }, {
      "left" : "extractMultilineTextualBlock",
      "right" : "extractMultilineTextualBlock",
      "info" : "SimpleName[50894-50922]:SimpleName[50894-50922]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[50923-50939]:SingleVariableDeclaration[50923-50939]"
    }, {
      "left" : "WhitespaceOption option",
      "right" : "WhitespaceOption option",
      "info" : "SingleVariableDeclaration[50995-51018]:SingleVariableDeclaration[50995-51018]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51020-54222]:Block[51020-54222]"
    }, {
      "left" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
      "right" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
      "info" : "IfStatement[51027-51169]:IfStatement[51027-51169]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51118-51169]:Block[51118-51169]"
    }, {
      "left" : "return new ExtractionInfo(\"\", token);",
      "right" : "return new ExtractionInfo(\"\", token);",
      "info" : "ReturnStatement[51126-51163]:ReturnStatement[51126-51163]"
    }, {
      "left" : "stream.update();",
      "right" : "stream.update();",
      "info" : "ExpressionStatement[51175-51191]:ExpressionStatement[51175-51191]"
    }, {
      "left" : "int startLineno = stream.getLineno();",
      "right" : "int startLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[51196-51233]:VariableDeclarationStatement[51196-51233]"
    }, {
      "left" : "int startCharno = stream.getCharno() + 1;",
      "right" : "int startCharno = stream.getCharno() + 1;",
      "info" : "VariableDeclarationStatement[51238-51279]:VariableDeclarationStatement[51238-51279]"
    }, {
      "left" : "String line = getRemainingJSDocLine();",
      "right" : "String line = getRemainingJSDocLine();",
      "info" : "VariableDeclarationStatement[51330-51368]:VariableDeclarationStatement[51330-51368]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[51373-51447]:IfStatement[51373-51447]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51414-51447]:Block[51414-51447]"
    }, {
      "left" : "line = line.trim();",
      "right" : "line = line.trim();",
      "info" : "ExpressionStatement[51422-51441]:ExpressionStatement[51422-51441]"
    }, {
      "left" : "StringBuilder builder = new StringBuilder();",
      "right" : "StringBuilder builder = new StringBuilder();",
      "info" : "VariableDeclarationStatement[51453-51497]:VariableDeclarationStatement[51453-51497]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[51502-51523]:ExpressionStatement[51502-51523]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[51529-51564]:ExpressionStatement[51529-51564]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[51569-51584]:ExpressionStatement[51569-51584]"
    }, {
      "left" : "boolean ignoreStar = false;",
      "right" : "boolean ignoreStar = false;",
      "info" : "VariableDeclarationStatement[51590-51617]:VariableDeclarationStatement[51590-51617]"
    }, {
      "left" : "int lineStartChar = -1;",
      "right" : "int lineStartChar = -1;",
      "info" : "VariableDeclarationStatement[51798-51821]:VariableDeclarationStatement[51798-51821]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[51827-54218]:DoStatement[51827-54218]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51830-54204]:Block[51830-54204]"
    }, {
      "left" : "switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Mark the position after the star as the new start of the line.\n            lineStartChar = stream.getCharno() + 1;\n          } else {\n            // The star is part of the comment.\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          lineStartChar = 0;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          boolean isEOC = token == JsDocToken.EOC;\n          if (!isEOC) {\n            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n              int numSpaces = stream.getCharno() - lineStartChar;\n              for (int i = 0; i < numSpaces; i++) {\n                builder.append(' ');\n              }\n              lineStartChar = -1;\n            } else if (builder.length() > 0) {\n              // All tokens must be separated by a space.\n              builder.append(' ');\n            }\n          }\n\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are OK.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          builder.append(toString(token));\n\n          line = getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
      "right" : "switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Mark the position after the star as the new start of the line.\n            lineStartChar = stream.getCharno() + 1;\n          } else {\n            // The star is part of the comment.\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          lineStartChar = 0;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          boolean isEOC = token == JsDocToken.EOC;\n          if (!isEOC) {\n            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n              int numSpaces = stream.getCharno() - lineStartChar;\n              for (int i = 0; i < numSpaces; i++) {\n                builder.append(' ');\n              }\n              lineStartChar = -1;\n            } else if (builder.length() > 0) {\n              // All tokens must be separated by a space.\n              builder.append(' ');\n            }\n          }\n\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are OK.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          builder.append(toString(token));\n\n          line = getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
      "info" : "SwitchStatement[51838-54198]:SwitchStatement[51838-54198]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[51863-51873]:SwitchCase[51863-51873]"
    }, {
      "left" : "if (ignoreStar)",
      "right" : "if (ignoreStar)",
      "info" : "IfStatement[51884-52233]:IfStatement[51884-52233]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51900-52043]:Block[51900-52043]"
    }, {
      "left" : "lineStartChar = stream.getCharno() + 1;",
      "right" : "lineStartChar = stream.getCharno() + 1;",
      "info" : "ExpressionStatement[51992-52031]:ExpressionStatement[51992-52031]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52049-52233]:Block[52049-52233]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[52111-52187]:IfStatement[52111-52187]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52137-52187]:Block[52137-52187]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[52153-52173]:ExpressionStatement[52153-52173]"
    }, {
      "left" : "builder.append('*');",
      "right" : "builder.append('*');",
      "info" : "ExpressionStatement[52201-52221]:ExpressionStatement[52201-52221]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[52245-52260]:ExpressionStatement[52245-52260]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[52271-52280]:ContinueStatement[52271-52280]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[52290-52299]:SwitchCase[52290-52299]"
    }, {
      "left" : "if (option != WhitespaceOption.SINGLE_LINE)",
      "right" : "if (option != WhitespaceOption.SINGLE_LINE)",
      "info" : "IfStatement[52310-52401]:IfStatement[52310-52401]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52354-52401]:Block[52354-52401]"
    }, {
      "left" : "builder.append(\"\\n\");",
      "right" : "builder.append(\"\\n\");",
      "info" : "ExpressionStatement[52368-52389]:ExpressionStatement[52368-52389]"
    }, {
      "left" : "ignoreStar = true;",
      "right" : "ignoreStar = true;",
      "info" : "ExpressionStatement[52413-52431]:ExpressionStatement[52413-52431]"
    }, {
      "left" : "lineStartChar = 0;",
      "right" : "lineStartChar = 0;",
      "info" : "ExpressionStatement[52442-52460]:ExpressionStatement[52442-52460]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[52471-52486]:ExpressionStatement[52471-52486]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[52497-52506]:ContinueStatement[52497-52506]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[52516-52524]:SwitchCase[52516-52524]"
    }, {
      "left" : "ignoreStar = false;",
      "right" : "ignoreStar = false;",
      "info" : "ExpressionStatement[52535-52554]:ExpressionStatement[52535-52554]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[52565-52600]:ExpressionStatement[52565-52600]"
    }, {
      "left" : "boolean isEOC = token == JsDocToken.EOC;",
      "right" : "boolean isEOC = token == JsDocToken.EOC;",
      "info" : "VariableDeclarationStatement[52612-52652]:VariableDeclarationStatement[52612-52652]"
    }, {
      "left" : "if (!isEOC)",
      "right" : "if (!isEOC)",
      "info" : "IfStatement[52663-53125]:IfStatement[52663-53125]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52675-53125]:Block[52675-53125]"
    }, {
      "left" : "if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE)",
      "right" : "if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[52689-53113]:IfStatement[52689-53113]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52753-52973]:Block[52753-52973]"
    }, {
      "left" : "int numSpaces = stream.getCharno() - lineStartChar;",
      "right" : "int numSpaces = stream.getCharno() - lineStartChar;",
      "info" : "VariableDeclarationStatement[52769-52820]:VariableDeclarationStatement[52769-52820]"
    }, {
      "left" : "for (int i = 0; i < numSpaces; i++)",
      "right" : "for (int i = 0; i < numSpaces; i++)",
      "info" : "ForStatement[52835-52925]:ForStatement[52835-52925]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52871-52925]:Block[52871-52925]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[52889-52909]:ExpressionStatement[52889-52909]"
    }, {
      "left" : "lineStartChar = -1;",
      "right" : "lineStartChar = -1;",
      "info" : "ExpressionStatement[52940-52959]:ExpressionStatement[52940-52959]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[52979-53113]:IfStatement[52979-53113]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53005-53113]:Block[53005-53113]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[53079-53099]:ExpressionStatement[53079-53099]"
    }, {
      "left" : "if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are OK.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE))",
      "right" : "if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are OK.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE))",
      "info" : "IfStatement[53137-53944]:IfStatement[53137-53944]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53416-53944]:Block[53416-53944]"
    }, {
      "left" : "String multilineText = builder.toString();",
      "right" : "String multilineText = builder.toString();",
      "info" : "VariableDeclarationStatement[53430-53472]:VariableDeclarationStatement[53430-53472]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[53486-53594]:IfStatement[53486-53594]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53527-53594]:Block[53527-53594]"
    }, {
      "left" : "multilineText = multilineText.trim();",
      "right" : "multilineText = multilineText.trim();",
      "info" : "ExpressionStatement[53543-53580]:ExpressionStatement[53543-53580]"
    }, {
      "left" : "int endLineno = stream.getLineno();",
      "right" : "int endLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[53608-53643]:VariableDeclarationStatement[53608-53643]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[53656-53691]:VariableDeclarationStatement[53656-53691]"
    }, {
      "left" : "if (multilineText.length() > 0)",
      "right" : "if (multilineText.length() > 0)",
      "info" : "IfStatement[53705-53870]:IfStatement[53705-53870]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53737-53870]:Block[53737-53870]"
    }, {
      "left" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
      "right" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
      "info" : "ExpressionStatement[53753-53856]:ExpressionStatement[53753-53856]"
    }, {
      "left" : "return new ExtractionInfo(multilineText, token);",
      "right" : "return new ExtractionInfo(multilineText, token);",
      "info" : "ReturnStatement[53884-53932]:ReturnStatement[53884-53932]"
    }, {
      "left" : "builder.append(toString(token));",
      "right" : "builder.append(toString(token));",
      "info" : "ExpressionStatement[53956-53988]:ExpressionStatement[53956-53988]"
    }, {
      "left" : "line = getRemainingJSDocLine();",
      "right" : "line = getRemainingJSDocLine();",
      "info" : "ExpressionStatement[54000-54031]:ExpressionStatement[54000-54031]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[54043-54131]:IfStatement[54043-54131]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54084-54131]:Block[54084-54131]"
    }, {
      "left" : "line = trimEnd(line);",
      "right" : "line = trimEnd(line);",
      "info" : "ExpressionStatement[54098-54119]:ExpressionStatement[54098-54119]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[54143-54164]:ExpressionStatement[54143-54164]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[54175-54190]:ExpressionStatement[54175-54190]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[54689-54696]:Modifier[54689-54696]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[54697-54711]:SimpleType[54697-54711]"
    }, {
      "left" : "extractBlockComment",
      "right" : "extractBlockComment",
      "info" : "SimpleName[54712-54731]:SimpleName[54712-54731]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[54732-54748]:SingleVariableDeclaration[54732-54748]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54750-55717]:Block[54750-55717]"
    }, {
      "left" : "StringBuilder builder = new StringBuilder();",
      "right" : "StringBuilder builder = new StringBuilder();",
      "info" : "VariableDeclarationStatement[54756-54800]:VariableDeclarationStatement[54756-54800]"
    }, {
      "left" : "boolean ignoreStar = true;",
      "right" : "boolean ignoreStar = true;",
      "info" : "VariableDeclarationStatement[54806-54832]:VariableDeclarationStatement[54806-54832]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[54838-55713]:DoStatement[54838-55713]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54841-55699]:Block[54841-55699]"
    }, {
      "left" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
      "right" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
      "info" : "SwitchStatement[54849-55693]:SwitchStatement[54849-55693]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[54874-54890]:SwitchCase[54874-54890]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[54899-54908]:SwitchCase[54899-54908]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[54917-54926]:SwitchCase[54917-54926]"
    }, {
      "left" : "return new ExtractionInfo(builder.toString().trim(), token);",
      "right" : "return new ExtractionInfo(builder.toString().trim(), token);",
      "info" : "ReturnStatement[54937-54997]:ReturnStatement[54937-54997]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[55007-55017]:SwitchCase[55007-55017]"
    }, {
      "left" : "if (!ignoreStar)",
      "right" : "if (!ignoreStar)",
      "info" : "IfStatement[55028-55181]:IfStatement[55028-55181]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55045-55181]:Block[55045-55181]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[55059-55135]:IfStatement[55059-55135]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55085-55135]:Block[55085-55135]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[55101-55121]:ExpressionStatement[55101-55121]"
    }, {
      "left" : "builder.append('*');",
      "right" : "builder.append('*');",
      "info" : "ExpressionStatement[55149-55169]:ExpressionStatement[55149-55169]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[55193-55208]:ExpressionStatement[55193-55208]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[55219-55228]:ContinueStatement[55219-55228]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[55238-55247]:SwitchCase[55238-55247]"
    }, {
      "left" : "ignoreStar = true;",
      "right" : "ignoreStar = true;",
      "info" : "ExpressionStatement[55258-55276]:ExpressionStatement[55258-55276]"
    }, {
      "left" : "builder.append('\\n');",
      "right" : "builder.append('\\n');",
      "info" : "ExpressionStatement[55287-55308]:ExpressionStatement[55287-55308]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[55319-55334]:ExpressionStatement[55319-55334]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[55345-55354]:ContinueStatement[55345-55354]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[55364-55372]:SwitchCase[55364-55372]"
    }, {
      "left" : "if (!ignoreStar && builder.length() > 0)",
      "right" : "if (!ignoreStar && builder.length() > 0)",
      "info" : "IfStatement[55383-55470]:IfStatement[55383-55470]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55424-55470]:Block[55424-55470]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[55438-55458]:ExpressionStatement[55438-55458]"
    }, {
      "left" : "ignoreStar = false;",
      "right" : "ignoreStar = false;",
      "info" : "ExpressionStatement[55482-55501]:ExpressionStatement[55482-55501]"
    }, {
      "left" : "builder.append(toString(token));",
      "right" : "builder.append(toString(token));",
      "info" : "ExpressionStatement[55513-55545]:ExpressionStatement[55513-55545]"
    }, {
      "left" : "String line = getRemainingJSDocLine();",
      "right" : "String line = getRemainingJSDocLine();",
      "info" : "VariableDeclarationStatement[55557-55595]:VariableDeclarationStatement[55557-55595]"
    }, {
      "left" : "line = trimEnd(line);",
      "right" : "line = trimEnd(line);",
      "info" : "ExpressionStatement[55606-55627]:ExpressionStatement[55606-55627]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[55638-55659]:ExpressionStatement[55638-55659]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[55670-55685]:ExpressionStatement[55670-55685]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[56119-56126]:Modifier[56119-56126]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[56127-56133]:Modifier[56127-56133]"
    }, {
      "left" : "String",
      "right" : "String",
      "info" : "SimpleType[56134-56140]:SimpleType[56134-56140]"
    }, {
      "left" : "trimEnd",
      "right" : "trimEnd",
      "info" : "SimpleName[56141-56148]:SimpleName[56141-56148]"
    }, {
      "left" : "String s",
      "right" : "String s",
      "info" : "SingleVariableDeclaration[56149-56157]:SingleVariableDeclaration[56149-56157]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56159-56483]:Block[56159-56483]"
    }, {
      "left" : "int trimCount = 0;",
      "right" : "int trimCount = 0;",
      "info" : "VariableDeclarationStatement[56165-56183]:VariableDeclarationStatement[56165-56183]"
    }, {
      "left" : "while (trimCount < s.length())",
      "right" : "while (trimCount < s.length())",
      "info" : "WhileStatement[56188-56379]:WhileStatement[56188-56379]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56219-56379]:Block[56219-56379]"
    }, {
      "left" : "char ch = s.charAt(s.length() - trimCount - 1);",
      "right" : "char ch = s.charAt(s.length() - trimCount - 1);",
      "info" : "VariableDeclarationStatement[56227-56274]:VariableDeclarationStatement[56227-56274]"
    }, {
      "left" : "if (Character.isWhitespace(ch))",
      "right" : "if (Character.isWhitespace(ch))",
      "info" : "IfStatement[56281-56373]:IfStatement[56281-56373]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56313-56343]:Block[56313-56343]"
    }, {
      "left" : "trimCount++;",
      "right" : "trimCount++;",
      "info" : "ExpressionStatement[56323-56335]:ExpressionStatement[56323-56335]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56349-56373]:Block[56349-56373]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[56359-56365]:BreakStatement[56359-56365]"
    }, {
      "left" : "if (trimCount == 0)",
      "right" : "if (trimCount == 0)",
      "info" : "IfStatement[56385-56428]:IfStatement[56385-56428]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56405-56428]:Block[56405-56428]"
    }, {
      "left" : "return s;",
      "right" : "return s;",
      "info" : "ReturnStatement[56413-56422]:ReturnStatement[56413-56422]"
    }, {
      "left" : "return s.substring(0, s.length() - trimCount);",
      "right" : "return s.substring(0, s.length() - trimCount);",
      "info" : "ReturnStatement[56433-56479]:ReturnStatement[56433-56479]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[57005-57012]:Modifier[57005-57012]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[57013-57017]:SimpleType[57013-57017]"
    }, {
      "left" : "parseTypeExpressionAnnotation",
      "right" : "parseTypeExpressionAnnotation",
      "info" : "SimpleName[57018-57047]:SimpleName[57018-57047]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[57048-57064]:SingleVariableDeclaration[57048-57064]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57066-57465]:Block[57066-57465]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[57072-57461]:IfStatement[57072-57461]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57100-57407]:Block[57100-57407]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57108-57119]:ExpressionStatement[57108-57119]"
    }, {
      "left" : "Node typeNode = parseTopLevelTypeExpression(next());",
      "right" : "Node typeNode = parseTopLevelTypeExpression(next());",
      "info" : "VariableDeclarationStatement[57126-57178]:VariableDeclarationStatement[57126-57178]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[57185-57377]:IfStatement[57185-57377]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57207-57377]:Block[57207-57377]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57217-57228]:ExpressionStatement[57217-57228]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[57237-57369]:IfStatement[57237-57369]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57264-57334]:Block[57264-57334]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[57276-57324]:ExpressionStatement[57276-57324]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57340-57369]:Block[57340-57369]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[57352-57359]:ExpressionStatement[57352-57359]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[57385-57401]:ReturnStatement[57385-57401]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57413-57461]:Block[57413-57461]"
    }, {
      "left" : "return parseTypeExpression(token);",
      "right" : "return parseTypeExpression(token);",
      "info" : "ReturnStatement[57421-57455]:ReturnStatement[57421-57455]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[57719-57726]:Modifier[57719-57726]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[57727-57731]:SimpleType[57727-57731]"
    }, {
      "left" : "parseParamTypeExpressionAnnotation",
      "right" : "parseParamTypeExpressionAnnotation",
      "info" : "SimpleName[57732-57766]:SimpleName[57732-57766]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[57767-57783]:SingleVariableDeclaration[57767-57783]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57785-58644]:Block[57785-58644]"
    }, {
      "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "info" : "ExpressionStatement[57791-57843]:ExpressionStatement[57791-57843]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57849-57860]:ExpressionStatement[57849-57860]"
    }, {
      "left" : "boolean restArg = false;",
      "right" : "boolean restArg = false;",
      "info" : "VariableDeclarationStatement[57866-57890]:VariableDeclarationStatement[57866-57890]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[57895-57910]:ExpressionStatement[57895-57910]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[57915-58159]:IfStatement[57915-58159]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57949-58159]:Block[57949-58159]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[57957-57972]:ExpressionStatement[57957-57972]"
    }, {
      "left" : "if (token == JsDocToken.RC)",
      "right" : "if (token == JsDocToken.RC)",
      "info" : "IfStatement[57979-58131]:IfStatement[57979-58131]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58007-58131]:Block[58007-58131]"
    }, {
      "left" : "return wrapNode(Token.ELLIPSIS, IR.empty());",
      "right" : "return wrapNode(Token.ELLIPSIS, IR.empty());",
      "info" : "ReturnStatement[58079-58123]:ReturnStatement[58079-58123]"
    }, {
      "left" : "restArg = true;",
      "right" : "restArg = true;",
      "info" : "ExpressionStatement[58138-58153]:ExpressionStatement[58138-58153]"
    }, {
      "left" : "Node typeNode = parseTopLevelTypeExpression(token);",
      "right" : "Node typeNode = parseTopLevelTypeExpression(token);",
      "info" : "VariableDeclarationStatement[58165-58216]:VariableDeclarationStatement[58165-58216]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[58221-58618]:IfStatement[58221-58618]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58243-58618]:Block[58243-58618]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58251-58262]:ExpressionStatement[58251-58262]"
    }, {
      "left" : "if (restArg)",
      "right" : "if (restArg)",
      "info" : "IfStatement[58269-58480]:IfStatement[58269-58480]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58282-58346]:Block[58282-58346]"
    }, {
      "left" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
      "right" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
      "info" : "ExpressionStatement[58292-58338]:ExpressionStatement[58292-58338]"
    }, {
      "left" : "if (match(JsDocToken.EQUALS))",
      "right" : "if (match(JsDocToken.EQUALS))",
      "info" : "IfStatement[58352-58480]:IfStatement[58352-58480]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58382-58480]:Block[58382-58480]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[58392-58399]:ExpressionStatement[58392-58399]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58408-58419]:ExpressionStatement[58408-58419]"
    }, {
      "left" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
      "right" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
      "info" : "ExpressionStatement[58428-58472]:ExpressionStatement[58428-58472]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[58488-58612]:IfStatement[58488-58612]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58515-58581]:Block[58515-58581]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[58525-58573]:ExpressionStatement[58525-58573]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58587-58612]:Block[58587-58612]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[58597-58604]:ExpressionStatement[58597-58604]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[58624-58640]:ReturnStatement[58624-58640]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[58715-58722]:Modifier[58715-58722]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[58723-58727]:SimpleType[58723-58727]"
    }, {
      "left" : "parseTypeNameAnnotation",
      "right" : "parseTypeNameAnnotation",
      "info" : "SimpleName[58728-58751]:SimpleName[58728-58751]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[58752-58768]:SingleVariableDeclaration[58752-58768]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58770-59149]:Block[58770-59149]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[58776-59145]:IfStatement[58776-59145]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58804-59097]:Block[58804-59097]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58812-58823]:ExpressionStatement[58812-58823]"
    }, {
      "left" : "Node typeNode = parseTypeName(next());",
      "right" : "Node typeNode = parseTypeName(next());",
      "info" : "VariableDeclarationStatement[58830-58868]:VariableDeclarationStatement[58830-58868]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[58875-59067]:IfStatement[58875-59067]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58897-59067]:Block[58897-59067]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58907-58918]:ExpressionStatement[58907-58918]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[58927-59059]:IfStatement[58927-59059]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58954-59024]:Block[58954-59024]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[58966-59014]:ExpressionStatement[58966-59014]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59030-59059]:Block[59030-59059]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[59042-59049]:ExpressionStatement[59042-59049]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[59075-59091]:ReturnStatement[59075-59091]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59103-59145]:Block[59103-59145]"
    }, {
      "left" : "return parseTypeName(token);",
      "right" : "return parseTypeName(token);",
      "info" : "ReturnStatement[59111-59139]:ReturnStatement[59111-59139]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[59309-59316]:Modifier[59309-59316]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[59317-59321]:SimpleType[59317-59321]"
    }, {
      "left" : "parseTopLevelTypeExpression",
      "right" : "parseTopLevelTypeExpression",
      "info" : "SimpleName[59322-59349]:SimpleName[59322-59349]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[59350-59366]:SingleVariableDeclaration[59350-59366]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59368-59811]:Block[59368-59811]"
    }, {
      "left" : "Node typeExpr = parseTypeExpression(token);",
      "right" : "Node typeExpr = parseTypeExpression(token);",
      "info" : "VariableDeclarationStatement[59374-59417]:VariableDeclarationStatement[59374-59417]"
    }, {
      "left" : "if (typeExpr != null)",
      "right" : "if (typeExpr != null)",
      "info" : "IfStatement[59422-59786]:IfStatement[59422-59786]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59444-59786]:Block[59444-59786]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[59490-59780]:IfStatement[59490-59780]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59518-59780]:Block[59518-59780]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[59528-59535]:ExpressionStatement[59528-59535]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[59544-59667]:IfStatement[59544-59667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59572-59667]:Block[59572-59667]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[59650-59657]:ExpressionStatement[59650-59657]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[59676-59687]:ExpressionStatement[59676-59687]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[59696-59711]:ExpressionStatement[59696-59711]"
    }, {
      "left" : "return parseUnionTypeWithAlternate(token, typeExpr);",
      "right" : "return parseUnionTypeWithAlternate(token, typeExpr);",
      "info" : "ReturnStatement[59720-59772]:ReturnStatement[59720-59772]"
    }, {
      "left" : "return typeExpr;",
      "right" : "return typeExpr;",
      "info" : "ReturnStatement[59791-59807]:ReturnStatement[59791-59807]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[59934-59941]:Modifier[59934-59941]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[59942-59946]:SimpleType[59942-59946]"
    }, {
      "left" : "parseTypeExpressionList",
      "right" : "parseTypeExpressionList",
      "info" : "SimpleName[59947-59970]:SimpleName[59947-59970]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[59971-59987]:SingleVariableDeclaration[59971-59987]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59989-60425]:Block[59989-60425]"
    }, {
      "left" : "Node typeExpr = parseTopLevelTypeExpression(token);",
      "right" : "Node typeExpr = parseTopLevelTypeExpression(token);",
      "info" : "VariableDeclarationStatement[59995-60046]:VariableDeclarationStatement[59995-60046]"
    }, {
      "left" : "if (typeExpr == null)",
      "right" : "if (typeExpr == null)",
      "info" : "IfStatement[60051-60099]:IfStatement[60051-60099]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60073-60099]:Block[60073-60099]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[60081-60093]:ReturnStatement[60081-60093]"
    }, {
      "left" : "Node typeList = IR.block();",
      "right" : "Node typeList = IR.block();",
      "info" : "VariableDeclarationStatement[60104-60131]:VariableDeclarationStatement[60104-60131]"
    }, {
      "left" : "typeList.addChildToBack(typeExpr);",
      "right" : "typeList.addChildToBack(typeExpr);",
      "info" : "ExpressionStatement[60136-60170]:ExpressionStatement[60136-60170]"
    }, {
      "left" : "while (match(JsDocToken.COMMA))",
      "right" : "while (match(JsDocToken.COMMA))",
      "info" : "WhileStatement[60175-60400]:WhileStatement[60175-60400]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60207-60400]:Block[60207-60400]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[60215-60222]:ExpressionStatement[60215-60222]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[60229-60240]:ExpressionStatement[60229-60240]"
    }, {
      "left" : "typeExpr = parseTopLevelTypeExpression(next());",
      "right" : "typeExpr = parseTopLevelTypeExpression(next());",
      "info" : "ExpressionStatement[60247-60294]:ExpressionStatement[60247-60294]"
    }, {
      "left" : "if (typeExpr == null)",
      "right" : "if (typeExpr == null)",
      "info" : "IfStatement[60301-60353]:IfStatement[60301-60353]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60323-60353]:Block[60323-60353]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[60333-60345]:ReturnStatement[60333-60345]"
    }, {
      "left" : "typeList.addChildToBack(typeExpr);",
      "right" : "typeList.addChildToBack(typeExpr);",
      "info" : "ExpressionStatement[60360-60394]:ExpressionStatement[60360-60394]"
    }, {
      "left" : "return typeList;",
      "right" : "return typeList;",
      "info" : "ReturnStatement[60405-60421]:ReturnStatement[60405-60421]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[60639-60646]:Modifier[60639-60646]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[60647-60651]:SimpleType[60647-60651]"
    }, {
      "left" : "parseTypeExpression",
      "right" : "parseTypeExpression",
      "info" : "SimpleName[60652-60671]:SimpleName[60652-60671]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[60672-60688]:SingleVariableDeclaration[60672-60688]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60690-62243]:Block[60690-62243]"
    }, {
      "left" : "if (token == JsDocToken.QMARK)",
      "right" : "if (token == JsDocToken.QMARK)",
      "info" : "IfStatement[60696-62239]:IfStatement[60696-62239]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60727-61743]:Block[60727-61743]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[61313-61328]:ExpressionStatement[61313-61328]"
    }, {
      "left" : "if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT)",
      "right" : "if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT)",
      "info" : "IfStatement[61335-61667]:IfStatement[61335-61667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61588-61667]:Block[61588-61667]"
    }, {
      "left" : "restoreLookAhead(token);",
      "right" : "restoreLookAhead(token);",
      "info" : "ExpressionStatement[61598-61622]:ExpressionStatement[61598-61622]"
    }, {
      "left" : "return newNode(Token.QMARK);",
      "right" : "return newNode(Token.QMARK);",
      "info" : "ReturnStatement[61631-61659]:ReturnStatement[61631-61659]"
    }, {
      "left" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(token));",
      "right" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(token));",
      "info" : "ReturnStatement[61675-61737]:ReturnStatement[61675-61737]"
    }, {
      "left" : "if (token == JsDocToken.BANG)",
      "right" : "if (token == JsDocToken.BANG)",
      "info" : "IfStatement[61749-62239]:IfStatement[61749-62239]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61779-61855]:Block[61779-61855]"
    }, {
      "left" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
      "right" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
      "info" : "ReturnStatement[61787-61849]:ReturnStatement[61787-61849]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61861-62239]:Block[61861-62239]"
    }, {
      "left" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
      "right" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
      "info" : "VariableDeclarationStatement[61869-61922]:VariableDeclarationStatement[61869-61922]"
    }, {
      "left" : "if (basicTypeExpr != null)",
      "right" : "if (basicTypeExpr != null)",
      "info" : "IfStatement[61929-62204]:IfStatement[61929-62204]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61956-62204]:Block[61956-62204]"
    }, {
      "left" : "if (match(JsDocToken.QMARK))",
      "right" : "if (match(JsDocToken.QMARK))",
      "info" : "IfStatement[61966-62196]:IfStatement[61966-62196]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61995-62079]:Block[61995-62079]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[62007-62014]:ExpressionStatement[62007-62014]"
    }, {
      "left" : "return wrapNode(Token.QMARK, basicTypeExpr);",
      "right" : "return wrapNode(Token.QMARK, basicTypeExpr);",
      "info" : "ReturnStatement[62025-62069]:ReturnStatement[62025-62069]"
    }, {
      "left" : "if (match(JsDocToken.BANG))",
      "right" : "if (match(JsDocToken.BANG))",
      "info" : "IfStatement[62085-62196]:IfStatement[62085-62196]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62113-62196]:Block[62113-62196]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[62125-62132]:ExpressionStatement[62125-62132]"
    }, {
      "left" : "return wrapNode(Token.BANG, basicTypeExpr);",
      "right" : "return wrapNode(Token.BANG, basicTypeExpr);",
      "info" : "ReturnStatement[62143-62186]:ReturnStatement[62143-62186]"
    }, {
      "left" : "return basicTypeExpr;",
      "right" : "return basicTypeExpr;",
      "info" : "ReturnStatement[62212-62233]:ReturnStatement[62212-62233]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[62386-62393]:Modifier[62386-62393]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[62394-62398]:SimpleType[62394-62398]"
    }, {
      "left" : "parseBasicTypeExpression",
      "right" : "parseBasicTypeExpression",
      "info" : "SimpleName[62399-62423]:SimpleName[62399-62423]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[62424-62440]:SingleVariableDeclaration[62424-62440]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62442-63245]:Block[62442-63245]"
    }, {
      "left" : "if (token == JsDocToken.STAR)",
      "right" : "if (token == JsDocToken.STAR)",
      "info" : "IfStatement[62448-63166]:IfStatement[62448-63166]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62478-62519]:Block[62478-62519]"
    }, {
      "left" : "return newNode(Token.STAR);",
      "right" : "return newNode(Token.STAR);",
      "info" : "ReturnStatement[62486-62513]:ReturnStatement[62486-62513]"
    }, {
      "left" : "if (token == JsDocToken.LB)",
      "right" : "if (token == JsDocToken.LB)",
      "info" : "IfStatement[62525-63166]:IfStatement[62525-63166]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62553-62615]:Block[62553-62615]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62561-62572]:ExpressionStatement[62561-62572]"
    }, {
      "left" : "return parseArrayType(next());",
      "right" : "return parseArrayType(next());",
      "info" : "ReturnStatement[62579-62609]:ReturnStatement[62579-62609]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[62621-63166]:IfStatement[62621-63166]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62649-62712]:Block[62649-62712]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62657-62668]:ExpressionStatement[62657-62668]"
    }, {
      "left" : "return parseRecordType(next());",
      "right" : "return parseRecordType(next());",
      "info" : "ReturnStatement[62675-62706]:ReturnStatement[62675-62706]"
    }, {
      "left" : "if (token == JsDocToken.LP)",
      "right" : "if (token == JsDocToken.LP)",
      "info" : "IfStatement[62718-63166]:IfStatement[62718-63166]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62746-62808]:Block[62746-62808]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62754-62765]:ExpressionStatement[62754-62765]"
    }, {
      "left" : "return parseUnionType(next());",
      "right" : "return parseUnionType(next());",
      "info" : "ReturnStatement[62772-62802]:ReturnStatement[62772-62802]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[62814-63166]:IfStatement[62814-63166]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62846-63166]:Block[62846-63166]"
    }, {
      "left" : "String string = stream.getString();",
      "right" : "String string = stream.getString();",
      "info" : "VariableDeclarationStatement[62854-62889]:VariableDeclarationStatement[62854-62889]"
    }, {
      "left" : "if (\"function\".equals(string))",
      "right" : "if (\"function\".equals(string))",
      "info" : "IfStatement[62896-63160]:IfStatement[62896-63160]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62927-62998]:Block[62927-62998]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62937-62948]:ExpressionStatement[62937-62948]"
    }, {
      "left" : "return parseFunctionType(next());",
      "right" : "return parseFunctionType(next());",
      "info" : "ReturnStatement[62957-62990]:ReturnStatement[62957-62990]"
    }, {
      "left" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
      "right" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
      "info" : "IfStatement[63004-63160]:IfStatement[63004-63160]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63061-63108]:Block[63061-63108]"
    }, {
      "left" : "return newStringNode(string);",
      "right" : "return newStringNode(string);",
      "info" : "ReturnStatement[63071-63100]:ReturnStatement[63071-63100]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63114-63160]:Block[63114-63160]"
    }, {
      "left" : "return parseTypeName(token);",
      "right" : "return parseTypeName(token);",
      "info" : "ReturnStatement[63124-63152]:ReturnStatement[63124-63152]"
    }, {
      "left" : "restoreLookAhead(token);",
      "right" : "restoreLookAhead(token);",
      "info" : "ExpressionStatement[63172-63196]:ExpressionStatement[63172-63196]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[63201-63241]:ReturnStatement[63201-63241]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[63378-63385]:Modifier[63378-63385]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[63386-63390]:SimpleType[63386-63390]"
    }, {
      "left" : "parseTypeName",
      "right" : "parseTypeName",
      "info" : "SimpleName[63391-63404]:SimpleName[63391-63404]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[63405-63421]:SingleVariableDeclaration[63405-63421]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63423-64315]:Block[63423-64315]"
    }, {
      "left" : "if (token != JsDocToken.STRING)",
      "right" : "if (token != JsDocToken.STRING)",
      "info" : "IfStatement[63429-63515]:IfStatement[63429-63515]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63461-63515]:Block[63461-63515]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[63469-63509]:ReturnStatement[63469-63509]"
    }, {
      "left" : "String typeName = stream.getString();",
      "right" : "String typeName = stream.getString();",
      "info" : "VariableDeclarationStatement[63521-63558]:VariableDeclarationStatement[63521-63558]"
    }, {
      "left" : "int lineno = stream.getLineno();",
      "right" : "int lineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[63563-63595]:VariableDeclarationStatement[63563-63595]"
    }, {
      "left" : "int charno = stream.getCharno();",
      "right" : "int charno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[63600-63632]:VariableDeclarationStatement[63600-63632]"
    }, {
      "left" : "while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.')",
      "right" : "while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.')",
      "info" : "WhileStatement[63637-63851]:WhileStatement[63637-63851]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63724-63851]:Block[63724-63851]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[63732-63743]:ExpressionStatement[63732-63743]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[63750-63845]:IfStatement[63750-63845]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63780-63845]:Block[63780-63845]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[63790-63797]:ExpressionStatement[63790-63797]"
    }, {
      "left" : "typeName += stream.getString();",
      "right" : "typeName += stream.getString();",
      "info" : "ExpressionStatement[63806-63837]:ExpressionStatement[63806-63837]"
    }, {
      "left" : "Node typeNameNode = newStringNode(typeName, lineno, charno);",
      "right" : "Node typeNameNode = newStringNode(typeName, lineno, charno);",
      "info" : "VariableDeclarationStatement[63857-63917]:VariableDeclarationStatement[63857-63917]"
    }, {
      "left" : "if (match(JsDocToken.LT))",
      "right" : "if (match(JsDocToken.LT))",
      "info" : "IfStatement[63923-64286]:IfStatement[63923-64286]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63949-64286]:Block[63949-64286]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[63957-63964]:ExpressionStatement[63957-63964]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[63971-63982]:ExpressionStatement[63971-63982]"
    }, {
      "left" : "Node memberType = parseTypeExpressionList(next());",
      "right" : "Node memberType = parseTypeExpressionList(next());",
      "info" : "VariableDeclarationStatement[63989-64039]:VariableDeclarationStatement[63989-64039]"
    }, {
      "left" : "if (memberType != null)",
      "right" : "if (memberType != null)",
      "info" : "IfStatement[64046-64280]:IfStatement[64046-64280]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64070-64280]:Block[64070-64280]"
    }, {
      "left" : "typeNameNode.addChildToFront(memberType);",
      "right" : "typeNameNode.addChildToFront(memberType);",
      "info" : "ExpressionStatement[64080-64121]:ExpressionStatement[64080-64121]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[64131-64142]:ExpressionStatement[64131-64142]"
    }, {
      "left" : "if (!match(JsDocToken.GT))",
      "right" : "if (!match(JsDocToken.GT))",
      "info" : "IfStatement[64151-64255]:IfStatement[64151-64255]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64178-64255]:Block[64178-64255]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
      "info" : "ReturnStatement[64190-64245]:ReturnStatement[64190-64245]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[64265-64272]:ExpressionStatement[64265-64272]"
    }, {
      "left" : "return typeNameNode;",
      "right" : "return typeNameNode;",
      "info" : "ReturnStatement[64291-64311]:ReturnStatement[64291-64311]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[64493-64500]:Modifier[64493-64500]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[64501-64505]:SimpleType[64501-64505]"
    }, {
      "left" : "parseFunctionType",
      "right" : "parseFunctionType",
      "info" : "SimpleName[64506-64523]:SimpleName[64506-64523]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[64524-64540]:SingleVariableDeclaration[64524-64540]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64542-66397]:Block[64542-66397]"
    }, {
      "left" : "if (token != JsDocToken.LP)",
      "right" : "if (token != JsDocToken.LP)",
      "info" : "IfStatement[64661-64789]:IfStatement[64661-64789]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64689-64789]:Block[64689-64789]"
    }, {
      "left" : "restoreLookAhead(token);",
      "right" : "restoreLookAhead(token);",
      "info" : "ExpressionStatement[64697-64721]:ExpressionStatement[64697-64721]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
      "info" : "ReturnStatement[64728-64783]:ReturnStatement[64728-64783]"
    }, {
      "left" : "Node functionType = newNode(Token.FUNCTION);",
      "right" : "Node functionType = newNode(Token.FUNCTION);",
      "info" : "VariableDeclarationStatement[64795-64839]:VariableDeclarationStatement[64795-64839]"
    }, {
      "left" : "Node parameters = null;",
      "right" : "Node parameters = null;",
      "info" : "VariableDeclarationStatement[64844-64867]:VariableDeclarationStatement[64844-64867]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[64872-64883]:ExpressionStatement[64872-64883]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[64888-65987]:IfStatement[64888-65987]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64915-65987]:Block[64915-65987]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[64923-64938]:ExpressionStatement[64923-64938]"
    }, {
      "left" : "boolean hasParams = true;",
      "right" : "boolean hasParams = true;",
      "info" : "VariableDeclarationStatement[64946-64971]:VariableDeclarationStatement[64946-64971]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[64978-65833]:IfStatement[64978-65833]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65010-65833]:Block[65010-65833]"
    }, {
      "left" : "String tokenStr = stream.getString();",
      "right" : "String tokenStr = stream.getString();",
      "info" : "VariableDeclarationStatement[65020-65057]:VariableDeclarationStatement[65020-65057]"
    }, {
      "left" : "boolean isThis = \"this\".equals(tokenStr);",
      "right" : "boolean isThis = \"this\".equals(tokenStr);",
      "info" : "VariableDeclarationStatement[65066-65107]:VariableDeclarationStatement[65066-65107]"
    }, {
      "left" : "boolean isNew = \"new\".equals(tokenStr);",
      "right" : "boolean isNew = \"new\".equals(tokenStr);",
      "info" : "VariableDeclarationStatement[65116-65155]:VariableDeclarationStatement[65116-65155]"
    }, {
      "left" : "if (isThis || isNew)",
      "right" : "if (isThis || isNew)",
      "info" : "IfStatement[65164-65825]:IfStatement[65164-65825]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65185-65825]:Block[65185-65825]"
    }, {
      "left" : "if (match(JsDocToken.COLON))",
      "right" : "if (match(JsDocToken.COLON))",
      "info" : "IfStatement[65197-65639]:IfStatement[65197-65639]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65226-65549]:Block[65226-65549]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[65240-65247]:ExpressionStatement[65240-65247]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[65260-65271]:ExpressionStatement[65260-65271]"
    }, {
      "left" : "Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));",
      "right" : "Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));",
      "info" : "VariableDeclarationStatement[65284-65401]:VariableDeclarationStatement[65284-65401]"
    }, {
      "left" : "if (contextType == null)",
      "right" : "if (contextType == null)",
      "info" : "IfStatement[65414-65481]:IfStatement[65414-65481]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65439-65481]:Block[65439-65481]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[65455-65467]:ReturnStatement[65455-65467]"
    }, {
      "left" : "functionType.addChildToFront(contextType);",
      "right" : "functionType.addChildToFront(contextType);",
      "info" : "ExpressionStatement[65495-65537]:ExpressionStatement[65495-65537]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65555-65639]:Block[65555-65639]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
      "info" : "ReturnStatement[65569-65627]:ReturnStatement[65569-65627]"
    }, {
      "left" : "if (match(JsDocToken.COMMA))",
      "right" : "if (match(JsDocToken.COMMA))",
      "info" : "IfStatement[65651-65815]:IfStatement[65651-65815]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65680-65765]:Block[65680-65765]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[65694-65701]:ExpressionStatement[65694-65701]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[65714-65725]:ExpressionStatement[65714-65725]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[65738-65753]:ExpressionStatement[65738-65753]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65771-65815]:Block[65771-65815]"
    }, {
      "left" : "hasParams = false;",
      "right" : "hasParams = false;",
      "info" : "ExpressionStatement[65785-65803]:ExpressionStatement[65785-65803]"
    }, {
      "left" : "if (hasParams)",
      "right" : "if (hasParams)",
      "info" : "IfStatement[65841-65981]:IfStatement[65841-65981]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65856-65981]:Block[65856-65981]"
    }, {
      "left" : "parameters = parseParametersType(token);",
      "right" : "parameters = parseParametersType(token);",
      "info" : "ExpressionStatement[65866-65906]:ExpressionStatement[65866-65906]"
    }, {
      "left" : "if (parameters == null)",
      "right" : "if (parameters == null)",
      "info" : "IfStatement[65915-65973]:IfStatement[65915-65973]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65939-65973]:Block[65939-65973]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[65951-65963]:ReturnStatement[65951-65963]"
    }, {
      "left" : "if (parameters != null)",
      "right" : "if (parameters != null)",
      "info" : "IfStatement[65993-66071]:IfStatement[65993-66071]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66017-66071]:Block[66017-66071]"
    }, {
      "left" : "functionType.addChildToBack(parameters);",
      "right" : "functionType.addChildToBack(parameters);",
      "info" : "ExpressionStatement[66025-66065]:ExpressionStatement[66025-66065]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[66077-66088]:ExpressionStatement[66077-66088]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[66093-66189]:IfStatement[66093-66189]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66120-66189]:Block[66120-66189]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "info" : "ReturnStatement[66128-66183]:ReturnStatement[66128-66183]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[66195-66206]:ExpressionStatement[66195-66206]"
    }, {
      "left" : "Node resultType = parseResultType(next());",
      "right" : "Node resultType = parseResultType(next());",
      "info" : "VariableDeclarationStatement[66211-66253]:VariableDeclarationStatement[66211-66253]"
    }, {
      "left" : "if (resultType == null)",
      "right" : "if (resultType == null)",
      "info" : "IfStatement[66258-66368]:IfStatement[66258-66368]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66282-66308]:Block[66282-66308]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[66290-66302]:ReturnStatement[66290-66302]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66314-66368]:Block[66314-66368]"
    }, {
      "left" : "functionType.addChildToBack(resultType);",
      "right" : "functionType.addChildToBack(resultType);",
      "info" : "ExpressionStatement[66322-66362]:ExpressionStatement[66322-66362]"
    }, {
      "left" : "return functionType;",
      "right" : "return functionType;",
      "info" : "ReturnStatement[66373-66393]:ReturnStatement[66373-66393]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[67592-67599]:Modifier[67592-67599]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[67600-67604]:SimpleType[67600-67604]"
    }, {
      "left" : "parseParametersType",
      "right" : "parseParametersType",
      "info" : "SimpleName[67605-67624]:SimpleName[67605-67624]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[67625-67641]:SingleVariableDeclaration[67625-67641]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67643-69496]:Block[67643-69496]"
    }, {
      "left" : "Node paramsType = newNode(Token.PARAM_LIST);",
      "right" : "Node paramsType = newNode(Token.PARAM_LIST);",
      "info" : "VariableDeclarationStatement[67649-67693]:VariableDeclarationStatement[67649-67693]"
    }, {
      "left" : "boolean isVarArgs = false;",
      "right" : "boolean isVarArgs = false;",
      "info" : "VariableDeclarationStatement[67698-67724]:VariableDeclarationStatement[67698-67724]"
    }, {
      "left" : "Node paramType = null;",
      "right" : "Node paramType = null;",
      "info" : "VariableDeclarationStatement[67729-67751]:VariableDeclarationStatement[67729-67751]"
    }, {
      "left" : "if (token != JsDocToken.RP)",
      "right" : "if (token != JsDocToken.RP)",
      "info" : "IfStatement[67756-69284]:IfStatement[67756-69284]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67784-69284]:Block[67784-69284]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[67792-69278]:DoStatement[67792-69278]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67795-69245]:Block[67795-69245]"
    }, {
      "left" : "if (paramType != null)",
      "right" : "if (paramType != null)",
      "info" : "IfStatement[67805-67938]:IfStatement[67805-67938]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67828-67938]:Block[67828-67938]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[67873-67880]:ExpressionStatement[67873-67880]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[67891-67902]:ExpressionStatement[67891-67902]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[67913-67928]:ExpressionStatement[67913-67928]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[67948-69072]:IfStatement[67948-69072]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67982-68848]:Block[67982-68848]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68214-68225]:ExpressionStatement[68214-68225]"
    }, {
      "left" : "if (match(JsDocToken.RP))",
      "right" : "if (match(JsDocToken.RP))",
      "info" : "IfStatement[68236-68809]:IfStatement[68236-68809]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68262-68324]:Block[68262-68324]"
    }, {
      "left" : "paramType = newNode(Token.ELLIPSIS);",
      "right" : "paramType = newNode(Token.ELLIPSIS);",
      "info" : "ExpressionStatement[68276-68312]:ExpressionStatement[68276-68312]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68330-68809]:Block[68330-68809]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68344-68355]:ExpressionStatement[68344-68355]"
    }, {
      "left" : "if (!match(JsDocToken.LB))",
      "right" : "if (!match(JsDocToken.LB))",
      "info" : "IfStatement[68368-68480]:IfStatement[68368-68480]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68395-68480]:Block[68395-68480]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
      "info" : "ReturnStatement[68411-68466]:ReturnStatement[68411-68466]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[68494-68501]:ExpressionStatement[68494-68501]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68514-68525]:ExpressionStatement[68514-68525]"
    }, {
      "left" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "right" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "info" : "ExpressionStatement[68538-68604]:ExpressionStatement[68538-68604]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68617-68628]:ExpressionStatement[68617-68628]"
    }, {
      "left" : "if (!match(JsDocToken.RB))",
      "right" : "if (!match(JsDocToken.RB))",
      "info" : "IfStatement[68641-68753]:IfStatement[68641-68753]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68668-68753]:Block[68668-68753]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ReturnStatement[68684-68739]:ReturnStatement[68684-68739]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68766-68777]:ExpressionStatement[68766-68777]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[68790-68797]:ExpressionStatement[68790-68797]"
    }, {
      "left" : "isVarArgs = true;",
      "right" : "isVarArgs = true;",
      "info" : "ExpressionStatement[68821-68838]:ExpressionStatement[68821-68838]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68854-69072]:Block[68854-69072]"
    }, {
      "left" : "paramType = parseTypeExpression(token);",
      "right" : "paramType = parseTypeExpression(token);",
      "info" : "ExpressionStatement[68866-68905]:ExpressionStatement[68866-68905]"
    }, {
      "left" : "if (match(JsDocToken.EQUALS))",
      "right" : "if (match(JsDocToken.EQUALS))",
      "info" : "IfStatement[68916-69062]:IfStatement[68916-69062]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68946-69062]:Block[68946-69062]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68960-68971]:ExpressionStatement[68960-68971]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[68984-68991]:ExpressionStatement[68984-68991]"
    }, {
      "left" : "paramType = wrapNode(Token.EQUALS, paramType);",
      "right" : "paramType = wrapNode(Token.EQUALS, paramType);",
      "info" : "ExpressionStatement[69004-69050]:ExpressionStatement[69004-69050]"
    }, {
      "left" : "if (paramType == null)",
      "right" : "if (paramType == null)",
      "info" : "IfStatement[69082-69139]:IfStatement[69082-69139]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69105-69139]:Block[69105-69139]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[69117-69129]:ReturnStatement[69117-69129]"
    }, {
      "left" : "paramsType.addChildToBack(paramType);",
      "right" : "paramsType.addChildToBack(paramType);",
      "info" : "ExpressionStatement[69148-69185]:ExpressionStatement[69148-69185]"
    }, {
      "left" : "if (isVarArgs)",
      "right" : "if (isVarArgs)",
      "info" : "IfStatement[69194-69237]:IfStatement[69194-69237]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69209-69237]:Block[69209-69237]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[69221-69227]:BreakStatement[69221-69227]"
    }, {
      "left" : "if (isVarArgs && match(JsDocToken.COMMA))",
      "right" : "if (isVarArgs && match(JsDocToken.COMMA))",
      "info" : "IfStatement[69290-69407]:IfStatement[69290-69407]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69332-69407]:Block[69332-69407]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
      "info" : "ReturnStatement[69340-69401]:ReturnStatement[69340-69401]"
    }, {
      "left" : "return paramsType;",
      "right" : "return paramsType;",
      "info" : "ReturnStatement[69474-69492]:ReturnStatement[69474-69492]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[69571-69578]:Modifier[69571-69578]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[69579-69583]:SimpleType[69579-69583]"
    }, {
      "left" : "parseResultType",
      "right" : "parseResultType",
      "info" : "SimpleName[69584-69599]:SimpleName[69584-69599]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[69600-69616]:SingleVariableDeclaration[69600-69616]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69618-69935]:Block[69618-69935]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[69624-69635]:ExpressionStatement[69624-69635]"
    }, {
      "left" : "if (!match(JsDocToken.COLON))",
      "right" : "if (!match(JsDocToken.COLON))",
      "info" : "IfStatement[69640-69712]:IfStatement[69640-69712]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69670-69712]:Block[69670-69712]"
    }, {
      "left" : "return newNode(Token.EMPTY);",
      "right" : "return newNode(Token.EMPTY);",
      "info" : "ReturnStatement[69678-69706]:ReturnStatement[69678-69706]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[69718-69733]:ExpressionStatement[69718-69733]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[69738-69749]:ExpressionStatement[69738-69749]"
    }, {
      "left" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
      "right" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
      "info" : "IfStatement[69754-69931]:IfStatement[69754-69931]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69821-69876]:Block[69821-69876]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[69829-69836]:ExpressionStatement[69829-69836]"
    }, {
      "left" : "return newNode(Token.VOID);",
      "right" : "return newNode(Token.VOID);",
      "info" : "ReturnStatement[69843-69870]:ReturnStatement[69843-69870]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69882-69931]:Block[69882-69931]"
    }, {
      "left" : "return parseTypeExpression(next());",
      "right" : "return parseTypeExpression(next());",
      "info" : "ReturnStatement[69890-69925]:ReturnStatement[69890-69925]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[70109-70116]:Modifier[70109-70116]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[70117-70121]:SimpleType[70117-70121]"
    }, {
      "left" : "parseUnionType",
      "right" : "parseUnionType",
      "info" : "SimpleName[70122-70136]:SimpleName[70122-70136]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[70137-70153]:SingleVariableDeclaration[70137-70153]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70155-70213]:Block[70155-70213]"
    }, {
      "left" : "return parseUnionTypeWithAlternate(token, null);",
      "right" : "return parseUnionTypeWithAlternate(token, null);",
      "info" : "ReturnStatement[70161-70209]:ReturnStatement[70161-70209]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[70339-70346]:Modifier[70339-70346]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[70347-70351]:SimpleType[70347-70351]"
    }, {
      "left" : "parseUnionTypeWithAlternate",
      "right" : "parseUnionTypeWithAlternate",
      "info" : "SimpleName[70352-70379]:SimpleName[70352-70379]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[70380-70396]:SingleVariableDeclaration[70380-70396]"
    }, {
      "left" : "Node alternate",
      "right" : "Node alternate",
      "info" : "SingleVariableDeclaration[70398-70412]:SingleVariableDeclaration[70398-70412]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70414-71417]:Block[70414-71417]"
    }, {
      "left" : "Node union = newNode(Token.PIPE);",
      "right" : "Node union = newNode(Token.PIPE);",
      "info" : "VariableDeclarationStatement[70420-70453]:VariableDeclarationStatement[70420-70453]"
    }, {
      "left" : "if (alternate != null)",
      "right" : "if (alternate != null)",
      "info" : "IfStatement[70458-70527]:IfStatement[70458-70527]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70481-70527]:Block[70481-70527]"
    }, {
      "left" : "union.addChildToBack(alternate);",
      "right" : "union.addChildToBack(alternate);",
      "info" : "ExpressionStatement[70489-70521]:ExpressionStatement[70489-70521]"
    }, {
      "left" : "Node expr = null;",
      "right" : "Node expr = null;",
      "info" : "VariableDeclarationStatement[70533-70550]:VariableDeclarationStatement[70533-70550]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[70555-71220]:DoStatement[70555-71220]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70558-71170]:Block[70558-71170]"
    }, {
      "left" : "if (expr != null)",
      "right" : "if (expr != null)",
      "info" : "IfStatement[70566-70977]:IfStatement[70566-70977]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70584-70977]:Block[70584-70977]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[70594-70605]:ExpressionStatement[70594-70605]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[70614-70629]:ExpressionStatement[70614-70629]"
    }, {
      "left" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
      "right" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
      "info" : "ExpressionStatement[70638-70731]:ExpressionStatement[70638-70731]"
    }, {
      "left" : "boolean isPipe = token == JsDocToken.PIPE;",
      "right" : "boolean isPipe = token == JsDocToken.PIPE;",
      "info" : "VariableDeclarationStatement[70741-70783]:VariableDeclarationStatement[70741-70783]"
    }, {
      "left" : "if (isPipe && match(JsDocToken.PIPE))",
      "right" : "if (isPipe && match(JsDocToken.PIPE))",
      "info" : "IfStatement[70792-70925]:IfStatement[70792-70925]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70830-70925]:Block[70830-70925]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[70908-70915]:ExpressionStatement[70908-70915]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[70934-70945]:ExpressionStatement[70934-70945]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[70954-70969]:ExpressionStatement[70954-70969]"
    }, {
      "left" : "expr = parseTypeExpression(token);",
      "right" : "expr = parseTypeExpression(token);",
      "info" : "ExpressionStatement[70984-71018]:ExpressionStatement[70984-71018]"
    }, {
      "left" : "if (expr == null)",
      "right" : "if (expr == null)",
      "info" : "IfStatement[71025-71073]:IfStatement[71025-71073]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71043-71073]:Block[71043-71073]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[71053-71065]:ReturnStatement[71053-71065]"
    }, {
      "left" : "union.addChildToBack(expr);",
      "right" : "union.addChildToBack(expr);",
      "info" : "ExpressionStatement[71081-71108]:ExpressionStatement[71081-71108]"
    }, {
      "left" : "if (alternate == null)",
      "right" : "if (alternate == null)",
      "info" : "IfStatement[71226-71395]:IfStatement[71226-71395]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71249-71395]:Block[71249-71395]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[71257-71268]:ExpressionStatement[71257-71268]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[71275-71375]:IfStatement[71275-71375]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71302-71375]:Block[71302-71375]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "info" : "ReturnStatement[71312-71367]:ReturnStatement[71312-71367]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[71382-71389]:ExpressionStatement[71382-71389]"
    }, {
      "left" : "return union;",
      "right" : "return union;",
      "info" : "ReturnStatement[71400-71413]:ReturnStatement[71400-71413]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[71593-71600]:Modifier[71593-71600]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[71601-71605]:SimpleType[71601-71605]"
    }, {
      "left" : "parseArrayType",
      "right" : "parseArrayType",
      "info" : "SimpleName[71606-71620]:SimpleName[71606-71620]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[71621-71637]:SingleVariableDeclaration[71621-71637]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71639-72364]:Block[71639-72364]"
    }, {
      "left" : "Node array = newNode(Token.LB);",
      "right" : "Node array = newNode(Token.LB);",
      "info" : "VariableDeclarationStatement[71645-71676]:VariableDeclarationStatement[71645-71676]"
    }, {
      "left" : "Node arg = null;",
      "right" : "Node arg = null;",
      "info" : "VariableDeclarationStatement[71681-71697]:VariableDeclarationStatement[71681-71697]"
    }, {
      "left" : "boolean hasVarArgs = false;",
      "right" : "boolean hasVarArgs = false;",
      "info" : "VariableDeclarationStatement[71702-71729]:VariableDeclarationStatement[71702-71729]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[71735-72228]:DoStatement[71735-72228]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71738-72195]:Block[71738-72195]"
    }, {
      "left" : "if (arg != null)",
      "right" : "if (arg != null)",
      "info" : "IfStatement[71746-71832]:IfStatement[71746-71832]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71763-71832]:Block[71763-71832]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[71773-71780]:ExpressionStatement[71773-71780]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[71789-71800]:ExpressionStatement[71789-71800]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[71809-71824]:ExpressionStatement[71809-71824]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[71839-72035]:IfStatement[71839-72035]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71873-71978]:Block[71873-71978]"
    }, {
      "left" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "right" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "info" : "ExpressionStatement[71883-71943]:ExpressionStatement[71883-71943]"
    }, {
      "left" : "hasVarArgs = true;",
      "right" : "hasVarArgs = true;",
      "info" : "ExpressionStatement[71952-71970]:ExpressionStatement[71952-71970]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71984-72035]:Block[71984-72035]"
    }, {
      "left" : "arg = parseTypeExpression(token);",
      "right" : "arg = parseTypeExpression(token);",
      "info" : "ExpressionStatement[71994-72027]:ExpressionStatement[71994-72027]"
    }, {
      "left" : "if (arg == null)",
      "right" : "if (arg == null)",
      "info" : "IfStatement[72043-72090]:IfStatement[72043-72090]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72060-72090]:Block[72060-72090]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[72070-72082]:ReturnStatement[72070-72082]"
    }, {
      "left" : "array.addChildToBack(arg);",
      "right" : "array.addChildToBack(arg);",
      "info" : "ExpressionStatement[72098-72124]:ExpressionStatement[72098-72124]"
    }, {
      "left" : "if (hasVarArgs)",
      "right" : "if (hasVarArgs)",
      "info" : "IfStatement[72131-72171]:IfStatement[72131-72171]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72147-72171]:Block[72147-72171]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[72157-72163]:BreakStatement[72157-72163]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[72178-72189]:ExpressionStatement[72178-72189]"
    }, {
      "left" : "if (!match(JsDocToken.RB))",
      "right" : "if (!match(JsDocToken.RB))",
      "info" : "IfStatement[72234-72330]:IfStatement[72234-72330]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72261-72330]:Block[72261-72330]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ReturnStatement[72269-72324]:ReturnStatement[72269-72324]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[72335-72342]:ExpressionStatement[72335-72342]"
    }, {
      "left" : "return array;",
      "right" : "return array;",
      "info" : "ReturnStatement[72347-72360]:ReturnStatement[72347-72360]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[72421-72428]:Modifier[72421-72428]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[72429-72433]:SimpleType[72429-72433]"
    }, {
      "left" : "parseRecordType",
      "right" : "parseRecordType",
      "info" : "SimpleName[72434-72449]:SimpleName[72434-72449]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[72450-72466]:SingleVariableDeclaration[72450-72466]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72468-72854]:Block[72468-72854]"
    }, {
      "left" : "Node recordType = newNode(Token.LC);",
      "right" : "Node recordType = newNode(Token.LC);",
      "info" : "VariableDeclarationStatement[72474-72510]:VariableDeclarationStatement[72474-72510]"
    }, {
      "left" : "Node fieldTypeList = parseFieldTypeList(token);",
      "right" : "Node fieldTypeList = parseFieldTypeList(token);",
      "info" : "VariableDeclarationStatement[72515-72562]:VariableDeclarationStatement[72515-72562]"
    }, {
      "left" : "if (fieldTypeList == null)",
      "right" : "if (fieldTypeList == null)",
      "info" : "IfStatement[72568-72649]:IfStatement[72568-72649]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72595-72649]:Block[72595-72649]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[72603-72643]:ReturnStatement[72603-72643]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[72655-72666]:ExpressionStatement[72655-72666]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[72671-72767]:IfStatement[72671-72767]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72698-72767]:Block[72698-72767]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ReturnStatement[72706-72761]:ReturnStatement[72706-72761]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[72773-72780]:ExpressionStatement[72773-72780]"
    }, {
      "left" : "recordType.addChildToBack(fieldTypeList);",
      "right" : "recordType.addChildToBack(fieldTypeList);",
      "info" : "ExpressionStatement[72786-72827]:ExpressionStatement[72786-72827]"
    }, {
      "left" : "return recordType;",
      "right" : "return recordType;",
      "info" : "ReturnStatement[72832-72850]:ReturnStatement[72832-72850]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[72932-72939]:Modifier[72932-72939]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[72940-72944]:SimpleType[72940-72944]"
    }, {
      "left" : "parseFieldTypeList",
      "right" : "parseFieldTypeList",
      "info" : "SimpleName[72945-72963]:SimpleName[72945-72963]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[72964-72980]:SingleVariableDeclaration[72964-72980]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72982-73458]:Block[72982-73458]"
    }, {
      "left" : "Node fieldTypeList = newNode(Token.LB);",
      "right" : "Node fieldTypeList = newNode(Token.LB);",
      "info" : "VariableDeclarationStatement[72988-73027]:VariableDeclarationStatement[72988-73027]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[73033-73427]:DoStatement[73033-73427]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73036-73413]:Block[73036-73413]"
    }, {
      "left" : "Node fieldType = parseFieldType(token);",
      "right" : "Node fieldType = parseFieldType(token);",
      "info" : "VariableDeclarationStatement[73044-73083]:VariableDeclarationStatement[73044-73083]"
    }, {
      "left" : "if (fieldType == null)",
      "right" : "if (fieldType == null)",
      "info" : "IfStatement[73091-73144]:IfStatement[73091-73144]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73114-73144]:Block[73114-73144]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[73124-73136]:ReturnStatement[73124-73136]"
    }, {
      "left" : "fieldTypeList.addChildToBack(fieldType);",
      "right" : "fieldTypeList.addChildToBack(fieldType);",
      "info" : "ExpressionStatement[73152-73192]:ExpressionStatement[73152-73192]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[73200-73211]:ExpressionStatement[73200-73211]"
    }, {
      "left" : "if (!match(JsDocToken.COMMA))",
      "right" : "if (!match(JsDocToken.COMMA))",
      "info" : "IfStatement[73218-73272]:IfStatement[73218-73272]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73248-73272]:Block[73248-73272]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[73258-73264]:BreakStatement[73258-73264]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[73314-73321]:ExpressionStatement[73314-73321]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[73374-73385]:ExpressionStatement[73374-73385]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[73392-73407]:ExpressionStatement[73392-73407]"
    }, {
      "left" : "return fieldTypeList;",
      "right" : "return fieldTypeList;",
      "info" : "ReturnStatement[73433-73454]:ReturnStatement[73433-73454]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[73533-73540]:Modifier[73533-73540]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[73541-73545]:SimpleType[73541-73545]"
    }, {
      "left" : "parseFieldType",
      "right" : "parseFieldType",
      "info" : "SimpleName[73546-73560]:SimpleName[73546-73560]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[73561-73577]:SingleVariableDeclaration[73561-73577]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73579-74169]:Block[73579-74169]"
    }, {
      "left" : "Node fieldName = parseFieldName(token);",
      "right" : "Node fieldName = parseFieldName(token);",
      "info" : "VariableDeclarationStatement[73585-73624]:VariableDeclarationStatement[73585-73624]"
    }, {
      "left" : "if (fieldName == null)",
      "right" : "if (fieldName == null)",
      "info" : "IfStatement[73630-73679]:IfStatement[73630-73679]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73653-73679]:Block[73653-73679]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[73661-73673]:ReturnStatement[73661-73673]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[73685-73696]:ExpressionStatement[73685-73696]"
    }, {
      "left" : "if (!match(JsDocToken.COLON))",
      "right" : "if (!match(JsDocToken.COLON))",
      "info" : "IfStatement[73701-73762]:IfStatement[73701-73762]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73731-73762]:Block[73731-73762]"
    }, {
      "left" : "return fieldName;",
      "right" : "return fieldName;",
      "info" : "ReturnStatement[73739-73756]:ReturnStatement[73739-73756]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[73794-73801]:ExpressionStatement[73794-73801]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[73886-73897]:ExpressionStatement[73886-73897]"
    }, {
      "left" : "Node typeExpression = parseTypeExpression(next());",
      "right" : "Node typeExpression = parseTypeExpression(next());",
      "info" : "VariableDeclarationStatement[73902-73952]:VariableDeclarationStatement[73902-73952]"
    }, {
      "left" : "if (typeExpression == null)",
      "right" : "if (typeExpression == null)",
      "info" : "IfStatement[73958-74012]:IfStatement[73958-74012]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73986-74012]:Block[73986-74012]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[73994-74006]:ReturnStatement[73994-74006]"
    }, {
      "left" : "Node fieldType = newNode(Token.COLON);",
      "right" : "Node fieldType = newNode(Token.COLON);",
      "info" : "VariableDeclarationStatement[74018-74056]:VariableDeclarationStatement[74018-74056]"
    }, {
      "left" : "fieldType.addChildToBack(fieldName);",
      "right" : "fieldType.addChildToBack(fieldName);",
      "info" : "ExpressionStatement[74061-74097]:ExpressionStatement[74061-74097]"
    }, {
      "left" : "fieldType.addChildToBack(typeExpression);",
      "right" : "fieldType.addChildToBack(typeExpression);",
      "info" : "ExpressionStatement[74102-74143]:ExpressionStatement[74102-74143]"
    }, {
      "left" : "return fieldType;",
      "right" : "return fieldType;",
      "info" : "ReturnStatement[74148-74165]:ReturnStatement[74148-74165]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[74276-74283]:Modifier[74276-74283]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[74284-74288]:SimpleType[74284-74288]"
    }, {
      "left" : "parseFieldName",
      "right" : "parseFieldName",
      "info" : "SimpleName[74289-74303]:SimpleName[74289-74303]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[74304-74320]:SingleVariableDeclaration[74304-74320]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[74322-74492]:Block[74322-74492]"
    }, {
      "left" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
      "right" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
      "info" : "SwitchStatement[74328-74488]:SwitchStatement[74328-74488]"
    }, {
      "left" : "case STRING:",
      "right" : "case STRING:",
      "info" : "SwitchCase[74351-74363]:SwitchCase[74351-74363]"
    }, {
      "left" : "String string = stream.getString();",
      "right" : "String string = stream.getString();",
      "info" : "VariableDeclarationStatement[74372-74407]:VariableDeclarationStatement[74372-74407]"
    }, {
      "left" : "return newStringNode(string);",
      "right" : "return newStringNode(string);",
      "info" : "ReturnStatement[74416-74445]:ReturnStatement[74416-74445]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[74453-74461]:SwitchCase[74453-74461]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[74470-74482]:ReturnStatement[74470-74482]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[74496-74503]:Modifier[74496-74503]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[74504-74508]:SimpleType[74504-74508]"
    }, {
      "left" : "wrapNode",
      "right" : "wrapNode",
      "info" : "SimpleName[74509-74517]:SimpleName[74509-74517]"
    }, {
      "left" : "int type",
      "right" : "int type",
      "info" : "SingleVariableDeclaration[74518-74526]:SingleVariableDeclaration[74518-74526]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[74528-74534]:SingleVariableDeclaration[74528-74534]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[74536-74679]:Block[74536-74679]"
    }, {
      "left" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);",
      "right" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);",
      "info" : "ReturnStatement[74542-74675]:ReturnStatement[74542-74675]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[74683-74690]:Modifier[74683-74690]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[74691-74695]:SimpleType[74691-74695]"
    }, {
      "left" : "newNode",
      "right" : "newNode",
      "info" : "SimpleName[74696-74703]:SimpleName[74696-74703]"
    }, {
      "left" : "int type",
      "right" : "int type",
      "info" : "SingleVariableDeclaration[74704-74712]:SingleVariableDeclaration[74704-74712]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[74714-74823]:Block[74714-74823]"
    }, {
      "left" : "return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
      "right" : "return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
      "info" : "ReturnStatement[74720-74819]:ReturnStatement[74720-74819]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[74827-74834]:Modifier[74827-74834]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[74835-74839]:SimpleType[74835-74839]"
    }, {
      "left" : "newStringNode",
      "right" : "newStringNode",
      "info" : "SimpleName[74840-74853]:SimpleName[74840-74853]"
    }, {
      "left" : "String s",
      "right" : "String s",
      "info" : "SingleVariableDeclaration[74854-74862]:SingleVariableDeclaration[74854-74862]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[74864-74938]:Block[74864-74938]"
    }, {
      "left" : "return newStringNode(s, stream.getLineno(), stream.getCharno());",
      "right" : "return newStringNode(s, stream.getLineno(), stream.getCharno());",
      "info" : "ReturnStatement[74870-74934]:ReturnStatement[74870-74934]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[74942-74949]:Modifier[74942-74949]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[74950-74954]:SimpleType[74950-74954]"
    }, {
      "left" : "newStringNode",
      "right" : "newStringNode",
      "info" : "SimpleName[74955-74968]:SimpleName[74955-74968]"
    }, {
      "left" : "String s",
      "right" : "String s",
      "info" : "SingleVariableDeclaration[74969-74977]:SingleVariableDeclaration[74969-74977]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[74979-74989]:SingleVariableDeclaration[74979-74989]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[74991-75001]:SingleVariableDeclaration[74991-75001]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[75003-75128]:Block[75003-75128]"
    }, {
      "left" : "Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);",
      "right" : "Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);",
      "info" : "VariableDeclarationStatement[75009-75081]:VariableDeclarationStatement[75009-75081]"
    }, {
      "left" : "n.setLength(s.length());",
      "right" : "n.setLength(s.length());",
      "info" : "ExpressionStatement[75086-75110]:ExpressionStatement[75086-75110]"
    }, {
      "left" : "return n;",
      "right" : "return n;",
      "info" : "ReturnStatement[75115-75124]:ReturnStatement[75115-75124]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[75250-75257]:Modifier[75250-75257]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[75258-75262]:SimpleType[75258-75262]"
    }, {
      "left" : "createTemplateNode",
      "right" : "createTemplateNode",
      "info" : "SimpleName[75263-75281]:SimpleName[75263-75281]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[75284-75530]:Block[75284-75530]"
    }, {
      "left" : "Node templateNode = IR.script();",
      "right" : "Node templateNode = IR.script();",
      "info" : "VariableDeclarationStatement[75332-75364]:VariableDeclarationStatement[75332-75364]"
    }, {
      "left" : "templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);",
      "right" : "templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);",
      "info" : "ExpressionStatement[75369-75501]:ExpressionStatement[75369-75501]"
    }, {
      "left" : "return templateNode;",
      "right" : "return templateNode;",
      "info" : "ReturnStatement[75506-75526]:ReturnStatement[75506-75526]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[75534-75541]:Modifier[75534-75541]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[75542-75546]:SimpleType[75542-75546]"
    }, {
      "left" : "reportTypeSyntaxWarning",
      "right" : "reportTypeSyntaxWarning",
      "info" : "SimpleName[75547-75570]:SimpleName[75547-75570]"
    }, {
      "left" : "String warning",
      "right" : "String warning",
      "info" : "SingleVariableDeclaration[75571-75585]:SingleVariableDeclaration[75571-75585]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[75587-75685]:Block[75587-75685]"
    }, {
      "left" : "parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[75593-75664]:ExpressionStatement[75593-75664]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[75669-75681]:ReturnStatement[75669-75681]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[75689-75696]:Modifier[75689-75696]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[75697-75701]:SimpleType[75697-75701]"
    }, {
      "left" : "reportGenericTypeSyntaxWarning",
      "right" : "reportGenericTypeSyntaxWarning",
      "info" : "SimpleName[75702-75732]:SimpleName[75702-75732]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[75735-75801]:Block[75735-75801]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
      "info" : "ReturnStatement[75741-75797]:ReturnStatement[75741-75797]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[75945-75952]:Modifier[75945-75952]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[75953-75963]:SimpleType[75953-75963]"
    }, {
      "left" : "eatTokensUntilEOL",
      "right" : "eatTokensUntilEOL",
      "info" : "SimpleName[75964-75981]:SimpleName[75964-75981]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[75984-76027]:Block[75984-76027]"
    }, {
      "left" : "return eatTokensUntilEOL(next());",
      "right" : "return eatTokensUntilEOL(next());",
      "info" : "ReturnStatement[75990-76023]:ReturnStatement[75990-76023]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[76171-76178]:Modifier[76171-76178]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[76179-76189]:SimpleType[76179-76189]"
    }, {
      "left" : "eatTokensUntilEOL",
      "right" : "eatTokensUntilEOL",
      "info" : "SimpleName[76190-76207]:SimpleName[76190-76207]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[76208-76224]:SingleVariableDeclaration[76208-76224]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[76226-76457]:Block[76226-76457]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[76232-76453]:DoStatement[76232-76453]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[76235-76439]:Block[76235-76439]"
    }, {
      "left" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
      "right" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
      "info" : "IfStatement[76243-76411]:IfStatement[76243-76411]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[76336-76411]:Block[76336-76411]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[76346-76381]:ExpressionStatement[76346-76381]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[76390-76403]:ReturnStatement[76390-76403]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[76418-76433]:ExpressionStatement[76418-76433]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[76758-76765]:Modifier[76758-76765]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[76766-76770]:PrimitiveType[76766-76770]"
    }, {
      "left" : "restoreLookAhead",
      "right" : "restoreLookAhead",
      "info" : "SimpleName[76771-76787]:SimpleName[76771-76787]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[76788-76804]:SingleVariableDeclaration[76788-76804]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[76806-76836]:Block[76806-76836]"
    }, {
      "left" : "unreadToken = token;",
      "right" : "unreadToken = token;",
      "info" : "ExpressionStatement[76812-76832]:ExpressionStatement[76812-76832]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[76940-76947]:Modifier[76940-76947]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[76948-76955]:PrimitiveType[76948-76955]"
    }, {
      "left" : "match",
      "right" : "match",
      "info" : "SimpleName[76956-76961]:SimpleName[76956-76961]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[76962-76978]:SingleVariableDeclaration[76962-76978]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[76980-77044]:Block[76980-77044]"
    }, {
      "left" : "unreadToken = next();",
      "right" : "unreadToken = next();",
      "info" : "ExpressionStatement[76986-77007]:ExpressionStatement[76986-77007]"
    }, {
      "left" : "return unreadToken == token;",
      "right" : "return unreadToken == token;",
      "info" : "ReturnStatement[77012-77040]:ReturnStatement[77012-77040]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[77154-77161]:Modifier[77154-77161]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[77162-77169]:PrimitiveType[77162-77169]"
    }, {
      "left" : "match",
      "right" : "match",
      "info" : "SimpleName[77170-77175]:SimpleName[77170-77175]"
    }, {
      "left" : "JsDocToken token1",
      "right" : "JsDocToken token1",
      "info" : "SingleVariableDeclaration[77176-77193]:SingleVariableDeclaration[77176-77193]"
    }, {
      "left" : "JsDocToken token2",
      "right" : "JsDocToken token2",
      "info" : "SingleVariableDeclaration[77195-77212]:SingleVariableDeclaration[77195-77212]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[77214-77304]:Block[77214-77304]"
    }, {
      "left" : "unreadToken = next();",
      "right" : "unreadToken = next();",
      "info" : "ExpressionStatement[77220-77241]:ExpressionStatement[77220-77241]"
    }, {
      "left" : "return unreadToken == token1 || unreadToken == token2;",
      "right" : "return unreadToken == token1 || unreadToken == token2;",
      "info" : "ReturnStatement[77246-77300]:ReturnStatement[77246-77300]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[77427-77434]:Modifier[77427-77434]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[77435-77445]:SimpleType[77435-77445]"
    }, {
      "left" : "next",
      "right" : "next",
      "info" : "SimpleName[77446-77450]:SimpleName[77446-77450]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[77453-77580]:Block[77453-77580]"
    }, {
      "left" : "if (unreadToken == NO_UNREAD_TOKEN)",
      "right" : "if (unreadToken == NO_UNREAD_TOKEN)",
      "info" : "IfStatement[77459-77576]:IfStatement[77459-77576]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[77495-77539]:Block[77495-77539]"
    }, {
      "left" : "return stream.getJsDocToken();",
      "right" : "return stream.getJsDocToken();",
      "info" : "ReturnStatement[77503-77533]:ReturnStatement[77503-77533]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[77545-77576]:Block[77545-77576]"
    }, {
      "left" : "return current();",
      "right" : "return current();",
      "info" : "ReturnStatement[77553-77570]:ReturnStatement[77553-77570]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[77657-77664]:Modifier[77657-77664]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[77665-77675]:SimpleType[77665-77675]"
    }, {
      "left" : "current",
      "right" : "current",
      "info" : "SimpleName[77676-77683]:SimpleName[77676-77683]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[77686-77772]:Block[77686-77772]"
    }, {
      "left" : "JsDocToken t = unreadToken;",
      "right" : "JsDocToken t = unreadToken;",
      "info" : "VariableDeclarationStatement[77692-77719]:VariableDeclarationStatement[77692-77719]"
    }, {
      "left" : "unreadToken = NO_UNREAD_TOKEN;",
      "right" : "unreadToken = NO_UNREAD_TOKEN;",
      "info" : "ExpressionStatement[77724-77754]:ExpressionStatement[77724-77754]"
    }, {
      "left" : "return t;",
      "right" : "return t;",
      "info" : "ReturnStatement[77759-77768]:ReturnStatement[77759-77768]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[77916-77923]:Modifier[77916-77923]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[77924-77928]:PrimitiveType[77924-77928]"
    }, {
      "left" : "skipEOLs",
      "right" : "skipEOLs",
      "info" : "SimpleName[77929-77937]:SimpleName[77929-77937]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[77940-78061]:Block[77940-78061]"
    }, {
      "left" : "while (match(JsDocToken.EOL))",
      "right" : "while (match(JsDocToken.EOL))",
      "info" : "WhileStatement[77946-78057]:WhileStatement[77946-78057]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[77976-78057]:Block[77976-78057]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[77984-77991]:ExpressionStatement[77984-77991]"
    }, {
      "left" : "if (match(JsDocToken.STAR))",
      "right" : "if (match(JsDocToken.STAR))",
      "info" : "IfStatement[77998-78051]:IfStatement[77998-78051]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[78026-78051]:Block[78026-78051]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[78036-78043]:ExpressionStatement[78036-78043]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[78117-78124]:Modifier[78117-78124]"
    }, {
      "left" : "String",
      "right" : "String",
      "info" : "SimpleType[78125-78131]:SimpleType[78125-78131]"
    }, {
      "left" : "getRemainingJSDocLine",
      "right" : "getRemainingJSDocLine",
      "info" : "SimpleName[78132-78153]:SimpleName[78132-78153]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[78156-78232]:Block[78156-78267]"
    }, {
      "left" : "String result = stream.getRemainingJSDocLine();",
      "right" : "String result = stream.getRemainingJSDocLine();",
      "info" : "VariableDeclarationStatement[78162-78209]:VariableDeclarationStatement[78162-78209]"
    }, {
      "left" : "return result;",
      "right" : "return result;",
      "info" : "ReturnStatement[78214-78228]:ReturnStatement[78249-78263]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[78345-78352]:Modifier[78380-78387]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[78353-78360]:PrimitiveType[78388-78395]"
    }, {
      "left" : "hasParsedFileOverviewDocInfo",
      "right" : "hasParsedFileOverviewDocInfo",
      "info" : "SimpleName[78361-78389]:SimpleName[78396-78424]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[78392-78452]:Block[78427-78487]"
    }, {
      "left" : "return jsdocBuilder.isPopulatedWithFileOverview();",
      "right" : "return jsdocBuilder.isPopulatedWithFileOverview();",
      "info" : "ReturnStatement[78398-78448]:ReturnStatement[78433-78483]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[78456-78463]:PrimitiveType[78491-78498]"
    }, {
      "left" : "hasParsedJSDocInfo",
      "right" : "hasParsedJSDocInfo",
      "info" : "SimpleName[78464-78482]:SimpleName[78499-78517]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[78485-78529]:Block[78520-78564]"
    }, {
      "left" : "return jsdocBuilder.isPopulated();",
      "right" : "return jsdocBuilder.isPopulated();",
      "info" : "ReturnStatement[78491-78525]:ReturnStatement[78526-78560]"
    }, {
      "left" : "JSDocInfo",
      "right" : "JSDocInfo",
      "info" : "SimpleType[78533-78542]:SimpleType[78568-78577]"
    }, {
      "left" : "retrieveAndResetParsedJSDocInfo",
      "right" : "retrieveAndResetParsedJSDocInfo",
      "info" : "SimpleName[78543-78574]:SimpleName[78578-78609]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[78577-78629]:Block[78612-78664]"
    }, {
      "left" : "return jsdocBuilder.build(associatedNode);",
      "right" : "return jsdocBuilder.build(associatedNode);",
      "info" : "ReturnStatement[78583-78625]:ReturnStatement[78618-78660]"
    }, {
      "left" : "JSDocInfo",
      "right" : "JSDocInfo",
      "info" : "SimpleType[78691-78700]:SimpleType[78726-78735]"
    }, {
      "left" : "getFileOverviewJSDocInfo",
      "right" : "getFileOverviewJSDocInfo",
      "info" : "SimpleName[78701-78725]:SimpleName[78736-78760]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[78728-78767]:Block[78763-78802]"
    }, {
      "left" : "return fileOverviewJSDocInfo;",
      "right" : "return fileOverviewJSDocInfo;",
      "info" : "ReturnStatement[78734-78763]:ReturnStatement[78769-78798]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[79121-79128]:Modifier[79156-79163]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[79129-79136]:PrimitiveType[79164-79171]"
    }, {
      "left" : "lookAheadForTypeAnnotation",
      "right" : "lookAheadForTypeAnnotation",
      "info" : "SimpleName[79137-79163]:SimpleName[79172-79198]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[79166-79461]:Block[79201-79496]"
    }, {
      "left" : "boolean matchedLc = false;",
      "right" : "boolean matchedLc = false;",
      "info" : "VariableDeclarationStatement[79172-79198]:VariableDeclarationStatement[79207-79233]"
    }, {
      "left" : "int c;",
      "right" : "int c;",
      "info" : "VariableDeclarationStatement[79203-79209]:VariableDeclarationStatement[79238-79244]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[79214-79410]:WhileStatement[79249-79445]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[79227-79410]:Block[79262-79445]"
    }, {
      "left" : "c = stream.getChar();",
      "right" : "c = stream.getChar();",
      "info" : "ExpressionStatement[79235-79256]:ExpressionStatement[79270-79291]"
    }, {
      "left" : "if (c == ' ')",
      "right" : "if (c == ' ')",
      "info" : "IfStatement[79263-79404]:IfStatement[79298-79439]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[79277-79304]:Block[79312-79339]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[79287-79296]:ContinueStatement[79322-79331]"
    }, {
      "left" : "if (c == '{')",
      "right" : "if (c == '{')",
      "info" : "IfStatement[79310-79404]:IfStatement[79345-79439]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[79324-79374]:Block[79359-79409]"
    }, {
      "left" : "matchedLc = true;",
      "right" : "matchedLc = true;",
      "info" : "ExpressionStatement[79334-79351]:ExpressionStatement[79369-79386]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[79360-79366]:BreakStatement[79395-79401]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[79380-79404]:Block[79415-79439]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[79390-79396]:BreakStatement[79425-79431]"
    }, {
      "left" : "stream.ungetChar(c);",
      "right" : "stream.ungetChar(c);",
      "info" : "ExpressionStatement[79415-79435]:ExpressionStatement[79450-79470]"
    }, {
      "left" : "return matchedLc;",
      "right" : "return matchedLc;",
      "info" : "ReturnStatement[79440-79457]:ReturnStatement[79475-79492]"
    } ]
  },
  "interFileMappings" : { }
}