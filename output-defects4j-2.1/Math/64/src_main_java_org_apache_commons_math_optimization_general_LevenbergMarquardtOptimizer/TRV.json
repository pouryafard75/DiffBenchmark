{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "private int solvedCols;",
      "right" : "private int solvedCols;",
      "info" : "FieldDeclaration[5347-5405]:FieldDeclaration[5347-5405]"
    }, {
      "left" : "private double[] diagR;",
      "right" : "private double[] diagR;",
      "info" : "FieldDeclaration[5411-5506]:FieldDeclaration[5411-5506]"
    }, {
      "left" : "private double[] jacNorm;",
      "right" : "private double[] jacNorm;",
      "info" : "FieldDeclaration[5512-5593]:FieldDeclaration[5512-5593]"
    }, {
      "left" : "private double[] beta;",
      "right" : "private double[] beta;",
      "info" : "FieldDeclaration[5599-5684]:FieldDeclaration[5599-5684]"
    }, {
      "left" : "private int[] permutation;",
      "right" : "private int[] permutation;",
      "info" : "FieldDeclaration[5690-5754]:FieldDeclaration[5690-5754]"
    }, {
      "left" : "private int rank;",
      "right" : "private int rank;",
      "info" : "FieldDeclaration[5760-5817]:FieldDeclaration[5760-5817]"
    }, {
      "left" : "private double lmPar;",
      "right" : "private double lmPar;",
      "info" : "FieldDeclaration[5823-5886]:FieldDeclaration[5823-5886]"
    }, {
      "left" : "private double[] lmDir;",
      "right" : "private double[] lmDir;",
      "info" : "FieldDeclaration[5892-5980]:FieldDeclaration[5892-5980]"
    }, {
      "left" : "private double initialStepBoundFactor;",
      "right" : "private double initialStepBoundFactor;",
      "info" : "FieldDeclaration[5986-6103]:FieldDeclaration[5986-6103]"
    }, {
      "left" : "private double costRelativeTolerance;",
      "right" : "private double costRelativeTolerance;",
      "info" : "FieldDeclaration[6109-6203]:FieldDeclaration[6109-6203]"
    }, {
      "left" : "private double parRelativeTolerance;",
      "right" : "private double parRelativeTolerance;",
      "info" : "FieldDeclaration[6209-6320]:FieldDeclaration[6209-6320]"
    }, {
      "left" : "private double orthoTolerance;",
      "right" : "private double orthoTolerance;",
      "info" : "FieldDeclaration[6326-6475]:FieldDeclaration[6326-6475]"
    }, {
      "left" : "private double qrRankingThreshold;",
      "right" : "private double qrRankingThreshold;",
      "info" : "FieldDeclaration[6481-6552]:FieldDeclaration[6481-6552]"
    }, {
      "left" : "public LevenbergMarquardtOptimizer()",
      "right" : "public LevenbergMarquardtOptimizer()",
      "info" : "MethodDeclaration[6558-8214]:MethodDeclaration[6558-8214]"
    }, {
      "left" : "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
      "right" : "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
      "info" : "MethodDeclaration[8220-8803]:MethodDeclaration[8220-8803]"
    }, {
      "left" : "public void setCostRelativeTolerance(double costRelativeTolerance)",
      "right" : "public void setCostRelativeTolerance(double costRelativeTolerance)",
      "info" : "MethodDeclaration[8809-9232]:MethodDeclaration[8809-9232]"
    }, {
      "left" : "public void setParRelativeTolerance(double parRelativeTolerance)",
      "right" : "public void setParRelativeTolerance(double parRelativeTolerance)",
      "info" : "MethodDeclaration[9238-9697]:MethodDeclaration[9238-9697]"
    }, {
      "left" : "public void setOrthoTolerance(double orthoTolerance)",
      "right" : "public void setOrthoTolerance(double orthoTolerance)",
      "info" : "MethodDeclaration[9703-10170]:MethodDeclaration[9703-10170]"
    }, {
      "left" : "public void setQRRankingThreshold(final double threshold)",
      "right" : "public void setQRRankingThreshold(final double threshold)",
      "info" : "MethodDeclaration[10176-10628]:MethodDeclaration[10176-10628]"
    }, {
      "left" : "private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3)",
      "right" : "private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3)",
      "info" : "MethodDeclaration[19665-25798]:MethodDeclaration[20217-26350]"
    }, {
      "left" : "private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work)",
      "right" : "private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work)",
      "info" : "MethodDeclaration[25804-30576]:MethodDeclaration[26356-31128]"
    }, {
      "left" : "private void qrDecomposition() throws OptimizationException",
      "right" : "private void qrDecomposition() throws OptimizationException",
      "info" : "MethodDeclaration[30582-34305]:MethodDeclaration[31134-34857]"
    }, {
      "left" : "private void qTy(double[] y)",
      "right" : "private void qTy(double[] y)",
      "info" : "MethodDeclaration[34311-34869]:MethodDeclaration[34863-35421]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7791-8214]:Block[7791-8214]"
    }, {
      "left" : "setMaxIterations(1000);",
      "right" : "setMaxIterations(1000);",
      "info" : "ExpressionStatement[7880-7903]:ExpressionStatement[7880-7903]"
    }, {
      "left" : "setConvergenceChecker(null);",
      "right" : "setConvergenceChecker(null);",
      "info" : "ExpressionStatement[7965-7993]:ExpressionStatement[7965-7993]"
    }, {
      "left" : "setInitialStepBoundFactor(100.0);",
      "right" : "setInitialStepBoundFactor(100.0);",
      "info" : "ExpressionStatement[8002-8035]:ExpressionStatement[8002-8035]"
    }, {
      "left" : "setCostRelativeTolerance(1.0e-10);",
      "right" : "setCostRelativeTolerance(1.0e-10);",
      "info" : "ExpressionStatement[8044-8078]:ExpressionStatement[8044-8078]"
    }, {
      "left" : "setParRelativeTolerance(1.0e-10);",
      "right" : "setParRelativeTolerance(1.0e-10);",
      "info" : "ExpressionStatement[8087-8120]:ExpressionStatement[8087-8120]"
    }, {
      "left" : "setOrthoTolerance(1.0e-10);",
      "right" : "setOrthoTolerance(1.0e-10);",
      "info" : "ExpressionStatement[8129-8156]:ExpressionStatement[8129-8156]"
    }, {
      "left" : "setQRRankingThreshold(MathUtils.SAFE_MIN);",
      "right" : "setQRRankingThreshold(MathUtils.SAFE_MIN);",
      "info" : "ExpressionStatement[8165-8207]:ExpressionStatement[8165-8207]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8734-8803]:Block[8734-8803]"
    }, {
      "left" : "this.initialStepBoundFactor = initialStepBoundFactor;",
      "right" : "this.initialStepBoundFactor = initialStepBoundFactor;",
      "info" : "ExpressionStatement[8744-8797]:ExpressionStatement[8744-8797]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9165-9232]:Block[9165-9232]"
    }, {
      "left" : "this.costRelativeTolerance = costRelativeTolerance;",
      "right" : "this.costRelativeTolerance = costRelativeTolerance;",
      "info" : "ExpressionStatement[9175-9226]:ExpressionStatement[9175-9226]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9632-9697]:Block[9632-9697]"
    }, {
      "left" : "this.parRelativeTolerance = parRelativeTolerance;",
      "right" : "this.parRelativeTolerance = parRelativeTolerance;",
      "info" : "ExpressionStatement[9642-9691]:ExpressionStatement[9642-9691]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10117-10170]:Block[10117-10170]"
    }, {
      "left" : "this.orthoTolerance = orthoTolerance;",
      "right" : "this.orthoTolerance = orthoTolerance;",
      "info" : "ExpressionStatement[10127-10164]:ExpressionStatement[10127-10164]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10576-10628]:Block[10576-10628]"
    }, {
      "left" : "this.qrRankingThreshold = threshold;",
      "right" : "this.qrRankingThreshold = threshold;",
      "info" : "ExpressionStatement[10586-10622]:ExpressionStatement[10586-10622]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20658-25798]:Block[21210-26350]"
    }, {
      "left" : "for (int j = 0; j < rank; ++j)",
      "right" : "for (int j = 0; j < rank; ++j)",
      "info" : "ForStatement[20809-20894]:ForStatement[21361-21446]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20840-20894]:Block[21392-21446]"
    }, {
      "left" : "lmDir[permutation[j]] = qy[j];",
      "right" : "lmDir[permutation[j]] = qy[j];",
      "info" : "ExpressionStatement[20854-20884]:ExpressionStatement[21406-21436]"
    }, {
      "left" : "for (int j = rank; j < cols; ++j)",
      "right" : "for (int j = rank; j < cols; ++j)",
      "info" : "ForStatement[20903-20987]:ForStatement[21455-21539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20937-20987]:Block[21489-21539]"
    }, {
      "left" : "lmDir[permutation[j]] = 0;",
      "right" : "lmDir[permutation[j]] = 0;",
      "info" : "ExpressionStatement[20951-20977]:ExpressionStatement[21503-21529]"
    }, {
      "left" : "for (int k = rank - 1; k >= 0; --k)",
      "right" : "for (int k = rank - 1; k >= 0; --k)",
      "info" : "ForStatement[20996-21277]:ForStatement[21548-21829]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21032-21277]:Block[21584-21829]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[21046-21070]:VariableDeclarationStatement[21598-21622]"
    }, {
      "left" : "double ypk = lmDir[pk] / diagR[pk];",
      "right" : "double ypk = lmDir[pk] / diagR[pk];",
      "info" : "VariableDeclarationStatement[21083-21118]:VariableDeclarationStatement[21635-21670]"
    }, {
      "left" : "for (int i = 0; i < k; ++i)",
      "right" : "for (int i = 0; i < k; ++i)",
      "info" : "ForStatement[21131-21238]:ForStatement[21683-21790]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21159-21238]:Block[21711-21790]"
    }, {
      "left" : "lmDir[permutation[i]] -= ypk * jacobian[i][pk];",
      "right" : "lmDir[permutation[i]] -= ypk * jacobian[i][pk];",
      "info" : "ExpressionStatement[21177-21224]:ExpressionStatement[21729-21776]"
    }, {
      "left" : "lmDir[pk] = ypk;",
      "right" : "lmDir[pk] = ypk;",
      "info" : "ExpressionStatement[21251-21267]:ExpressionStatement[21803-21819]"
    }, {
      "left" : "double dxNorm = 0;",
      "right" : "double dxNorm = 0;",
      "info" : "VariableDeclarationStatement[21400-21418]:VariableDeclarationStatement[21952-21970]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[21427-21613]:ForStatement[21979-22165]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21464-21613]:Block[22016-22165]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[21478-21502]:VariableDeclarationStatement[22030-22054]"
    }, {
      "left" : "double s = diag[pj] * lmDir[pj];",
      "right" : "double s = diag[pj] * lmDir[pj];",
      "info" : "VariableDeclarationStatement[21515-21547]:VariableDeclarationStatement[22067-22099]"
    }, {
      "left" : "work1[pj] = s;",
      "right" : "work1[pj] = s;",
      "info" : "ExpressionStatement[21560-21574]:ExpressionStatement[22112-22126]"
    }, {
      "left" : "dxNorm += s * s;",
      "right" : "dxNorm += s * s;",
      "info" : "ExpressionStatement[21587-21603]:ExpressionStatement[22139-22155]"
    }, {
      "left" : "dxNorm = Math.sqrt(dxNorm);",
      "right" : "dxNorm = Math.sqrt(dxNorm);",
      "info" : "ExpressionStatement[21622-21649]:ExpressionStatement[22174-22201]"
    }, {
      "left" : "double fp = dxNorm - delta;",
      "right" : "double fp = dxNorm - delta;",
      "info" : "VariableDeclarationStatement[21658-21685]:VariableDeclarationStatement[22210-22237]"
    }, {
      "left" : "if (fp <= 0.1 * delta)",
      "right" : "if (fp <= 0.1 * delta)",
      "info" : "IfStatement[21694-21771]:IfStatement[22246-22323]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21717-21771]:Block[22269-22323]"
    }, {
      "left" : "lmPar = 0;",
      "right" : "lmPar = 0;",
      "info" : "ExpressionStatement[21731-21741]:ExpressionStatement[22283-22293]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[21754-21761]:ReturnStatement[22306-22313]"
    }, {
      "left" : "double sum2;",
      "right" : "double sum2;",
      "info" : "VariableDeclarationStatement[21962-21974]:VariableDeclarationStatement[22514-22526]"
    }, {
      "left" : "double parl = 0;",
      "right" : "double parl = 0;",
      "info" : "VariableDeclarationStatement[21983-21999]:VariableDeclarationStatement[22535-22551]"
    }, {
      "left" : "if (rank == solvedCols)",
      "right" : "if (rank == solvedCols)",
      "info" : "IfStatement[22008-22649]:IfStatement[22560-23201]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22032-22649]:Block[22584-23201]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[22046-22187]:ForStatement[22598-22739]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22083-22187]:Block[22635-22739]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[22101-22125]:VariableDeclarationStatement[22653-22677]"
    }, {
      "left" : "work1[pj] *= diag[pj] / dxNorm;",
      "right" : "work1[pj] *= diag[pj] / dxNorm;",
      "info" : "ExpressionStatement[22142-22173]:ExpressionStatement[22694-22725]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[22200-22209]:ExpressionStatement[22752-22761]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[22222-22599]:ForStatement[22774-23151]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22259-22599]:Block[22811-23151]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[22277-22301]:VariableDeclarationStatement[22829-22853]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[22318-22333]:VariableDeclarationStatement[22870-22885]"
    }, {
      "left" : "for (int i = 0; i < j; ++i)",
      "right" : "for (int i = 0; i < j; ++i)",
      "info" : "ForStatement[22350-22465]:ForStatement[22902-23017]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22378-22465]:Block[22930-23017]"
    }, {
      "left" : "sum += jacobian[i][pj] * work1[permutation[i]];",
      "right" : "sum += jacobian[i][pj] * work1[permutation[i]];",
      "info" : "ExpressionStatement[22400-22447]:ExpressionStatement[22952-22999]"
    }, {
      "left" : "double s = (work1[pj] - sum) / diagR[pj];",
      "right" : "double s = (work1[pj] - sum) / diagR[pj];",
      "info" : "VariableDeclarationStatement[22482-22523]:VariableDeclarationStatement[23034-23075]"
    }, {
      "left" : "work1[pj] = s;",
      "right" : "work1[pj] = s;",
      "info" : "ExpressionStatement[22540-22554]:ExpressionStatement[23092-23106]"
    }, {
      "left" : "sum2 += s * s;",
      "right" : "sum2 += s * s;",
      "info" : "ExpressionStatement[22571-22585]:ExpressionStatement[23123-23137]"
    }, {
      "left" : "parl = fp / (delta * sum2);",
      "right" : "parl = fp / (delta * sum2);",
      "info" : "ExpressionStatement[22612-22639]:ExpressionStatement[23164-23191]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[22731-22740]:ExpressionStatement[23283-23292]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[22749-23027]:ForStatement[23301-23579]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22786-23027]:Block[23338-23579]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[22800-22824]:VariableDeclarationStatement[23352-23376]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[22837-22852]:VariableDeclarationStatement[23389-23404]"
    }, {
      "left" : "for (int i = 0; i <= j; ++i)",
      "right" : "for (int i = 0; i <= j; ++i)",
      "info" : "ForStatement[22865-22957]:ForStatement[23417-23509]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22894-22957]:Block[23446-23509]"
    }, {
      "left" : "sum += jacobian[i][pj] * qy[i];",
      "right" : "sum += jacobian[i][pj] * qy[i];",
      "info" : "ExpressionStatement[22912-22943]:ExpressionStatement[23464-23495]"
    }, {
      "left" : "sum /= diag[pj];",
      "right" : "sum /= diag[pj];",
      "info" : "ExpressionStatement[22970-22986]:ExpressionStatement[23522-23538]"
    }, {
      "left" : "sum2 += sum * sum;",
      "right" : "sum2 += sum * sum;",
      "info" : "ExpressionStatement[22999-23017]:ExpressionStatement[23551-23569]"
    }, {
      "left" : "double gNorm = Math.sqrt(sum2);",
      "right" : "double gNorm = Math.sqrt(sum2);",
      "info" : "VariableDeclarationStatement[23036-23067]:VariableDeclarationStatement[23588-23619]"
    }, {
      "left" : "double paru = gNorm / delta;",
      "right" : "double paru = gNorm / delta;",
      "info" : "VariableDeclarationStatement[23076-23104]:VariableDeclarationStatement[23628-23656]"
    }, {
      "left" : "if (paru == 0)",
      "right" : "if (paru == 0)",
      "info" : "IfStatement[23113-23262]:IfStatement[23665-23814]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23128-23262]:Block[23680-23814]"
    }, {
      "left" : "paru = 2.2251e-308 / Math.min(delta, 0.1);",
      "right" : "paru = 2.2251e-308 / Math.min(delta, 0.1);",
      "info" : "ExpressionStatement[23210-23252]:ExpressionStatement[23762-23804]"
    }, {
      "left" : "lmPar = Math.min(paru, Math.max(lmPar, parl));",
      "right" : "lmPar = Math.min(paru, Math.max(lmPar, parl));",
      "info" : "ExpressionStatement[23384-23430]:ExpressionStatement[23936-23982]"
    }, {
      "left" : "if (lmPar == 0)",
      "right" : "if (lmPar == 0)",
      "info" : "IfStatement[23439-23502]:IfStatement[23991-24054]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23455-23502]:Block[24007-24054]"
    }, {
      "left" : "lmPar = gNorm / dxNorm;",
      "right" : "lmPar = gNorm / dxNorm;",
      "info" : "ExpressionStatement[23469-23492]:ExpressionStatement[24021-24044]"
    }, {
      "left" : "for (int countdown = 10; countdown >= 0; --countdown)",
      "right" : "for (int countdown = 10; countdown >= 0; --countdown)",
      "info" : "ForStatement[23512-25792]:ForStatement[24064-26344]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23566-25792]:Block[24118-26344]"
    }, {
      "left" : "if (lmPar == 0)",
      "right" : "if (lmPar == 0)",
      "info" : "IfStatement[23648-23740]:IfStatement[24200-24292]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23664-23740]:Block[24216-24292]"
    }, {
      "left" : "lmPar = Math.max(2.2251e-308, 0.001 * paru);",
      "right" : "lmPar = Math.max(2.2251e-308, 0.001 * paru);",
      "info" : "ExpressionStatement[23682-23726]:ExpressionStatement[24234-24278]"
    }, {
      "left" : "double sPar = Math.sqrt(lmPar);",
      "right" : "double sPar = Math.sqrt(lmPar);",
      "info" : "VariableDeclarationStatement[23753-23784]:VariableDeclarationStatement[24305-24336]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[23797-23935]:ForStatement[24349-24487]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23834-23935]:Block[24386-24487]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[23852-23876]:VariableDeclarationStatement[24404-24428]"
    }, {
      "left" : "work1[pj] = sPar * diag[pj];",
      "right" : "work1[pj] = sPar * diag[pj];",
      "info" : "ExpressionStatement[23893-23921]:ExpressionStatement[24445-24473]"
    }, {
      "left" : "determineLMDirection(qy, work1, work2, work3);",
      "right" : "determineLMDirection(qy, work1, work2, work3);",
      "info" : "ExpressionStatement[23948-23994]:ExpressionStatement[24500-24546]"
    }, {
      "left" : "dxNorm = 0;",
      "right" : "dxNorm = 0;",
      "info" : "ExpressionStatement[24008-24019]:ExpressionStatement[24560-24571]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[24032-24238]:ForStatement[24584-24790]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24069-24238]:Block[24621-24790]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[24087-24111]:VariableDeclarationStatement[24639-24663]"
    }, {
      "left" : "double s = diag[pj] * lmDir[pj];",
      "right" : "double s = diag[pj] * lmDir[pj];",
      "info" : "VariableDeclarationStatement[24128-24160]:VariableDeclarationStatement[24680-24712]"
    }, {
      "left" : "work3[pj] = s;",
      "right" : "work3[pj] = s;",
      "info" : "ExpressionStatement[24177-24191]:ExpressionStatement[24729-24743]"
    }, {
      "left" : "dxNorm += s * s;",
      "right" : "dxNorm += s * s;",
      "info" : "ExpressionStatement[24208-24224]:ExpressionStatement[24760-24776]"
    }, {
      "left" : "dxNorm = Math.sqrt(dxNorm);",
      "right" : "dxNorm = Math.sqrt(dxNorm);",
      "info" : "ExpressionStatement[24251-24278]:ExpressionStatement[24803-24830]"
    }, {
      "left" : "double previousFP = fp;",
      "right" : "double previousFP = fp;",
      "info" : "VariableDeclarationStatement[24291-24314]:VariableDeclarationStatement[24843-24866]"
    }, {
      "left" : "fp = dxNorm - delta;",
      "right" : "fp = dxNorm - delta;",
      "info" : "ExpressionStatement[24327-24347]:ExpressionStatement[24879-24899]"
    }, {
      "left" : "if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0)))",
      "right" : "if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0)))",
      "info" : "IfStatement[24514-24667]:IfStatement[25066-25219]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24628-24667]:Block[25180-25219]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[24646-24653]:ReturnStatement[25198-25205]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[24726-24878]:ForStatement[25278-25430]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24763-24878]:Block[25315-25430]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[24781-24805]:VariableDeclarationStatement[25333-25357]"
    }, {
      "left" : "work1[pj] = work3[pj] * diag[pj] / dxNorm;",
      "right" : "work1[pj] = work3[pj] * diag[pj] / dxNorm;",
      "info" : "ExpressionStatement[24822-24864]:ExpressionStatement[25374-25416]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[24891-25208]:ForStatement[25443-25760]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24928-25208]:Block[25480-25760]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[24946-24970]:VariableDeclarationStatement[25498-25522]"
    }, {
      "left" : "work1[pj] /= work2[j];",
      "right" : "work1[pj] /= work2[j];",
      "info" : "ExpressionStatement[24987-25009]:ExpressionStatement[25539-25561]"
    }, {
      "left" : "double tmp = work1[pj];",
      "right" : "double tmp = work1[pj];",
      "info" : "VariableDeclarationStatement[25026-25049]:VariableDeclarationStatement[25578-25601]"
    }, {
      "left" : "for (int i = j + 1; i < solvedCols; ++i)",
      "right" : "for (int i = j + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[25066-25194]:ForStatement[25618-25746]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25107-25194]:Block[25659-25746]"
    }, {
      "left" : "work1[permutation[i]] -= jacobian[i][pj] * tmp;",
      "right" : "work1[permutation[i]] -= jacobian[i][pj] * tmp;",
      "info" : "ExpressionStatement[25129-25176]:ExpressionStatement[25681-25728]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[25221-25230]:ExpressionStatement[25773-25782]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[25243-25376]:ForStatement[25795-25928]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25280-25376]:Block[25832-25928]"
    }, {
      "left" : "double s = work1[permutation[j]];",
      "right" : "double s = work1[permutation[j]];",
      "info" : "VariableDeclarationStatement[25298-25331]:VariableDeclarationStatement[25850-25883]"
    }, {
      "left" : "sum2 += s * s;",
      "right" : "sum2 += s * s;",
      "info" : "ExpressionStatement[25348-25362]:ExpressionStatement[25900-25914]"
    }, {
      "left" : "double correction = fp / (delta * sum2);",
      "right" : "double correction = fp / (delta * sum2);",
      "info" : "VariableDeclarationStatement[25389-25429]:VariableDeclarationStatement[25941-25981]"
    }, {
      "left" : "if (fp > 0)",
      "right" : "if (fp > 0)",
      "info" : "IfStatement[25518-25670]:IfStatement[26070-26222]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25530-25591]:Block[26082-26143]"
    }, {
      "left" : "parl = Math.max(parl, lmPar);",
      "right" : "parl = Math.max(parl, lmPar);",
      "info" : "ExpressionStatement[25548-25577]:ExpressionStatement[26100-26129]"
    }, {
      "left" : "if (fp < 0)",
      "right" : "if (fp < 0)",
      "info" : "IfStatement[25597-25670]:IfStatement[26149-26222]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25609-25670]:Block[26161-26222]"
    }, {
      "left" : "paru = Math.min(paru, lmPar);",
      "right" : "paru = Math.min(paru, lmPar);",
      "info" : "ExpressionStatement[25627-25656]:ExpressionStatement[26179-26208]"
    }, {
      "left" : "lmPar = Math.max(parl, lmPar + correction);",
      "right" : "lmPar = Math.max(parl, lmPar + correction);",
      "info" : "ExpressionStatement[25738-25781]:ExpressionStatement[26290-26333]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26706-30576]:Block[27258-31128]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[26846-27127]:ForStatement[27398-27679]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26883-27127]:Block[27435-27679]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[26897-26921]:VariableDeclarationStatement[27449-27473]"
    }, {
      "left" : "for (int i = j + 1; i < solvedCols; ++i)",
      "right" : "for (int i = j + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[26934-27053]:ForStatement[27486-27605]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26975-27053]:Block[27527-27605]"
    }, {
      "left" : "jacobian[i][pj] = jacobian[j][permutation[i]];",
      "right" : "jacobian[i][pj] = jacobian[j][permutation[i]];",
      "info" : "ExpressionStatement[26993-27039]:ExpressionStatement[27545-27591]"
    }, {
      "left" : "lmDir[j] = diagR[pj];",
      "right" : "lmDir[j] = diagR[pj];",
      "info" : "ExpressionStatement[27066-27087]:ExpressionStatement[27618-27639]"
    }, {
      "left" : "work[j]  = qy[j];",
      "right" : "work[j]  = qy[j];",
      "info" : "ExpressionStatement[27100-27117]:ExpressionStatement[27652-27669]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[27204-29649]:ForStatement[27756-30201]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27241-29649]:Block[27793-30201]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[27391-27415]:VariableDeclarationStatement[27943-27967]"
    }, {
      "left" : "double dpj = diag[pj];",
      "right" : "double dpj = diag[pj];",
      "info" : "VariableDeclarationStatement[27428-27450]:VariableDeclarationStatement[27980-28002]"
    }, {
      "left" : "if (dpj != 0)",
      "right" : "if (dpj != 0)",
      "info" : "IfStatement[27463-27554]:IfStatement[28015-28106]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27477-27554]:Block[28029-28106]"
    }, {
      "left" : "Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);",
      "right" : "Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);",
      "info" : "ExpressionStatement[27495-27540]:ExpressionStatement[28047-28092]"
    }, {
      "left" : "lmDiag[j] = dpj;",
      "right" : "lmDiag[j] = dpj;",
      "info" : "ExpressionStatement[27567-27583]:ExpressionStatement[28119-28135]"
    }, {
      "left" : "double qtbpj = 0;",
      "right" : "double qtbpj = 0;",
      "info" : "VariableDeclarationStatement[27770-27787]:VariableDeclarationStatement[28322-28339]"
    }, {
      "left" : "for (int k = j; k < solvedCols; ++k)",
      "right" : "for (int k = j; k < solvedCols; ++k)",
      "info" : "ForStatement[27800-29418]:ForStatement[28352-29970]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27837-29418]:Block[28389-29970]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[27855-27879]:VariableDeclarationStatement[28407-28431]"
    }, {
      "left" : "if (lmDiag[k] != 0)",
      "right" : "if (lmDiag[k] != 0)",
      "info" : "IfStatement[28028-29404]:IfStatement[28580-29956]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28048-29404]:Block[28600-29956]"
    }, {
      "left" : "final double sin;",
      "right" : "final double sin;",
      "info" : "VariableDeclarationStatement[28071-28088]:VariableDeclarationStatement[28623-28640]"
    }, {
      "left" : "final double cos;",
      "right" : "final double cos;",
      "info" : "VariableDeclarationStatement[28109-28126]:VariableDeclarationStatement[28661-28678]"
    }, {
      "left" : "double rkk = jacobian[k][pk];",
      "right" : "double rkk = jacobian[k][pk];",
      "info" : "VariableDeclarationStatement[28147-28176]:VariableDeclarationStatement[28699-28728]"
    }, {
      "left" : "if (Math.abs(rkk) < Math.abs(lmDiag[k]))",
      "right" : "if (Math.abs(rkk) < Math.abs(lmDiag[k]))",
      "info" : "IfStatement[28197-28632]:IfStatement[28749-29184]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28238-28438]:Block[28790-28990]"
    }, {
      "left" : "final double cotan = rkk / lmDiag[k];",
      "right" : "final double cotan = rkk / lmDiag[k];",
      "info" : "VariableDeclarationStatement[28264-28301]:VariableDeclarationStatement[28816-28853]"
    }, {
      "left" : "sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);",
      "right" : "sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);",
      "info" : "ExpressionStatement[28326-28371]:ExpressionStatement[28878-28923]"
    }, {
      "left" : "cos   = sin * cotan;",
      "right" : "cos   = sin * cotan;",
      "info" : "ExpressionStatement[28396-28416]:ExpressionStatement[28948-28968]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28444-28632]:Block[28996-29184]"
    }, {
      "left" : "final double tan = lmDiag[k] / rkk;",
      "right" : "final double tan = lmDiag[k] / rkk;",
      "info" : "VariableDeclarationStatement[28470-28505]:VariableDeclarationStatement[29022-29057]"
    }, {
      "left" : "cos = 1.0 / Math.sqrt(1.0 + tan * tan);",
      "right" : "cos = 1.0 / Math.sqrt(1.0 + tan * tan);",
      "info" : "ExpressionStatement[28530-28569]:ExpressionStatement[29082-29121]"
    }, {
      "left" : "sin = cos * tan;",
      "right" : "sin = cos * tan;",
      "info" : "ExpressionStatement[28594-28610]:ExpressionStatement[29146-29162]"
    }, {
      "left" : "jacobian[k][pk] = cos * rkk + sin * lmDiag[k];",
      "right" : "jacobian[k][pk] = cos * rkk + sin * lmDiag[k];",
      "info" : "ExpressionStatement[28779-28825]:ExpressionStatement[29331-29377]"
    }, {
      "left" : "final double temp = cos * work[k] + sin * qtbpj;",
      "right" : "final double temp = cos * work[k] + sin * qtbpj;",
      "info" : "VariableDeclarationStatement[28846-28894]:VariableDeclarationStatement[29398-29446]"
    }, {
      "left" : "qtbpj = -sin * work[k] + cos * qtbpj;",
      "right" : "qtbpj = -sin * work[k] + cos * qtbpj;",
      "info" : "ExpressionStatement[28915-28952]:ExpressionStatement[29467-29504]"
    }, {
      "left" : "work[k] = temp;",
      "right" : "work[k] = temp;",
      "info" : "ExpressionStatement[28973-28988]:ExpressionStatement[29525-29540]"
    }, {
      "left" : "for (int i = k + 1; i < solvedCols; ++i)",
      "right" : "for (int i = k + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[29078-29385]:ForStatement[29630-29937]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29119-29385]:Block[29671-29937]"
    }, {
      "left" : "double rik = jacobian[i][pk];",
      "right" : "double rik = jacobian[i][pk];",
      "info" : "VariableDeclarationStatement[29145-29174]:VariableDeclarationStatement[29697-29726]"
    }, {
      "left" : "final double temp2 = cos * rik + sin * lmDiag[i];",
      "right" : "final double temp2 = cos * rik + sin * lmDiag[i];",
      "info" : "VariableDeclarationStatement[29199-29248]:VariableDeclarationStatement[29751-29800]"
    }, {
      "left" : "lmDiag[i] = -sin * rik + cos * lmDiag[i];",
      "right" : "lmDiag[i] = -sin * rik + cos * lmDiag[i];",
      "info" : "ExpressionStatement[29273-29314]:ExpressionStatement[29825-29866]"
    }, {
      "left" : "jacobian[i][pk] = temp2;",
      "right" : "jacobian[i][pk] = temp2;",
      "info" : "ExpressionStatement[29339-29363]:ExpressionStatement[29891-29915]"
    }, {
      "left" : "lmDiag[j] = jacobian[j][permutation[j]];",
      "right" : "lmDiag[j] = jacobian[j][permutation[j]];",
      "info" : "ExpressionStatement[29546-29586]:ExpressionStatement[30098-30138]"
    }, {
      "left" : "jacobian[j][permutation[j]] = lmDir[j];",
      "right" : "jacobian[j][permutation[j]] = lmDir[j];",
      "info" : "ExpressionStatement[29599-29638]:ExpressionStatement[30151-30190]"
    }, {
      "left" : "int nSing = solvedCols;",
      "right" : "int nSing = solvedCols;",
      "info" : "VariableDeclarationStatement[29780-29803]:VariableDeclarationStatement[30332-30355]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[29812-30043]:ForStatement[30364-30595]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29849-30043]:Block[30401-30595]"
    }, {
      "left" : "if ((lmDiag[j] == 0) && (nSing == solvedCols))",
      "right" : "if ((lmDiag[j] == 0) && (nSing == solvedCols))",
      "info" : "IfStatement[29863-29952]:IfStatement[30415-30504]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29910-29952]:Block[30462-30504]"
    }, {
      "left" : "nSing = j;",
      "right" : "nSing = j;",
      "info" : "ExpressionStatement[29928-29938]:ExpressionStatement[30480-30490]"
    }, {
      "left" : "if (nSing < solvedCols)",
      "right" : "if (nSing < solvedCols)",
      "info" : "IfStatement[29965-30033]:IfStatement[30517-30585]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29989-30033]:Block[30541-30585]"
    }, {
      "left" : "work[j] = 0;",
      "right" : "work[j] = 0;",
      "info" : "ExpressionStatement[30007-30019]:ExpressionStatement[30559-30571]"
    }, {
      "left" : "if (nSing > 0)",
      "right" : "if (nSing > 0)",
      "info" : "IfStatement[30052-30397]:IfStatement[30604-30949]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30067-30397]:Block[30619-30949]"
    }, {
      "left" : "for (int j = nSing - 1; j >= 0; --j)",
      "right" : "for (int j = nSing - 1; j >= 0; --j)",
      "info" : "ForStatement[30081-30387]:ForStatement[30633-30939]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30118-30387]:Block[30670-30939]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[30136-30160]:VariableDeclarationStatement[30688-30712]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[30177-30192]:VariableDeclarationStatement[30729-30744]"
    }, {
      "left" : "for (int i = j + 1; i < nSing; ++i)",
      "right" : "for (int i = j + 1; i < nSing; ++i)",
      "info" : "ForStatement[30209-30318]:ForStatement[30761-30870]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30245-30318]:Block[30797-30870]"
    }, {
      "left" : "sum += jacobian[i][pj] * work[i];",
      "right" : "sum += jacobian[i][pj] * work[i];",
      "info" : "ExpressionStatement[30267-30300]:ExpressionStatement[30819-30852]"
    }, {
      "left" : "work[j] = (work[j] - sum) / lmDiag[j];",
      "right" : "work[j] = (work[j] - sum) / lmDiag[j];",
      "info" : "ExpressionStatement[30335-30373]:ExpressionStatement[30887-30925]"
    }, {
      "left" : "for (int j = 0; j < lmDir.length; ++j)",
      "right" : "for (int j = 0; j < lmDir.length; ++j)",
      "info" : "ForStatement[30474-30569]:ForStatement[31026-31121]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30513-30569]:Block[31065-31121]"
    }, {
      "left" : "lmDir[permutation[j]] = work[j];",
      "right" : "lmDir[permutation[j]] = work[j];",
      "info" : "ExpressionStatement[30527-30559]:ExpressionStatement[31079-31111]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31867-34305]:Block[32419-34857]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[31905-32203]:ForStatement[32457-32755]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31936-32203]:Block[32488-32755]"
    }, {
      "left" : "permutation[k] = k;",
      "right" : "permutation[k] = k;",
      "info" : "ExpressionStatement[31950-31969]:ExpressionStatement[32502-32521]"
    }, {
      "left" : "double norm2 = 0;",
      "right" : "double norm2 = 0;",
      "info" : "VariableDeclarationStatement[31982-31999]:VariableDeclarationStatement[32534-32551]"
    }, {
      "left" : "for (int i = 0; i < jacobian.length; ++i)",
      "right" : "for (int i = 0; i < jacobian.length; ++i)",
      "info" : "ForStatement[32012-32150]:ForStatement[32564-32702]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32054-32150]:Block[32606-32702]"
    }, {
      "left" : "double akk = jacobian[i][k];",
      "right" : "double akk = jacobian[i][k];",
      "info" : "VariableDeclarationStatement[32072-32100]:VariableDeclarationStatement[32624-32652]"
    }, {
      "left" : "norm2 += akk * akk;",
      "right" : "norm2 += akk * akk;",
      "info" : "ExpressionStatement[32117-32136]:ExpressionStatement[32669-32688]"
    }, {
      "left" : "jacNorm[k] = Math.sqrt(norm2);",
      "right" : "jacNorm[k] = Math.sqrt(norm2);",
      "info" : "ExpressionStatement[32163-32193]:ExpressionStatement[32715-32745]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[32265-34270]:ForStatement[32817-34822]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32296-34270]:Block[32848-34822]"
    }, {
      "left" : "int nextColumn = -1;",
      "right" : "int nextColumn = -1;",
      "info" : "VariableDeclarationStatement[32388-32408]:VariableDeclarationStatement[32940-32960]"
    }, {
      "left" : "double ak2 = Double.NEGATIVE_INFINITY;",
      "right" : "double ak2 = Double.NEGATIVE_INFINITY;",
      "info" : "VariableDeclarationStatement[32421-32459]:VariableDeclarationStatement[32973-33011]"
    }, {
      "left" : "for (int i = k; i < cols; ++i)",
      "right" : "for (int i = k; i < cols; ++i)",
      "info" : "ForStatement[32472-33108]:ForStatement[33024-33660]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32503-33108]:Block[33055-33660]"
    }, {
      "left" : "double norm2 = 0;",
      "right" : "double norm2 = 0;",
      "info" : "VariableDeclarationStatement[32521-32538]:VariableDeclarationStatement[33073-33090]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[32555-32718]:ForStatement[33107-33270]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32597-32718]:Block[33149-33270]"
    }, {
      "left" : "double aki = jacobian[j][permutation[i]];",
      "right" : "double aki = jacobian[j][permutation[i]];",
      "info" : "VariableDeclarationStatement[32619-32660]:VariableDeclarationStatement[33171-33212]"
    }, {
      "left" : "norm2 += aki * aki;",
      "right" : "norm2 += aki * aki;",
      "info" : "ExpressionStatement[32681-32700]:ExpressionStatement[33233-33252]"
    }, {
      "left" : "if (Double.isInfinite(norm2) || Double.isNaN(norm2))",
      "right" : "if (Double.isInfinite(norm2) || Double.isNaN(norm2))",
      "info" : "IfStatement[32735-32965]:IfStatement[33287-33517]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32788-32965]:Block[33340-33517]"
    }, {
      "left" : "throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                            rows, cols);",
      "right" : "throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                            rows, cols);",
      "info" : "ThrowStatement[32810-32947]:ThrowStatement[33362-33499]"
    }, {
      "left" : "if (norm2 > ak2)",
      "right" : "if (norm2 > ak2)",
      "info" : "IfStatement[32982-33094]:IfStatement[33534-33646]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32999-33094]:Block[33551-33646]"
    }, {
      "left" : "nextColumn = i;",
      "right" : "nextColumn = i;",
      "info" : "ExpressionStatement[33021-33036]:ExpressionStatement[33573-33588]"
    }, {
      "left" : "ak2        = norm2;",
      "right" : "ak2        = norm2;",
      "info" : "ExpressionStatement[33057-33076]:ExpressionStatement[33609-33628]"
    }, {
      "left" : "if (ak2 <= qrRankingThreshold)",
      "right" : "if (ak2 <= qrRankingThreshold)",
      "info" : "IfStatement[33121-33217]:IfStatement[33673-33769]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33152-33217]:Block[33704-33769]"
    }, {
      "left" : "rank = k;",
      "right" : "rank = k;",
      "info" : "ExpressionStatement[33170-33179]:ExpressionStatement[33722-33731]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[33196-33203]:ReturnStatement[33748-33755]"
    }, {
      "left" : "int pk                  = permutation[nextColumn];",
      "right" : "int pk                  = permutation[nextColumn];",
      "info" : "VariableDeclarationStatement[33230-33280]:VariableDeclarationStatement[33782-33832]"
    }, {
      "left" : "permutation[nextColumn] = permutation[k];",
      "right" : "permutation[nextColumn] = permutation[k];",
      "info" : "ExpressionStatement[33293-33334]:ExpressionStatement[33845-33886]"
    }, {
      "left" : "permutation[k]          = pk;",
      "right" : "permutation[k]          = pk;",
      "info" : "ExpressionStatement[33347-33376]:ExpressionStatement[33899-33928]"
    }, {
      "left" : "double akk   = jacobian[k][pk];",
      "right" : "double akk   = jacobian[k][pk];",
      "info" : "VariableDeclarationStatement[33444-33475]:VariableDeclarationStatement[33996-34027]"
    }, {
      "left" : "double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);",
      "right" : "double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);",
      "info" : "VariableDeclarationStatement[33488-33548]:VariableDeclarationStatement[34040-34100]"
    }, {
      "left" : "double betak = 1.0 / (ak2 - akk * alpha);",
      "right" : "double betak = 1.0 / (ak2 - akk * alpha);",
      "info" : "VariableDeclarationStatement[33561-33602]:VariableDeclarationStatement[34113-34154]"
    }, {
      "left" : "beta[pk]     = betak;",
      "right" : "beta[pk]     = betak;",
      "info" : "ExpressionStatement[33615-33636]:ExpressionStatement[34167-34188]"
    }, {
      "left" : "diagR[pk]        = alpha;",
      "right" : "diagR[pk]        = alpha;",
      "info" : "ExpressionStatement[33694-33719]:ExpressionStatement[34246-34271]"
    }, {
      "left" : "jacobian[k][pk] -= alpha;",
      "right" : "jacobian[k][pk] -= alpha;",
      "info" : "ExpressionStatement[33732-33757]:ExpressionStatement[34284-34309]"
    }, {
      "left" : "for (int dk = cols - 1 - k; dk > 0; --dk)",
      "right" : "for (int dk = cols - 1 - k; dk > 0; --dk)",
      "info" : "ForStatement[33818-34259]:ForStatement[34370-34811]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33860-34259]:Block[34412-34811]"
    }, {
      "left" : "double gamma = 0;",
      "right" : "double gamma = 0;",
      "info" : "VariableDeclarationStatement[33878-33895]:VariableDeclarationStatement[34430-34447]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[33912-34054]:ForStatement[34464-34606]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33954-34054]:Block[34506-34606]"
    }, {
      "left" : "gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];",
      "right" : "gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];",
      "info" : "ExpressionStatement[33976-34036]:ExpressionStatement[34528-34588]"
    }, {
      "left" : "gamma *= betak;",
      "right" : "gamma *= betak;",
      "info" : "ExpressionStatement[34071-34086]:ExpressionStatement[34623-34638]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[34103-34245]:ForStatement[34655-34797]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34145-34245]:Block[34697-34797]"
    }, {
      "left" : "jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];",
      "right" : "jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];",
      "info" : "ExpressionStatement[34167-34227]:ExpressionStatement[34719-34779]"
    }, {
      "left" : "rank = solvedCols;",
      "right" : "rank = solvedCols;",
      "info" : "ExpressionStatement[34280-34298]:ExpressionStatement[34832-34850]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34497-34869]:Block[35049-35421]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[34507-34863]:ForStatement[35059-35415]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34538-34863]:Block[35090-35415]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[34552-34576]:VariableDeclarationStatement[35104-35128]"
    }, {
      "left" : "double gamma = 0;",
      "right" : "double gamma = 0;",
      "info" : "VariableDeclarationStatement[34589-34606]:VariableDeclarationStatement[35141-35158]"
    }, {
      "left" : "for (int i = k; i < rows; ++i)",
      "right" : "for (int i = k; i < rows; ++i)",
      "info" : "ForStatement[34619-34714]:ForStatement[35171-35266]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34650-34714]:Block[35202-35266]"
    }, {
      "left" : "gamma += jacobian[i][pk] * y[i];",
      "right" : "gamma += jacobian[i][pk] * y[i];",
      "info" : "ExpressionStatement[34668-34700]:ExpressionStatement[35220-35252]"
    }, {
      "left" : "gamma *= beta[pk];",
      "right" : "gamma *= beta[pk];",
      "info" : "ExpressionStatement[34727-34745]:ExpressionStatement[35279-35297]"
    }, {
      "left" : "for (int i = k; i < rows; ++i)",
      "right" : "for (int i = k; i < rows; ++i)",
      "info" : "ForStatement[34758-34853]:ForStatement[35310-35405]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34789-34853]:Block[35341-35405]"
    }, {
      "left" : "y[i] -= gamma * jacobian[i][pk];",
      "right" : "y[i] -= gamma * jacobian[i][pk];",
      "info" : "ExpressionStatement[34807-34839]:ExpressionStatement[35359-35391]"
    } ]
  },
  "interFileMappings" : { }
}