{
  "matchedElements" : [
 {
    "left" : "class : Reporter",
    "right" : "class : Reporter",
    "info" : "TypeDeclaration[1363-38214]:TypeDeclaration[1363-38345]"
  }, {
    "left" : "public checkedExceptionInvalid(t ) : void",
    "right" : "public checkedExceptionInvalid(t ) : void",
    "info" : "MethodDeclaration[1831-2037]:MethodDeclaration[1831-2037]"
  }, {
    "left" : "public cannotStubWithNullThrowable() : void",
    "right" : "public cannotStubWithNullThrowable() : void",
    "info" : "MethodDeclaration[2043-2197]:MethodDeclaration[2043-2197]"
  }, {
    "left" : "public unfinishedStubbing(location ) : void",
    "right" : "public unfinishedStubbing(location ) : void",
    "info" : "MethodDeclaration[2203-3015]:MethodDeclaration[2203-3015]"
  }, {
    "left" : "public incorrectUseOfApi() : void",
    "right" : "public incorrectUseOfApi() : void",
    "info" : "MethodDeclaration[3021-3643]:MethodDeclaration[3021-3643]"
  }, {
    "left" : "public missingMethodInvocation() : void",
    "right" : "public missingMethodInvocation() : void",
    "info" : "MethodDeclaration[3649-4358]:MethodDeclaration[3649-4358]"
  }, {
    "left" : "public unfinishedVerificationException(location ) : void",
    "right" : "public unfinishedVerificationException(location ) : void",
    "info" : "MethodDeclaration[4364-5055]:MethodDeclaration[4364-5055]"
  }, {
    "left" : "public notAMockPassedToVerify(type ) : void",
    "right" : "public notAMockPassedToVerify(type ) : void",
    "info" : "MethodDeclaration[5061-5578]:MethodDeclaration[5061-5578]"
  }, {
    "left" : "public nullPassedToVerify() : void",
    "right" : "public nullPassedToVerify() : void",
    "info" : "MethodDeclaration[5584-6124]:MethodDeclaration[5584-6124]"
  }, {
    "left" : "public notAMockPassedToWhenMethod() : void",
    "right" : "public notAMockPassedToWhenMethod() : void",
    "info" : "MethodDeclaration[6130-6419]:MethodDeclaration[6130-6419]"
  }, {
    "left" : "public nullPassedToWhenMethod() : void",
    "right" : "public nullPassedToWhenMethod() : void",
    "info" : "MethodDeclaration[6425-6789]:MethodDeclaration[6425-6789]"
  }, {
    "left" : "public mocksHaveToBePassedToVerifyNoMoreInteractions() : void",
    "right" : "public mocksHaveToBePassedToVerifyNoMoreInteractions() : void",
    "info" : "MethodDeclaration[6795-7174]:MethodDeclaration[6795-7174]"
  }, {
    "left" : "public notAMockPassedToVerifyNoMoreInteractions() : void",
    "right" : "public notAMockPassedToVerifyNoMoreInteractions() : void",
    "info" : "MethodDeclaration[7180-7554]:MethodDeclaration[7180-7554]"
  }, {
    "left" : "public nullPassedToVerifyNoMoreInteractions() : void",
    "right" : "public nullPassedToVerifyNoMoreInteractions() : void",
    "info" : "MethodDeclaration[7560-7913]:MethodDeclaration[7560-7913]"
  }, {
    "left" : "public notAMockPassedWhenCreatingInOrder() : void",
    "right" : "public notAMockPassedWhenCreatingInOrder() : void",
    "info" : "MethodDeclaration[7919-8246]:MethodDeclaration[7919-8246]"
  }, {
    "left" : "public nullPassedWhenCreatingInOrder() : void",
    "right" : "public nullPassedWhenCreatingInOrder() : void",
    "info" : "MethodDeclaration[8252-8578]:MethodDeclaration[8252-8578]"
  }, {
    "left" : "public mocksHaveToBePassedWhenCreatingInOrder() : void",
    "right" : "public mocksHaveToBePassedWhenCreatingInOrder() : void",
    "info" : "MethodDeclaration[8584-8910]:MethodDeclaration[8584-8910]"
  }, {
    "left" : "public inOrderRequiresFamiliarMock() : void",
    "right" : "public inOrderRequiresFamiliarMock() : void",
    "info" : "MethodDeclaration[8916-9263]:MethodDeclaration[8916-9263]"
  }, {
    "left" : "public invalidUseOfMatchers(expectedMatchersCount int, recordedMatchers ...) : void",
    "right" : "public invalidUseOfMatchers(expectedMatchersCount int, recordedMatchers ...) : void",
    "info" : "MethodDeclaration[9269-10194]:MethodDeclaration[9269-10194]"
  }, {
    "left" : "public incorrectUseOfAdditionalMatchers(additionalMatcherName , expectedSubMatchersCount int, matcherStack ) : void",
    "right" : "public incorrectUseOfAdditionalMatchers(additionalMatcherName , expectedSubMatchersCount int, matcherStack ) : void",
    "info" : "MethodDeclaration[10200-11340]:MethodDeclaration[10200-11340]"
  }, {
    "left" : "public stubPassedToVerify() : void",
    "right" : "public stubPassedToVerify() : void",
    "info" : "MethodDeclaration[11346-11646]:MethodDeclaration[11346-11646]"
  }, {
    "left" : "public reportNoSubMatchersFound(additionalMatcherName ) : void",
    "right" : "public reportNoSubMatchersFound(additionalMatcherName ) : void",
    "info" : "MethodDeclaration[11652-11932]:MethodDeclaration[11652-11932]"
  }, {
    "left" : "private locationsOf(matchers ...) : ",
    "right" : "private locationsOf(matchers ...) : ",
    "info" : "MethodDeclaration[11939-12229]:MethodDeclaration[11939-12229]"
  }, {
    "left" : "public argumentsAreDifferent(wanted , actual , actualLocation ) : void",
    "right" : "public argumentsAreDifferent(wanted , actual , actualLocation ) : void",
    "info" : "MethodDeclaration[12235-12695]:MethodDeclaration[12235-12695]"
  }, {
    "left" : "public wantedButNotInvoked(wanted ) : void",
    "right" : "public wantedButNotInvoked(wanted ) : void",
    "info" : "MethodDeclaration[12701-12849]:MethodDeclaration[12701-12849]"
  }, {
    "left" : "public wantedButNotInvoked(wanted , invocations ...) : void",
    "right" : "public wantedButNotInvoked(wanted , invocations ...) : void",
    "info" : "MethodDeclaration[12855-13682]:MethodDeclaration[12855-13682]"
  }, {
    "left" : "private createWantedButNotInvokedMessage(wanted ) : ",
    "right" : "private createWantedButNotInvokedMessage(wanted ) : ",
    "info" : "MethodDeclaration[13688-13936]:MethodDeclaration[13688-13936]"
  }, {
    "left" : "public wantedButNotInvokedInOrder(wanted , previous ...) : void",
    "right" : "public wantedButNotInvokedInOrder(wanted , previous ...) : void",
    "info" : "MethodDeclaration[13942-14432]:MethodDeclaration[13942-14432]"
  }, {
    "left" : "public tooManyActualInvocations(wantedCount int, actualCount int, wanted , firstUndesired ) : void",
    "right" : "public tooManyActualInvocations(wantedCount int, actualCount int, wanted , firstUndesired ) : void",
    "info" : "MethodDeclaration[14438-14730]:MethodDeclaration[14438-14730]"
  }, {
    "left" : "private createTooManyInvocationsMessage(wantedCount int, actualCount int, wanted , firstUndesired ) : ",
    "right" : "private createTooManyInvocationsMessage(wantedCount int, actualCount int, wanted , firstUndesired ) : ",
    "info" : "MethodDeclaration[14736-15221]:MethodDeclaration[14736-15221]"
  }, {
    "left" : "public neverWantedButInvoked(wanted , firstUndesired ) : void",
    "right" : "public neverWantedButInvoked(wanted , firstUndesired ) : void",
    "info" : "MethodDeclaration[15227-15576]:MethodDeclaration[15227-15576]"
  }, {
    "left" : "public tooManyActualInvocationsInOrder(wantedCount int, actualCount int, wanted , firstUndesired ) : void",
    "right" : "public tooManyActualInvocationsInOrder(wantedCount int, actualCount int, wanted , firstUndesired ) : void",
    "info" : "MethodDeclaration[15582-15950]:MethodDeclaration[15582-15950]"
  }, {
    "left" : "private createTooLittleInvocationsMessage(discrepancy , wanted , lastActualInvocation ) : ",
    "right" : "private createTooLittleInvocationsMessage(discrepancy , wanted , lastActualInvocation ) : ",
    "info" : "MethodDeclaration[15956-16598]:MethodDeclaration[15956-16598]"
  }, {
    "left" : "public tooLittleActualInvocations(discrepancy , wanted , lastActualLocation ) : void",
    "right" : "public tooLittleActualInvocations(discrepancy , wanted , lastActualLocation ) : void",
    "info" : "MethodDeclaration[16604-16920]:MethodDeclaration[16604-16920]"
  }, {
    "left" : "public tooLittleActualInvocationsInOrder(discrepancy , wanted , lastActualLocation ) : void",
    "right" : "public tooLittleActualInvocationsInOrder(discrepancy , wanted , lastActualLocation ) : void",
    "info" : "MethodDeclaration[16926-17316]:MethodDeclaration[16926-17316]"
  }, {
    "left" : "public noMoreInteractionsWanted(undesired , invocations ...) : void",
    "right" : "public noMoreInteractionsWanted(undesired , invocations ...) : void",
    "info" : "MethodDeclaration[17322-17855]:MethodDeclaration[17322-17874]"
  }, {
    "left" : "public noMoreInteractionsWantedInOrder(undesired ) : void",
    "right" : "public noMoreInteractionsWantedInOrder(undesired ) : void",
    "info" : "MethodDeclaration[17861-18206]:MethodDeclaration[17880-18244]"
  }, {
    "left" : "public cannotMockFinalClass(clazz ) : void",
    "right" : "public cannotMockFinalClass(clazz ) : void",
    "info" : "MethodDeclaration[18212-18546]:MethodDeclaration[18250-18584]"
  }, {
    "left" : "public cannotStubVoidMethodWithAReturnValue(methodName ) : void",
    "right" : "public cannotStubVoidMethodWithAReturnValue(methodName ) : void",
    "info" : "MethodDeclaration[18552-19679]:MethodDeclaration[18590-19717]"
  }, {
    "left" : "public onlyVoidMethodsCanBeSetToDoNothing() : void",
    "right" : "public onlyVoidMethodsCanBeSetToDoNothing() : void",
    "info" : "MethodDeclaration[19685-20190]:MethodDeclaration[19723-20228]"
  }, {
    "left" : "public wrongTypeOfReturnValue(expectedType , actualType , methodName ) : void",
    "right" : "public wrongTypeOfReturnValue(expectedType , actualType , methodName ) : void",
    "info" : "MethodDeclaration[20196-21095]:MethodDeclaration[20234-21133]"
  }, {
    "left" : "public wantedAtMostX(maxNumberOfInvocations int, foundSize int) : void",
    "right" : "public wantedAtMostX(maxNumberOfInvocations int, foundSize int) : void",
    "info" : "MethodDeclaration[21101-21305]:MethodDeclaration[21139-21343]"
  }, {
    "left" : "public misplacedArgumentMatcher(lastMatchers ...) : void",
    "right" : "public misplacedArgumentMatcher(lastMatchers ...) : void",
    "info" : "MethodDeclaration[21311-22280]:MethodDeclaration[21349-22318]"
  }, {
    "left" : "public smartNullPointerException(invocation , location ) : void",
    "right" : "public smartNullPointerException(invocation , location ) : void",
    "info" : "MethodDeclaration[22286-22670]:MethodDeclaration[22324-22708]"
  }, {
    "left" : "public noArgumentValueWasCaptured() : void",
    "right" : "public noArgumentValueWasCaptured() : void",
    "info" : "MethodDeclaration[22676-23432]:MethodDeclaration[22714-23470]"
  }, {
    "left" : "public extraInterfacesDoesNotAcceptNullParameters() : void",
    "right" : "public extraInterfacesDoesNotAcceptNullParameters() : void",
    "info" : "MethodDeclaration[23438-23624]:MethodDeclaration[23476-23662]"
  }, {
    "left" : "public extraInterfacesAcceptsOnlyInterfaces(wrongType ) : void",
    "right" : "public extraInterfacesAcceptsOnlyInterfaces(wrongType ) : void",
    "info" : "MethodDeclaration[23630-23927]:MethodDeclaration[23668-23965]"
  }, {
    "left" : "public extraInterfacesCannotContainMockedType(wrongType ) : void",
    "right" : "public extraInterfacesCannotContainMockedType(wrongType ) : void",
    "info" : "MethodDeclaration[23933-24308]:MethodDeclaration[23971-24346]"
  }, {
    "left" : "public extraInterfacesRequiresAtLeastOneInterface() : void",
    "right" : "public extraInterfacesRequiresAtLeastOneInterface() : void",
    "info" : "MethodDeclaration[24314-24500]:MethodDeclaration[24352-24538]"
  }, {
    "left" : "public mockedTypeIsInconsistentWithSpiedInstanceType(mockedType , spiedInstance ) : void",
    "right" : "public mockedTypeIsInconsistentWithSpiedInstanceType(mockedType , spiedInstance ) : void",
    "info" : "MethodDeclaration[24506-25182]:MethodDeclaration[24544-25220]"
  }, {
    "left" : "public cannotCallAbstractRealMethod() : void",
    "right" : "public cannotCallAbstractRealMethod() : void",
    "info" : "MethodDeclaration[25188-25578]:MethodDeclaration[25226-25616]"
  }, {
    "left" : "public cannotVerifyToString() : void",
    "right" : "public cannotVerifyToString() : void",
    "info" : "MethodDeclaration[25584-26258]:MethodDeclaration[25622-26296]"
  }, {
    "left" : "public moreThanOneAnnotationNotAllowed(fieldName ) : void",
    "right" : "public moreThanOneAnnotationNotAllowed(fieldName ) : void",
    "info" : "MethodDeclaration[26264-26627]:MethodDeclaration[26302-26665]"
  }, {
    "left" : "public unsupportedCombinationOfAnnotations(undesiredAnnotationOne , undesiredAnnotationTwo ) : void",
    "right" : "public unsupportedCombinationOfAnnotations(undesiredAnnotationOne , undesiredAnnotationTwo ) : void",
    "info" : "MethodDeclaration[26633-26942]:MethodDeclaration[26671-26980]"
  }, {
    "left" : "public cannotInitializeForSpyAnnotation(fieldName , details ...) : void",
    "right" : "public cannotInitializeForSpyAnnotation(fieldName , details ...) : void",
    "info" : "MethodDeclaration[26948-27633]:MethodDeclaration[26986-27671]"
  }, {
    "left" : "public cannotInitializeForInjectMocksAnnotation(fieldName , details ...) : void",
    "right" : "public cannotInitializeForInjectMocksAnnotation(fieldName , details ...) : void",
    "info" : "MethodDeclaration[27639-28399]:MethodDeclaration[27677-28437]"
  }, {
    "left" : "public atMostAndNeverShouldNotBeUsedWithTimeout() : void",
    "right" : "public atMostAndNeverShouldNotBeUsedWithTimeout() : void",
    "info" : "MethodDeclaration[28405-29050]:MethodDeclaration[28443-29088]"
  }, {
    "left" : "public fieldInitialisationThrewException(field , details ...) : void",
    "right" : "public fieldInitialisationThrewException(field , details ...) : void",
    "info" : "MethodDeclaration[29056-29567]:MethodDeclaration[29094-29605]"
  }, {
    "left" : "public invocationListenerDoesNotAcceptNullParameters() : void",
    "right" : "public invocationListenerDoesNotAcceptNullParameters() : void",
    "info" : "MethodDeclaration[29573-29733]:MethodDeclaration[29611-29771]"
  }, {
    "left" : "public invocationListenersRequiresAtLeastOneListener() : void",
    "right" : "public invocationListenersRequiresAtLeastOneListener() : void",
    "info" : "MethodDeclaration[29739-29898]:MethodDeclaration[29777-29936]"
  }, {
    "left" : "public invocationListenerThrewException(listener , listenerThrowable ) : void",
    "right" : "public invocationListenerThrewException(listener , listenerThrowable ) : void",
    "info" : "MethodDeclaration[29904-30290]:MethodDeclaration[29942-30328]"
  }, {
    "left" : "public cannotInjectDependency(field , matchingMock , details ...) : void",
    "right" : "public cannotInjectDependency(field , matchingMock , details ...) : void",
    "info" : "MethodDeclaration[30296-30834]:MethodDeclaration[30334-30872]"
  }, {
    "left" : "private exceptionCauseMessageIfAvailable(details ...) : ",
    "right" : "private exceptionCauseMessageIfAvailable(details ...) : ",
    "info" : "MethodDeclaration[30840-30962]:MethodDeclaration[30878-31093]"
  }, {
    "left" : "public mockedTypeIsInconsistentWithDelegatedInstanceType(mockedType , delegatedInstance ) : void",
    "right" : "public mockedTypeIsInconsistentWithDelegatedInstanceType(mockedType , delegatedInstance ) : void",
    "info" : "MethodDeclaration[30968-31660]:MethodDeclaration[31099-31791]"
  }, {
    "left" : "public spyAndDelegateAreMutuallyExclusive() : void",
    "right" : "public spyAndDelegateAreMutuallyExclusive() : void",
    "info" : "MethodDeclaration[31666-31879]:MethodDeclaration[31797-32010]"
  }, {
    "left" : "public invalidArgumentRangeAtIdentityAnswerCreationTime() : void",
    "right" : "public invalidArgumentRangeAtIdentityAnswerCreationTime() : void",
    "info" : "MethodDeclaration[31885-32274]:MethodDeclaration[32016-32405]"
  }, {
    "left" : "public invalidArgumentPositionRangeAtInvocationTime(invocation , willReturnLastParameter boolean, argumentIndex int) : int",
    "right" : "public invalidArgumentPositionRangeAtInvocationTime(invocation , willReturnLastParameter boolean, argumentIndex int) : int",
    "info" : "MethodDeclaration[32280-33225]:MethodDeclaration[32411-33356]"
  }, {
    "left" : "private possibleArgumentTypesOf(invocation ) : ",
    "right" : "private possibleArgumentTypesOf(invocation ) : ",
    "info" : "MethodDeclaration[33231-34191]:MethodDeclaration[33362-34322]"
  }, {
    "left" : "public wrongTypeOfArgumentToReturn(invocation , expectedType , actualType , argumentIndex int) : void",
    "right" : "public wrongTypeOfArgumentToReturn(invocation , expectedType , actualType , argumentIndex int) : void",
    "info" : "MethodDeclaration[34197-35652]:MethodDeclaration[34328-35783]"
  }, {
    "left" : "public defaultAnswerDoesNotAcceptNullParameter() : void",
    "right" : "public defaultAnswerDoesNotAcceptNullParameter() : void",
    "info" : "MethodDeclaration[35658-35805]:MethodDeclaration[35789-35936]"
  }, {
    "left" : "public serializableWontWorkForObjectsThatDontImplementSerializable(classToMock ) : void",
    "right" : "public serializableWontWorkForObjectsThatDontImplementSerializable(classToMock ) : void",
    "info" : "MethodDeclaration[35811-36605]:MethodDeclaration[35942-36736]"
  }, {
    "left" : "public delegatedMethodHasWrongReturnType(mockMethod , delegateMethod , mock , delegate ) : void",
    "right" : "public delegatedMethodHasWrongReturnType(mockMethod , delegateMethod , mock , delegate ) : void",
    "info" : "MethodDeclaration[36611-37327]:MethodDeclaration[36742-37458]"
  }, {
    "left" : "public delegatedMethodDoesNotExistOnDelegate(mockMethod , mock , delegate ) : void",
    "right" : "public delegatedMethodDoesNotExistOnDelegate(mockMethod , mock , delegate ) : void",
    "info" : "MethodDeclaration[37330-37884]:MethodDeclaration[37461-38015]"
  }, {
    "left" : "public usingConstructorWithFancySerializable(mode ) : void",
    "right" : "public usingConstructorWithFancySerializable(mode ) : void",
    "info" : "MethodDeclaration[37890-38102]:MethodDeclaration[38021-38233]"
  }, {
    "left" : "private safelyGetMockName(mock ) : ",
    "right" : "private safelyGetMockName(mock ) : ",
    "info" : "MethodDeclaration[38108-38212]:MethodDeclaration[38239-38343]"
  } ],
  "mappings" : [
 {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[1802-1808]:Modifier[1802-1808]"
  }, {
    "left" : "class",
    "right" : "class",
    "info" : "TYPE_DECLARATION_KIND[1809-1814]:TYPE_DECLARATION_KIND[1809-1814]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[1831-1837]:Modifier[1831-1837]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[1838-1842]:PrimitiveType[1838-1842]"
  }, {
    "left" : "checkedExceptionInvalid",
    "right" : "checkedExceptionInvalid",
    "info" : "SimpleName[1843-1866]:SimpleName[1843-1866]"
  }, {
    "left" : "Throwable t",
    "right" : "Throwable t",
    "info" : "SingleVariableDeclaration[1867-1878]:SingleVariableDeclaration[1867-1878]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[1880-2037]:Block[1880-2037]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n        ));",
    "info" : "ThrowStatement[1890-2031]:ThrowStatement[1890-2031]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[2043-2049]:Modifier[2043-2049]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[2050-2054]:PrimitiveType[2050-2054]"
  }, {
    "left" : "cannotStubWithNullThrowable",
    "right" : "cannotStubWithNullThrowable",
    "info" : "SimpleName[2055-2082]:SimpleName[2055-2082]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[2085-2197]:Block[2085-2197]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n        ));",
    "info" : "ThrowStatement[2095-2190]:ThrowStatement[2095-2190]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[2203-2209]:Modifier[2203-2209]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[2210-2214]:PrimitiveType[2210-2214]"
  }, {
    "left" : "unfinishedStubbing",
    "right" : "unfinishedStubbing",
    "info" : "SimpleName[2215-2233]:SimpleName[2215-2233]"
  }, {
    "left" : "Location location",
    "right" : "Location location",
    "info" : "SingleVariableDeclaration[2234-2251]:SingleVariableDeclaration[2234-2251]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[2253-3015]:Block[2253-3015]"
  }, {
    "left" : "throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \" 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed\",\n                \"\"\n        ));",
    "right" : "throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \" 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[2263-3009]:ThrowStatement[2263-3009]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[3021-3027]:Modifier[3021-3027]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[3028-3032]:PrimitiveType[3028-3032]"
  }, {
    "left" : "incorrectUseOfApi",
    "right" : "incorrectUseOfApi",
    "info" : "SimpleName[3033-3050]:SimpleName[3033-3050]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[3053-3643]:Block[3053-3643]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Incorrect use of API detected here:\",\n                new LocationImpl(),\n                \"\",\n                \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                \"Examples of correct usage:\",\n                \"    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);\",\n                \"    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);\",\n                \"\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Incorrect use of API detected here:\",\n                new LocationImpl(),\n                \"\",\n                \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                \"Examples of correct usage:\",\n                \"    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);\",\n                \"    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[3063-3637]:ThrowStatement[3063-3637]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[3649-3655]:Modifier[3649-3655]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[3656-3660]:PrimitiveType[3656-3660]"
  }, {
    "left" : "missingMethodInvocation",
    "right" : "missingMethodInvocation",
    "info" : "SimpleName[3661-3684]:SimpleName[3661-3684]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[3687-4358]:Block[3687-4358]"
  }, {
    "left" : "throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be 'a method call on a mock'.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"   \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"2. inside when() you don't call method on mock but on some other object.\",\n                \"\"\n        ));",
    "right" : "throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be 'a method call on a mock'.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"   \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"2. inside when() you don't call method on mock but on some other object.\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[3697-4352]:ThrowStatement[3697-4352]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[4364-4370]:Modifier[4364-4370]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[4371-4375]:PrimitiveType[4371-4375]"
  }, {
    "left" : "unfinishedVerificationException",
    "right" : "unfinishedVerificationException",
    "info" : "SimpleName[4376-4407]:SimpleName[4376-4407]"
  }, {
    "left" : "Location location",
    "right" : "Location location",
    "info" : "SingleVariableDeclaration[4408-4425]:SingleVariableDeclaration[4408-4425]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[4427-5055]:Block[4427-5055]"
  }, {
    "left" : "UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));",
    "right" : "UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));",
    "info" : "VariableDeclarationStatement[4437-5023]:VariableDeclarationStatement[4437-5023]"
  }, {
    "left" : "throw exception;",
    "right" : "throw exception;",
    "info" : "ThrowStatement[5033-5049]:ThrowStatement[5033-5049]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[5061-5067]:Modifier[5061-5067]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[5068-5072]:PrimitiveType[5068-5072]"
  }, {
    "left" : "notAMockPassedToVerify",
    "right" : "notAMockPassedToVerify",
    "info" : "SimpleName[5073-5095]:SimpleName[5073-5095]"
  }, {
    "left" : "Class type",
    "right" : "Class type",
    "info" : "SingleVariableDeclaration[5096-5106]:SingleVariableDeclaration[5096-5106]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[5108-5578]:Block[5108-5578]"
  }, {
    "left" : "throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));",
    "right" : "throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));",
    "info" : "ThrowStatement[5118-5572]:ThrowStatement[5118-5572]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[5584-5590]:Modifier[5584-5590]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[5591-5595]:PrimitiveType[5591-5595]"
  }, {
    "left" : "nullPassedToVerify",
    "right" : "nullPassedToVerify",
    "info" : "SimpleName[5596-5614]:SimpleName[5596-5614]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[5617-6124]:Block[5617-6124]"
  }, {
    "left" : "throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"    not: verify(mock.someMethod());\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));",
    "right" : "throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"    not: verify(mock.someMethod());\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));",
    "info" : "ThrowStatement[5627-6118]:ThrowStatement[5627-6118]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[6130-6136]:Modifier[6130-6136]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[6137-6141]:PrimitiveType[6137-6141]"
  }, {
    "left" : "notAMockPassedToWhenMethod",
    "right" : "notAMockPassedToWhenMethod",
    "info" : "SimpleName[6142-6168]:SimpleName[6142-6168]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6171-6419]:Block[6171-6419]"
  }, {
    "left" : "throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));",
    "right" : "throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));",
    "info" : "ThrowStatement[6181-6413]:ThrowStatement[6181-6413]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[6425-6431]:Modifier[6425-6431]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[6432-6436]:PrimitiveType[6432-6436]"
  }, {
    "left" : "nullPassedToWhenMethod",
    "right" : "nullPassedToWhenMethod",
    "info" : "SimpleName[6437-6459]:SimpleName[6437-6459]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6462-6789]:Block[6462-6789]"
  }, {
    "left" : "throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));",
    "right" : "throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));",
    "info" : "ThrowStatement[6472-6783]:ThrowStatement[6472-6783]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[6795-6801]:Modifier[6795-6801]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[6802-6806]:PrimitiveType[6802-6806]"
  }, {
    "left" : "mocksHaveToBePassedToVerifyNoMoreInteractions",
    "right" : "mocksHaveToBePassedToVerifyNoMoreInteractions",
    "info" : "SimpleName[6807-6852]:SimpleName[6807-6852]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6855-7174]:Block[6855-7174]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[6865-7168]:ThrowStatement[6865-7168]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[7180-7186]:Modifier[7180-7186]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[7187-7191]:PrimitiveType[7187-7191]"
  }, {
    "left" : "notAMockPassedToVerifyNoMoreInteractions",
    "right" : "notAMockPassedToVerifyNoMoreInteractions",
    "info" : "SimpleName[7192-7232]:SimpleName[7192-7232]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7235-7554]:Block[7235-7554]"
  }, {
    "left" : "throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));",
    "right" : "throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[7245-7548]:ThrowStatement[7245-7548]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[7560-7566]:Modifier[7560-7566]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[7567-7571]:PrimitiveType[7567-7571]"
  }, {
    "left" : "nullPassedToVerifyNoMoreInteractions",
    "right" : "nullPassedToVerifyNoMoreInteractions",
    "info" : "SimpleName[7572-7608]:SimpleName[7572-7608]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7611-7913]:Block[7611-7913]"
  }, {
    "left" : "throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));",
    "right" : "throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));",
    "info" : "ThrowStatement[7621-7907]:ThrowStatement[7621-7907]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[7919-7925]:Modifier[7919-7925]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[7926-7930]:PrimitiveType[7926-7930]"
  }, {
    "left" : "notAMockPassedWhenCreatingInOrder",
    "right" : "notAMockPassedWhenCreatingInOrder",
    "info" : "SimpleName[7931-7964]:SimpleName[7931-7964]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7967-8246]:Block[7967-8246]"
  }, {
    "left" : "throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));",
    "right" : "throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));",
    "info" : "ThrowStatement[7977-8240]:ThrowStatement[7977-8240]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[8252-8258]:Modifier[8252-8258]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[8259-8263]:PrimitiveType[8259-8263]"
  }, {
    "left" : "nullPassedWhenCreatingInOrder",
    "right" : "nullPassedWhenCreatingInOrder",
    "info" : "SimpleName[8264-8293]:SimpleName[8264-8293]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8296-8578]:Block[8296-8578]"
  }, {
    "left" : "throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));",
    "right" : "throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));",
    "info" : "ThrowStatement[8306-8572]:ThrowStatement[8306-8572]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[8584-8590]:Modifier[8584-8590]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[8591-8595]:PrimitiveType[8591-8595]"
  }, {
    "left" : "mocksHaveToBePassedWhenCreatingInOrder",
    "right" : "mocksHaveToBePassedWhenCreatingInOrder",
    "info" : "SimpleName[8596-8634]:SimpleName[8596-8634]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8637-8910]:Block[8637-8910]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));",
    "info" : "ThrowStatement[8647-8904]:ThrowStatement[8647-8904]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[8916-8922]:Modifier[8916-8922]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[8923-8927]:PrimitiveType[8923-8927]"
  }, {
    "left" : "inOrderRequiresFamiliarMock",
    "right" : "inOrderRequiresFamiliarMock",
    "info" : "SimpleName[8928-8955]:SimpleName[8928-8955]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8958-9263]:Block[8958-9263]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n        ));",
    "info" : "ThrowStatement[8968-9257]:ThrowStatement[8968-9257]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[9269-9275]:Modifier[9269-9275]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[9276-9280]:PrimitiveType[9276-9280]"
  }, {
    "left" : "invalidUseOfMatchers",
    "right" : "invalidUseOfMatchers",
    "info" : "SimpleName[9281-9301]:SimpleName[9281-9301]"
  }, {
    "left" : "int expectedMatchersCount",
    "right" : "int expectedMatchersCount",
    "info" : "SingleVariableDeclaration[9302-9327]:SingleVariableDeclaration[9302-9327]"
  }, {
    "left" : "List<LocalizedMatcher> recordedMatchers",
    "right" : "List<LocalizedMatcher> recordedMatchers",
    "info" : "SingleVariableDeclaration[9329-9368]:SingleVariableDeclaration[9329-9368]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[9370-10194]:Block[9370-10194]"
  }, {
    "left" : "throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n                        locationsOf(recordedMatchers),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\",\n                \"\"\n        ));",
    "right" : "throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n                        locationsOf(recordedMatchers),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[9380-10188]:ThrowStatement[9380-10188]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[10200-10206]:Modifier[10200-10206]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[10207-10211]:PrimitiveType[10207-10211]"
  }, {
    "left" : "incorrectUseOfAdditionalMatchers",
    "right" : "incorrectUseOfAdditionalMatchers",
    "info" : "SimpleName[10212-10244]:SimpleName[10212-10244]"
  }, {
    "left" : "String additionalMatcherName",
    "right" : "String additionalMatcherName",
    "info" : "SingleVariableDeclaration[10245-10273]:SingleVariableDeclaration[10245-10273]"
  }, {
    "left" : "int expectedSubMatchersCount",
    "right" : "int expectedSubMatchersCount",
    "info" : "SingleVariableDeclaration[10275-10303]:SingleVariableDeclaration[10275-10303]"
  }, {
    "left" : "Collection<LocalizedMatcher> matcherStack",
    "right" : "Collection<LocalizedMatcher> matcherStack",
    "info" : "SingleVariableDeclaration[10305-10346]:SingleVariableDeclaration[10305-10346]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[10348-11340]:Block[10348-11340]"
  }, {
    "left" : "throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n                new LocationImpl(),\n                \"\",\n                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n                locationsOf(matcherStack),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n                \"\"\n        ));",
    "right" : "throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n                new LocationImpl(),\n                \"\",\n                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n                locationsOf(matcherStack),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[10358-11334]:ThrowStatement[10358-11334]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[11346-11352]:Modifier[11346-11352]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[11353-11357]:PrimitiveType[11353-11357]"
  }, {
    "left" : "stubPassedToVerify",
    "right" : "stubPassedToVerify",
    "info" : "SimpleName[11358-11376]:SimpleName[11358-11376]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[11379-11646]:Block[11379-11646]"
  }, {
    "left" : "throw new CannotVerifyStubOnlyMock(join(\n                \"Argument passed to verify() is a stubOnly() mock, not a full blown mock!\",\n                \"If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.\"\n        ));",
    "right" : "throw new CannotVerifyStubOnlyMock(join(\n                \"Argument passed to verify() is a stubOnly() mock, not a full blown mock!\",\n                \"If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.\"\n        ));",
    "info" : "ThrowStatement[11389-11640]:ThrowStatement[11389-11640]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[11652-11658]:Modifier[11652-11658]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[11659-11663]:PrimitiveType[11659-11663]"
  }, {
    "left" : "reportNoSubMatchersFound",
    "right" : "reportNoSubMatchersFound",
    "info" : "SimpleName[11664-11688]:SimpleName[11664-11688]"
  }, {
    "left" : "String additionalMatcherName",
    "right" : "String additionalMatcherName",
    "info" : "SingleVariableDeclaration[11689-11717]:SingleVariableDeclaration[11689-11717]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[11719-11932]:Block[11719-11932]"
  }, {
    "left" : "throw new InvalidUseOfMatchersException(join(\n                \"No matchers found for additional matcher \" + additionalMatcherName,\n                new LocationImpl(),\n                \"\"\n        ));",
    "right" : "throw new InvalidUseOfMatchersException(join(\n                \"No matchers found for additional matcher \" + additionalMatcherName,\n                new LocationImpl(),\n                \"\"\n        ));",
    "info" : "ThrowStatement[11729-11926]:ThrowStatement[11729-11926]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[11939-11946]:Modifier[11939-11946]"
  }, {
    "left" : "Object",
    "right" : "Object",
    "info" : "SimpleType[11947-11953]:SimpleType[11947-11953]"
  }, {
    "left" : "locationsOf",
    "right" : "locationsOf",
    "info" : "SimpleName[11954-11965]:SimpleName[11954-11965]"
  }, {
    "left" : "Collection<LocalizedMatcher> matchers",
    "right" : "Collection<LocalizedMatcher> matchers",
    "info" : "SingleVariableDeclaration[11966-12003]:SingleVariableDeclaration[11966-12003]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12005-12229]:Block[12005-12229]"
  }, {
    "left" : "List<String> description = new ArrayList<String>();",
    "right" : "List<String> description = new ArrayList<String>();",
    "info" : "VariableDeclarationStatement[12015-12066]:VariableDeclarationStatement[12015-12066]"
  }, {
    "left" : "for (LocalizedMatcher matcher : matchers)\n            description.add(matcher.getLocation().toString());",
    "right" : "for (LocalizedMatcher matcher : matchers)\n            description.add(matcher.getLocation().toString());",
    "info" : "EnhancedForStatement[12075-12179]:EnhancedForStatement[12075-12179]"
  }, {
    "left" : "description.add(matcher.getLocation().toString());",
    "right" : "description.add(matcher.getLocation().toString());",
    "info" : "ExpressionStatement[12129-12179]:ExpressionStatement[12129-12179]"
  }, {
    "left" : "return join(description.toArray());",
    "right" : "return join(description.toArray());",
    "info" : "ReturnStatement[12188-12223]:ReturnStatement[12188-12223]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[12235-12241]:Modifier[12235-12241]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[12242-12246]:PrimitiveType[12242-12246]"
  }, {
    "left" : "argumentsAreDifferent",
    "right" : "argumentsAreDifferent",
    "info" : "SimpleName[12247-12268]:SimpleName[12247-12268]"
  }, {
    "left" : "String wanted",
    "right" : "String wanted",
    "info" : "SingleVariableDeclaration[12269-12282]:SingleVariableDeclaration[12269-12282]"
  }, {
    "left" : "String actual",
    "right" : "String actual",
    "info" : "SingleVariableDeclaration[12284-12297]:SingleVariableDeclaration[12284-12297]"
  }, {
    "left" : "Location actualLocation",
    "right" : "Location actualLocation",
    "info" : "SingleVariableDeclaration[12299-12322]:SingleVariableDeclaration[12299-12322]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12324-12695]:Block[12324-12695]"
  }, {
    "left" : "String message = join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new LocationImpl(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n        );",
    "right" : "String message = join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new LocationImpl(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n        );",
    "info" : "VariableDeclarationStatement[12334-12601]:VariableDeclarationStatement[12334-12601]"
  }, {
    "left" : "throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);",
    "right" : "throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);",
    "info" : "ThrowStatement[12611-12689]:ThrowStatement[12611-12689]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[12701-12707]:Modifier[12701-12707]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[12708-12712]:PrimitiveType[12708-12712]"
  }, {
    "left" : "wantedButNotInvoked",
    "right" : "wantedButNotInvoked",
    "info" : "SimpleName[12713-12732]:SimpleName[12713-12732]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[12733-12759]:SingleVariableDeclaration[12733-12759]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12761-12849]:Block[12761-12849]"
  }, {
    "left" : "throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));",
    "right" : "throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));",
    "info" : "ThrowStatement[12771-12843]:ThrowStatement[12771-12843]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[12855-12861]:Modifier[12855-12861]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[12862-12866]:PrimitiveType[12862-12866]"
  }, {
    "left" : "wantedButNotInvoked",
    "right" : "wantedButNotInvoked",
    "info" : "SimpleName[12867-12886]:SimpleName[12867-12886]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[12887-12913]:SingleVariableDeclaration[12887-12913]"
  }, {
    "left" : "List<? extends DescribedInvocation> invocations",
    "right" : "List<? extends DescribedInvocation> invocations",
    "info" : "SingleVariableDeclaration[12915-12962]:SingleVariableDeclaration[12915-12962]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12964-13682]:Block[12964-13682]"
  }, {
    "left" : "String allInvocations;",
    "right" : "String allInvocations;",
    "info" : "VariableDeclarationStatement[12974-12996]:VariableDeclarationStatement[12974-12996]"
  }, {
    "left" : "if (invocations.isEmpty())",
    "right" : "if (invocations.isEmpty())",
    "info" : "IfStatement[13005-13543]:IfStatement[13005-13543]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13032-13132]:Block[13032-13132]"
  }, {
    "left" : "allInvocations = \"Actually, there were zero interactions with this mock.\\n\";",
    "right" : "allInvocations = \"Actually, there were zero interactions with this mock.\\n\";",
    "info" : "ExpressionStatement[13046-13122]:ExpressionStatement[13046-13122]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13138-13543]:Block[13138-13543]"
  }, {
    "left" : "StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");",
    "right" : "StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");",
    "info" : "VariableDeclarationStatement[13152-13251]:VariableDeclarationStatement[13152-13251]"
  }, {
    "left" : "for (DescribedInvocation i : invocations)",
    "right" : "for (DescribedInvocation i : invocations)",
    "info" : "EnhancedForStatement[13264-13489]:EnhancedForStatement[13264-13489]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13306-13489]:Block[13306-13489]"
  }, {
    "left" : "sb.append(i.toString())\n                        .append(\"\\n\")\n                        .append(i.getLocation())\n                        .append(\"\\n\\n\");",
    "right" : "sb.append(i.toString())\n                        .append(\"\\n\")\n                        .append(i.getLocation())\n                        .append(\"\\n\\n\");",
    "info" : "ExpressionStatement[13324-13475]:ExpressionStatement[13324-13475]"
  }, {
    "left" : "allInvocations = sb.toString();",
    "right" : "allInvocations = sb.toString();",
    "info" : "ExpressionStatement[13502-13533]:ExpressionStatement[13502-13533]"
  }, {
    "left" : "String message = createWantedButNotInvokedMessage(wanted);",
    "right" : "String message = createWantedButNotInvokedMessage(wanted);",
    "info" : "VariableDeclarationStatement[13553-13611]:VariableDeclarationStatement[13553-13611]"
  }, {
    "left" : "throw new WantedButNotInvoked(message + allInvocations);",
    "right" : "throw new WantedButNotInvoked(message + allInvocations);",
    "info" : "ThrowStatement[13620-13676]:ThrowStatement[13620-13676]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[13688-13695]:Modifier[13688-13695]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[13696-13702]:SimpleType[13696-13702]"
  }, {
    "left" : "createWantedButNotInvokedMessage",
    "right" : "createWantedButNotInvokedMessage",
    "info" : "SimpleName[13703-13735]:SimpleName[13703-13735]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[13736-13762]:SingleVariableDeclaration[13736-13762]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13764-13936]:Block[13764-13936]"
  }, {
    "left" : "return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"\"\n        );",
    "right" : "return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"\"\n        );",
    "info" : "ReturnStatement[13774-13930]:ReturnStatement[13774-13930]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[13942-13948]:Modifier[13942-13948]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[13949-13953]:PrimitiveType[13949-13953]"
  }, {
    "left" : "wantedButNotInvokedInOrder",
    "right" : "wantedButNotInvokedInOrder",
    "info" : "SimpleName[13954-13980]:SimpleName[13954-13980]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[13981-14007]:SingleVariableDeclaration[13981-14007]"
  }, {
    "left" : "DescribedInvocation previous",
    "right" : "DescribedInvocation previous",
    "info" : "SingleVariableDeclaration[14009-14037]:SingleVariableDeclaration[14009-14037]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14039-14432]:Block[14039-14432]"
  }, {
    "left" : "throw new VerificationInOrderFailure(join(\n                \"Verification in order failure\",\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"Wanted anywhere AFTER following interaction:\",\n                previous.toString(),\n                previous.getLocation(),\n                \"\"\n        ));",
    "right" : "throw new VerificationInOrderFailure(join(\n                \"Verification in order failure\",\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"Wanted anywhere AFTER following interaction:\",\n                previous.toString(),\n                previous.getLocation(),\n                \"\"\n        ));",
    "info" : "ThrowStatement[14049-14426]:ThrowStatement[14049-14426]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[14438-14444]:Modifier[14438-14444]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[14445-14449]:PrimitiveType[14445-14449]"
  }, {
    "left" : "tooManyActualInvocations",
    "right" : "tooManyActualInvocations",
    "info" : "SimpleName[14450-14474]:SimpleName[14450-14474]"
  }, {
    "left" : "int wantedCount",
    "right" : "int wantedCount",
    "info" : "SingleVariableDeclaration[14475-14490]:SingleVariableDeclaration[14475-14490]"
  }, {
    "left" : "int actualCount",
    "right" : "int actualCount",
    "info" : "SingleVariableDeclaration[14492-14507]:SingleVariableDeclaration[14492-14507]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[14509-14535]:SingleVariableDeclaration[14509-14535]"
  }, {
    "left" : "Location firstUndesired",
    "right" : "Location firstUndesired",
    "info" : "SingleVariableDeclaration[14537-14560]:SingleVariableDeclaration[14537-14560]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14562-14730]:Block[14562-14730]"
  }, {
    "left" : "String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);",
    "right" : "String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);",
    "info" : "VariableDeclarationStatement[14572-14671]:VariableDeclarationStatement[14572-14671]"
  }, {
    "left" : "throw new TooManyActualInvocations(message);",
    "right" : "throw new TooManyActualInvocations(message);",
    "info" : "ThrowStatement[14680-14724]:ThrowStatement[14680-14724]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[14736-14743]:Modifier[14736-14743]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[14744-14750]:SimpleType[14744-14750]"
  }, {
    "left" : "createTooManyInvocationsMessage",
    "right" : "createTooManyInvocationsMessage",
    "info" : "SimpleName[14751-14782]:SimpleName[14751-14782]"
  }, {
    "left" : "int wantedCount",
    "right" : "int wantedCount",
    "info" : "SingleVariableDeclaration[14783-14798]:SingleVariableDeclaration[14783-14798]"
  }, {
    "left" : "int actualCount",
    "right" : "int actualCount",
    "info" : "SingleVariableDeclaration[14800-14815]:SingleVariableDeclaration[14800-14815]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[14817-14843]:SingleVariableDeclaration[14817-14843]"
  }, {
    "left" : "Location firstUndesired",
    "right" : "Location firstUndesired",
    "info" : "SingleVariableDeclaration[14896-14919]:SingleVariableDeclaration[14896-14919]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14921-15221]:Block[14921-15221]"
  }, {
    "left" : "return join(\n                wanted.toString(),\n                \"Wanted \" + pluralize(wantedCount) + \":\",\n                new LocationImpl(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );",
    "right" : "return join(\n                wanted.toString(),\n                \"Wanted \" + pluralize(wantedCount) + \":\",\n                new LocationImpl(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );",
    "info" : "ReturnStatement[14931-15215]:ReturnStatement[14931-15215]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[15227-15233]:Modifier[15227-15233]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[15234-15238]:PrimitiveType[15234-15238]"
  }, {
    "left" : "neverWantedButInvoked",
    "right" : "neverWantedButInvoked",
    "info" : "SimpleName[15239-15260]:SimpleName[15239-15260]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[15261-15287]:SingleVariableDeclaration[15261-15287]"
  }, {
    "left" : "Location firstUndesired",
    "right" : "Location firstUndesired",
    "info" : "SingleVariableDeclaration[15289-15312]:SingleVariableDeclaration[15289-15312]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[15314-15576]:Block[15314-15576]"
  }, {
    "left" : "throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new LocationImpl(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));",
    "right" : "throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new LocationImpl(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));",
    "info" : "ThrowStatement[15324-15570]:ThrowStatement[15324-15570]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[15582-15588]:Modifier[15582-15588]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[15589-15593]:PrimitiveType[15589-15593]"
  }, {
    "left" : "tooManyActualInvocationsInOrder",
    "right" : "tooManyActualInvocationsInOrder",
    "info" : "SimpleName[15594-15625]:SimpleName[15594-15625]"
  }, {
    "left" : "int wantedCount",
    "right" : "int wantedCount",
    "info" : "SingleVariableDeclaration[15626-15641]:SingleVariableDeclaration[15626-15641]"
  }, {
    "left" : "int actualCount",
    "right" : "int actualCount",
    "info" : "SingleVariableDeclaration[15643-15658]:SingleVariableDeclaration[15643-15658]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[15660-15686]:SingleVariableDeclaration[15660-15686]"
  }, {
    "left" : "Location firstUndesired",
    "right" : "Location firstUndesired",
    "info" : "SingleVariableDeclaration[15688-15711]:SingleVariableDeclaration[15688-15711]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[15713-15950]:Block[15713-15950]"
  }, {
    "left" : "String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);",
    "right" : "String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);",
    "info" : "VariableDeclarationStatement[15723-15822]:VariableDeclarationStatement[15723-15822]"
  }, {
    "left" : "throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));",
    "right" : "throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));",
    "info" : "ThrowStatement[15831-15944]:ThrowStatement[15831-15944]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[15956-15963]:Modifier[15956-15963]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[15964-15970]:SimpleType[15964-15970]"
  }, {
    "left" : "createTooLittleInvocationsMessage",
    "right" : "createTooLittleInvocationsMessage",
    "info" : "SimpleName[15971-16004]:SimpleName[15971-16004]"
  }, {
    "left" : "org.mockito.internal.reporting.Discrepancy discrepancy",
    "right" : "org.mockito.internal.reporting.Discrepancy discrepancy",
    "info" : "SingleVariableDeclaration[16005-16059]:SingleVariableDeclaration[16005-16059]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[16061-16087]:SingleVariableDeclaration[16061-16087]"
  }, {
    "left" : "Location lastActualInvocation",
    "right" : "Location lastActualInvocation",
    "info" : "SingleVariableDeclaration[16142-16171]:SingleVariableDeclaration[16142-16171]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16173-16598]:Block[16173-16598]"
  }, {
    "left" : "String ending =\n                (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";",
    "right" : "String ending =\n                (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";",
    "info" : "VariableDeclarationStatement[16183-16282]:VariableDeclarationStatement[16183-16282]"
  }, {
    "left" : "String message = join(\n                wanted.toString(),\n                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                new LocationImpl(),\n                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                ending\n        );",
    "right" : "String message = join(\n                wanted.toString(),\n                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                new LocationImpl(),\n                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                ending\n        );",
    "info" : "VariableDeclarationStatement[16292-16568]:VariableDeclarationStatement[16292-16568]"
  }, {
    "left" : "return message;",
    "right" : "return message;",
    "info" : "ReturnStatement[16577-16592]:ReturnStatement[16577-16592]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[16604-16610]:Modifier[16604-16610]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[16611-16615]:PrimitiveType[16611-16615]"
  }, {
    "left" : "tooLittleActualInvocations",
    "right" : "tooLittleActualInvocations",
    "info" : "SimpleName[16616-16642]:SimpleName[16616-16642]"
  }, {
    "left" : "org.mockito.internal.reporting.Discrepancy discrepancy",
    "right" : "org.mockito.internal.reporting.Discrepancy discrepancy",
    "info" : "SingleVariableDeclaration[16643-16697]:SingleVariableDeclaration[16643-16697]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[16699-16725]:SingleVariableDeclaration[16699-16725]"
  }, {
    "left" : "Location lastActualLocation",
    "right" : "Location lastActualLocation",
    "info" : "SingleVariableDeclaration[16727-16754]:SingleVariableDeclaration[16727-16754]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16756-16920]:Block[16756-16920]"
  }, {
    "left" : "String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);",
    "right" : "String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);",
    "info" : "VariableDeclarationStatement[16766-16858]:VariableDeclarationStatement[16766-16858]"
  }, {
    "left" : "throw new TooLittleActualInvocations(message);",
    "right" : "throw new TooLittleActualInvocations(message);",
    "info" : "ThrowStatement[16868-16914]:ThrowStatement[16868-16914]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[16926-16932]:Modifier[16926-16932]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[16933-16937]:PrimitiveType[16933-16937]"
  }, {
    "left" : "tooLittleActualInvocationsInOrder",
    "right" : "tooLittleActualInvocationsInOrder",
    "info" : "SimpleName[16938-16971]:SimpleName[16938-16971]"
  }, {
    "left" : "org.mockito.internal.reporting.Discrepancy discrepancy",
    "right" : "org.mockito.internal.reporting.Discrepancy discrepancy",
    "info" : "SingleVariableDeclaration[16972-17026]:SingleVariableDeclaration[16972-17026]"
  }, {
    "left" : "DescribedInvocation wanted",
    "right" : "DescribedInvocation wanted",
    "info" : "SingleVariableDeclaration[17028-17054]:SingleVariableDeclaration[17028-17054]"
  }, {
    "left" : "Location lastActualLocation",
    "right" : "Location lastActualLocation",
    "info" : "SingleVariableDeclaration[17056-17083]:SingleVariableDeclaration[17056-17083]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17085-17316]:Block[17085-17316]"
  }, {
    "left" : "String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);",
    "right" : "String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);",
    "info" : "VariableDeclarationStatement[17095-17187]:VariableDeclarationStatement[17095-17187]"
  }, {
    "left" : "throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));",
    "right" : "throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));",
    "info" : "ThrowStatement[17197-17310]:ThrowStatement[17197-17310]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[17322-17328]:Modifier[17322-17328]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[17329-17333]:PrimitiveType[17329-17333]"
  }, {
    "left" : "noMoreInteractionsWanted",
    "right" : "noMoreInteractionsWanted",
    "info" : "SimpleName[17334-17358]:SimpleName[17334-17358]"
  }, {
    "left" : "Invocation undesired",
    "right" : "Invocation undesired",
    "info" : "SingleVariableDeclaration[17359-17379]:SingleVariableDeclaration[17359-17379]"
  }, {
    "left" : "List<VerificationAwareInvocation> invocations",
    "right" : "List<VerificationAwareInvocation> invocations",
    "info" : "SingleVariableDeclaration[17381-17426]:SingleVariableDeclaration[17381-17426]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17428-17855]:Block[17428-17874]"
  }, {
    "left" : "ScenarioPrinter scenarioPrinter = new ScenarioPrinter();",
    "right" : "ScenarioPrinter scenarioPrinter = new ScenarioPrinter();",
    "info" : "VariableDeclarationStatement[17438-17494]:VariableDeclarationStatement[17438-17494]"
  }, {
    "left" : "String scenario = scenarioPrinter.print(invocations);",
    "right" : "String scenario = scenarioPrinter.print(invocations);",
    "info" : "VariableDeclarationStatement[17503-17556]:VariableDeclarationStatement[17503-17556]"
  }, {
    "left" : "throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                undesired.getLocation(),\n                scenario\n        ));",
    "right" : "throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                undesired.getLocation(),\n                scenario\n        ));",
    "info" : "ThrowStatement[17566-17849]:ThrowStatement[17566-17868]"
  }, {
    "left" : "undesired.getMock()",
    "right" : "undesired.getMock()",
    "info" : "MethodInvocation[17744-17763]:MethodInvocation[17762-17781]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[17861-17867]:Modifier[17880-17886]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[17868-17872]:PrimitiveType[17887-17891]"
  }, {
    "left" : "noMoreInteractionsWantedInOrder",
    "right" : "noMoreInteractionsWantedInOrder",
    "info" : "SimpleName[17873-17904]:SimpleName[17892-17923]"
  }, {
    "left" : "Invocation undesired",
    "right" : "Invocation undesired",
    "info" : "SingleVariableDeclaration[17905-17925]:SingleVariableDeclaration[17924-17944]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17927-18206]:Block[17946-18244]"
  }, {
    "left" : "throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                undesired.getLocation()\n        ));",
    "right" : "throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                undesired.getLocation()\n        ));",
    "info" : "ThrowStatement[17937-18200]:ThrowStatement[17956-18238]"
  }, {
    "left" : "undesired.getMock()",
    "right" : "undesired.getMock()",
    "info" : "MethodInvocation[18121-18140]:MethodInvocation[18158-18177]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[18212-18218]:Modifier[18250-18256]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[18219-18223]:PrimitiveType[18257-18261]"
  }, {
    "left" : "cannotMockFinalClass",
    "right" : "cannotMockFinalClass",
    "info" : "SimpleName[18224-18244]:SimpleName[18262-18282]"
  }, {
    "left" : "Class<?> clazz",
    "right" : "Class<?> clazz",
    "info" : "SingleVariableDeclaration[18245-18259]:SingleVariableDeclaration[18283-18297]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18261-18546]:Block[18299-18584]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));",
    "info" : "ThrowStatement[18271-18540]:ThrowStatement[18309-18578]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[18552-18558]:Modifier[18590-18596]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[18559-18563]:PrimitiveType[18597-18601]"
  }, {
    "left" : "cannotStubVoidMethodWithAReturnValue",
    "right" : "cannotStubVoidMethodWithAReturnValue",
    "info" : "SimpleName[18564-18600]:SimpleName[18602-18638]"
  }, {
    "left" : "String methodName",
    "right" : "String methodName",
    "info" : "SingleVariableDeclaration[18601-18618]:SingleVariableDeclaration[18639-18656]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18620-19679]:Block[18658-19717]"
  }, {
    "left" : "throw new CannotStubVoidMethodWithReturnValue(join(\n                \"'\" + methodName + \"' is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.\",\n                \"2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.\",\n                \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"4. \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));",
    "right" : "throw new CannotStubVoidMethodWithReturnValue(join(\n                \"'\" + methodName + \"' is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.\",\n                \"2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.\",\n                \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"4. \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));",
    "info" : "ThrowStatement[18630-19673]:ThrowStatement[18668-19711]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[19685-19691]:Modifier[19723-19729]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[19692-19696]:PrimitiveType[19730-19734]"
  }, {
    "left" : "onlyVoidMethodsCanBeSetToDoNothing",
    "right" : "onlyVoidMethodsCanBeSetToDoNothing",
    "info" : "SimpleName[19697-19731]:SimpleName[19735-19769]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19734-20190]:Block[19772-20228]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n        ));",
    "info" : "ThrowStatement[19744-20184]:ThrowStatement[19782-20222]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[20196-20202]:Modifier[20234-20240]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[20203-20207]:PrimitiveType[20241-20245]"
  }, {
    "left" : "wrongTypeOfReturnValue",
    "right" : "wrongTypeOfReturnValue",
    "info" : "SimpleName[20208-20230]:SimpleName[20246-20268]"
  }, {
    "left" : "String expectedType",
    "right" : "String expectedType",
    "info" : "SingleVariableDeclaration[20231-20250]:SingleVariableDeclaration[20269-20288]"
  }, {
    "left" : "String actualType",
    "right" : "String actualType",
    "info" : "SingleVariableDeclaration[20252-20269]:SingleVariableDeclaration[20290-20307]"
  }, {
    "left" : "String methodName",
    "right" : "String methodName",
    "info" : "SingleVariableDeclaration[20271-20288]:SingleVariableDeclaration[20309-20326]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20290-21095]:Block[20328-21133]"
  }, {
    "left" : "throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));",
    "right" : "throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[20300-21089]:ThrowStatement[20338-21127]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[21101-21107]:Modifier[21139-21145]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[21108-21112]:PrimitiveType[21146-21150]"
  }, {
    "left" : "wantedAtMostX",
    "right" : "wantedAtMostX",
    "info" : "SimpleName[21113-21126]:SimpleName[21151-21164]"
  }, {
    "left" : "int maxNumberOfInvocations",
    "right" : "int maxNumberOfInvocations",
    "info" : "SingleVariableDeclaration[21127-21153]:SingleVariableDeclaration[21165-21191]"
  }, {
    "left" : "int foundSize",
    "right" : "int foundSize",
    "info" : "SingleVariableDeclaration[21155-21168]:SingleVariableDeclaration[21193-21206]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21170-21305]:Block[21208-21343]"
  }, {
    "left" : "throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));",
    "right" : "throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));",
    "info" : "ThrowStatement[21180-21299]:ThrowStatement[21218-21337]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[21311-21317]:Modifier[21349-21355]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[21318-21322]:PrimitiveType[21356-21360]"
  }, {
    "left" : "misplacedArgumentMatcher",
    "right" : "misplacedArgumentMatcher",
    "info" : "SimpleName[21323-21347]:SimpleName[21361-21385]"
  }, {
    "left" : "List<LocalizedMatcher> lastMatchers",
    "right" : "List<LocalizedMatcher> lastMatchers",
    "info" : "SingleVariableDeclaration[21348-21383]:SingleVariableDeclaration[21386-21421]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21385-22280]:Block[21423-22318]"
  }, {
    "left" : "throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                locationsOf(lastMatchers),\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));",
    "right" : "throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                locationsOf(lastMatchers),\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));",
    "info" : "ThrowStatement[21395-22274]:ThrowStatement[21433-22312]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[22286-22292]:Modifier[22324-22330]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[22293-22297]:PrimitiveType[22331-22335]"
  }, {
    "left" : "smartNullPointerException",
    "right" : "smartNullPointerException",
    "info" : "SimpleName[22298-22323]:SimpleName[22336-22361]"
  }, {
    "left" : "String invocation",
    "right" : "String invocation",
    "info" : "SingleVariableDeclaration[22324-22341]:SingleVariableDeclaration[22362-22379]"
  }, {
    "left" : "Location location",
    "right" : "Location location",
    "info" : "SingleVariableDeclaration[22343-22360]:SingleVariableDeclaration[22381-22398]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22362-22670]:Block[22400-22708]"
  }, {
    "left" : "throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new LocationImpl(),\n                \"because this method call was *not* stubbed correctly:\",\n                location,\n                invocation,\n                \"\"\n        ));",
    "right" : "throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new LocationImpl(),\n                \"because this method call was *not* stubbed correctly:\",\n                location,\n                invocation,\n                \"\"\n        ));",
    "info" : "ThrowStatement[22372-22664]:ThrowStatement[22410-22702]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[22676-22682]:Modifier[22714-22720]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[22683-22687]:PrimitiveType[22721-22725]"
  }, {
    "left" : "noArgumentValueWasCaptured",
    "right" : "noArgumentValueWasCaptured",
    "info" : "SimpleName[22688-22714]:SimpleName[22726-22752]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22717-23432]:Block[22755-23470]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[22727-23426]:ThrowStatement[22765-23464]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[23438-23444]:Modifier[23476-23482]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[23445-23449]:PrimitiveType[23483-23487]"
  }, {
    "left" : "extraInterfacesDoesNotAcceptNullParameters",
    "right" : "extraInterfacesDoesNotAcceptNullParameters",
    "info" : "SimpleName[23450-23492]:SimpleName[23488-23530]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23495-23624]:Block[23533-23662]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n        ));",
    "info" : "ThrowStatement[23505-23618]:ThrowStatement[23543-23656]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[23630-23636]:Modifier[23668-23674]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[23637-23641]:PrimitiveType[23675-23679]"
  }, {
    "left" : "extraInterfacesAcceptsOnlyInterfaces",
    "right" : "extraInterfacesAcceptsOnlyInterfaces",
    "info" : "SimpleName[23642-23678]:SimpleName[23680-23716]"
  }, {
    "left" : "Class<?> wrongType",
    "right" : "Class<?> wrongType",
    "info" : "SingleVariableDeclaration[23679-23697]:SingleVariableDeclaration[23717-23735]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23699-23927]:Block[23737-23965]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));",
    "info" : "ThrowStatement[23709-23921]:ThrowStatement[23747-23959]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[23933-23939]:Modifier[23971-23977]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[23940-23944]:PrimitiveType[23978-23982]"
  }, {
    "left" : "extraInterfacesCannotContainMockedType",
    "right" : "extraInterfacesCannotContainMockedType",
    "info" : "SimpleName[23945-23983]:SimpleName[23983-24021]"
  }, {
    "left" : "Class<?> wrongType",
    "right" : "Class<?> wrongType",
    "info" : "SingleVariableDeclaration[23984-24002]:SingleVariableDeclaration[24022-24040]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24004-24308]:Block[24042-24346]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));",
    "info" : "ThrowStatement[24014-24302]:ThrowStatement[24052-24340]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[24314-24320]:Modifier[24352-24358]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[24321-24325]:PrimitiveType[24359-24363]"
  }, {
    "left" : "extraInterfacesRequiresAtLeastOneInterface",
    "right" : "extraInterfacesRequiresAtLeastOneInterface",
    "info" : "SimpleName[24326-24368]:SimpleName[24364-24406]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24371-24500]:Block[24409-24538]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));",
    "info" : "ThrowStatement[24381-24494]:ThrowStatement[24419-24532]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[24506-24512]:Modifier[24544-24550]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[24513-24517]:PrimitiveType[24551-24555]"
  }, {
    "left" : "mockedTypeIsInconsistentWithSpiedInstanceType",
    "right" : "mockedTypeIsInconsistentWithSpiedInstanceType",
    "info" : "SimpleName[24518-24563]:SimpleName[24556-24601]"
  }, {
    "left" : "Class<?> mockedType",
    "right" : "Class<?> mockedType",
    "info" : "SingleVariableDeclaration[24564-24583]:SingleVariableDeclaration[24602-24621]"
  }, {
    "left" : "Object spiedInstance",
    "right" : "Object spiedInstance",
    "info" : "SingleVariableDeclaration[24585-24605]:SingleVariableDeclaration[24623-24643]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24607-25182]:Block[24645-25220]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n        ));",
    "info" : "ThrowStatement[24617-25176]:ThrowStatement[24655-25214]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[25188-25194]:Modifier[25226-25232]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[25195-25199]:PrimitiveType[25233-25237]"
  }, {
    "left" : "cannotCallAbstractRealMethod",
    "right" : "cannotCallAbstractRealMethod",
    "info" : "SimpleName[25200-25228]:SimpleName[25238-25266]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25231-25578]:Block[25269-25616]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Cannot call abstract real method on java object!\",\n                \"Calling real methods is only possible when mocking non abstract method.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Cannot call abstract real method on java object!\",\n                \"Calling real methods is only possible when mocking non abstract method.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();\"\n        ));",
    "info" : "ThrowStatement[25241-25572]:ThrowStatement[25279-25610]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[25584-25590]:Modifier[25622-25628]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[25591-25595]:PrimitiveType[25629-25633]"
  }, {
    "left" : "cannotVerifyToString",
    "right" : "cannotVerifyToString",
    "info" : "SimpleName[25596-25616]:SimpleName[25634-25654]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25619-26258]:Block[25657-26296]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));",
    "info" : "ThrowStatement[25629-26252]:ThrowStatement[25667-26290]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[26264-26270]:Modifier[26302-26308]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[26271-26275]:PrimitiveType[26309-26313]"
  }, {
    "left" : "moreThanOneAnnotationNotAllowed",
    "right" : "moreThanOneAnnotationNotAllowed",
    "info" : "SimpleName[26276-26307]:SimpleName[26314-26345]"
  }, {
    "left" : "String fieldName",
    "right" : "String fieldName",
    "info" : "SingleVariableDeclaration[26308-26324]:SingleVariableDeclaration[26346-26362]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26326-26627]:Block[26364-26665]"
  }, {
    "left" : "throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");",
    "right" : "throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");",
    "info" : "ThrowStatement[26336-26621]:ThrowStatement[26374-26659]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[26633-26639]:Modifier[26671-26677]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[26640-26644]:PrimitiveType[26678-26682]"
  }, {
    "left" : "unsupportedCombinationOfAnnotations",
    "right" : "unsupportedCombinationOfAnnotations",
    "info" : "SimpleName[26645-26680]:SimpleName[26683-26718]"
  }, {
    "left" : "String undesiredAnnotationOne",
    "right" : "String undesiredAnnotationOne",
    "info" : "SingleVariableDeclaration[26681-26710]:SingleVariableDeclaration[26719-26748]"
  }, {
    "left" : "String undesiredAnnotationTwo",
    "right" : "String undesiredAnnotationTwo",
    "info" : "SingleVariableDeclaration[26712-26741]:SingleVariableDeclaration[26750-26779]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26743-26942]:Block[26781-26980]"
  }, {
    "left" : "throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);",
    "right" : "throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);",
    "info" : "ThrowStatement[26753-26936]:ThrowStatement[26791-26974]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[26948-26954]:Modifier[26986-26992]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[26955-26959]:PrimitiveType[26993-26997]"
  }, {
    "left" : "cannotInitializeForSpyAnnotation",
    "right" : "cannotInitializeForSpyAnnotation",
    "info" : "SimpleName[26960-26992]:SimpleName[26998-27030]"
  }, {
    "left" : "String fieldName",
    "right" : "String fieldName",
    "info" : "SingleVariableDeclaration[26993-27009]:SingleVariableDeclaration[27031-27047]"
  }, {
    "left" : "Exception details",
    "right" : "Exception details",
    "info" : "SingleVariableDeclaration[27011-27028]:SingleVariableDeclaration[27049-27066]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27030-27633]:Block[27068-27671]"
  }, {
    "left" : "throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n                \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @Spy:\",\n                \"   @Spy List mock = new LinkedList();\",\n                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);",
    "right" : "throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n                \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @Spy:\",\n                \"   @Spy List mock = new LinkedList();\",\n                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);",
    "info" : "ThrowStatement[27040-27627]:ThrowStatement[27078-27665]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[27639-27645]:Modifier[27677-27683]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[27646-27650]:PrimitiveType[27684-27688]"
  }, {
    "left" : "cannotInitializeForInjectMocksAnnotation",
    "right" : "cannotInitializeForInjectMocksAnnotation",
    "info" : "SimpleName[27651-27691]:SimpleName[27689-27729]"
  }, {
    "left" : "String fieldName",
    "right" : "String fieldName",
    "info" : "SingleVariableDeclaration[27692-27708]:SingleVariableDeclaration[27730-27746]"
  }, {
    "left" : "Exception details",
    "right" : "Exception details",
    "info" : "SingleVariableDeclaration[27710-27727]:SingleVariableDeclaration[27748-27765]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27729-28399]:Block[27767-28437]"
  }, {
    "left" : "throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @InjectMocks:\",\n                \"   @InjectMocks Service service = new Service();\",\n                \"   @InjectMocks Service service;\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"   //and... don't forget about some @Mocks for injection :)\",\n                \"\"), details);",
    "right" : "throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @InjectMocks:\",\n                \"   @InjectMocks Service service = new Service();\",\n                \"   @InjectMocks Service service;\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"   //and... don't forget about some @Mocks for injection :)\",\n                \"\"), details);",
    "info" : "ThrowStatement[27739-28393]:ThrowStatement[27777-28431]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[28405-28411]:Modifier[28443-28449]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[28412-28416]:PrimitiveType[28450-28454]"
  }, {
    "left" : "atMostAndNeverShouldNotBeUsedWithTimeout",
    "right" : "atMostAndNeverShouldNotBeUsedWithTimeout",
    "info" : "SimpleName[28417-28457]:SimpleName[28455-28495]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28460-29050]:Block[28498-29088]"
  }, {
    "left" : "throw new FriendlyReminderException(join(\"\",\n                \"Don't panic! I'm just a friendly reminder!\",\n                \"timeout() should not be used with atMost() or never() because...\",\n                \"...it does not make much sense - the test would have passed immediately in concurency\",\n                \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n                \"In future release we will remove timeout(x).atMost(y) from the API.\",\n                \"If you want to find out more please refer to issue 235\",\n                \"\"));",
    "right" : "throw new FriendlyReminderException(join(\"\",\n                \"Don't panic! I'm just a friendly reminder!\",\n                \"timeout() should not be used with atMost() or never() because...\",\n                \"...it does not make much sense - the test would have passed immediately in concurency\",\n                \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n                \"In future release we will remove timeout(x).atMost(y) from the API.\",\n                \"If you want to find out more please refer to issue 235\",\n                \"\"));",
    "info" : "ThrowStatement[28470-29044]:ThrowStatement[28508-29082]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[29056-29062]:Modifier[29094-29100]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[29063-29067]:PrimitiveType[29101-29105]"
  }, {
    "left" : "fieldInitialisationThrewException",
    "right" : "fieldInitialisationThrewException",
    "info" : "SimpleName[29068-29101]:SimpleName[29106-29139]"
  }, {
    "left" : "Field field",
    "right" : "Field field",
    "info" : "SingleVariableDeclaration[29102-29113]:SingleVariableDeclaration[29140-29151]"
  }, {
    "left" : "Throwable details",
    "right" : "Throwable details",
    "info" : "SingleVariableDeclaration[29115-29132]:SingleVariableDeclaration[29153-29170]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29134-29567]:Block[29172-29605]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Cannot instantiate @InjectMocks field named '\" + field.getName() + \"' of type '\" + field.getType() +  \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However the constructor or the initialization block threw an exception : \" + details.getMessage(),\n                \"\"), details);",
    "right" : "throw new MockitoException(join(\n                \"Cannot instantiate @InjectMocks field named '\" + field.getName() + \"' of type '\" + field.getType() +  \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However the constructor or the initialization block threw an exception : \" + details.getMessage(),\n                \"\"), details);",
    "info" : "ThrowStatement[29144-29560]:ThrowStatement[29182-29598]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[29573-29579]:Modifier[29611-29617]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[29580-29584]:PrimitiveType[29618-29622]"
  }, {
    "left" : "invocationListenerDoesNotAcceptNullParameters",
    "right" : "invocationListenerDoesNotAcceptNullParameters",
    "info" : "SimpleName[29585-29630]:SimpleName[29623-29668]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29633-29733]:Block[29671-29771]"
  }, {
    "left" : "throw new MockitoException(\"invocationListeners() does not accept null parameters\");",
    "right" : "throw new MockitoException(\"invocationListeners() does not accept null parameters\");",
    "info" : "ThrowStatement[29643-29727]:ThrowStatement[29681-29765]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[29739-29745]:Modifier[29777-29783]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[29746-29750]:PrimitiveType[29784-29788]"
  }, {
    "left" : "invocationListenersRequiresAtLeastOneListener",
    "right" : "invocationListenersRequiresAtLeastOneListener",
    "info" : "SimpleName[29751-29796]:SimpleName[29789-29834]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29799-29898]:Block[29837-29936]"
  }, {
    "left" : "throw new MockitoException(\"invocationListeners() requires at least one listener\");",
    "right" : "throw new MockitoException(\"invocationListeners() requires at least one listener\");",
    "info" : "ThrowStatement[29809-29892]:ThrowStatement[29847-29930]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[29904-29910]:Modifier[29942-29948]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[29911-29915]:PrimitiveType[29949-29953]"
  }, {
    "left" : "invocationListenerThrewException",
    "right" : "invocationListenerThrewException",
    "info" : "SimpleName[29916-29948]:SimpleName[29954-29986]"
  }, {
    "left" : "InvocationListener listener",
    "right" : "InvocationListener listener",
    "info" : "SingleVariableDeclaration[29949-29976]:SingleVariableDeclaration[29987-30014]"
  }, {
    "left" : "Throwable listenerThrowable",
    "right" : "Throwable listenerThrowable",
    "info" : "SingleVariableDeclaration[29978-30005]:SingleVariableDeclaration[30016-30043]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30007-30290]:Block[30045-30328]"
  }, {
    "left" : "throw new MockitoException(StringJoiner.join(\n                \"The invocation listener with type \" + listener.getClass().getName(),\n                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);",
    "right" : "throw new MockitoException(StringJoiner.join(\n                \"The invocation listener with type \" + listener.getClass().getName(),\n                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);",
    "info" : "ThrowStatement[30017-30284]:ThrowStatement[30055-30322]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[30296-30302]:Modifier[30334-30340]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[30303-30307]:PrimitiveType[30341-30345]"
  }, {
    "left" : "cannotInjectDependency",
    "right" : "cannotInjectDependency",
    "info" : "SimpleName[30308-30330]:SimpleName[30346-30368]"
  }, {
    "left" : "Field field",
    "right" : "Field field",
    "info" : "SingleVariableDeclaration[30331-30342]:SingleVariableDeclaration[30369-30380]"
  }, {
    "left" : "Object matchingMock",
    "right" : "Object matchingMock",
    "info" : "SingleVariableDeclaration[30344-30363]:SingleVariableDeclaration[30382-30401]"
  }, {
    "left" : "Exception details",
    "right" : "Exception details",
    "info" : "SingleVariableDeclaration[30365-30382]:SingleVariableDeclaration[30403-30420]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30384-30834]:Block[30422-30872]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Mockito couldn't inject mock dependency '\" + safelyGetMockName(matchingMock) + \"' on field \",\n                \"'\" + field + \"'\",\n                \"whose type '\" + field.getDeclaringClass().getCanonicalName() + \"' was annotated by @InjectMocks in your test.\",\n                \"Also I failed because: \" + exceptionCauseMessageIfAvailable(details),\n                \"\"\n        ), details);",
    "right" : "throw new MockitoException(join(\n                \"Mockito couldn't inject mock dependency '\" + safelyGetMockName(matchingMock) + \"' on field \",\n                \"'\" + field + \"'\",\n                \"whose type '\" + field.getDeclaringClass().getCanonicalName() + \"' was annotated by @InjectMocks in your test.\",\n                \"Also I failed because: \" + exceptionCauseMessageIfAvailable(details),\n                \"\"\n        ), details);",
    "info" : "ThrowStatement[30394-30828]:ThrowStatement[30432-30866]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[30840-30847]:Modifier[30878-30885]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[30848-30854]:SimpleType[30886-30892]"
  }, {
    "left" : "exceptionCauseMessageIfAvailable",
    "right" : "exceptionCauseMessageIfAvailable",
    "info" : "SimpleName[30855-30887]:SimpleName[30893-30925]"
  }, {
    "left" : "Exception details",
    "right" : "Exception details",
    "info" : "SingleVariableDeclaration[30888-30905]:SingleVariableDeclaration[30926-30943]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30907-30962]:Block[30945-31093]"
  }, {
    "left" : "return details.getCause().getMessage();",
    "right" : "return details.getCause().getMessage();",
    "info" : "ReturnStatement[30917-30956]:ReturnStatement[31048-31087]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[30968-30974]:Modifier[31099-31105]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[30975-30979]:PrimitiveType[31106-31110]"
  }, {
    "left" : "mockedTypeIsInconsistentWithDelegatedInstanceType",
    "right" : "mockedTypeIsInconsistentWithDelegatedInstanceType",
    "info" : "SimpleName[30980-31029]:SimpleName[31111-31160]"
  }, {
    "left" : "Class mockedType",
    "right" : "Class mockedType",
    "info" : "SingleVariableDeclaration[31030-31046]:SingleVariableDeclaration[31161-31177]"
  }, {
    "left" : "Object delegatedInstance",
    "right" : "Object delegatedInstance",
    "info" : "SingleVariableDeclaration[31048-31072]:SingleVariableDeclaration[31179-31203]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31074-31660]:Block[31205-31791]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your delegated instance.\",\n                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct delegate:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your delegated instance.\",\n                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct delegate:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n        ));",
    "info" : "ThrowStatement[31084-31654]:ThrowStatement[31215-31785]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[31666-31672]:Modifier[31797-31803]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[31673-31677]:PrimitiveType[31804-31808]"
  }, {
    "left" : "spyAndDelegateAreMutuallyExclusive",
    "right" : "spyAndDelegateAreMutuallyExclusive",
    "info" : "SimpleName[31678-31712]:SimpleName[31809-31843]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31715-31879]:Block[31846-32010]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n        )) ;",
    "right" : "throw new MockitoException(join(\n                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n        )) ;",
    "info" : "ThrowStatement[31725-31873]:ThrowStatement[31856-32004]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[31885-31891]:Modifier[32016-32022]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[31892-31896]:PrimitiveType[32023-32027]"
  }, {
    "left" : "invalidArgumentRangeAtIdentityAnswerCreationTime",
    "right" : "invalidArgumentRangeAtIdentityAnswerCreationTime",
    "info" : "SimpleName[31897-31945]:SimpleName[32028-32076]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31948-32274]:Block[32079-32405]"
  }, {
    "left" : "throw new MockitoException(join(\"Invalid argument index.\",\n                \"The index need to be a positive number that indicates the position of the argument to return.\",\n                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n                \"returned.\"));",
    "right" : "throw new MockitoException(join(\"Invalid argument index.\",\n                \"The index need to be a positive number that indicates the position of the argument to return.\",\n                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n                \"returned.\"));",
    "info" : "ThrowStatement[31958-32268]:ThrowStatement[32089-32399]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[32280-32286]:Modifier[32411-32417]"
  }, {
    "left" : "int",
    "right" : "int",
    "info" : "PrimitiveType[32287-32290]:PrimitiveType[32418-32421]"
  }, {
    "left" : "invalidArgumentPositionRangeAtInvocationTime",
    "right" : "invalidArgumentPositionRangeAtInvocationTime",
    "info" : "SimpleName[32291-32335]:SimpleName[32422-32466]"
  }, {
    "left" : "InvocationOnMock invocation",
    "right" : "InvocationOnMock invocation",
    "info" : "SingleVariableDeclaration[32336-32363]:SingleVariableDeclaration[32467-32494]"
  }, {
    "left" : "boolean willReturnLastParameter",
    "right" : "boolean willReturnLastParameter",
    "info" : "SingleVariableDeclaration[32365-32396]:SingleVariableDeclaration[32496-32527]"
  }, {
    "left" : "int argumentIndex",
    "right" : "int argumentIndex",
    "info" : "SingleVariableDeclaration[32398-32415]:SingleVariableDeclaration[32529-32546]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32417-33225]:Block[32548-33356]"
  }, {
    "left" : "throw new MockitoException(\n                join(\"Invalid argument index for the current invocation of method : \",\n                        \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                        \"\",\n                        (willReturnLastParameter ?\n                                \"Last parameter wanted\" :\n                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n                        \"\"));",
    "right" : "throw new MockitoException(\n                join(\"Invalid argument index for the current invocation of method : \",\n                        \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                        \"\",\n                        (willReturnLastParameter ?\n                                \"Last parameter wanted\" :\n                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n                        \"\"));",
    "info" : "ThrowStatement[32427-33219]:ThrowStatement[32558-33350]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[33231-33238]:Modifier[33362-33369]"
  }, {
    "left" : "StringBuilder",
    "right" : "StringBuilder",
    "info" : "SimpleType[33239-33252]:SimpleType[33370-33383]"
  }, {
    "left" : "possibleArgumentTypesOf",
    "right" : "possibleArgumentTypesOf",
    "info" : "SimpleName[33253-33276]:SimpleName[33384-33407]"
  }, {
    "left" : "InvocationOnMock invocation",
    "right" : "InvocationOnMock invocation",
    "info" : "SingleVariableDeclaration[33277-33304]:SingleVariableDeclaration[33408-33435]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33306-34191]:Block[33437-34322]"
  }, {
    "left" : "Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();",
    "right" : "Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();",
    "info" : "VariableDeclarationStatement[33316-33387]:VariableDeclarationStatement[33447-33518]"
  }, {
    "left" : "if (parameterTypes.length == 0)",
    "right" : "if (parameterTypes.length == 0)",
    "info" : "IfStatement[33396-33511]:IfStatement[33527-33642]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33428-33511]:Block[33559-33642]"
  }, {
    "left" : "return new StringBuilder(\"the method has no arguments.\\n\");",
    "right" : "return new StringBuilder(\"the method has no arguments.\\n\");",
    "info" : "ReturnStatement[33442-33501]:ReturnStatement[33573-33632]"
  }, {
    "left" : "StringBuilder stringBuilder = new StringBuilder(\"the possible argument indexes for this method are :\\n\");",
    "right" : "StringBuilder stringBuilder = new StringBuilder(\"the possible argument indexes for this method are :\\n\");",
    "info" : "VariableDeclarationStatement[33521-33626]:VariableDeclarationStatement[33652-33757]"
  }, {
    "left" : "for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++)",
    "right" : "for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++)",
    "info" : "ForStatement[33635-34155]:ForStatement[33766-34286]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33728-34155]:Block[33859-34286]"
  }, {
    "left" : "stringBuilder.append(\"    [\").append(i);",
    "right" : "stringBuilder.append(\"    [\").append(i);",
    "info" : "ExpressionStatement[33742-33782]:ExpressionStatement[33873-33913]"
  }, {
    "left" : "if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1)",
    "right" : "if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1)",
    "info" : "IfStatement[33796-34145]:IfStatement[33927-34276]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33869-34025]:Block[34000-34156]"
  }, {
    "left" : "stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  <- Vararg\").append(\"\\n\");",
    "right" : "stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  <- Vararg\").append(\"\\n\");",
    "info" : "ExpressionStatement[33887-34011]:ExpressionStatement[34018-34142]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34031-34145]:Block[34162-34276]"
  }, {
    "left" : "stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");",
    "right" : "stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");",
    "info" : "ExpressionStatement[34049-34131]:ExpressionStatement[34180-34262]"
  }, {
    "left" : "return stringBuilder;",
    "right" : "return stringBuilder;",
    "info" : "ReturnStatement[34164-34185]:ReturnStatement[34295-34316]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[34197-34203]:Modifier[34328-34334]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[34204-34208]:PrimitiveType[34335-34339]"
  }, {
    "left" : "wrongTypeOfArgumentToReturn",
    "right" : "wrongTypeOfArgumentToReturn",
    "info" : "SimpleName[34209-34236]:SimpleName[34340-34367]"
  }, {
    "left" : "InvocationOnMock invocation",
    "right" : "InvocationOnMock invocation",
    "info" : "SingleVariableDeclaration[34237-34264]:SingleVariableDeclaration[34368-34395]"
  }, {
    "left" : "String expectedType",
    "right" : "String expectedType",
    "info" : "SingleVariableDeclaration[34266-34285]:SingleVariableDeclaration[34397-34416]"
  }, {
    "left" : "Class actualType",
    "right" : "Class actualType",
    "info" : "SingleVariableDeclaration[34287-34303]:SingleVariableDeclaration[34418-34434]"
  }, {
    "left" : "int argumentIndex",
    "right" : "int argumentIndex",
    "info" : "SingleVariableDeclaration[34305-34322]:SingleVariableDeclaration[34436-34453]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34324-35652]:Block[34455-35783]"
  }, {
    "left" : "throw new WrongTypeOfReturnValue(join(\n                \"The argument of type '\" + actualType.getSimpleName() + \"' cannot be returned because the following \",\n                \"method should return the type '\" + expectedType + \"'\",\n                \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                \"\",\n                \"The reason for this error can be :\",\n                \"1. The wanted argument position is incorrect.\",\n                \"2. The answer is used on the wrong interaction.\",\n                \"\",\n                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n                \"***\",\n                \"However if you're still unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));",
    "right" : "throw new WrongTypeOfReturnValue(join(\n                \"The argument of type '\" + actualType.getSimpleName() + \"' cannot be returned because the following \",\n                \"method should return the type '\" + expectedType + \"'\",\n                \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                \"\",\n                \"The reason for this error can be :\",\n                \"1. The wanted argument position is incorrect.\",\n                \"2. The answer is used on the wrong interaction.\",\n                \"\",\n                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n                \"***\",\n                \"However if you're still unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[34334-35646]:ThrowStatement[34465-35777]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[35658-35664]:Modifier[35789-35795]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[35665-35669]:PrimitiveType[35796-35800]"
  }, {
    "left" : "defaultAnswerDoesNotAcceptNullParameter",
    "right" : "defaultAnswerDoesNotAcceptNullParameter",
    "info" : "SimpleName[35670-35709]:SimpleName[35801-35840]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35712-35805]:Block[35843-35936]"
  }, {
    "left" : "throw new MockitoException(\"defaultAnswer() does not accept null parameter\");",
    "right" : "throw new MockitoException(\"defaultAnswer() does not accept null parameter\");",
    "info" : "ThrowStatement[35722-35799]:ThrowStatement[35853-35930]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[35811-35817]:Modifier[35942-35948]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[35818-35822]:PrimitiveType[35949-35953]"
  }, {
    "left" : "serializableWontWorkForObjectsThatDontImplementSerializable",
    "right" : "serializableWontWorkForObjectsThatDontImplementSerializable",
    "info" : "SimpleName[35823-35882]:SimpleName[35954-36013]"
  }, {
    "left" : "Class classToMock",
    "right" : "Class classToMock",
    "info" : "SingleVariableDeclaration[35883-35900]:SingleVariableDeclaration[36014-36031]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35902-36605]:Block[36033-36736]"
  }, {
    "left" : "throw new MockitoException(join(\n                \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n                \"\",\n                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n                \"i.e. the top-most superclass has to implements Serializable.\",\n                \"\"\n        ));",
    "right" : "throw new MockitoException(join(\n                \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n                \"\",\n                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n                \"i.e. the top-most superclass has to implements Serializable.\",\n                \"\"\n        ));",
    "info" : "ThrowStatement[35912-36599]:ThrowStatement[36043-36730]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[36611-36617]:Modifier[36742-36748]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[36618-36622]:PrimitiveType[36749-36753]"
  }, {
    "left" : "delegatedMethodHasWrongReturnType",
    "right" : "delegatedMethodHasWrongReturnType",
    "info" : "SimpleName[36623-36656]:SimpleName[36754-36787]"
  }, {
    "left" : "Method mockMethod",
    "right" : "Method mockMethod",
    "info" : "SingleVariableDeclaration[36657-36674]:SingleVariableDeclaration[36788-36805]"
  }, {
    "left" : "Method delegateMethod",
    "right" : "Method delegateMethod",
    "info" : "SingleVariableDeclaration[36676-36697]:SingleVariableDeclaration[36807-36828]"
  }, {
    "left" : "Object mock",
    "right" : "Object mock",
    "info" : "SingleVariableDeclaration[36699-36710]:SingleVariableDeclaration[36830-36841]"
  }, {
    "left" : "Object delegate",
    "right" : "Object delegate",
    "info" : "SingleVariableDeclaration[36712-36727]:SingleVariableDeclaration[36843-36858]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36729-37327]:Block[36860-37458]"
  }, {
    "left" : "throw new MockitoException(join(\n    \t        \"Methods called on delegated instance must have compatible return types with the mock.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"return type should be: \" + mockMethod.getReturnType().getSimpleName() + \", but was: \" + delegateMethod.getReturnType().getSimpleName(),\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));",
    "right" : "throw new MockitoException(join(\n    \t        \"Methods called on delegated instance must have compatible return types with the mock.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"return type should be: \" + mockMethod.getReturnType().getSimpleName() + \", but was: \" + delegateMethod.getReturnType().getSimpleName(),\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));",
    "info" : "ThrowStatement[36736-37321]:ThrowStatement[36867-37452]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[37330-37336]:Modifier[37461-37467]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[37337-37341]:PrimitiveType[37468-37472]"
  }, {
    "left" : "delegatedMethodDoesNotExistOnDelegate",
    "right" : "delegatedMethodDoesNotExistOnDelegate",
    "info" : "SimpleName[37342-37379]:SimpleName[37473-37510]"
  }, {
    "left" : "Method mockMethod",
    "right" : "Method mockMethod",
    "info" : "SingleVariableDeclaration[37380-37397]:SingleVariableDeclaration[37511-37528]"
  }, {
    "left" : "Object mock",
    "right" : "Object mock",
    "info" : "SingleVariableDeclaration[37399-37410]:SingleVariableDeclaration[37530-37541]"
  }, {
    "left" : "Object delegate",
    "right" : "Object delegate",
    "info" : "SingleVariableDeclaration[37412-37427]:SingleVariableDeclaration[37543-37558]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37429-37884]:Block[37560-38015]"
  }, {
    "left" : "throw new MockitoException(join(\n    \t        \"Methods called on mock must exist in delegated instance.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"no such method was found.\",\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));",
    "right" : "throw new MockitoException(join(\n    \t        \"Methods called on mock must exist in delegated instance.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"no such method was found.\",\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));",
    "info" : "ThrowStatement[37433-37881]:ThrowStatement[37564-38012]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[37890-37896]:Modifier[38021-38027]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[37897-37901]:PrimitiveType[38028-38032]"
  }, {
    "left" : "usingConstructorWithFancySerializable",
    "right" : "usingConstructorWithFancySerializable",
    "info" : "SimpleName[37902-37939]:SimpleName[38033-38070]"
  }, {
    "left" : "SerializableMode mode",
    "right" : "SerializableMode mode",
    "info" : "SingleVariableDeclaration[37940-37961]:SingleVariableDeclaration[38071-38092]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37963-38102]:Block[38094-38233]"
  }, {
    "left" : "throw new MockitoException(\"Mocks instantiated with constructor cannot be combined with \" + mode + \" serialization mode.\");",
    "right" : "throw new MockitoException(\"Mocks instantiated with constructor cannot be combined with \" + mode + \" serialization mode.\");",
    "info" : "ThrowStatement[37973-38096]:ThrowStatement[38104-38227]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[38108-38115]:Modifier[38239-38246]"
  }, {
    "left" : "MockName",
    "right" : "MockName",
    "info" : "SimpleType[38116-38124]:SimpleType[38247-38255]"
  }, {
    "left" : "safelyGetMockName",
    "right" : "safelyGetMockName",
    "info" : "SimpleName[38125-38142]:SimpleName[38256-38273]"
  }, {
    "left" : "Object mock",
    "right" : "Object mock",
    "info" : "SingleVariableDeclaration[38143-38154]:SingleVariableDeclaration[38274-38285]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38156-38212]:Block[38287-38343]"
  }, {
    "left" : "return new MockUtil().getMockName(mock);",
    "right" : "return new MockUtil().getMockName(mock);",
    "info" : "ReturnStatement[38166-38206]:ReturnStatement[38297-38337]"
  } ]
}