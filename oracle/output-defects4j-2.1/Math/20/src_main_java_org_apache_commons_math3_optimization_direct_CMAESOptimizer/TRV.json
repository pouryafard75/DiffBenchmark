{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;",
      "right" : "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;",
      "info" : "FieldDeclaration[4427-4550]:FieldDeclaration[4427-4550]"
    }, {
      "left" : "public static final double DEFAULT_STOPFITNESS = 0;",
      "right" : "public static final double DEFAULT_STOPFITNESS = 0;",
      "info" : "FieldDeclaration[4555-4667]:FieldDeclaration[4555-4667]"
    }, {
      "left" : "public static final boolean DEFAULT_ISACTIVECMA = true;",
      "right" : "public static final boolean DEFAULT_ISACTIVECMA = true;",
      "info" : "FieldDeclaration[4672-4788]:FieldDeclaration[4672-4788]"
    }, {
      "left" : "public static final int DEFAULT_MAXITERATIONS = 30000;",
      "right" : "public static final int DEFAULT_MAXITERATIONS = 30000;",
      "info" : "FieldDeclaration[4793-4910]:FieldDeclaration[4793-4910]"
    }, {
      "left" : "public static final int DEFAULT_DIAGONALONLY = 0;",
      "right" : "public static final int DEFAULT_DIAGONALONLY = 0;",
      "info" : "FieldDeclaration[4915-5026]:FieldDeclaration[4915-5026]"
    }, {
      "left" : "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();",
      "right" : "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();",
      "info" : "FieldDeclaration[5031-5161]:FieldDeclaration[5031-5161]"
    }, {
      "left" : "private int lambda;",
      "right" : "private int lambda;",
      "info" : "FieldDeclaration[5199-5626]:FieldDeclaration[5199-5626]"
    }, {
      "left" : "private boolean isActiveCMA;",
      "right" : "private boolean isActiveCMA;",
      "info" : "FieldDeclaration[5650-6029]:FieldDeclaration[5650-6029]"
    }, {
      "left" : "private int checkFeasableCount;",
      "right" : "private int checkFeasableCount;",
      "info" : "FieldDeclaration[6034-6266]:FieldDeclaration[6034-6266]"
    }, {
      "left" : "private double[][] boundaries;",
      "right" : "private double[][] boundaries;",
      "info" : "FieldDeclaration[6271-6426]:FieldDeclaration[6271-6426]"
    }, {
      "left" : "private double[] inputSigma;",
      "right" : "private double[] inputSigma;",
      "info" : "FieldDeclaration[6431-6700]:FieldDeclaration[6431-6700]"
    }, {
      "left" : "private int dimension;",
      "right" : "private int dimension;",
      "info" : "FieldDeclaration[6705-6786]:FieldDeclaration[6705-6786]"
    }, {
      "left" : "private int diagonalOnly = 0;",
      "right" : "private int diagonalOnly = 0;",
      "info" : "FieldDeclaration[6791-7301]:FieldDeclaration[6791-7301]"
    }, {
      "left" : "private boolean isMinimize = true;",
      "right" : "private boolean isMinimize = true;",
      "info" : "FieldDeclaration[7306-7399]:FieldDeclaration[7306-7399]"
    }, {
      "left" : "private boolean generateStatistics = false;",
      "right" : "private boolean generateStatistics = false;",
      "info" : "FieldDeclaration[7404-7505]:FieldDeclaration[7404-7505]"
    }, {
      "left" : "private int maxIterations;",
      "right" : "private int maxIterations;",
      "info" : "FieldDeclaration[7539-7614]:FieldDeclaration[7539-7614]"
    }, {
      "left" : "private double stopFitness;",
      "right" : "private double stopFitness;",
      "info" : "FieldDeclaration[7619-7682]:FieldDeclaration[7619-7682]"
    }, {
      "left" : "private double stopTolUpX;",
      "right" : "private double stopTolUpX;",
      "info" : "FieldDeclaration[7687-7761]:FieldDeclaration[7687-7761]"
    }, {
      "left" : "private double stopTolX;",
      "right" : "private double stopTolX;",
      "info" : "FieldDeclaration[7766-7836]:FieldDeclaration[7766-7836]"
    }, {
      "left" : "private double stopTolFun;",
      "right" : "private double stopTolFun;",
      "info" : "FieldDeclaration[7841-7918]:FieldDeclaration[7841-7918]"
    }, {
      "left" : "private double stopTolHistFun;",
      "right" : "private double stopTolHistFun;",
      "info" : "FieldDeclaration[7923-8013]:FieldDeclaration[7923-8013]"
    }, {
      "left" : "private int mu;",
      "right" : "private int mu;",
      "info" : "FieldDeclaration[8056-8126]:FieldDeclaration[8056-8126]"
    }, {
      "left" : "private double logMu2;",
      "right" : "private double logMu2;",
      "info" : "FieldDeclaration[8134-8205]:FieldDeclaration[8134-8205]"
    }, {
      "left" : "private RealMatrix weights;",
      "right" : "private RealMatrix weights;",
      "info" : "FieldDeclaration[8210-8282]:FieldDeclaration[8210-8282]"
    }, {
      "left" : "private double mueff;",
      "right" : "private double mueff;",
      "info" : "FieldDeclaration[8287-8358]:FieldDeclaration[8287-8358]"
    }, {
      "left" : "private double sigma;",
      "right" : "private double sigma;",
      "info" : "FieldDeclaration[8416-8492]:FieldDeclaration[8416-8492]"
    }, {
      "left" : "private double cc;",
      "right" : "private double cc;",
      "info" : "FieldDeclaration[8497-8547]:FieldDeclaration[8497-8547]"
    }, {
      "left" : "private double cs;",
      "right" : "private double cs;",
      "info" : "FieldDeclaration[8552-8616]:FieldDeclaration[8552-8616]"
    }, {
      "left" : "private double damps;",
      "right" : "private double damps;",
      "info" : "FieldDeclaration[8621-8676]:FieldDeclaration[8621-8676]"
    }, {
      "left" : "private double ccov1;",
      "right" : "private double ccov1;",
      "info" : "FieldDeclaration[8681-8748]:FieldDeclaration[8681-8748]"
    }, {
      "left" : "private double ccovmu;",
      "right" : "private double ccovmu;",
      "info" : "FieldDeclaration[8753-8820]:FieldDeclaration[8753-8820]"
    }, {
      "left" : "private double chiN;",
      "right" : "private double chiN;",
      "info" : "FieldDeclaration[8825-8903]:FieldDeclaration[8825-8903]"
    }, {
      "left" : "private double ccov1Sep;",
      "right" : "private double ccov1Sep;",
      "info" : "FieldDeclaration[8908-8992]:FieldDeclaration[8908-8992]"
    }, {
      "left" : "private double ccovmuSep;",
      "right" : "private double ccovmuSep;",
      "info" : "FieldDeclaration[8997-9081]:FieldDeclaration[8997-9081]"
    }, {
      "left" : "private RealMatrix xmean;",
      "right" : "private RealMatrix xmean;",
      "info" : "FieldDeclaration[9140-9197]:FieldDeclaration[9140-9197]"
    }, {
      "left" : "private RealMatrix pc;",
      "right" : "private RealMatrix pc;",
      "info" : "FieldDeclaration[9202-9251]:FieldDeclaration[9202-9251]"
    }, {
      "left" : "private RealMatrix ps;",
      "right" : "private RealMatrix ps;",
      "info" : "FieldDeclaration[9256-9315]:FieldDeclaration[9256-9315]"
    }, {
      "left" : "private double normps;",
      "right" : "private double normps;",
      "info" : "FieldDeclaration[9320-9388]:FieldDeclaration[9320-9388]"
    }, {
      "left" : "private RealMatrix B;",
      "right" : "private RealMatrix B;",
      "info" : "FieldDeclaration[9393-9444]:FieldDeclaration[9393-9444]"
    }, {
      "left" : "private RealMatrix D;",
      "right" : "private RealMatrix D;",
      "info" : "FieldDeclaration[9449-9490]:FieldDeclaration[9449-9490]"
    }, {
      "left" : "private RealMatrix BD;",
      "right" : "private RealMatrix BD;",
      "info" : "FieldDeclaration[9495-9556]:FieldDeclaration[9495-9556]"
    }, {
      "left" : "private RealMatrix diagD;",
      "right" : "private RealMatrix diagD;",
      "info" : "FieldDeclaration[9561-9641]:FieldDeclaration[9561-9641]"
    }, {
      "left" : "private RealMatrix C;",
      "right" : "private RealMatrix C;",
      "info" : "FieldDeclaration[9646-9697]:FieldDeclaration[9646-9697]"
    }, {
      "left" : "private RealMatrix diagC;",
      "right" : "private RealMatrix diagC;",
      "info" : "FieldDeclaration[9702-9776]:FieldDeclaration[9702-9776]"
    }, {
      "left" : "private int iterations;",
      "right" : "private int iterations;",
      "info" : "FieldDeclaration[9781-9855]:FieldDeclaration[9781-9855]"
    }, {
      "left" : "private double[] fitnessHistory;",
      "right" : "private double[] fitnessHistory;",
      "info" : "FieldDeclaration[9861-9934]:FieldDeclaration[9861-9934]"
    }, {
      "left" : "private int historySize;",
      "right" : "private int historySize;",
      "info" : "FieldDeclaration[9939-10012]:FieldDeclaration[9939-10012]"
    }, {
      "left" : "private RandomGenerator random;",
      "right" : "private RandomGenerator random;",
      "info" : "FieldDeclaration[10018-10078]:FieldDeclaration[10018-10078]"
    }, {
      "left" : "private List<Double> statisticsSigmaHistory = new ArrayList<Double>();",
      "right" : "private List<Double> statisticsSigmaHistory = new ArrayList<Double>();",
      "info" : "FieldDeclaration[10084-10190]:FieldDeclaration[10084-10190]"
    }, {
      "left" : "private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>();",
      "right" : "private List<RealMatrix> statisticsMeanHistory = new ArrayList<RealMatrix>();",
      "info" : "FieldDeclaration[10195-10307]:FieldDeclaration[10195-10307]"
    }, {
      "left" : "private List<Double> statisticsFitnessHistory = new ArrayList<Double>();",
      "right" : "private List<Double> statisticsFitnessHistory = new ArrayList<Double>();",
      "info" : "FieldDeclaration[10312-10422]:FieldDeclaration[10312-10422]"
    }, {
      "left" : "private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>();",
      "right" : "private List<RealMatrix> statisticsDHistory = new ArrayList<RealMatrix>();",
      "info" : "FieldDeclaration[10427-10533]:FieldDeclaration[10427-10533]"
    }, {
      "left" : "public CMAESOptimizer()",
      "right" : "public CMAESOptimizer()",
      "info" : "MethodDeclaration[10539-10655]:MethodDeclaration[10539-10655]"
    }, {
      "left" : "public CMAESOptimizer(int lambda)",
      "right" : "public CMAESOptimizer(int lambda)",
      "info" : "MethodDeclaration[10661-10957]:MethodDeclaration[10661-10957]"
    }, {
      "left" : "public CMAESOptimizer(int lambda, double[] inputSigma)",
      "right" : "public CMAESOptimizer(int lambda, double[] inputSigma)",
      "info" : "MethodDeclaration[10963-11374]:MethodDeclaration[10963-11374]"
    }, {
      "left" : "public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics)",
      "right" : "public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics)",
      "info" : "MethodDeclaration[11380-12692]:MethodDeclaration[11380-12692]"
    }, {
      "left" : "public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker)",
      "right" : "public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker)",
      "info" : "MethodDeclaration[12698-14290]:MethodDeclaration[12698-14290]"
    }, {
      "left" : "public List<Double> getStatisticsSigmaHistory()",
      "right" : "public List<Double> getStatisticsSigmaHistory()",
      "info" : "MethodDeclaration[14296-14446]:MethodDeclaration[14296-14446]"
    }, {
      "left" : "public List<RealMatrix> getStatisticsMeanHistory()",
      "right" : "public List<RealMatrix> getStatisticsMeanHistory()",
      "info" : "MethodDeclaration[14452-14603]:MethodDeclaration[14452-14603]"
    }, {
      "left" : "public List<Double> getStatisticsFitnessHistory()",
      "right" : "public List<Double> getStatisticsFitnessHistory()",
      "info" : "MethodDeclaration[14609-14765]:MethodDeclaration[14609-14765]"
    }, {
      "left" : "public List<RealMatrix> getStatisticsDHistory()",
      "right" : "public List<RealMatrix> getStatisticsDHistory()",
      "info" : "MethodDeclaration[14771-14913]:MethodDeclaration[14771-14913]"
    }, {
      "left" : "protected PointValuePair doOptimize()",
      "right" : "protected PointValuePair doOptimize()",
      "info" : "MethodDeclaration[14919-22313]:MethodDeclaration[14919-22313]"
    }, {
      "left" : "private void checkParameters()",
      "right" : "private void checkParameters()",
      "info" : "MethodDeclaration[22319-24575]:MethodDeclaration[22319-24575]"
    }, {
      "left" : "private void initializeCMA(double[] guess)",
      "right" : "private void initializeCMA(double[] guess)",
      "info" : "MethodDeclaration[24581-28061]:MethodDeclaration[24581-28061]"
    }, {
      "left" : "private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold)",
      "right" : "private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold)",
      "info" : "MethodDeclaration[28067-29008]:MethodDeclaration[28067-29008]"
    }, {
      "left" : "private void updateCovarianceDiagonalOnly(boolean hsig,\n                                              final RealMatrix bestArz,\n                                              final RealMatrix xold)",
      "right" : "private void updateCovarianceDiagonalOnly(boolean hsig,\n                                              final RealMatrix bestArz,\n                                              final RealMatrix xold)",
      "info" : "MethodDeclaration[29014-30303]:MethodDeclaration[29014-30303]"
    }, {
      "left" : "private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n            final RealMatrix arz, final int[] arindex, final RealMatrix xold)",
      "right" : "private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n            final RealMatrix arz, final int[] arindex, final RealMatrix xold)",
      "info" : "MethodDeclaration[30309-34452]:MethodDeclaration[30309-34452]"
    }, {
      "left" : "private void updateBD(double negccov)",
      "right" : "private void updateBD(double negccov)",
      "info" : "MethodDeclaration[34458-35997]:MethodDeclaration[34458-35997]"
    }, {
      "left" : "private static void push(double[] vals, double val)",
      "right" : "private static void push(double[] vals, double val)",
      "info" : "MethodDeclaration[36003-36346]:MethodDeclaration[36003-36346]"
    }, {
      "left" : "private int[] sortedIndices(final double[] doubles)",
      "right" : "private int[] sortedIndices(final double[] doubles)",
      "info" : "MethodDeclaration[36352-36953]:MethodDeclaration[36352-36953]"
    }, {
      "left" : "DoubleIndex",
      "right" : "DoubleIndex",
      "info" : "TypeDeclaration[36959-38216]:TypeDeclaration[36959-38216]"
    }, {
      "left" : "private double value;",
      "right" : "private double value;",
      "info" : "FieldDeclaration[37142-37196]:FieldDeclaration[37142-37196]"
    }, {
      "left" : "private int index;",
      "right" : "private int index;",
      "info" : "FieldDeclaration[37205-37263]:FieldDeclaration[37205-37263]"
    }, {
      "left" : "DoubleIndex(double value, int index)",
      "right" : "DoubleIndex(double value, int index)",
      "info" : "MethodDeclaration[37273-37500]:MethodDeclaration[37273-37500]"
    }, {
      "left" : "public int compareTo(DoubleIndex o)",
      "right" : "public int compareTo(DoubleIndex o)",
      "info" : "MethodDeclaration[37510-37637]:MethodDeclaration[37510-37637]"
    }, {
      "left" : "public boolean equals(Object other)",
      "right" : "public boolean equals(Object other)",
      "info" : "MethodDeclaration[37647-37989]:MethodDeclaration[37647-37989]"
    }, {
      "left" : "public int hashCode()",
      "right" : "public int hashCode()",
      "info" : "MethodDeclaration[37999-38209]:MethodDeclaration[37999-38209]"
    }, {
      "left" : "private double valueRange;",
      "right" : "private double valueRange;",
      "info" : "FieldDeclaration[38450-38538]:FieldDeclaration[38450-38538]"
    }, {
      "left" : "private boolean isRepairMode;",
      "right" : "private boolean isRepairMode;",
      "info" : "FieldDeclaration[38547-38710]:FieldDeclaration[38547-38710]"
    }, {
      "left" : "public FitnessFunction()",
      "right" : "public FitnessFunction()",
      "info" : "MethodDeclaration[38720-38863]:MethodDeclaration[38720-38863]"
    }, {
      "left" : "public double[] encode(final double[] x)",
      "right" : "public double[] encode(final double[] x)",
      "info" : "MethodDeclaration[38873-39394]:MethodDeclaration[38873-39394]"
    }, {
      "left" : "public double[] decode(final double[] x)",
      "right" : "public double[] decode(final double[] x)",
      "info" : "MethodDeclaration[39669-40188]:MethodDeclaration[39742-40261]"
    }, {
      "left" : "public double value(final double[] point)",
      "right" : "public double value(final double[] point)",
      "info" : "MethodDeclaration[40198-40883]:MethodDeclaration[40271-40956]"
    }, {
      "left" : "public boolean isFeasible(final double[] x)",
      "right" : "public boolean isFeasible(final double[] x)",
      "info" : "MethodDeclaration[40893-41409]:MethodDeclaration[40966-41482]"
    }, {
      "left" : "public void setValueRange(double valueRange)",
      "right" : "public void setValueRange(double valueRange)",
      "info" : "MethodDeclaration[41419-41603]:MethodDeclaration[41492-41676]"
    }, {
      "left" : "private double[] repair(final double[] x)",
      "right" : "private double[] repair(final double[] x)",
      "info" : "MethodDeclaration[41613-42189]:MethodDeclaration[41686-42262]"
    }, {
      "left" : "private double penalty(final double[] x, final double[] repaired)",
      "right" : "private double penalty(final double[] x, final double[] repaired)",
      "info" : "MethodDeclaration[42199-42737]:MethodDeclaration[42272-42810]"
    }, {
      "left" : "private static RealMatrix log(final RealMatrix m)",
      "right" : "private static RealMatrix log(final RealMatrix m)",
      "info" : "MethodDeclaration[42834-43332]:MethodDeclaration[42907-43405]"
    }, {
      "left" : "private static RealMatrix sqrt(final RealMatrix m)",
      "right" : "private static RealMatrix sqrt(final RealMatrix m)",
      "info" : "MethodDeclaration[43338-43858]:MethodDeclaration[43411-43931]"
    }, {
      "left" : "private static RealMatrix square(final RealMatrix m)",
      "right" : "private static RealMatrix square(final RealMatrix m)",
      "info" : "MethodDeclaration[43864-44391]:MethodDeclaration[43937-44464]"
    }, {
      "left" : "private static RealMatrix times(final RealMatrix m, final RealMatrix n)",
      "right" : "private static RealMatrix times(final RealMatrix m, final RealMatrix n)",
      "info" : "MethodDeclaration[44397-44978]:MethodDeclaration[44470-45051]"
    }, {
      "left" : "private static RealMatrix divide(final RealMatrix m, final RealMatrix n)",
      "right" : "private static RealMatrix divide(final RealMatrix m, final RealMatrix n)",
      "info" : "MethodDeclaration[44984-45559]:MethodDeclaration[45057-45632]"
    }, {
      "left" : "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols)",
      "right" : "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols)",
      "info" : "MethodDeclaration[45565-46093]:MethodDeclaration[45638-46166]"
    }, {
      "left" : "private static RealMatrix triu(final RealMatrix m, int k)",
      "right" : "private static RealMatrix triu(final RealMatrix m, int k)",
      "info" : "MethodDeclaration[46099-46628]:MethodDeclaration[46172-46701]"
    }, {
      "left" : "private static RealMatrix sumRows(final RealMatrix m)",
      "right" : "private static RealMatrix sumRows(final RealMatrix m)",
      "info" : "MethodDeclaration[46634-47154]:MethodDeclaration[46707-47227]"
    }, {
      "left" : "private static RealMatrix diag(final RealMatrix m)",
      "right" : "private static RealMatrix diag(final RealMatrix m)",
      "info" : "MethodDeclaration[47160-47972]:MethodDeclaration[47233-48045]"
    }, {
      "left" : "private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2)",
      "right" : "private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2)",
      "info" : "MethodDeclaration[47978-48390]:MethodDeclaration[48051-48463]"
    }, {
      "left" : "private static RealMatrix ones(int n, int m)",
      "right" : "private static RealMatrix ones(int n, int m)",
      "info" : "MethodDeclaration[48396-48751]:MethodDeclaration[48469-48824]"
    }, {
      "left" : "private static RealMatrix eye(int n, int m)",
      "right" : "private static RealMatrix eye(int n, int m)",
      "info" : "MethodDeclaration[48757-49168]:MethodDeclaration[48830-49241]"
    }, {
      "left" : "private static RealMatrix zeros(int n, int m)",
      "right" : "private static RealMatrix zeros(int n, int m)",
      "info" : "MethodDeclaration[49174-49401]:MethodDeclaration[49247-49474]"
    }, {
      "left" : "private static RealMatrix repmat(final RealMatrix mat, int n, int m)",
      "right" : "private static RealMatrix repmat(final RealMatrix mat, int n, int m)",
      "info" : "MethodDeclaration[49407-50051]:MethodDeclaration[49480-50124]"
    }, {
      "left" : "private static RealMatrix sequence(double start, double end, double step)",
      "right" : "private static RealMatrix sequence(double start, double end, double step)",
      "info" : "MethodDeclaration[50057-50575]:MethodDeclaration[50130-50648]"
    }, {
      "left" : "private static double max(final RealMatrix m)",
      "right" : "private static double max(final RealMatrix m)",
      "info" : "MethodDeclaration[50581-51063]:MethodDeclaration[50654-51136]"
    }, {
      "left" : "private static double min(final RealMatrix m)",
      "right" : "private static double min(final RealMatrix m)",
      "info" : "MethodDeclaration[51069-51550]:MethodDeclaration[51142-51623]"
    }, {
      "left" : "private static double max(final double[] m)",
      "right" : "private static double max(final double[] m)",
      "info" : "MethodDeclaration[51556-51887]:MethodDeclaration[51629-51960]"
    }, {
      "left" : "private static double min(final double[] m)",
      "right" : "private static double min(final double[] m)",
      "info" : "MethodDeclaration[51893-52223]:MethodDeclaration[51966-52296]"
    }, {
      "left" : "private static int[] inverse(final int[] indices)",
      "right" : "private static int[] inverse(final int[] indices)",
      "info" : "MethodDeclaration[52229-52576]:MethodDeclaration[52302-52649]"
    }, {
      "left" : "private static int[] reverse(final int[] indices)",
      "right" : "private static int[] reverse(final int[] indices)",
      "info" : "MethodDeclaration[52582-52949]:MethodDeclaration[52655-53022]"
    }, {
      "left" : "private double[] randn(int size)",
      "right" : "private double[] randn(int size)",
      "info" : "MethodDeclaration[52955-53268]:MethodDeclaration[53028-53341]"
    }, {
      "left" : "private RealMatrix randn1(int size, int popSize)",
      "right" : "private RealMatrix randn1(int size, int popSize)",
      "info" : "MethodDeclaration[53274-53749]:MethodDeclaration[53347-53822]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10631-10655]:Block[10631-10655]"
    }, {
      "left" : "this(0);",
      "right" : "this(0);",
      "info" : "ConstructorInvocation[10641-10649]:ConstructorInvocation[10641-10649]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10749-10957]:Block[10749-10957]"
    }, {
      "left" : "this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);",
      "right" : "this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);",
      "info" : "ConstructorInvocation[10759-10951]:ConstructorInvocation[10759-10951]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11160-11374]:Block[11160-11374]"
    }, {
      "left" : "this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);",
      "right" : "this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);",
      "info" : "ConstructorInvocation[11170-11368]:ConstructorInvocation[11170-11368]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12496-12692]:Block[12496-12692]"
    }, {
      "left" : "this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());",
      "right" : "this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());",
      "info" : "ConstructorInvocation[12506-12686]:ConstructorInvocation[12506-12686]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13840-14290]:Block[13840-14290]"
    }, {
      "left" : "super(checker);",
      "right" : "super(checker);",
      "info" : "SuperConstructorInvocation[13850-13865]:SuperConstructorInvocation[13850-13865]"
    }, {
      "left" : "this.lambda = lambda;",
      "right" : "this.lambda = lambda;",
      "info" : "ExpressionStatement[13874-13895]:ExpressionStatement[13874-13895]"
    }, {
      "left" : "this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();",
      "right" : "this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();",
      "info" : "ExpressionStatement[13904-13980]:ExpressionStatement[13904-13980]"
    }, {
      "left" : "this.maxIterations = maxIterations;",
      "right" : "this.maxIterations = maxIterations;",
      "info" : "ExpressionStatement[13989-14024]:ExpressionStatement[13989-14024]"
    }, {
      "left" : "this.stopFitness = stopFitness;",
      "right" : "this.stopFitness = stopFitness;",
      "info" : "ExpressionStatement[14033-14064]:ExpressionStatement[14033-14064]"
    }, {
      "left" : "this.isActiveCMA = isActiveCMA;",
      "right" : "this.isActiveCMA = isActiveCMA;",
      "info" : "ExpressionStatement[14073-14104]:ExpressionStatement[14073-14104]"
    }, {
      "left" : "this.diagonalOnly = diagonalOnly;",
      "right" : "this.diagonalOnly = diagonalOnly;",
      "info" : "ExpressionStatement[14113-14146]:ExpressionStatement[14113-14146]"
    }, {
      "left" : "this.checkFeasableCount = checkFeasableCount;",
      "right" : "this.checkFeasableCount = checkFeasableCount;",
      "info" : "ExpressionStatement[14155-14200]:ExpressionStatement[14155-14200]"
    }, {
      "left" : "this.random = random;",
      "right" : "this.random = random;",
      "info" : "ExpressionStatement[14209-14230]:ExpressionStatement[14209-14230]"
    }, {
      "left" : "this.generateStatistics = generateStatistics;",
      "right" : "this.generateStatistics = generateStatistics;",
      "info" : "ExpressionStatement[14239-14284]:ExpressionStatement[14239-14284]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14400-14446]:Block[14400-14446]"
    }, {
      "left" : "return statisticsSigmaHistory;",
      "right" : "return statisticsSigmaHistory;",
      "info" : "ReturnStatement[14410-14440]:ReturnStatement[14410-14440]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14558-14603]:Block[14558-14603]"
    }, {
      "left" : "return statisticsMeanHistory;",
      "right" : "return statisticsMeanHistory;",
      "info" : "ReturnStatement[14568-14597]:ReturnStatement[14568-14597]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14717-14765]:Block[14717-14765]"
    }, {
      "left" : "return statisticsFitnessHistory;",
      "right" : "return statisticsFitnessHistory;",
      "info" : "ReturnStatement[14727-14759]:ReturnStatement[14727-14759]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14871-14913]:Block[14871-14913]"
    }, {
      "left" : "return statisticsDHistory;",
      "right" : "return statisticsDHistory;",
      "info" : "ReturnStatement[14881-14907]:ReturnStatement[14881-14907]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14996-22313]:Block[14996-22313]"
    }, {
      "left" : "checkParameters();",
      "right" : "checkParameters();",
      "info" : "ExpressionStatement[15006-15024]:ExpressionStatement[15006-15024]"
    }, {
      "left" : "isMinimize = getGoalType().equals(GoalType.MINIMIZE);",
      "right" : "isMinimize = getGoalType().equals(GoalType.MINIMIZE);",
      "info" : "ExpressionStatement[15114-15167]:ExpressionStatement[15114-15167]"
    }, {
      "left" : "final FitnessFunction fitfun = new FitnessFunction();",
      "right" : "final FitnessFunction fitfun = new FitnessFunction();",
      "info" : "VariableDeclarationStatement[15176-15229]:VariableDeclarationStatement[15176-15229]"
    }, {
      "left" : "final double[] guess = fitfun.encode(getStartPoint());",
      "right" : "final double[] guess = fitfun.encode(getStartPoint());",
      "info" : "VariableDeclarationStatement[15238-15292]:VariableDeclarationStatement[15238-15292]"
    }, {
      "left" : "dimension = guess.length;",
      "right" : "dimension = guess.length;",
      "info" : "ExpressionStatement[15360-15385]:ExpressionStatement[15360-15385]"
    }, {
      "left" : "initializeCMA(guess);",
      "right" : "initializeCMA(guess);",
      "info" : "ExpressionStatement[15394-15415]:ExpressionStatement[15394-15415]"
    }, {
      "left" : "iterations = 0;",
      "right" : "iterations = 0;",
      "info" : "ExpressionStatement[15424-15439]:ExpressionStatement[15424-15439]"
    }, {
      "left" : "double bestValue = fitfun.value(guess);",
      "right" : "double bestValue = fitfun.value(guess);",
      "info" : "VariableDeclarationStatement[15448-15487]:VariableDeclarationStatement[15448-15487]"
    }, {
      "left" : "push(fitnessHistory, bestValue);",
      "right" : "push(fitnessHistory, bestValue);",
      "info" : "ExpressionStatement[15496-15528]:ExpressionStatement[15496-15528]"
    }, {
      "left" : "PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);",
      "right" : "PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);",
      "info" : "VariableDeclarationStatement[15537-15651]:VariableDeclarationStatement[15537-15651]"
    }, {
      "left" : "PointValuePair lastResult = null;",
      "right" : "PointValuePair lastResult = null;",
      "info" : "VariableDeclarationStatement[15660-15693]:VariableDeclarationStatement[15660-15693]"
    }, {
      "left" : "generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                // Generate and evaluate lambda offspring\n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                // generate random offspring\n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        // regenerate random arguments for row\n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                // Sort by fitness and compute weighted mean into xmean\n                int[] arindex = sortedIndices(fitness);\n                // Calculate new xmean, this is selection and recombination\n                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                // Adapt step size sigma - Eq. (5)\n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                // handle termination criteria\n                // Break, if fitness is good enough\n                if (stopFitness != 0) { // only if stopFitness is defined\n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                // condition number of the covariance matrix exceeds 1e14\n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                // user defined termination\n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                // Adjust step size in case of equal function values (flat fitness)\n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                // store best in history\n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }",
      "right" : "generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                // Generate and evaluate lambda offspring\n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                // generate random offspring\n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        // regenerate random arguments for row\n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                // Sort by fitness and compute weighted mean into xmean\n                int[] arindex = sortedIndices(fitness);\n                // Calculate new xmean, this is selection and recombination\n                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                // Adapt step size sigma - Eq. (5)\n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                // handle termination criteria\n                // Break, if fitness is good enough\n                if (stopFitness != 0) { // only if stopFitness is defined\n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                // condition number of the covariance matrix exceeds 1e14\n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                // user defined termination\n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                // Adjust step size in case of equal function values (flat fitness)\n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                // store best in history\n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }",
      "info" : "LabeledStatement[15785-22283]:LabeledStatement[15785-22283]"
    }, {
      "left" : "for (iterations = 1; iterations <= maxIterations; iterations++)",
      "right" : "for (iterations = 1; iterations <= maxIterations; iterations++)",
      "info" : "ForStatement[15813-22283]:ForStatement[15813-22283]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15877-22283]:Block[15877-22283]"
    }, {
      "left" : "RealMatrix arz = randn1(dimension, lambda);",
      "right" : "RealMatrix arz = randn1(dimension, lambda);",
      "info" : "VariableDeclarationStatement[15953-15996]:VariableDeclarationStatement[15953-15996]"
    }, {
      "left" : "RealMatrix arx = zeros(dimension, lambda);",
      "right" : "RealMatrix arx = zeros(dimension, lambda);",
      "info" : "VariableDeclarationStatement[16013-16055]:VariableDeclarationStatement[16013-16055]"
    }, {
      "left" : "double[] fitness = new double[lambda];",
      "right" : "double[] fitness = new double[lambda];",
      "info" : "VariableDeclarationStatement[16072-16110]:VariableDeclarationStatement[16072-16110]"
    }, {
      "left" : "for (int k = 0; k < lambda; k++)",
      "right" : "for (int k = 0; k < lambda; k++)",
      "info" : "ForStatement[16172-17348]:ForStatement[16172-17348]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16205-17348]:Block[16205-17348]"
    }, {
      "left" : "RealMatrix arxk = null;",
      "right" : "RealMatrix arxk = null;",
      "info" : "VariableDeclarationStatement[16227-16250]:VariableDeclarationStatement[16227-16250]"
    }, {
      "left" : "for (int i = 0; i < checkFeasableCount+1; i++)",
      "right" : "for (int i = 0; i < checkFeasableCount+1; i++)",
      "info" : "ForStatement[16271-17037]:ForStatement[16271-17037]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16318-17037]:Block[16318-17037]"
    }, {
      "left" : "if (diagonalOnly <= 0)",
      "right" : "if (diagonalOnly <= 0)",
      "info" : "IfStatement[16344-16736]:IfStatement[16344-16736]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16367-16561]:Block[16367-16561]"
    }, {
      "left" : "arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));",
      "right" : "arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));",
      "info" : "ExpressionStatement[16397-16510]:ExpressionStatement[16397-16510]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16567-16736]:Block[16567-16736]"
    }, {
      "left" : "arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));",
      "right" : "arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));",
      "info" : "ExpressionStatement[16597-16710]:ExpressionStatement[16597-16710]"
    }, {
      "left" : "if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0)))",
      "right" : "if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0)))",
      "info" : "IfStatement[16761-16892]:IfStatement[16761-16892]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16830-16892]:Block[16830-16892]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16860-16866]:BreakStatement[16860-16866]"
    }, {
      "left" : "arz.setColumn(k, randn(dimension));",
      "right" : "arz.setColumn(k, randn(dimension));",
      "info" : "ExpressionStatement[16980-17015]:ExpressionStatement[16980-17015]"
    }, {
      "left" : "copyColumn(arxk, 0, arx, k);",
      "right" : "copyColumn(arxk, 0, arx, k);",
      "info" : "ExpressionStatement[17058-17086]:ExpressionStatement[17058-17086]"
    }, {
      "left" : "try{...}",
      "right" : "try{...}",
      "info" : "TryStatement[17107-17330]:TryStatement[17107-17330]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17111-17222]:Block[17111-17222]"
    }, {
      "left" : "fitness[k] = fitfun.value(arx.getColumn(k));",
      "right" : "fitness[k] = fitfun.value(arx.getColumn(k));",
      "info" : "ExpressionStatement[17137-17181]:ExpressionStatement[17137-17181]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17261-17330]:Block[17261-17330]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[17287-17308]:BreakStatement[17287-17308]"
    }, {
      "left" : "int[] arindex = sortedIndices(fitness);",
      "right" : "int[] arindex = sortedIndices(fitness);",
      "info" : "VariableDeclarationStatement[17437-17476]:VariableDeclarationStatement[17437-17476]"
    }, {
      "left" : "RealMatrix xold = xmean;",
      "right" : "RealMatrix xold = xmean;",
      "info" : "VariableDeclarationStatement[17569-17593]:VariableDeclarationStatement[17569-17593]"
    }, {
      "left" : "RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));",
      "right" : "RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));",
      "info" : "VariableDeclarationStatement[17645-17717]:VariableDeclarationStatement[17645-17717]"
    }, {
      "left" : "xmean = bestArx.multiply(weights);",
      "right" : "xmean = bestArx.multiply(weights);",
      "info" : "ExpressionStatement[17734-17768]:ExpressionStatement[17734-17768]"
    }, {
      "left" : "RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));",
      "right" : "RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));",
      "info" : "VariableDeclarationStatement[17785-17857]:VariableDeclarationStatement[17785-17857]"
    }, {
      "left" : "RealMatrix zmean = bestArz.multiply(weights);",
      "right" : "RealMatrix zmean = bestArz.multiply(weights);",
      "info" : "VariableDeclarationStatement[17874-17919]:VariableDeclarationStatement[17874-17919]"
    }, {
      "left" : "boolean hsig = updateEvolutionPaths(zmean, xold);",
      "right" : "boolean hsig = updateEvolutionPaths(zmean, xold);",
      "info" : "VariableDeclarationStatement[17936-17985]:VariableDeclarationStatement[17936-17985]"
    }, {
      "left" : "if (diagonalOnly <= 0)",
      "right" : "if (diagonalOnly <= 0)",
      "info" : "IfStatement[18002-18213]:IfStatement[18002-18213]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18025-18117]:Block[18025-18117]"
    }, {
      "left" : "updateCovariance(hsig, bestArx, arz, arindex, xold);",
      "right" : "updateCovariance(hsig, bestArx, arz, arindex, xold);",
      "info" : "ExpressionStatement[18047-18099]:ExpressionStatement[18047-18099]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18123-18213]:Block[18123-18213]"
    }, {
      "left" : "updateCovarianceDiagonalOnly(hsig, bestArz, xold);",
      "right" : "updateCovarianceDiagonalOnly(hsig, bestArz, xold);",
      "info" : "ExpressionStatement[18145-18195]:ExpressionStatement[18145-18195]"
    }, {
      "left" : "sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));",
      "right" : "sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));",
      "info" : "ExpressionStatement[18281-18342]:ExpressionStatement[18281-18342]"
    }, {
      "left" : "double bestFitness = fitness[arindex[0]];",
      "right" : "double bestFitness = fitness[arindex[0]];",
      "info" : "VariableDeclarationStatement[18359-18400]:VariableDeclarationStatement[18359-18400]"
    }, {
      "left" : "double worstFitness = fitness[arindex[arindex.length-1]];",
      "right" : "double worstFitness = fitness[arindex[arindex.length-1]];",
      "info" : "VariableDeclarationStatement[18417-18474]:VariableDeclarationStatement[18417-18474]"
    }, {
      "left" : "if (bestValue > bestFitness)",
      "right" : "if (bestValue > bestFitness)",
      "info" : "IfStatement[18491-19097]:IfStatement[18491-19097]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18520-19097]:Block[18520-19097]"
    }, {
      "left" : "bestValue = bestFitness;",
      "right" : "bestValue = bestFitness;",
      "info" : "ExpressionStatement[18542-18566]:ExpressionStatement[18542-18566]"
    }, {
      "left" : "lastResult = optimum;",
      "right" : "lastResult = optimum;",
      "info" : "ExpressionStatement[18587-18608]:ExpressionStatement[18587-18608]"
    }, {
      "left" : "optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);",
      "right" : "optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);",
      "info" : "ExpressionStatement[18629-18802]:ExpressionStatement[18629-18802]"
    }, {
      "left" : "if (getConvergenceChecker() != null && lastResult != null)",
      "right" : "if (getConvergenceChecker() != null && lastResult != null)",
      "info" : "IfStatement[18823-19079]:IfStatement[18823-19079]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18882-19079]:Block[18882-19079]"
    }, {
      "left" : "if (getConvergenceChecker().converged(iterations, optimum, lastResult))",
      "right" : "if (getConvergenceChecker().converged(iterations, optimum, lastResult))",
      "info" : "IfStatement[18908-19057]:IfStatement[18908-19057]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18980-19057]:Block[18980-19057]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[19010-19031]:BreakStatement[19010-19031]"
    }, {
      "left" : "if (stopFitness != 0)",
      "right" : "if (stopFitness != 0)",
      "info" : "IfStatement[19213-19439]:IfStatement[19213-19439]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19235-19439]:Block[19235-19439]"
    }, {
      "left" : "if (bestFitness < (isMinimize ? stopFitness : -stopFitness))",
      "right" : "if (bestFitness < (isMinimize ? stopFitness : -stopFitness))",
      "info" : "IfStatement[19291-19421]:IfStatement[19291-19421]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19352-19421]:Block[19352-19421]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[19378-19399]:BreakStatement[19378-19399]"
    }, {
      "left" : "double[] sqrtDiagC = sqrt(diagC).getColumn(0);",
      "right" : "double[] sqrtDiagC = sqrt(diagC).getColumn(0);",
      "info" : "VariableDeclarationStatement[19456-19502]:VariableDeclarationStatement[19456-19502]"
    }, {
      "left" : "double[] pcCol = pc.getColumn(0);",
      "right" : "double[] pcCol = pc.getColumn(0);",
      "info" : "VariableDeclarationStatement[19519-19552]:VariableDeclarationStatement[19519-19552]"
    }, {
      "left" : "for (int i = 0; i < dimension; i++)",
      "right" : "for (int i = 0; i < dimension; i++)",
      "info" : "ForStatement[19569-19878]:ForStatement[19569-19878]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19605-19878]:Block[19605-19878]"
    }, {
      "left" : "if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX)",
      "right" : "if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX)",
      "info" : "IfStatement[19627-19748]:IfStatement[19627-19748]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19694-19748]:Block[19694-19748]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[19720-19726]:BreakStatement[19720-19726]"
    }, {
      "left" : "if (i >= dimension-1)",
      "right" : "if (i >= dimension-1)",
      "info" : "IfStatement[19769-19860]:IfStatement[19769-19860]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19791-19860]:Block[19791-19860]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[19817-19838]:BreakStatement[19817-19838]"
    }, {
      "left" : "for (int i = 0; i < dimension; i++)",
      "right" : "for (int i = 0; i < dimension; i++)",
      "info" : "ForStatement[19895-20077]:ForStatement[19895-20077]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19931-20077]:Block[19931-20077]"
    }, {
      "left" : "if (sigma*sqrtDiagC[i] > stopTolUpX)",
      "right" : "if (sigma*sqrtDiagC[i] > stopTolUpX)",
      "info" : "IfStatement[19953-20059]:IfStatement[19953-20059]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19990-20059]:Block[19990-20059]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[20016-20037]:BreakStatement[20016-20037]"
    }, {
      "left" : "double historyBest = min(fitnessHistory);",
      "right" : "double historyBest = min(fitnessHistory);",
      "info" : "VariableDeclarationStatement[20094-20135]:VariableDeclarationStatement[20094-20135]"
    }, {
      "left" : "double historyWorst = max(fitnessHistory);",
      "right" : "double historyWorst = max(fitnessHistory);",
      "info" : "VariableDeclarationStatement[20152-20194]:VariableDeclarationStatement[20152-20194]"
    }, {
      "left" : "if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun)",
      "right" : "if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun)",
      "info" : "IfStatement[20211-20406]:IfStatement[20211-20406]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20345-20406]:Block[20345-20406]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[20367-20388]:BreakStatement[20367-20388]"
    }, {
      "left" : "if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun)",
      "right" : "if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun)",
      "info" : "IfStatement[20423-20593]:IfStatement[20423-20593]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20532-20593]:Block[20532-20593]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[20554-20575]:BreakStatement[20554-20575]"
    }, {
      "left" : "if (max(diagD)/min(diagD) > 1e7)",
      "right" : "if (max(diagD)/min(diagD) > 1e7)",
      "info" : "IfStatement[20684-20778]:IfStatement[20684-20778]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20717-20778]:Block[20717-20778]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[20739-20760]:BreakStatement[20739-20760]"
    }, {
      "left" : "if (getConvergenceChecker() != null)",
      "right" : "if (getConvergenceChecker() != null)",
      "info" : "IfStatement[20839-21329]:IfStatement[20839-21329]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20876-21329]:Block[20876-21329]"
    }, {
      "left" : "PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);",
      "right" : "PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);",
      "info" : "VariableDeclarationStatement[20898-21061]:VariableDeclarationStatement[20898-21061]"
    }, {
      "left" : "if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult))",
      "right" : "if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult))",
      "info" : "IfStatement[21082-21269]:IfStatement[21082-21269]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21200-21269]:Block[21200-21269]"
    }, {
      "left" : "break generationLoop;",
      "right" : "break generationLoop;",
      "info" : "BreakStatement[21226-21247]:BreakStatement[21226-21247]"
    }, {
      "left" : "lastResult = current;",
      "right" : "lastResult = current;",
      "info" : "ExpressionStatement[21290-21311]:ExpressionStatement[21290-21311]"
    }, {
      "left" : "if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]])",
      "right" : "if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]])",
      "info" : "IfStatement[21430-21566]:IfStatement[21430-21566]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21487-21566]:Block[21487-21566]"
    }, {
      "left" : "sigma = sigma * Math.exp(0.2+cs/damps);",
      "right" : "sigma = sigma * Math.exp(0.2+cs/damps);",
      "info" : "ExpressionStatement[21509-21548]:ExpressionStatement[21509-21548]"
    }, {
      "left" : "if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0)",
      "right" : "if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0)",
      "info" : "IfStatement[21583-21787]:IfStatement[21583-21787]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21708-21787]:Block[21708-21787]"
    }, {
      "left" : "sigma = sigma * Math.exp(0.2+cs/damps);",
      "right" : "sigma = sigma * Math.exp(0.2+cs/damps);",
      "info" : "ExpressionStatement[21730-21769]:ExpressionStatement[21730-21769]"
    }, {
      "left" : "push(fitnessHistory,bestFitness);",
      "right" : "push(fitnessHistory,bestFitness);",
      "info" : "ExpressionStatement[21845-21878]:ExpressionStatement[21845-21878]"
    }, {
      "left" : "fitfun.setValueRange(worstFitness-bestFitness);",
      "right" : "fitfun.setValueRange(worstFitness-bestFitness);",
      "info" : "ExpressionStatement[21895-21942]:ExpressionStatement[21895-21942]"
    }, {
      "left" : "if (generateStatistics)",
      "right" : "if (generateStatistics)",
      "info" : "IfStatement[21959-22269]:IfStatement[21959-22269]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21983-22269]:Block[21983-22269]"
    }, {
      "left" : "statisticsSigmaHistory.add(sigma);",
      "right" : "statisticsSigmaHistory.add(sigma);",
      "info" : "ExpressionStatement[22005-22039]:ExpressionStatement[22005-22039]"
    }, {
      "left" : "statisticsFitnessHistory.add(bestFitness);",
      "right" : "statisticsFitnessHistory.add(bestFitness);",
      "info" : "ExpressionStatement[22060-22102]:ExpressionStatement[22060-22102]"
    }, {
      "left" : "statisticsMeanHistory.add(xmean.transpose());",
      "right" : "statisticsMeanHistory.add(xmean.transpose());",
      "info" : "ExpressionStatement[22123-22168]:ExpressionStatement[22123-22168]"
    }, {
      "left" : "statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));",
      "right" : "statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));",
      "info" : "ExpressionStatement[22189-22251]:ExpressionStatement[22189-22251]"
    }, {
      "left" : "return optimum;",
      "right" : "return optimum;",
      "info" : "ReturnStatement[22292-22307]:ReturnStatement[22292-22307]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22443-24575]:Block[22443-24575]"
    }, {
      "left" : "final double[] init = getStartPoint();",
      "right" : "final double[] init = getStartPoint();",
      "info" : "VariableDeclarationStatement[22453-22491]:VariableDeclarationStatement[22453-22491]"
    }, {
      "left" : "final double[] lB = getLowerBound();",
      "right" : "final double[] lB = getLowerBound();",
      "info" : "VariableDeclarationStatement[22500-22536]:VariableDeclarationStatement[22500-22536]"
    }, {
      "left" : "final double[] uB = getUpperBound();",
      "right" : "final double[] uB = getUpperBound();",
      "info" : "VariableDeclarationStatement[22545-22581]:VariableDeclarationStatement[22545-22581]"
    }, {
      "left" : "boolean hasFiniteBounds = false;",
      "right" : "boolean hasFiniteBounds = false;",
      "info" : "VariableDeclarationStatement[22659-22691]:VariableDeclarationStatement[22659-22691]"
    }, {
      "left" : "for (int i = 0; i < lB.length; i++)",
      "right" : "for (int i = 0; i < lB.length; i++)",
      "info" : "ForStatement[22700-22914]:ForStatement[22700-22914]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22736-22914]:Block[22736-22914]"
    }, {
      "left" : "if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i]))",
      "right" : "if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i]))",
      "info" : "IfStatement[22750-22904]:IfStatement[22750-22904]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22826-22904]:Block[22826-22904]"
    }, {
      "left" : "hasFiniteBounds = true;",
      "right" : "hasFiniteBounds = true;",
      "info" : "ExpressionStatement[22844-22867]:ExpressionStatement[22844-22867]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[22884-22890]:BreakStatement[22884-22890]"
    }, {
      "left" : "boolean hasInfiniteBounds = false;",
      "right" : "boolean hasInfiniteBounds = false;",
      "info" : "VariableDeclarationStatement[22993-23027]:VariableDeclarationStatement[22993-23027]"
    }, {
      "left" : "if (hasFiniteBounds)",
      "right" : "if (hasFiniteBounds)",
      "info" : "IfStatement[23036-23909]:IfStatement[23036-23909]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23057-23798]:Block[23057-23798]"
    }, {
      "left" : "for (int i = 0; i < lB.length; i++)",
      "right" : "for (int i = 0; i < lB.length; i++)",
      "info" : "ForStatement[23071-23309]:ForStatement[23071-23309]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23107-23309]:Block[23107-23309]"
    }, {
      "left" : "if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i]))",
      "right" : "if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i]))",
      "info" : "IfStatement[23125-23295]:IfStatement[23125-23295]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23203-23295]:Block[23203-23295]"
    }, {
      "left" : "hasInfiniteBounds = true;",
      "right" : "hasInfiniteBounds = true;",
      "info" : "ExpressionStatement[23225-23250]:ExpressionStatement[23225-23250]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[23271-23277]:BreakStatement[23271-23277]"
    }, {
      "left" : "if (hasInfiniteBounds)",
      "right" : "if (hasInfiniteBounds)",
      "info" : "IfStatement[23323-23788]:IfStatement[23323-23788]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23346-23582]:Block[23346-23582]"
    }, {
      "left" : "throw new MathUnsupportedOperationException();",
      "right" : "throw new MathUnsupportedOperationException();",
      "info" : "ThrowStatement[23522-23568]:ThrowStatement[23522-23568]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23588-23788]:Block[23588-23788]"
    }, {
      "left" : "boundaries = new double[2][];",
      "right" : "boundaries = new double[2][];",
      "info" : "ExpressionStatement[23673-23702]:ExpressionStatement[23673-23702]"
    }, {
      "left" : "boundaries[0] = lB;",
      "right" : "boundaries[0] = lB;",
      "info" : "ExpressionStatement[23719-23738]:ExpressionStatement[23719-23738]"
    }, {
      "left" : "boundaries[1] = uB;",
      "right" : "boundaries[1] = uB;",
      "info" : "ExpressionStatement[23755-23774]:ExpressionStatement[23755-23774]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23804-23909]:Block[23804-23909]"
    }, {
      "left" : "boundaries = null;",
      "right" : "boundaries = null;",
      "info" : "ExpressionStatement[23881-23899]:ExpressionStatement[23881-23899]"
    }, {
      "left" : "if (inputSigma != null)",
      "right" : "if (inputSigma != null)",
      "info" : "IfStatement[23919-24569]:IfStatement[23919-24569]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23943-24569]:Block[23943-24569]"
    }, {
      "left" : "if (inputSigma.length != init.length)",
      "right" : "if (inputSigma.length != init.length)",
      "info" : "IfStatement[23957-24096]:IfStatement[23957-24096]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23995-24096]:Block[23995-24096]"
    }, {
      "left" : "throw new DimensionMismatchException(inputSigma.length, init.length);",
      "right" : "throw new DimensionMismatchException(inputSigma.length, init.length);",
      "info" : "ThrowStatement[24013-24082]:ThrowStatement[24013-24082]"
    }, {
      "left" : "for (int i = 0; i < init.length; i++)",
      "right" : "for (int i = 0; i < init.length; i++)",
      "info" : "ForStatement[24109-24559]:ForStatement[24109-24559]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24147-24559]:Block[24147-24559]"
    }, {
      "left" : "if (inputSigma[i] < 0)",
      "right" : "if (inputSigma[i] < 0)",
      "info" : "IfStatement[24165-24274]:IfStatement[24165-24274]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24188-24274]:Block[24188-24274]"
    }, {
      "left" : "throw new NotPositiveException(inputSigma[i]);",
      "right" : "throw new NotPositiveException(inputSigma[i]);",
      "info" : "ThrowStatement[24210-24256]:ThrowStatement[24210-24256]"
    }, {
      "left" : "if (boundaries != null)",
      "right" : "if (boundaries != null)",
      "info" : "IfStatement[24291-24545]:IfStatement[24291-24545]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24315-24545]:Block[24315-24545]"
    }, {
      "left" : "if (inputSigma[i] > boundaries[1][i] - boundaries[0][i])",
      "right" : "if (inputSigma[i] > boundaries[1][i] - boundaries[0][i])",
      "info" : "IfStatement[24337-24527]:IfStatement[24337-24527]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24394-24527]:Block[24394-24527]"
    }, {
      "left" : "throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);",
      "right" : "throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);",
      "info" : "ThrowStatement[24420-24505]:ThrowStatement[24420-24505]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24779-28061]:Block[24779-28061]"
    }, {
      "left" : "if (lambda <= 0)",
      "right" : "if (lambda <= 0)",
      "info" : "IfStatement[24789-24876]:IfStatement[24789-24876]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24806-24876]:Block[24806-24876]"
    }, {
      "left" : "lambda = 4 + (int) (3. * Math.log(dimension));",
      "right" : "lambda = 4 + (int) (3. * Math.log(dimension));",
      "info" : "ExpressionStatement[24820-24866]:ExpressionStatement[24820-24866]"
    }, {
      "left" : "double[][] sigmaArray = new double[guess.length][1];",
      "right" : "double[][] sigmaArray = new double[guess.length][1];",
      "info" : "VariableDeclarationStatement[24913-24965]:VariableDeclarationStatement[24913-24965]"
    }, {
      "left" : "for (int i = 0; i < guess.length; i++)",
      "right" : "for (int i = 0; i < guess.length; i++)",
      "info" : "ForStatement[24974-25211]:ForStatement[24974-25211]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25013-25211]:Block[25013-25211]"
    }, {
      "left" : "final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];",
      "right" : "final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];",
      "info" : "VariableDeclarationStatement[25027-25114]:VariableDeclarationStatement[25027-25114]"
    }, {
      "left" : "sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;",
      "right" : "sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;",
      "info" : "ExpressionStatement[25127-25201]:ExpressionStatement[25127-25201]"
    }, {
      "left" : "RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);",
      "right" : "RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);",
      "info" : "VariableDeclarationStatement[25220-25285]:VariableDeclarationStatement[25220-25285]"
    }, {
      "left" : "sigma = max(insigma);",
      "right" : "sigma = max(insigma);",
      "info" : "ExpressionStatement[25294-25315]:ExpressionStatement[25294-25315]"
    }, {
      "left" : "stopTolUpX = 1e3 * max(insigma);",
      "right" : "stopTolUpX = 1e3 * max(insigma);",
      "info" : "ExpressionStatement[25398-25430]:ExpressionStatement[25398-25430]"
    }, {
      "left" : "stopTolX = 1e-11 * max(insigma);",
      "right" : "stopTolX = 1e-11 * max(insigma);",
      "info" : "ExpressionStatement[25439-25471]:ExpressionStatement[25439-25471]"
    }, {
      "left" : "stopTolFun = 1e-12;",
      "right" : "stopTolFun = 1e-12;",
      "info" : "ExpressionStatement[25480-25499]:ExpressionStatement[25480-25499]"
    }, {
      "left" : "stopTolHistFun = 1e-13;",
      "right" : "stopTolHistFun = 1e-13;",
      "info" : "ExpressionStatement[25508-25531]:ExpressionStatement[25508-25531]"
    }, {
      "left" : "mu = lambda / 2;",
      "right" : "mu = lambda / 2;",
      "info" : "ExpressionStatement[25593-25609]:ExpressionStatement[25593-25609]"
    }, {
      "left" : "logMu2 = Math.log(mu + 0.5);",
      "right" : "logMu2 = Math.log(mu + 0.5);",
      "info" : "ExpressionStatement[25664-25692]:ExpressionStatement[25664-25692]"
    }, {
      "left" : "weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);",
      "right" : "weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);",
      "info" : "ExpressionStatement[25701-25773]:ExpressionStatement[25701-25773]"
    }, {
      "left" : "double sumw = 0;",
      "right" : "double sumw = 0;",
      "info" : "VariableDeclarationStatement[25782-25798]:VariableDeclarationStatement[25782-25798]"
    }, {
      "left" : "double sumwq = 0;",
      "right" : "double sumwq = 0;",
      "info" : "VariableDeclarationStatement[25807-25824]:VariableDeclarationStatement[25807-25824]"
    }, {
      "left" : "for (int i = 0; i < mu; i++)",
      "right" : "for (int i = 0; i < mu; i++)",
      "info" : "ForStatement[25833-25971]:ForStatement[25833-25971]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25862-25971]:Block[25862-25971]"
    }, {
      "left" : "double w = weights.getEntry(i, 0);",
      "right" : "double w = weights.getEntry(i, 0);",
      "info" : "VariableDeclarationStatement[25876-25910]:VariableDeclarationStatement[25876-25910]"
    }, {
      "left" : "sumw += w;",
      "right" : "sumw += w;",
      "info" : "ExpressionStatement[25923-25933]:ExpressionStatement[25923-25933]"
    }, {
      "left" : "sumwq += w * w;",
      "right" : "sumwq += w * w;",
      "info" : "ExpressionStatement[25946-25961]:ExpressionStatement[25946-25961]"
    }, {
      "left" : "weights = weights.scalarMultiply(1. / sumw);",
      "right" : "weights = weights.scalarMultiply(1. / sumw);",
      "info" : "ExpressionStatement[25980-26024]:ExpressionStatement[25980-26024]"
    }, {
      "left" : "mueff = sumw * sumw / sumwq;",
      "right" : "mueff = sumw * sumw / sumwq;",
      "info" : "ExpressionStatement[26033-26061]:ExpressionStatement[26033-26061]"
    }, {
      "left" : "cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);",
      "right" : "cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);",
      "info" : "ExpressionStatement[26176-26266]:ExpressionStatement[26176-26266]"
    }, {
      "left" : "cs = (mueff + 2.) / (dimension + mueff + 3.);",
      "right" : "cs = (mueff + 2.) / (dimension + mueff + 3.);",
      "info" : "ExpressionStatement[26275-26320]:ExpressionStatement[26275-26320]"
    }, {
      "left" : "damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs;",
      "right" : "damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs;",
      "info" : "ExpressionStatement[26329-26600]:ExpressionStatement[26329-26600]"
    }, {
      "left" : "ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);",
      "right" : "ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);",
      "info" : "ExpressionStatement[26628-26689]:ExpressionStatement[26628-26689]"
    }, {
      "left" : "ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));",
      "right" : "ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));",
      "info" : "ExpressionStatement[26698-26823]:ExpressionStatement[26698-26823]"
    }, {
      "left" : "ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);",
      "right" : "ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);",
      "info" : "ExpressionStatement[26832-26887]:ExpressionStatement[26832-26887]"
    }, {
      "left" : "ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);",
      "right" : "ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);",
      "info" : "ExpressionStatement[26896-26961]:ExpressionStatement[26896-26961]"
    }, {
      "left" : "chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));",
      "right" : "chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));",
      "info" : "ExpressionStatement[26970-27081]:ExpressionStatement[26970-27081]"
    }, {
      "left" : "xmean = MatrixUtils.createColumnRealMatrix(guess);",
      "right" : "xmean = MatrixUtils.createColumnRealMatrix(guess);",
      "info" : "ExpressionStatement[27157-27207]:ExpressionStatement[27157-27207]"
    }, {
      "left" : "diagD = insigma.scalarMultiply(1. / sigma);",
      "right" : "diagD = insigma.scalarMultiply(1. / sigma);",
      "info" : "ExpressionStatement[27301-27344]:ExpressionStatement[27301-27344]"
    }, {
      "left" : "diagC = square(diagD);",
      "right" : "diagC = square(diagD);",
      "info" : "ExpressionStatement[27353-27375]:ExpressionStatement[27353-27375]"
    }, {
      "left" : "pc = zeros(dimension, 1);",
      "right" : "pc = zeros(dimension, 1);",
      "info" : "ExpressionStatement[27384-27409]:ExpressionStatement[27384-27409]"
    }, {
      "left" : "ps = zeros(dimension, 1);",
      "right" : "ps = zeros(dimension, 1);",
      "info" : "ExpressionStatement[27453-27478]:ExpressionStatement[27453-27478]"
    }, {
      "left" : "normps = ps.getFrobeniusNorm();",
      "right" : "normps = ps.getFrobeniusNorm();",
      "info" : "ExpressionStatement[27522-27553]:ExpressionStatement[27522-27553]"
    }, {
      "left" : "B = eye(dimension, dimension);",
      "right" : "B = eye(dimension, dimension);",
      "info" : "ExpressionStatement[27563-27593]:ExpressionStatement[27563-27593]"
    }, {
      "left" : "D = ones(dimension, 1);",
      "right" : "D = ones(dimension, 1);",
      "info" : "ExpressionStatement[27602-27625]:ExpressionStatement[27602-27625]"
    }, {
      "left" : "BD = times(B, repmat(diagD.transpose(), dimension, 1));",
      "right" : "BD = times(B, repmat(diagD.transpose(), dimension, 1));",
      "info" : "ExpressionStatement[27668-27723]:ExpressionStatement[27668-27723]"
    }, {
      "left" : "C = B.multiply(diag(square(D)).multiply(B.transpose()));",
      "right" : "C = B.multiply(diag(square(D)).multiply(B.transpose()));",
      "info" : "ExpressionStatement[27732-27788]:ExpressionStatement[27732-27788]"
    }, {
      "left" : "historySize = 10 + (int) (3. * 10. * dimension / lambda);",
      "right" : "historySize = 10 + (int) (3. * 10. * dimension / lambda);",
      "info" : "ExpressionStatement[27811-27868]:ExpressionStatement[27811-27868]"
    }, {
      "left" : "fitnessHistory = new double[historySize];",
      "right" : "fitnessHistory = new double[historySize];",
      "info" : "ExpressionStatement[27877-27918]:ExpressionStatement[27877-27918]"
    }, {
      "left" : "for (int i = 0; i < historySize; i++)",
      "right" : "for (int i = 0; i < historySize; i++)",
      "info" : "ForStatement[27956-28055]:ForStatement[27956-28055]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27994-28055]:Block[27994-28055]"
    }, {
      "left" : "fitnessHistory[i] = Double.MAX_VALUE;",
      "right" : "fitnessHistory[i] = Double.MAX_VALUE;",
      "info" : "ExpressionStatement[28008-28045]:ExpressionStatement[28008-28045]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28438-29008]:Block[28438-29008]"
    }, {
      "left" : "ps = ps.scalarMultiply(1. - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2. - cs) * mueff)));",
      "right" : "ps = ps.scalarMultiply(1. - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2. - cs) * mueff)));",
      "info" : "ExpressionStatement[28448-28595]:ExpressionStatement[28448-28595]"
    }, {
      "left" : "normps = ps.getFrobeniusNorm();",
      "right" : "normps = ps.getFrobeniusNorm();",
      "info" : "ExpressionStatement[28604-28635]:ExpressionStatement[28604-28635]"
    }, {
      "left" : "boolean hsig = normps /\n            Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /\n                chiN < 1.4 + 2. / (dimension + 1.);",
      "right" : "boolean hsig = normps /\n            Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /\n                chiN < 1.4 + 2. / (dimension + 1.);",
      "info" : "VariableDeclarationStatement[28644-28784]:VariableDeclarationStatement[28644-28784]"
    }, {
      "left" : "pc = pc.scalarMultiply(1. - cc);",
      "right" : "pc = pc.scalarMultiply(1. - cc);",
      "info" : "ExpressionStatement[28793-28825]:ExpressionStatement[28793-28825]"
    }, {
      "left" : "if (hsig)",
      "right" : "if (hsig)",
      "info" : "IfStatement[28834-28981]:IfStatement[28834-28981]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28844-28981]:Block[28844-28981]"
    }, {
      "left" : "pc = pc.add(xmean.subtract(xold).scalarMultiply(\n                    Math.sqrt(cc * (2. - cc) * mueff) / sigma));",
      "right" : "pc = pc.add(xmean.subtract(xold).scalarMultiply(\n                    Math.sqrt(cc * (2. - cc) * mueff) / sigma));",
      "info" : "ExpressionStatement[28858-28971]:ExpressionStatement[28858-28971]"
    }, {
      "left" : "return hsig;",
      "right" : "return hsig;",
      "info" : "ReturnStatement[28990-29002]:ReturnStatement[28990-29002]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29518-30303]:Block[29518-30303]"
    }, {
      "left" : "double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc);",
      "right" : "double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc);",
      "info" : "VariableDeclarationStatement[29571-29624]:VariableDeclarationStatement[29571-29624]"
    }, {
      "left" : "oldFac += 1. - ccov1Sep - ccovmuSep;",
      "right" : "oldFac += 1. - ccov1Sep - ccovmuSep;",
      "info" : "ExpressionStatement[29633-29669]:ExpressionStatement[29633-29669]"
    }, {
      "left" : "diagC = diagC.scalarMultiply(oldFac) // regard old matrix\n                // plus rank one update\n                .add(square(pc).scalarMultiply(ccov1Sep))\n                // plus rank mu update\n                .add((times(diagC, square(bestArz).multiply(weights)))\n                        .scalarMultiply(ccovmuSep));",
      "right" : "diagC = diagC.scalarMultiply(oldFac) // regard old matrix\n                // plus rank one update\n                .add(square(pc).scalarMultiply(ccov1Sep))\n                // plus rank mu update\n                .add((times(diagC, square(bestArz).multiply(weights)))\n                        .scalarMultiply(ccovmuSep));",
      "info" : "ExpressionStatement[29678-29996]:ExpressionStatement[29678-29996]"
    }, {
      "left" : "diagD = sqrt(diagC);",
      "right" : "diagD = sqrt(diagC);",
      "info" : "ExpressionStatement[30005-30025]:ExpressionStatement[30005-30025]"
    }, {
      "left" : "if (diagonalOnly > 1 && iterations > diagonalOnly)",
      "right" : "if (diagonalOnly > 1 && iterations > diagonalOnly)",
      "info" : "IfStatement[30053-30297]:IfStatement[30053-30297]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30104-30297]:Block[30104-30297]"
    }, {
      "left" : "diagonalOnly = 0;",
      "right" : "diagonalOnly = 0;",
      "info" : "ExpressionStatement[30168-30185]:ExpressionStatement[30168-30185]"
    }, {
      "left" : "B = eye(dimension, dimension);",
      "right" : "B = eye(dimension, dimension);",
      "info" : "ExpressionStatement[30198-30228]:ExpressionStatement[30198-30228]"
    }, {
      "left" : "BD = diag(diagD);",
      "right" : "BD = diag(diagD);",
      "info" : "ExpressionStatement[30241-30258]:ExpressionStatement[30241-30258]"
    }, {
      "left" : "C = diag(diagC);",
      "right" : "C = diag(diagC);",
      "info" : "ExpressionStatement[30271-30287]:ExpressionStatement[30271-30287]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30935-34452]:Block[30935-34452]"
    }, {
      "left" : "double negccov = 0;",
      "right" : "double negccov = 0;",
      "info" : "VariableDeclarationStatement[30945-30964]:VariableDeclarationStatement[30945-30964]"
    }, {
      "left" : "if (ccov1 + ccovmu > 0)",
      "right" : "if (ccov1 + ccovmu > 0)",
      "info" : "IfStatement[30973-34419]:IfStatement[30973-34419]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30997-34419]:Block[30997-34419]"
    }, {
      "left" : "RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                    .scalarMultiply(1. / sigma);",
      "right" : "RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                    .scalarMultiply(1. / sigma);",
      "info" : "VariableDeclarationStatement[31011-31116]:VariableDeclarationStatement[31011-31116]"
    }, {
      "left" : "RealMatrix roneu = pc.multiply(pc.transpose())\n                    .scalarMultiply(ccov1);",
      "right" : "RealMatrix roneu = pc.multiply(pc.transpose())\n                    .scalarMultiply(ccov1);",
      "info" : "VariableDeclarationStatement[31154-31244]:VariableDeclarationStatement[31154-31244]"
    }, {
      "left" : "double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);",
      "right" : "double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);",
      "info" : "VariableDeclarationStatement[31323-31373]:VariableDeclarationStatement[31323-31373]"
    }, {
      "left" : "oldFac += 1. - ccov1 - ccovmu;",
      "right" : "oldFac += 1. - ccov1 - ccovmu;",
      "info" : "ExpressionStatement[31386-31416]:ExpressionStatement[31386-31416]"
    }, {
      "left" : "if (isActiveCMA)",
      "right" : "if (isActiveCMA)",
      "info" : "IfStatement[31429-34409]:IfStatement[31429-34409]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31446-33910]:Block[31446-33910]"
    }, {
      "left" : "negccov = (1. - ccovmu) * 0.25 * mueff /\n                (Math.pow(dimension + 2., 1.5) + 2. * mueff);",
      "right" : "negccov = (1. - ccovmu) * 0.25 * mueff /\n                (Math.pow(dimension + 2., 1.5) + 2. * mueff);",
      "info" : "ExpressionStatement[31520-31622]:ExpressionStatement[31520-31622]"
    }, {
      "left" : "double negminresidualvariance = 0.66;",
      "right" : "double negminresidualvariance = 0.66;",
      "info" : "VariableDeclarationStatement[31639-31676]:VariableDeclarationStatement[31639-31676]"
    }, {
      "left" : "double negalphaold = 0.5;",
      "right" : "double negalphaold = 0.5;",
      "info" : "VariableDeclarationStatement[31801-31826]:VariableDeclarationStatement[31801-31826]"
    }, {
      "left" : "int[] arReverseIndex = reverse(arindex);",
      "right" : "int[] arReverseIndex = reverse(arindex);",
      "info" : "VariableDeclarationStatement[32005-32045]:VariableDeclarationStatement[32005-32045]"
    }, {
      "left" : "RealMatrix arzneg\n                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));",
      "right" : "RealMatrix arzneg\n                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));",
      "info" : "VariableDeclarationStatement[32062-32160]:VariableDeclarationStatement[32062-32160]"
    }, {
      "left" : "RealMatrix arnorms = sqrt(sumRows(square(arzneg)));",
      "right" : "RealMatrix arnorms = sqrt(sumRows(square(arzneg)));",
      "info" : "VariableDeclarationStatement[32177-32228]:VariableDeclarationStatement[32177-32228]"
    }, {
      "left" : "int[] idxnorms = sortedIndices(arnorms.getRow(0));",
      "right" : "int[] idxnorms = sortedIndices(arnorms.getRow(0));",
      "info" : "VariableDeclarationStatement[32245-32295]:VariableDeclarationStatement[32245-32295]"
    }, {
      "left" : "RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);",
      "right" : "RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);",
      "info" : "VariableDeclarationStatement[32312-32372]:VariableDeclarationStatement[32312-32372]"
    }, {
      "left" : "int[] idxReverse = reverse(idxnorms);",
      "right" : "int[] idxReverse = reverse(idxnorms);",
      "info" : "VariableDeclarationStatement[32389-32426]:VariableDeclarationStatement[32389-32426]"
    }, {
      "left" : "RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);",
      "right" : "RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);",
      "info" : "VariableDeclarationStatement[32443-32506]:VariableDeclarationStatement[32443-32506]"
    }, {
      "left" : "arnorms = divide(arnormsReverse, arnormsSorted);",
      "right" : "arnorms = divide(arnormsReverse, arnormsSorted);",
      "info" : "ExpressionStatement[32523-32571]:ExpressionStatement[32523-32571]"
    }, {
      "left" : "int[] idxInv = inverse(idxnorms);",
      "right" : "int[] idxInv = inverse(idxnorms);",
      "info" : "VariableDeclarationStatement[32588-32621]:VariableDeclarationStatement[32588-32621]"
    }, {
      "left" : "RealMatrix arnormsInv = selectColumns(arnorms, idxInv);",
      "right" : "RealMatrix arnormsInv = selectColumns(arnorms, idxInv);",
      "info" : "VariableDeclarationStatement[32638-32693]:VariableDeclarationStatement[32638-32693]"
    }, {
      "left" : "double negcovMax = (1. - negminresidualvariance) /\n                        square(arnormsInv).multiply(weights).getEntry(0, 0);",
      "right" : "double negcovMax = (1. - negminresidualvariance) /\n                        square(arnormsInv).multiply(weights).getEntry(0, 0);",
      "info" : "VariableDeclarationStatement[32765-32892]:VariableDeclarationStatement[32765-32892]"
    }, {
      "left" : "if (negccov > negcovMax)",
      "right" : "if (negccov > negcovMax)",
      "info" : "IfStatement[32909-32994]:IfStatement[32909-32994]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32934-32994]:Block[32934-32994]"
    }, {
      "left" : "negccov = negcovMax;",
      "right" : "negccov = negcovMax;",
      "info" : "ExpressionStatement[32956-32976]:ExpressionStatement[32956-32976]"
    }, {
      "left" : "arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));",
      "right" : "arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));",
      "info" : "ExpressionStatement[33011-33068]:ExpressionStatement[33011-33068]"
    }, {
      "left" : "RealMatrix artmp = BD.multiply(arzneg);",
      "right" : "RealMatrix artmp = BD.multiply(arzneg);",
      "info" : "VariableDeclarationStatement[33085-33124]:VariableDeclarationStatement[33085-33124]"
    }, {
      "left" : "RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n                        artmp.transpose());",
      "right" : "RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n                        artmp.transpose());",
      "info" : "VariableDeclarationStatement[33141-33242]:VariableDeclarationStatement[33141-33242]"
    }, {
      "left" : "oldFac += negalphaold * negccov;",
      "right" : "oldFac += negalphaold * negccov;",
      "info" : "ExpressionStatement[33259-33291]:ExpressionStatement[33259-33291]"
    }, {
      "left" : "C = C.scalarMultiply(oldFac)\n                        // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(\n                                // plus rank mu update\n                                ccovmu + (1. - negalphaold) * negccov)\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())))\n                        .subtract(Cneg.scalarMultiply(negccov));",
      "right" : "C = C.scalarMultiply(oldFac)\n                        // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(\n                                // plus rank mu update\n                                ccovmu + (1. - negalphaold) * negccov)\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())))\n                        .subtract(Cneg.scalarMultiply(negccov));",
      "info" : "ExpressionStatement[33308-33896]:ExpressionStatement[33308-33896]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33916-34409]:Block[33916-34409]"
    }, {
      "left" : "C = C.scalarMultiply(oldFac) // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())));",
      "right" : "C = C.scalarMultiply(oldFac) // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())));",
      "info" : "ExpressionStatement[33991-34395]:ExpressionStatement[33991-34395]"
    }, {
      "left" : "updateBD(negccov);",
      "right" : "updateBD(negccov);",
      "info" : "ExpressionStatement[34428-34446]:ExpressionStatement[34428-34446]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34599-35997]:Block[34599-35997]"
    }, {
      "left" : "if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.)",
      "right" : "if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.)",
      "info" : "IfStatement[34609-35991]:IfStatement[34609-35991]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34732-35991]:Block[34732-35991]"
    }, {
      "left" : "C = triu(C, 0).add(triu(C, 1).transpose());",
      "right" : "C = triu(C, 0).add(triu(C, 1).transpose());",
      "info" : "ExpressionStatement[34779-34822]:ExpressionStatement[34779-34822]"
    }, {
      "left" : "EigenDecomposition eig = new EigenDecomposition(C);",
      "right" : "EigenDecomposition eig = new EigenDecomposition(C);",
      "info" : "VariableDeclarationStatement[34894-34945]:VariableDeclarationStatement[34894-34945]"
    }, {
      "left" : "B = eig.getV();",
      "right" : "B = eig.getV();",
      "info" : "ExpressionStatement[34958-34973]:ExpressionStatement[34958-34973]"
    }, {
      "left" : "D = eig.getD();",
      "right" : "D = eig.getD();",
      "info" : "ExpressionStatement[35037-35052]:ExpressionStatement[35037-35052]"
    }, {
      "left" : "diagD = diag(D);",
      "right" : "diagD = diag(D);",
      "info" : "ExpressionStatement[35065-35081]:ExpressionStatement[35065-35081]"
    }, {
      "left" : "if (min(diagD) <= 0)",
      "right" : "if (min(diagD) <= 0)",
      "info" : "IfStatement[35094-35526]:IfStatement[35094-35526]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35115-35526]:Block[35115-35526]"
    }, {
      "left" : "for (int i = 0; i < dimension; i++)",
      "right" : "for (int i = 0; i < dimension; i++)",
      "info" : "ForStatement[35133-35312]:ForStatement[35133-35312]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35169-35312]:Block[35169-35312]"
    }, {
      "left" : "if (diagD.getEntry(i, 0) < 0)",
      "right" : "if (diagD.getEntry(i, 0) < 0)",
      "info" : "IfStatement[35191-35294]:IfStatement[35191-35294]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35221-35294]:Block[35221-35294]"
    }, {
      "left" : "diagD.setEntry(i, 0, 0.);",
      "right" : "diagD.setEntry(i, 0, 0.);",
      "info" : "ExpressionStatement[35247-35272]:ExpressionStatement[35247-35272]"
    }, {
      "left" : "double tfac = max(diagD) / 1e14;",
      "right" : "double tfac = max(diagD) / 1e14;",
      "info" : "VariableDeclarationStatement[35329-35361]:VariableDeclarationStatement[35329-35361]"
    }, {
      "left" : "C = C.add(eye(dimension, dimension).scalarMultiply(tfac));",
      "right" : "C = C.add(eye(dimension, dimension).scalarMultiply(tfac));",
      "info" : "ExpressionStatement[35378-35436]:ExpressionStatement[35378-35436]"
    }, {
      "left" : "diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));",
      "right" : "diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));",
      "info" : "ExpressionStatement[35453-35512]:ExpressionStatement[35453-35512]"
    }, {
      "left" : "if (max(diagD) > 1e14 * min(diagD))",
      "right" : "if (max(diagD) > 1e14 * min(diagD))",
      "info" : "IfStatement[35539-35803]:IfStatement[35539-35803]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35575-35803]:Block[35575-35803]"
    }, {
      "left" : "double tfac = max(diagD) / 1e14 - min(diagD);",
      "right" : "double tfac = max(diagD) / 1e14 - min(diagD);",
      "info" : "VariableDeclarationStatement[35593-35638]:VariableDeclarationStatement[35593-35638]"
    }, {
      "left" : "C = C.add(eye(dimension, dimension).scalarMultiply(tfac));",
      "right" : "C = C.add(eye(dimension, dimension).scalarMultiply(tfac));",
      "info" : "ExpressionStatement[35655-35713]:ExpressionStatement[35655-35713]"
    }, {
      "left" : "diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));",
      "right" : "diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));",
      "info" : "ExpressionStatement[35730-35789]:ExpressionStatement[35730-35789]"
    }, {
      "left" : "diagC = diag(C);",
      "right" : "diagC = diag(C);",
      "info" : "ExpressionStatement[35816-35832]:ExpressionStatement[35816-35832]"
    }, {
      "left" : "diagD = sqrt(diagD);",
      "right" : "diagD = sqrt(diagD);",
      "info" : "ExpressionStatement[35845-35865]:ExpressionStatement[35845-35865]"
    }, {
      "left" : "BD = times(B, repmat(diagD.transpose(), dimension, 1));",
      "right" : "BD = times(B, repmat(diagD.transpose(), dimension, 1));",
      "info" : "ExpressionStatement[35916-35971]:ExpressionStatement[35916-35971]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36223-36346]:Block[36223-36346]"
    }, {
      "left" : "for (int i = vals.length-1; i > 0; i--)",
      "right" : "for (int i = vals.length-1; i > 0; i--)",
      "info" : "ForStatement[36233-36317]:ForStatement[36233-36317]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36273-36317]:Block[36273-36317]"
    }, {
      "left" : "vals[i] = vals[i-1];",
      "right" : "vals[i] = vals[i-1];",
      "info" : "ExpressionStatement[36287-36307]:ExpressionStatement[36287-36307]"
    }, {
      "left" : "vals[0] = val;",
      "right" : "vals[0] = val;",
      "info" : "ExpressionStatement[36326-36340]:ExpressionStatement[36326-36340]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36572-36953]:Block[36572-36953]"
    }, {
      "left" : "DoubleIndex[] dis = new DoubleIndex[doubles.length];",
      "right" : "DoubleIndex[] dis = new DoubleIndex[doubles.length];",
      "info" : "VariableDeclarationStatement[36582-36634]:VariableDeclarationStatement[36582-36634]"
    }, {
      "left" : "for (int i = 0; i < doubles.length; i++)",
      "right" : "for (int i = 0; i < doubles.length; i++)",
      "info" : "ForStatement[36643-36748]:ForStatement[36643-36748]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36684-36748]:Block[36684-36748]"
    }, {
      "left" : "dis[i] = new DoubleIndex(doubles[i], i);",
      "right" : "dis[i] = new DoubleIndex(doubles[i], i);",
      "info" : "ExpressionStatement[36698-36738]:ExpressionStatement[36698-36738]"
    }, {
      "left" : "Arrays.sort(dis);",
      "right" : "Arrays.sort(dis);",
      "info" : "ExpressionStatement[36757-36774]:ExpressionStatement[36757-36774]"
    }, {
      "left" : "int[] indices = new int[doubles.length];",
      "right" : "int[] indices = new int[doubles.length];",
      "info" : "VariableDeclarationStatement[36783-36823]:VariableDeclarationStatement[36783-36823]"
    }, {
      "left" : "for (int i = 0; i < doubles.length; i++)",
      "right" : "for (int i = 0; i < doubles.length; i++)",
      "info" : "ForStatement[36832-36923]:ForStatement[36832-36923]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36873-36923]:Block[36873-36923]"
    }, {
      "left" : "indices[i] = dis[i].index;",
      "right" : "indices[i] = dis[i].index;",
      "info" : "ExpressionStatement[36887-36913]:ExpressionStatement[36887-36913]"
    }, {
      "left" : "return indices;",
      "right" : "return indices;",
      "info" : "ReturnStatement[36932-36947]:ReturnStatement[36932-36947]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37425-37500]:Block[37425-37500]"
    }, {
      "left" : "this.value = value;",
      "right" : "this.value = value;",
      "info" : "ExpressionStatement[37439-37458]:ExpressionStatement[37439-37458]"
    }, {
      "left" : "this.index = index;",
      "right" : "this.index = index;",
      "info" : "ExpressionStatement[37471-37490]:ExpressionStatement[37471-37490]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37575-37637]:Block[37575-37637]"
    }, {
      "left" : "return Double.compare(value, o.value);",
      "right" : "return Double.compare(value, o.value);",
      "info" : "ReturnStatement[37589-37627]:ReturnStatement[37589-37627]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37730-37989]:Block[37730-37989]"
    }, {
      "left" : "if (this == other)",
      "right" : "if (this == other)",
      "info" : "IfStatement[37745-37808]:IfStatement[37745-37808]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37764-37808]:Block[37764-37808]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[37782-37794]:ReturnStatement[37782-37794]"
    }, {
      "left" : "if (other instanceof DoubleIndex)",
      "right" : "if (other instanceof DoubleIndex)",
      "info" : "IfStatement[37822-37951]:IfStatement[37822-37951]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37856-37951]:Block[37856-37951]"
    }, {
      "left" : "return Double.compare(value, ((DoubleIndex) other).value) == 0;",
      "right" : "return Double.compare(value, ((DoubleIndex) other).value) == 0;",
      "info" : "ReturnStatement[37874-37937]:ReturnStatement[37874-37937]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[37965-37978]:ReturnStatement[37965-37978]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38068-38209]:Block[38068-38209]"
    }, {
      "left" : "long bits = Double.doubleToLongBits(value);",
      "right" : "long bits = Double.doubleToLongBits(value);",
      "info" : "VariableDeclarationStatement[38082-38125]:VariableDeclarationStatement[38082-38125]"
    }, {
      "left" : "return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);",
      "right" : "return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);",
      "info" : "ReturnStatement[38138-38199]:ReturnStatement[38138-38199]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38789-38863]:Block[38789-38863]"
    }, {
      "left" : "valueRange = 1.0;",
      "right" : "valueRange = 1.0;",
      "info" : "ExpressionStatement[38803-38820]:ExpressionStatement[38803-38820]"
    }, {
      "left" : "isRepairMode = true;",
      "right" : "isRepairMode = true;",
      "info" : "ExpressionStatement[38833-38853]:ExpressionStatement[38833-38853]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39043-39394]:Block[39043-39394]"
    }, {
      "left" : "if (boundaries == null)",
      "right" : "if (boundaries == null)",
      "info" : "IfStatement[39057-39122]:IfStatement[39057-39122]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39081-39122]:Block[39081-39122]"
    }, {
      "left" : "return x;",
      "right" : "return x;",
      "info" : "ReturnStatement[39099-39108]:ReturnStatement[39099-39108]"
    }, {
      "left" : "double[] res = new double[x.length];",
      "right" : "double[] res = new double[x.length];",
      "info" : "VariableDeclarationStatement[39135-39171]:VariableDeclarationStatement[39135-39171]"
    }, {
      "left" : "for (int i = 0; i < x.length; i++)",
      "right" : "for (int i = 0; i < x.length; i++)",
      "info" : "ForStatement[39184-39360]:ForStatement[39184-39360]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39219-39360]:Block[39219-39360]"
    }, {
      "left" : "double diff = boundaries[1][i] - boundaries[0][i];",
      "right" : "double diff = boundaries[1][i] - boundaries[0][i];",
      "info" : "VariableDeclarationStatement[39237-39287]:VariableDeclarationStatement[39237-39287]"
    }, {
      "left" : "res[i] = (x[i] - boundaries[0][i]) / diff;",
      "right" : "res[i] = (x[i] - boundaries[0][i]) / diff;",
      "info" : "ExpressionStatement[39304-39346]:ExpressionStatement[39304-39346]"
    }, {
      "left" : "return res;",
      "right" : "return res;",
      "info" : "ReturnStatement[39373-39384]:ReturnStatement[39373-39384]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39839-40188]:Block[39912-40261]"
    }, {
      "left" : "if (boundaries == null)",
      "right" : "if (boundaries == null)",
      "info" : "IfStatement[39853-39918]:IfStatement[39926-39991]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39877-39918]:Block[39950-39991]"
    }, {
      "left" : "return x;",
      "right" : "return x;",
      "info" : "ReturnStatement[39895-39904]:ReturnStatement[39968-39977]"
    }, {
      "left" : "double[] res = new double[x.length];",
      "right" : "double[] res = new double[x.length];",
      "info" : "VariableDeclarationStatement[39931-39967]:VariableDeclarationStatement[40004-40040]"
    }, {
      "left" : "for (int i = 0; i < x.length; i++)",
      "right" : "for (int i = 0; i < x.length; i++)",
      "info" : "ForStatement[39980-40154]:ForStatement[40053-40227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40015-40154]:Block[40088-40227]"
    }, {
      "left" : "double diff = boundaries[1][i] - boundaries[0][i];",
      "right" : "double diff = boundaries[1][i] - boundaries[0][i];",
      "info" : "VariableDeclarationStatement[40033-40083]:VariableDeclarationStatement[40106-40156]"
    }, {
      "left" : "res[i] = diff * x[i] + boundaries[0][i];",
      "right" : "res[i] = diff * x[i] + boundaries[0][i];",
      "info" : "ExpressionStatement[40100-40140]:ExpressionStatement[40173-40213]"
    }, {
      "left" : "return res;",
      "right" : "return res;",
      "info" : "ReturnStatement[40167-40178]:ReturnStatement[40240-40251]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40390-40883]:Block[40463-40956]"
    }, {
      "left" : "double value;",
      "right" : "double value;",
      "info" : "VariableDeclarationStatement[40404-40417]:VariableDeclarationStatement[40477-40490]"
    }, {
      "left" : "if (boundaries != null && isRepairMode)",
      "right" : "if (boundaries != null && isRepairMode)",
      "info" : "IfStatement[40430-40825]:IfStatement[40503-40898]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40470-40697]:Block[40543-40770]"
    }, {
      "left" : "double[] repaired = repair(point);",
      "right" : "double[] repaired = repair(point);",
      "info" : "VariableDeclarationStatement[40488-40522]:VariableDeclarationStatement[40561-40595]"
    }, {
      "left" : "value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);",
      "right" : "value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);",
      "info" : "ExpressionStatement[40539-40683]:ExpressionStatement[40612-40756]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40703-40825]:Block[40776-40898]"
    }, {
      "left" : "value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));",
      "right" : "value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));",
      "info" : "ExpressionStatement[40721-40811]:ExpressionStatement[40794-40884]"
    }, {
      "left" : "return isMinimize ? value : -value;",
      "right" : "return isMinimize ? value : -value;",
      "info" : "ReturnStatement[40838-40873]:ReturnStatement[40911-40946]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41059-41409]:Block[41132-41482]"
    }, {
      "left" : "if (boundaries == null)",
      "right" : "if (boundaries == null)",
      "info" : "IfStatement[41073-41141]:IfStatement[41146-41214]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41097-41141]:Block[41170-41214]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[41115-41127]:ReturnStatement[41188-41200]"
    }, {
      "left" : "for (int i = 0; i < x.length; i++)",
      "right" : "for (int i = 0; i < x.length; i++)",
      "info" : "ForStatement[41154-41374]:ForStatement[41227-41447]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41189-41374]:Block[41262-41447]"
    }, {
      "left" : "if (x[i] < 0)",
      "right" : "if (x[i] < 0)",
      "info" : "IfStatement[41207-41274]:IfStatement[41280-41347]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41221-41274]:Block[41294-41347]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[41243-41256]:ReturnStatement[41316-41329]"
    }, {
      "left" : "if (x[i] > 1.0)",
      "right" : "if (x[i] > 1.0)",
      "info" : "IfStatement[41291-41360]:IfStatement[41364-41433]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41307-41360]:Block[41380-41433]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[41329-41342]:ReturnStatement[41402-41415]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[41387-41399]:ReturnStatement[41460-41472]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41550-41603]:Block[41623-41676]"
    }, {
      "left" : "this.valueRange = valueRange;",
      "right" : "this.valueRange = valueRange;",
      "info" : "ExpressionStatement[41564-41593]:ExpressionStatement[41637-41666]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41800-42189]:Block[41873-42262]"
    }, {
      "left" : "double[] repaired = new double[x.length];",
      "right" : "double[] repaired = new double[x.length];",
      "info" : "VariableDeclarationStatement[41814-41855]:VariableDeclarationStatement[41887-41928]"
    }, {
      "left" : "for (int i = 0; i < x.length; i++)",
      "right" : "for (int i = 0; i < x.length; i++)",
      "info" : "ForStatement[41868-42150]:ForStatement[41941-42223]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41903-42150]:Block[41976-42223]"
    }, {
      "left" : "if (x[i] < 0)",
      "right" : "if (x[i] < 0)",
      "info" : "IfStatement[41921-42136]:IfStatement[41994-42209]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41935-41991]:Block[42008-42064]"
    }, {
      "left" : "repaired[i] = 0;",
      "right" : "repaired[i] = 0;",
      "info" : "ExpressionStatement[41957-41973]:ExpressionStatement[42030-42046]"
    }, {
      "left" : "if (x[i] > 1.0)",
      "right" : "if (x[i] > 1.0)",
      "info" : "IfStatement[41997-42136]:IfStatement[42070-42209]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42013-42071]:Block[42086-42144]"
    }, {
      "left" : "repaired[i] = 1.0;",
      "right" : "repaired[i] = 1.0;",
      "info" : "ExpressionStatement[42035-42053]:ExpressionStatement[42108-42126]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42077-42136]:Block[42150-42209]"
    }, {
      "left" : "repaired[i] = x[i];",
      "right" : "repaired[i] = x[i];",
      "info" : "ExpressionStatement[42099-42118]:ExpressionStatement[42172-42191]"
    }, {
      "left" : "return repaired;",
      "right" : "return repaired;",
      "info" : "ReturnStatement[42163-42179]:ReturnStatement[42236-42252]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42473-42737]:Block[42546-42810]"
    }, {
      "left" : "double penalty = 0;",
      "right" : "double penalty = 0;",
      "info" : "VariableDeclarationStatement[42487-42506]:VariableDeclarationStatement[42560-42579]"
    }, {
      "left" : "for (int i = 0; i < x.length; i++)",
      "right" : "for (int i = 0; i < x.length; i++)",
      "info" : "ForStatement[42519-42675]:ForStatement[42592-42748]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42554-42675]:Block[42627-42748]"
    }, {
      "left" : "double diff = Math.abs(x[i] - repaired[i]);",
      "right" : "double diff = Math.abs(x[i] - repaired[i]);",
      "info" : "VariableDeclarationStatement[42572-42615]:VariableDeclarationStatement[42645-42688]"
    }, {
      "left" : "penalty += diff * valueRange;",
      "right" : "penalty += diff * valueRange;",
      "info" : "ExpressionStatement[42632-42661]:ExpressionStatement[42705-42734]"
    }, {
      "left" : "return isMinimize ? penalty : -penalty;",
      "right" : "return isMinimize ? penalty : -penalty;",
      "info" : "ReturnStatement[42688-42727]:ReturnStatement[42761-42800]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42997-43332]:Block[43070-43405]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "right" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "info" : "VariableDeclarationStatement[43007-43078]:VariableDeclarationStatement[43080-43151]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[43087-43275]:ForStatement[43160-43348]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43133-43275]:Block[43206-43348]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[43147-43265]:ForStatement[43220-43338]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43196-43265]:Block[43269-43338]"
    }, {
      "left" : "d[r][c] = Math.log(m.getEntry(r, c));",
      "right" : "d[r][c] = Math.log(m.getEntry(r, c));",
      "info" : "ExpressionStatement[43214-43251]:ExpressionStatement[43287-43324]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[43284-43326]:ReturnStatement[43357-43399]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43522-43858]:Block[43595-43931]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "right" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "info" : "VariableDeclarationStatement[43532-43603]:VariableDeclarationStatement[43605-43676]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[43612-43801]:ForStatement[43685-43874]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43658-43801]:Block[43731-43874]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[43672-43791]:ForStatement[43745-43864]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43721-43791]:Block[43794-43864]"
    }, {
      "left" : "d[r][c] = Math.sqrt(m.getEntry(r, c));",
      "right" : "d[r][c] = Math.sqrt(m.getEntry(r, c));",
      "info" : "ExpressionStatement[43739-43777]:ExpressionStatement[43812-43850]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[43810-43852]:ReturnStatement[43883-43925]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44032-44391]:Block[44105-44464]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "right" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "info" : "VariableDeclarationStatement[44042-44113]:VariableDeclarationStatement[44115-44186]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[44122-44334]:ForStatement[44195-44407]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44168-44334]:Block[44241-44407]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[44182-44324]:ForStatement[44255-44397]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44231-44324]:Block[44304-44397]"
    }, {
      "left" : "double e = m.getEntry(r, c);",
      "right" : "double e = m.getEntry(r, c);",
      "info" : "VariableDeclarationStatement[44249-44277]:VariableDeclarationStatement[44322-44350]"
    }, {
      "left" : "d[r][c] = e * e;",
      "right" : "d[r][c] = e * e;",
      "info" : "ExpressionStatement[44294-44310]:ExpressionStatement[44367-44383]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[44343-44385]:ReturnStatement[44416-44458]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44634-44978]:Block[44707-45051]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "right" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "info" : "VariableDeclarationStatement[44644-44715]:VariableDeclarationStatement[44717-44788]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[44724-44921]:ForStatement[44797-44994]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44770-44921]:Block[44843-44994]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[44784-44911]:ForStatement[44857-44984]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44833-44911]:Block[44906-44984]"
    }, {
      "left" : "d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);",
      "right" : "d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);",
      "info" : "ExpressionStatement[44851-44897]:ExpressionStatement[44924-44970]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[44930-44972]:ReturnStatement[45003-45045]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45215-45559]:Block[45288-45632]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "right" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "info" : "VariableDeclarationStatement[45225-45296]:VariableDeclarationStatement[45298-45369]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[45305-45502]:ForStatement[45378-45575]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45351-45502]:Block[45424-45575]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[45365-45492]:ForStatement[45438-45565]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45414-45492]:Block[45487-45565]"
    }, {
      "left" : "d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);",
      "right" : "d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);",
      "info" : "ExpressionStatement[45432-45478]:ExpressionStatement[45505-45551]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[45511-45553]:ReturnStatement[45584-45626]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45784-46093]:Block[45857-46166]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][cols.length];",
      "right" : "double[][] d = new double[m.getRowDimension()][cols.length];",
      "info" : "VariableDeclarationStatement[45794-45854]:VariableDeclarationStatement[45867-45927]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[45863-46036]:ForStatement[45936-46109]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45909-46036]:Block[45982-46109]"
    }, {
      "left" : "for (int c = 0; c < cols.length; c++)",
      "right" : "for (int c = 0; c < cols.length; c++)",
      "info" : "ForStatement[45923-46026]:ForStatement[45996-46099]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45961-46026]:Block[46034-46099]"
    }, {
      "left" : "d[r][c] = m.getEntry(r, cols[c]);",
      "right" : "d[r][c] = m.getEntry(r, cols[c]);",
      "info" : "ExpressionStatement[45979-46012]:ExpressionStatement[46052-46085]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[46045-46087]:ReturnStatement[46118-46160]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46286-46628]:Block[46359-46701]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "right" : "double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];",
      "info" : "VariableDeclarationStatement[46296-46367]:VariableDeclarationStatement[46369-46440]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[46376-46571]:ForStatement[46449-46644]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46422-46571]:Block[46495-46644]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[46436-46561]:ForStatement[46509-46634]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46485-46561]:Block[46558-46634]"
    }, {
      "left" : "d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;",
      "right" : "d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;",
      "info" : "ExpressionStatement[46503-46547]:ExpressionStatement[46576-46620]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[46580-46622]:ReturnStatement[46653-46695]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46795-47154]:Block[46868-47227]"
    }, {
      "left" : "double[][] d = new double[1][m.getColumnDimension()];",
      "right" : "double[][] d = new double[1][m.getColumnDimension()];",
      "info" : "VariableDeclarationStatement[46805-46858]:VariableDeclarationStatement[46878-46931]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[46867-47097]:ForStatement[46940-47170]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46916-47097]:Block[46989-47170]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[46930-46945]:VariableDeclarationStatement[47003-47018]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[46958-47060]:ForStatement[47031-47133]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47004-47060]:Block[47077-47133]"
    }, {
      "left" : "sum += m.getEntry(r, c);",
      "right" : "sum += m.getEntry(r, c);",
      "info" : "ExpressionStatement[47022-47046]:ExpressionStatement[47095-47119]"
    }, {
      "left" : "d[0][c] = sum;",
      "right" : "d[0][c] = sum;",
      "info" : "ExpressionStatement[47073-47087]:ExpressionStatement[47146-47160]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[47106-47148]:ReturnStatement[47179-47221]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47402-47972]:Block[47475-48045]"
    }, {
      "left" : "if (m.getColumnDimension() == 1)",
      "right" : "if (m.getColumnDimension() == 1)",
      "info" : "IfStatement[47412-47966]:IfStatement[47485-48039]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47445-47710]:Block[47518-47783]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][m.getRowDimension()];",
      "right" : "double[][] d = new double[m.getRowDimension()][m.getRowDimension()];",
      "info" : "VariableDeclarationStatement[47459-47527]:VariableDeclarationStatement[47532-47600]"
    }, {
      "left" : "for (int i = 0; i < m.getRowDimension(); i++)",
      "right" : "for (int i = 0; i < m.getRowDimension(); i++)",
      "info" : "ForStatement[47540-47645]:ForStatement[47613-47718]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47586-47645]:Block[47659-47718]"
    }, {
      "left" : "d[i][i] = m.getEntry(i, 0);",
      "right" : "d[i][i] = m.getEntry(i, 0);",
      "info" : "ExpressionStatement[47604-47631]:ExpressionStatement[47677-47704]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[47658-47700]:ReturnStatement[47731-47773]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47716-47966]:Block[47789-48039]"
    }, {
      "left" : "double[][] d = new double[m.getRowDimension()][1];",
      "right" : "double[][] d = new double[m.getRowDimension()][1];",
      "info" : "VariableDeclarationStatement[47730-47780]:VariableDeclarationStatement[47803-47853]"
    }, {
      "left" : "for (int i = 0; i < m.getColumnDimension(); i++)",
      "right" : "for (int i = 0; i < m.getColumnDimension(); i++)",
      "info" : "ForStatement[47793-47901]:ForStatement[47866-47974]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47842-47901]:Block[47915-47974]"
    }, {
      "left" : "d[i][0] = m.getEntry(i, i);",
      "right" : "d[i][0] = m.getEntry(i, i);",
      "info" : "ExpressionStatement[47860-47887]:ExpressionStatement[47933-47960]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[47914-47956]:ReturnStatement[47987-48029]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48260-48390]:Block[48333-48463]"
    }, {
      "left" : "for (int i = 0; i < m1.getRowDimension(); i++)",
      "right" : "for (int i = 0; i < m1.getRowDimension(); i++)",
      "info" : "ForStatement[48270-48384]:ForStatement[48343-48457]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48317-48384]:Block[48390-48457]"
    }, {
      "left" : "m2.setEntry(i, col2, m1.getEntry(i, col1));",
      "right" : "m2.setEntry(i, col2, m1.getEntry(i, col1));",
      "info" : "ExpressionStatement[48331-48374]:ExpressionStatement[48404-48447]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48568-48751]:Block[48641-48824]"
    }, {
      "left" : "double[][] d = new double[n][m];",
      "right" : "double[][] d = new double[n][m];",
      "info" : "VariableDeclarationStatement[48578-48610]:VariableDeclarationStatement[48651-48683]"
    }, {
      "left" : "for (int r = 0; r < n; r++)",
      "right" : "for (int r = 0; r < n; r++)",
      "info" : "ForStatement[48619-48694]:ForStatement[48692-48767]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48647-48694]:Block[48720-48767]"
    }, {
      "left" : "Arrays.fill(d[r], 1.0);",
      "right" : "Arrays.fill(d[r], 1.0);",
      "info" : "ExpressionStatement[48661-48684]:ExpressionStatement[48734-48757]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[48703-48745]:ReturnStatement[48776-48818]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48953-49168]:Block[49026-49241]"
    }, {
      "left" : "double[][] d = new double[n][m];",
      "right" : "double[][] d = new double[n][m];",
      "info" : "VariableDeclarationStatement[48963-48995]:VariableDeclarationStatement[49036-49068]"
    }, {
      "left" : "for (int r = 0; r < n; r++)",
      "right" : "for (int r = 0; r < n; r++)",
      "info" : "ForStatement[49004-49111]:ForStatement[49077-49184]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49032-49111]:Block[49105-49184]"
    }, {
      "left" : "if (r < m)",
      "right" : "if (r < m)",
      "info" : "IfStatement[49046-49101]:IfStatement[49119-49174]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49057-49101]:Block[49130-49174]"
    }, {
      "left" : "d[r][r] = 1;",
      "right" : "d[r][r] = 1;",
      "info" : "ExpressionStatement[49075-49087]:ExpressionStatement[49148-49160]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[49120-49162]:ReturnStatement[49193-49235]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49347-49401]:Block[49420-49474]"
    }, {
      "left" : "return new Array2DRowRealMatrix(n, m);",
      "right" : "return new Array2DRowRealMatrix(n, m);",
      "info" : "ReturnStatement[49357-49395]:ReturnStatement[49430-49468]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49689-50051]:Block[49762-50124]"
    }, {
      "left" : "int rd = mat.getRowDimension();",
      "right" : "int rd = mat.getRowDimension();",
      "info" : "VariableDeclarationStatement[49699-49730]:VariableDeclarationStatement[49772-49803]"
    }, {
      "left" : "int cd = mat.getColumnDimension();",
      "right" : "int cd = mat.getColumnDimension();",
      "info" : "VariableDeclarationStatement[49739-49773]:VariableDeclarationStatement[49812-49846]"
    }, {
      "left" : "double[][] d = new double[n * rd][m * cd];",
      "right" : "double[][] d = new double[n * rd][m * cd];",
      "info" : "VariableDeclarationStatement[49782-49824]:VariableDeclarationStatement[49855-49897]"
    }, {
      "left" : "for (int r = 0; r < n * rd; r++)",
      "right" : "for (int r = 0; r < n * rd; r++)",
      "info" : "ForStatement[49833-49994]:ForStatement[49906-50067]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49866-49994]:Block[49939-50067]"
    }, {
      "left" : "for (int c = 0; c < m * cd; c++)",
      "right" : "for (int c = 0; c < m * cd; c++)",
      "info" : "ForStatement[49880-49984]:ForStatement[49953-50057]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49913-49984]:Block[49986-50057]"
    }, {
      "left" : "d[r][c] = mat.getEntry(r % rd, c % cd);",
      "right" : "d[r][c] = mat.getEntry(r % rd, c % cd);",
      "info" : "ExpressionStatement[49931-49970]:ExpressionStatement[50004-50043]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[50003-50045]:ReturnStatement[50076-50118]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50283-50575]:Block[50356-50648]"
    }, {
      "left" : "int size = (int) ((end - start) / step + 1);",
      "right" : "int size = (int) ((end - start) / step + 1);",
      "info" : "VariableDeclarationStatement[50293-50337]:VariableDeclarationStatement[50366-50410]"
    }, {
      "left" : "double[][] d = new double[size][1];",
      "right" : "double[][] d = new double[size][1];",
      "info" : "VariableDeclarationStatement[50346-50381]:VariableDeclarationStatement[50419-50454]"
    }, {
      "left" : "double value = start;",
      "right" : "double value = start;",
      "info" : "VariableDeclarationStatement[50390-50411]:VariableDeclarationStatement[50463-50484]"
    }, {
      "left" : "for (int r = 0; r < size; r++)",
      "right" : "for (int r = 0; r < size; r++)",
      "info" : "ForStatement[50420-50518]:ForStatement[50493-50591]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50451-50518]:Block[50524-50591]"
    }, {
      "left" : "d[r][0] = value;",
      "right" : "d[r][0] = value;",
      "info" : "ExpressionStatement[50465-50481]:ExpressionStatement[50538-50554]"
    }, {
      "left" : "value += step;",
      "right" : "value += step;",
      "info" : "ExpressionStatement[50494-50508]:ExpressionStatement[50567-50581]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[50527-50569]:ReturnStatement[50600-50642]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50730-51063]:Block[50803-51136]"
    }, {
      "left" : "double max = -Double.MAX_VALUE;",
      "right" : "double max = -Double.MAX_VALUE;",
      "info" : "VariableDeclarationStatement[50740-50771]:VariableDeclarationStatement[50813-50844]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[50780-51037]:ForStatement[50853-51110]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50826-51037]:Block[50899-51110]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[50840-51027]:ForStatement[50913-51100]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50889-51027]:Block[50962-51100]"
    }, {
      "left" : "double e = m.getEntry(r, c);",
      "right" : "double e = m.getEntry(r, c);",
      "info" : "VariableDeclarationStatement[50907-50935]:VariableDeclarationStatement[50980-51008]"
    }, {
      "left" : "if (max < e)",
      "right" : "if (max < e)",
      "info" : "IfStatement[50952-51013]:IfStatement[51025-51086]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50965-51013]:Block[51038-51086]"
    }, {
      "left" : "max = e;",
      "right" : "max = e;",
      "info" : "ExpressionStatement[50987-50995]:ExpressionStatement[51060-51068]"
    }, {
      "left" : "return max;",
      "right" : "return max;",
      "info" : "ReturnStatement[51046-51057]:ReturnStatement[51119-51130]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51218-51550]:Block[51291-51623]"
    }, {
      "left" : "double min = Double.MAX_VALUE;",
      "right" : "double min = Double.MAX_VALUE;",
      "info" : "VariableDeclarationStatement[51228-51258]:VariableDeclarationStatement[51301-51331]"
    }, {
      "left" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "right" : "for (int r = 0; r < m.getRowDimension(); r++)",
      "info" : "ForStatement[51267-51524]:ForStatement[51340-51597]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51313-51524]:Block[51386-51597]"
    }, {
      "left" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "right" : "for (int c = 0; c < m.getColumnDimension(); c++)",
      "info" : "ForStatement[51327-51514]:ForStatement[51400-51587]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51376-51514]:Block[51449-51587]"
    }, {
      "left" : "double e = m.getEntry(r, c);",
      "right" : "double e = m.getEntry(r, c);",
      "info" : "VariableDeclarationStatement[51394-51422]:VariableDeclarationStatement[51467-51495]"
    }, {
      "left" : "if (min > e)",
      "right" : "if (min > e)",
      "info" : "IfStatement[51439-51500]:IfStatement[51512-51573]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51452-51500]:Block[51525-51573]"
    }, {
      "left" : "min = e;",
      "right" : "min = e;",
      "info" : "ExpressionStatement[51474-51482]:ExpressionStatement[51547-51555]"
    }, {
      "left" : "return min;",
      "right" : "return min;",
      "info" : "ReturnStatement[51533-51544]:ReturnStatement[51606-51617]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51693-51887]:Block[51766-51960]"
    }, {
      "left" : "double max = -Double.MAX_VALUE;",
      "right" : "double max = -Double.MAX_VALUE;",
      "info" : "VariableDeclarationStatement[51703-51734]:VariableDeclarationStatement[51776-51807]"
    }, {
      "left" : "for (int r = 0; r < m.length; r++)",
      "right" : "for (int r = 0; r < m.length; r++)",
      "info" : "ForStatement[51743-51861]:ForStatement[51816-51934]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51778-51861]:Block[51851-51934]"
    }, {
      "left" : "if (max < m[r])",
      "right" : "if (max < m[r])",
      "info" : "IfStatement[51792-51851]:IfStatement[51865-51924]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51808-51851]:Block[51881-51924]"
    }, {
      "left" : "max = m[r];",
      "right" : "max = m[r];",
      "info" : "ExpressionStatement[51826-51837]:ExpressionStatement[51899-51910]"
    }, {
      "left" : "return max;",
      "right" : "return max;",
      "info" : "ReturnStatement[51870-51881]:ReturnStatement[51943-51954]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52030-52223]:Block[52103-52296]"
    }, {
      "left" : "double min = Double.MAX_VALUE;",
      "right" : "double min = Double.MAX_VALUE;",
      "info" : "VariableDeclarationStatement[52040-52070]:VariableDeclarationStatement[52113-52143]"
    }, {
      "left" : "for (int r = 0; r < m.length; r++)",
      "right" : "for (int r = 0; r < m.length; r++)",
      "info" : "ForStatement[52079-52197]:ForStatement[52152-52270]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52114-52197]:Block[52187-52270]"
    }, {
      "left" : "if (min > m[r])",
      "right" : "if (min > m[r])",
      "info" : "IfStatement[52128-52187]:IfStatement[52201-52260]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52144-52187]:Block[52217-52260]"
    }, {
      "left" : "min = m[r];",
      "right" : "min = m[r];",
      "info" : "ExpressionStatement[52162-52173]:ExpressionStatement[52235-52246]"
    }, {
      "left" : "return min;",
      "right" : "return min;",
      "info" : "ReturnStatement[52206-52217]:ReturnStatement[52279-52290]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52398-52576]:Block[52471-52649]"
    }, {
      "left" : "int[] inverse = new int[indices.length];",
      "right" : "int[] inverse = new int[indices.length];",
      "info" : "VariableDeclarationStatement[52408-52448]:VariableDeclarationStatement[52481-52521]"
    }, {
      "left" : "for (int i = 0; i < indices.length; i++)",
      "right" : "for (int i = 0; i < indices.length; i++)",
      "info" : "ForStatement[52457-52546]:ForStatement[52530-52619]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52498-52546]:Block[52571-52619]"
    }, {
      "left" : "inverse[indices[i]] = i;",
      "right" : "inverse[indices[i]] = i;",
      "info" : "ExpressionStatement[52512-52536]:ExpressionStatement[52585-52609]"
    }, {
      "left" : "return inverse;",
      "right" : "return inverse;",
      "info" : "ReturnStatement[52555-52570]:ReturnStatement[52628-52643]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52750-52949]:Block[52823-53022]"
    }, {
      "left" : "int[] reverse = new int[indices.length];",
      "right" : "int[] reverse = new int[indices.length];",
      "info" : "VariableDeclarationStatement[52760-52800]:VariableDeclarationStatement[52833-52873]"
    }, {
      "left" : "for (int i = 0; i < indices.length; i++)",
      "right" : "for (int i = 0; i < indices.length; i++)",
      "info" : "ForStatement[52809-52919]:ForStatement[52882-52992]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52850-52919]:Block[52923-52992]"
    }, {
      "left" : "reverse[i] = indices[indices.length - i - 1];",
      "right" : "reverse[i] = indices[indices.length - i - 1];",
      "info" : "ExpressionStatement[52864-52909]:ExpressionStatement[52937-52982]"
    }, {
      "left" : "return reverse;",
      "right" : "return reverse;",
      "info" : "ReturnStatement[52928-52943]:ReturnStatement[53001-53016]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53099-53268]:Block[53172-53341]"
    }, {
      "left" : "double[] randn = new double[size];",
      "right" : "double[] randn = new double[size];",
      "info" : "VariableDeclarationStatement[53109-53143]:VariableDeclarationStatement[53182-53216]"
    }, {
      "left" : "for (int i = 0; i < size; i++)",
      "right" : "for (int i = 0; i < size; i++)",
      "info" : "ForStatement[53152-53240]:ForStatement[53225-53313]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53183-53240]:Block[53256-53313]"
    }, {
      "left" : "randn[i] = random.nextGaussian();",
      "right" : "randn[i] = random.nextGaussian();",
      "info" : "ExpressionStatement[53197-53230]:ExpressionStatement[53270-53303]"
    }, {
      "left" : "return randn;",
      "right" : "return randn;",
      "info" : "ReturnStatement[53249-53262]:ReturnStatement[53322-53335]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53479-53749]:Block[53552-53822]"
    }, {
      "left" : "double[][] d = new double[size][popSize];",
      "right" : "double[][] d = new double[size][popSize];",
      "info" : "VariableDeclarationStatement[53489-53530]:VariableDeclarationStatement[53562-53603]"
    }, {
      "left" : "for (int r = 0; r < size; r++)",
      "right" : "for (int r = 0; r < size; r++)",
      "info" : "ForStatement[53539-53692]:ForStatement[53612-53765]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53570-53692]:Block[53643-53765]"
    }, {
      "left" : "for (int c = 0; c < popSize; c++)",
      "right" : "for (int c = 0; c < popSize; c++)",
      "info" : "ForStatement[53584-53682]:ForStatement[53657-53755]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53618-53682]:Block[53691-53755]"
    }, {
      "left" : "d[r][c] = random.nextGaussian();",
      "right" : "d[r][c] = random.nextGaussian();",
      "info" : "ExpressionStatement[53636-53668]:ExpressionStatement[53709-53741]"
    }, {
      "left" : "return new Array2DRowRealMatrix(d, false);",
      "right" : "return new Array2DRowRealMatrix(d, false);",
      "info" : "ReturnStatement[53701-53743]:ReturnStatement[53774-53816]"
    } ]
  },
  "interFileMappings" : { }
}