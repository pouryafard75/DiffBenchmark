{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "private static final char[] HEX_CHARS\n      = { '0', '1', '2', '3', '4', '5', '6', '7',\n          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };",
      "right" : "private static final char[] HEX_CHARS\n      = { '0', '1', '2', '3', '4', '5', '6', '7',\n          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };",
      "info" : "FieldDeclaration[1168-1307]:FieldDeclaration[1168-1307]"
    }, {
      "left" : "private final CodeConsumer cc;",
      "right" : "private final CodeConsumer cc;",
      "info" : "FieldDeclaration[1311-1341]:FieldDeclaration[1311-1341]"
    }, {
      "left" : "private final CharsetEncoder outputCharsetEncoder;",
      "right" : "private final CharsetEncoder outputCharsetEncoder;",
      "info" : "FieldDeclaration[1345-1395]:FieldDeclaration[1345-1395]"
    }, {
      "left" : "CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset)",
      "right" : "CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset)",
      "info" : "MethodDeclaration[1399-1959]:MethodDeclaration[1399-1959]"
    }, {
      "left" : "CodeGenerator(CodeConsumer consumer)",
      "right" : "CodeGenerator(CodeConsumer consumer)",
      "info" : "MethodDeclaration[1963-2031]:MethodDeclaration[1963-2031]"
    }, {
      "left" : "public void tagAsStrict()",
      "right" : "public void tagAsStrict()",
      "info" : "MethodDeclaration[2035-2150]:MethodDeclaration[2035-2150]"
    }, {
      "left" : "void add(String str)",
      "right" : "void add(String str)",
      "info" : "MethodDeclaration[2154-2197]:MethodDeclaration[2154-2197]"
    }, {
      "left" : "private void addIdentifier(String identifier)",
      "right" : "private void addIdentifier(String identifier)",
      "info" : "MethodDeclaration[2201-2304]:MethodDeclaration[2201-2304]"
    }, {
      "left" : "void add(Node n)",
      "right" : "void add(Node n)",
      "info" : "MethodDeclaration[2308-2357]:MethodDeclaration[2308-2357]"
    }, {
      "left" : "void add(Node n, Context context)",
      "right" : "void add(Node n, Context context)",
      "info" : "MethodDeclaration[2361-21884]:MethodDeclaration[2361-21884]"
    }, {
      "left" : "static boolean isSimpleNumber(String s)",
      "right" : "static boolean isSimpleNumber(String s)",
      "info" : "MethodDeclaration[21888-22127]:MethodDeclaration[21888-22127]"
    }, {
      "left" : "static double getSimpleNumber(String s)",
      "right" : "static double getSimpleNumber(String s)",
      "info" : "MethodDeclaration[22131-22348]:MethodDeclaration[22131-22348]"
    }, {
      "left" : "private boolean isIndirectEval(Node n)",
      "right" : "private boolean isIndirectEval(Node n)",
      "info" : "MethodDeclaration[22352-22576]:MethodDeclaration[22352-22576]"
    }, {
      "left" : "private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild)",
      "right" : "private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild)",
      "info" : "MethodDeclaration[22580-24736]:MethodDeclaration[22580-24736]"
    }, {
      "left" : "private boolean isOneExactlyFunctionOrDo(Node n)",
      "right" : "private boolean isOneExactlyFunctionOrDo(Node n)",
      "info" : "MethodDeclaration[24740-25655]:MethodDeclaration[24740-25655]"
    }, {
      "left" : "void addLeftExpr(Node n, int minPrecedence, Context context)",
      "right" : "void addLeftExpr(Node n, int minPrecedence, Context context)",
      "info" : "MethodDeclaration[25659-26199]:MethodDeclaration[25659-26199]"
    }, {
      "left" : "void addExpr(Node n, int minPrecedence)",
      "right" : "void addExpr(Node n, int minPrecedence)",
      "info" : "MethodDeclaration[26203-26294]:MethodDeclaration[26203-26294]"
    }, {
      "left" : "private void addExpr(Node n, int minPrecedence, Context context)",
      "right" : "private void addExpr(Node n, int minPrecedence, Context context)",
      "info" : "MethodDeclaration[26298-26645]:MethodDeclaration[26298-26645]"
    }, {
      "left" : "void addList(Node firstInList)",
      "right" : "void addList(Node firstInList)",
      "info" : "MethodDeclaration[26649-26732]:MethodDeclaration[26649-26732]"
    }, {
      "left" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument)",
      "right" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument)",
      "info" : "MethodDeclaration[26736-26875]:MethodDeclaration[26736-26875]"
    }, {
      "left" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext)",
      "right" : "void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext)",
      "info" : "MethodDeclaration[26879-27292]:MethodDeclaration[26879-27292]"
    }, {
      "left" : "void addArrayList(Node firstInList)",
      "right" : "void addArrayList(Node firstInList)",
      "info" : "MethodDeclaration[27296-27982]:MethodDeclaration[27296-27982]"
    }, {
      "left" : "void addCaseBody(Node caseBody)",
      "right" : "void addCaseBody(Node caseBody)",
      "info" : "MethodDeclaration[27986-28088]:MethodDeclaration[27986-28088]"
    }, {
      "left" : "void addAllSiblings(Node n)",
      "right" : "void addAllSiblings(Node n)",
      "info" : "MethodDeclaration[28092-28196]:MethodDeclaration[28092-28196]"
    }, {
      "left" : "static String jsString(String s, CharsetEncoder outputCharsetEncoder)",
      "right" : "static String jsString(String s, CharsetEncoder outputCharsetEncoder)",
      "info" : "MethodDeclaration[28200-29069]:MethodDeclaration[28200-29069]"
    }, {
      "left" : "static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder)",
      "right" : "static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder)",
      "info" : "MethodDeclaration[29073-29257]:MethodDeclaration[29073-29257]"
    }, {
      "left" : "static String escapeToDoubleQuotedJsString(String s)",
      "right" : "static String escapeToDoubleQuotedJsString(String s)",
      "info" : "MethodDeclaration[29261-29466]:MethodDeclaration[29261-29466]"
    }, {
      "left" : "static String regexpEscape(String s)",
      "right" : "static String regexpEscape(String s)",
      "info" : "MethodDeclaration[29595-29671]:MethodDeclaration[29595-29671]"
    }, {
      "left" : "static String identifierEscape(String s)",
      "right" : "static String identifierEscape(String s)",
      "info" : "MethodDeclaration[32544-33234]:MethodDeclaration[32543-33233]"
    }, {
      "left" : "private static int getNonEmptyChildCount(Node n, int maxCount)",
      "right" : "private static int getNonEmptyChildCount(Node n, int maxCount)",
      "info" : "MethodDeclaration[33237-33754]:MethodDeclaration[33236-33753]"
    }, {
      "left" : "private static Node getFirstNonEmptyChild(Node n)",
      "right" : "private static Node getFirstNonEmptyChild(Node n)",
      "info" : "MethodDeclaration[33758-34188]:MethodDeclaration[33757-34187]"
    }, {
      "left" : "enum : Context",
      "right" : "enum : Context",
      "info" : "EnumDeclaration[34393-34795]:EnumDeclaration[34392-34794]"
    }, {
      "left" : "private Context getContextForNonEmptyExpression(Context currentContext)",
      "right" : "private Context getContextForNonEmptyExpression(Context currentContext)",
      "info" : "MethodDeclaration[34799-34990]:MethodDeclaration[34798-34989]"
    }, {
      "left" : "private  Context getContextForNoInOperator(Context context)",
      "right" : "private  Context getContextForNoInOperator(Context context)",
      "info" : "MethodDeclaration[34994-35329]:MethodDeclaration[34993-35328]"
    }, {
      "left" : "private  Context clearContextForNoInOperator(Context context)",
      "right" : "private  Context clearContextForNoInOperator(Context context)",
      "info" : "MethodDeclaration[35333-35770]:MethodDeclaration[35332-35769]"
    }, {
      "left" : "private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c)",
      "right" : "private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c)",
      "info" : "MethodDeclaration[35774-36124]:MethodDeclaration[35773-36123]"
    }, {
      "left" : "private static void appendHexJavaScriptRepresentation(\n      int codePoint, Appendable out)\n      throws IOException",
      "right" : "private static void appendHexJavaScriptRepresentation(\n      int codePoint, Appendable out)\n      throws IOException",
      "info" : "MethodDeclaration[36128-37214]:MethodDeclaration[36127-37213]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1466-1959]:Block[1466-1959]"
    }, {
      "left" : "cc = consumer;",
      "right" : "cc = consumer;",
      "info" : "ExpressionStatement[1472-1486]:ExpressionStatement[1472-1486]"
    }, {
      "left" : "if (outputCharset == null || outputCharset == Charsets.US_ASCII)",
      "right" : "if (outputCharset == null || outputCharset == Charsets.US_ASCII)",
      "info" : "IfStatement[1491-1955]:IfStatement[1491-1955]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1556-1880]:Block[1556-1880]"
    }, {
      "left" : "this.outputCharsetEncoder = null;",
      "right" : "this.outputCharsetEncoder = null;",
      "info" : "ExpressionStatement[1841-1874]:ExpressionStatement[1841-1874]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1886-1955]:Block[1886-1955]"
    }, {
      "left" : "this.outputCharsetEncoder = outputCharset.newEncoder();",
      "right" : "this.outputCharsetEncoder = outputCharset.newEncoder();",
      "info" : "ExpressionStatement[1894-1949]:ExpressionStatement[1894-1949]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2000-2031]:Block[2000-2031]"
    }, {
      "left" : "this(consumer, null);",
      "right" : "this(consumer, null);",
      "info" : "ConstructorInvocation[2006-2027]:ConstructorInvocation[2006-2027]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2119-2150]:Block[2119-2150]"
    }, {
      "left" : "add(\"'use strict';\");",
      "right" : "add(\"'use strict';\");",
      "info" : "ExpressionStatement[2125-2146]:ExpressionStatement[2125-2146]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2175-2197]:Block[2175-2197]"
    }, {
      "left" : "cc.add(str);",
      "right" : "cc.add(str);",
      "info" : "ExpressionStatement[2181-2193]:ExpressionStatement[2181-2193]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2247-2304]:Block[2247-2304]"
    }, {
      "left" : "cc.addIdentifier(identifierEscape(identifier));",
      "right" : "cc.addIdentifier(identifierEscape(identifier));",
      "info" : "ExpressionStatement[2253-2300]:ExpressionStatement[2253-2300]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2325-2357]:Block[2325-2357]"
    }, {
      "left" : "add(n, Context.OTHER);",
      "right" : "add(n, Context.OTHER);",
      "info" : "ExpressionStatement[2331-2353]:ExpressionStatement[2331-2353]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2395-21884]:Block[2395-21884]"
    }, {
      "left" : "if (!cc.continueProcessing())",
      "right" : "if (!cc.continueProcessing())",
      "info" : "IfStatement[2401-2452]:IfStatement[2401-2452]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2431-2452]:Block[2431-2452]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[2439-2446]:ReturnStatement[2439-2446]"
    }, {
      "left" : "int type = n.getType();",
      "right" : "int type = n.getType();",
      "info" : "VariableDeclarationStatement[2458-2481]:VariableDeclarationStatement[2458-2481]"
    }, {
      "left" : "String opstr = NodeUtil.opToStr(type);",
      "right" : "String opstr = NodeUtil.opToStr(type);",
      "info" : "VariableDeclarationStatement[2486-2524]:VariableDeclarationStatement[2486-2524]"
    }, {
      "left" : "int childCount = n.getChildCount();",
      "right" : "int childCount = n.getChildCount();",
      "info" : "VariableDeclarationStatement[2529-2564]:VariableDeclarationStatement[2529-2564]"
    }, {
      "left" : "Node first = n.getFirstChild();",
      "right" : "Node first = n.getFirstChild();",
      "info" : "VariableDeclarationStatement[2569-2600]:VariableDeclarationStatement[2569-2600]"
    }, {
      "left" : "Node last = n.getLastChild();",
      "right" : "Node last = n.getLastChild();",
      "info" : "VariableDeclarationStatement[2605-2634]:VariableDeclarationStatement[2605-2634]"
    }, {
      "left" : "if (opstr != null && first != last)",
      "right" : "if (opstr != null && first != last)",
      "info" : "IfStatement[2675-3666]:IfStatement[2675-3666]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2711-3666]:Block[2711-3666]"
    }, {
      "left" : "Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);",
      "right" : "Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);",
      "info" : "ExpressionStatement[2719-2874]:ExpressionStatement[2719-2874]"
    }, {
      "left" : "int p = NodeUtil.precedence(type);",
      "right" : "int p = NodeUtil.precedence(type);",
      "info" : "VariableDeclarationStatement[2881-2915]:VariableDeclarationStatement[2881-2915]"
    }, {
      "left" : "addLeftExpr(first, p, context);",
      "right" : "addLeftExpr(first, p, context);",
      "info" : "ExpressionStatement[2922-2953]:ExpressionStatement[2922-2953]"
    }, {
      "left" : "cc.addOp(opstr, true);",
      "right" : "cc.addOp(opstr, true);",
      "info" : "ExpressionStatement[2960-2982]:ExpressionStatement[2960-2982]"
    }, {
      "left" : "Context rhsContext = getContextForNoInOperator(context);",
      "right" : "Context rhsContext = getContextForNoInOperator(context);",
      "info" : "VariableDeclarationStatement[3097-3153]:VariableDeclarationStatement[3097-3153]"
    }, {
      "left" : "if (last.getType() == type &&\n          NodeUtil.isAssociative(type))",
      "right" : "if (last.getType() == type &&\n          NodeUtil.isAssociative(type))",
      "info" : "IfStatement[3283-3646]:IfStatement[3283-3646]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3353-3400]:Block[3353-3400]"
    }, {
      "left" : "addExpr(last, p, rhsContext);",
      "right" : "addExpr(last, p, rhsContext);",
      "info" : "ExpressionStatement[3363-3392]:ExpressionStatement[3363-3392]"
    }, {
      "left" : "if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last))",
      "right" : "if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last))",
      "info" : "IfStatement[3406-3646]:IfStatement[3406-3646]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3471-3589]:Block[3471-3589]"
    }, {
      "left" : "addExpr(last, p, rhsContext);",
      "right" : "addExpr(last, p, rhsContext);",
      "info" : "ExpressionStatement[3552-3581]:ExpressionStatement[3552-3581]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3595-3646]:Block[3595-3646]"
    }, {
      "left" : "addExpr(last, p + 1, rhsContext);",
      "right" : "addExpr(last, p + 1, rhsContext);",
      "info" : "ExpressionStatement[3605-3638]:ExpressionStatement[3605-3638]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[3653-3660]:ReturnStatement[3653-3660]"
    }, {
      "left" : "cc.startSourceMapping(n);",
      "right" : "cc.startSourceMapping(n);",
      "info" : "ExpressionStatement[3672-3697]:ExpressionStatement[3672-3697]"
    }, {
      "left" : "switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            add(jsString(n.getString(), outputCharsetEncoder));\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.getType() == Token.STRING);\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }",
      "right" : "switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            add(jsString(n.getString(), outputCharsetEncoder));\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.getType() == Token.STRING);\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }",
      "info" : "SwitchStatement[3703-21851]:SwitchStatement[3703-21851]"
    }, {
      "left" : "case Token.TRY:",
      "right" : "case Token.TRY:",
      "info" : "SwitchCase[3725-3740]:SwitchCase[3725-3740]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3741-4379]:Block[3741-4379]"
    }, {
      "left" : "Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());",
      "right" : "Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());",
      "info" : "ExpressionStatement[3751-3876]:ExpressionStatement[3751-3876]"
    }, {
      "left" : "Preconditions.checkState(childCount >= 2 && childCount <= 3);",
      "right" : "Preconditions.checkState(childCount >= 2 && childCount <= 3);",
      "info" : "ExpressionStatement[3885-3946]:ExpressionStatement[3885-3946]"
    }, {
      "left" : "add(\"try\");",
      "right" : "add(\"try\");",
      "info" : "ExpressionStatement[3956-3967]:ExpressionStatement[3956-3967]"
    }, {
      "left" : "add(first, Context.PRESERVE_BLOCK);",
      "right" : "add(first, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[3976-4011]:ExpressionStatement[3976-4011]"
    }, {
      "left" : "Node catchblock = first.getNext().getFirstChild();",
      "right" : "Node catchblock = first.getNext().getFirstChild();",
      "info" : "VariableDeclarationStatement[4122-4172]:VariableDeclarationStatement[4122-4172]"
    }, {
      "left" : "if (catchblock != null)",
      "right" : "if (catchblock != null)",
      "info" : "IfStatement[4181-4243]:IfStatement[4181-4243]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4205-4243]:Block[4205-4243]"
    }, {
      "left" : "add(catchblock);",
      "right" : "add(catchblock);",
      "info" : "ExpressionStatement[4217-4233]:ExpressionStatement[4217-4233]"
    }, {
      "left" : "if (childCount == 3)",
      "right" : "if (childCount == 3)",
      "info" : "IfStatement[4253-4356]:IfStatement[4253-4356]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4274-4356]:Block[4274-4356]"
    }, {
      "left" : "add(\"finally\");",
      "right" : "add(\"finally\");",
      "info" : "ExpressionStatement[4286-4301]:ExpressionStatement[4286-4301]"
    }, {
      "left" : "add(last, Context.PRESERVE_BLOCK);",
      "right" : "add(last, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[4312-4346]:ExpressionStatement[4312-4346]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4365-4371]:BreakStatement[4365-4371]"
    }, {
      "left" : "case Token.CATCH:",
      "right" : "case Token.CATCH:",
      "info" : "SwitchCase[4387-4404]:SwitchCase[4387-4404]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[4413-4455]:ExpressionStatement[4413-4455]"
    }, {
      "left" : "add(\"catch(\");",
      "right" : "add(\"catch(\");",
      "info" : "ExpressionStatement[4464-4478]:ExpressionStatement[4464-4478]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[4487-4498]:ExpressionStatement[4487-4498]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[4507-4516]:ExpressionStatement[4507-4516]"
    }, {
      "left" : "add(last, Context.PRESERVE_BLOCK);",
      "right" : "add(last, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[4525-4559]:ExpressionStatement[4525-4559]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4568-4574]:BreakStatement[4568-4574]"
    }, {
      "left" : "case Token.THROW:",
      "right" : "case Token.THROW:",
      "info" : "SwitchCase[4582-4599]:SwitchCase[4582-4599]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[4608-4650]:ExpressionStatement[4608-4650]"
    }, {
      "left" : "add(\"throw\");",
      "right" : "add(\"throw\");",
      "info" : "ExpressionStatement[4659-4672]:ExpressionStatement[4659-4672]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[4681-4692]:ExpressionStatement[4681-4692]"
    }, {
      "left" : "cc.endStatement(true);",
      "right" : "cc.endStatement(true);",
      "info" : "ExpressionStatement[4800-4822]:ExpressionStatement[4800-4822]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4831-4837]:BreakStatement[4831-4837]"
    }, {
      "left" : "case Token.RETURN:",
      "right" : "case Token.RETURN:",
      "info" : "SwitchCase[4845-4863]:SwitchCase[4845-4863]"
    }, {
      "left" : "add(\"return\");",
      "right" : "add(\"return\");",
      "info" : "ExpressionStatement[4872-4886]:ExpressionStatement[4872-4886]"
    }, {
      "left" : "if (childCount == 1)",
      "right" : "if (childCount == 1)",
      "info" : "IfStatement[4895-5019]:IfStatement[4895-5019]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4916-4949]:Block[4916-4949]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[4928-4939]:ExpressionStatement[4928-4939]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4955-5019]:Block[4955-5019]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[4967-5009]:ExpressionStatement[4967-5009]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[5028-5046]:ExpressionStatement[5028-5046]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5055-5061]:BreakStatement[5055-5061]"
    }, {
      "left" : "case Token.VAR:",
      "right" : "case Token.VAR:",
      "info" : "SwitchCase[5069-5084]:SwitchCase[5069-5084]"
    }, {
      "left" : "if (first != null)",
      "right" : "if (first != null)",
      "info" : "IfStatement[5093-5215]:IfStatement[5093-5215]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5112-5215]:Block[5112-5215]"
    }, {
      "left" : "add(\"var \");",
      "right" : "add(\"var \");",
      "info" : "ExpressionStatement[5124-5136]:ExpressionStatement[5124-5136]"
    }, {
      "left" : "addList(first, false, getContextForNoInOperator(context));",
      "right" : "addList(first, false, getContextForNoInOperator(context));",
      "info" : "ExpressionStatement[5147-5205]:ExpressionStatement[5147-5205]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5224-5230]:BreakStatement[5224-5230]"
    }, {
      "left" : "case Token.LABEL_NAME:",
      "right" : "case Token.LABEL_NAME:",
      "info" : "SwitchCase[5238-5260]:SwitchCase[5238-5260]"
    }, {
      "left" : "Preconditions.checkState(!n.getString().isEmpty());",
      "right" : "Preconditions.checkState(!n.getString().isEmpty());",
      "info" : "ExpressionStatement[5269-5320]:ExpressionStatement[5269-5320]"
    }, {
      "left" : "addIdentifier(n.getString());",
      "right" : "addIdentifier(n.getString());",
      "info" : "ExpressionStatement[5329-5358]:ExpressionStatement[5329-5358]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5367-5373]:BreakStatement[5367-5373]"
    }, {
      "left" : "case Token.NAME:",
      "right" : "case Token.NAME:",
      "info" : "SwitchCase[5381-5397]:SwitchCase[5381-5397]"
    }, {
      "left" : "if (first == null || first.getType() == Token.EMPTY)",
      "right" : "if (first == null || first.getType() == Token.EMPTY)",
      "info" : "IfStatement[5406-5958]:IfStatement[5406-5958]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5459-5510]:Block[5459-5510]"
    }, {
      "left" : "addIdentifier(n.getString());",
      "right" : "addIdentifier(n.getString());",
      "info" : "ExpressionStatement[5471-5500]:ExpressionStatement[5471-5500]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5516-5958]:Block[5516-5958]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[5528-5570]:ExpressionStatement[5528-5570]"
    }, {
      "left" : "addIdentifier(n.getString());",
      "right" : "addIdentifier(n.getString());",
      "info" : "ExpressionStatement[5581-5610]:ExpressionStatement[5581-5610]"
    }, {
      "left" : "cc.addOp(\"=\", true);",
      "right" : "cc.addOp(\"=\", true);",
      "info" : "ExpressionStatement[5621-5641]:ExpressionStatement[5621-5641]"
    }, {
      "left" : "if (first.getType() == Token.COMMA)",
      "right" : "if (first.getType() == Token.COMMA)",
      "info" : "IfStatement[5652-5948]:IfStatement[5652-5948]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5688-5764]:Block[5688-5764]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(Token.ASSIGN));",
      "right" : "addExpr(first, NodeUtil.precedence(Token.ASSIGN));",
      "info" : "ExpressionStatement[5702-5752]:ExpressionStatement[5702-5752]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5770-5948]:Block[5770-5948]"
    }, {
      "left" : "addExpr(first, 0, getContextForNoInOperator(context));",
      "right" : "addExpr(first, 0, getContextForNoInOperator(context));",
      "info" : "ExpressionStatement[5882-5936]:ExpressionStatement[5882-5936]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[5967-5973]:BreakStatement[5967-5973]"
    }, {
      "left" : "case Token.ARRAYLIT:",
      "right" : "case Token.ARRAYLIT:",
      "info" : "SwitchCase[5981-6001]:SwitchCase[5981-6001]"
    }, {
      "left" : "add(\"[\");",
      "right" : "add(\"[\");",
      "info" : "ExpressionStatement[6010-6019]:ExpressionStatement[6010-6019]"
    }, {
      "left" : "addArrayList(first);",
      "right" : "addArrayList(first);",
      "info" : "ExpressionStatement[6028-6048]:ExpressionStatement[6028-6048]"
    }, {
      "left" : "add(\"]\");",
      "right" : "add(\"]\");",
      "info" : "ExpressionStatement[6057-6066]:ExpressionStatement[6057-6066]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6075-6081]:BreakStatement[6075-6081]"
    }, {
      "left" : "case Token.LP:",
      "right" : "case Token.LP:",
      "info" : "SwitchCase[6089-6103]:SwitchCase[6089-6103]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[6112-6121]:ExpressionStatement[6112-6121]"
    }, {
      "left" : "addList(first);",
      "right" : "addList(first);",
      "info" : "ExpressionStatement[6130-6145]:ExpressionStatement[6130-6145]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[6154-6163]:ExpressionStatement[6154-6163]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6172-6178]:BreakStatement[6172-6178]"
    }, {
      "left" : "case Token.COMMA:",
      "right" : "case Token.COMMA:",
      "info" : "SwitchCase[6186-6203]:SwitchCase[6186-6203]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[6212-6254]:ExpressionStatement[6212-6254]"
    }, {
      "left" : "addList(first, false, context);",
      "right" : "addList(first, false, context);",
      "info" : "ExpressionStatement[6263-6294]:ExpressionStatement[6263-6294]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6303-6309]:BreakStatement[6303-6309]"
    }, {
      "left" : "case Token.NUMBER:",
      "right" : "case Token.NUMBER:",
      "info" : "SwitchCase[6317-6335]:SwitchCase[6317-6335]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[6344-6386]:ExpressionStatement[6344-6386]"
    }, {
      "left" : "cc.addNumber(n.getDouble());",
      "right" : "cc.addNumber(n.getDouble());",
      "info" : "ExpressionStatement[6395-6423]:ExpressionStatement[6395-6423]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6432-6438]:BreakStatement[6432-6438]"
    }, {
      "left" : "case Token.TYPEOF:",
      "right" : "case Token.TYPEOF:",
      "info" : "SwitchCase[6446-6464]:SwitchCase[6446-6464]"
    }, {
      "left" : "case Token.VOID:",
      "right" : "case Token.VOID:",
      "info" : "SwitchCase[6471-6487]:SwitchCase[6471-6487]"
    }, {
      "left" : "case Token.NOT:",
      "right" : "case Token.NOT:",
      "info" : "SwitchCase[6494-6509]:SwitchCase[6494-6509]"
    }, {
      "left" : "case Token.BITNOT:",
      "right" : "case Token.BITNOT:",
      "info" : "SwitchCase[6516-6534]:SwitchCase[6516-6534]"
    }, {
      "left" : "case Token.POS:",
      "right" : "case Token.POS:",
      "info" : "SwitchCase[6541-6556]:SwitchCase[6541-6556]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6557-6800]:Block[6557-6800]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[6629-6671]:ExpressionStatement[6629-6671]"
    }, {
      "left" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "right" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "info" : "ExpressionStatement[6680-6726]:ExpressionStatement[6680-6726]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(type));",
      "right" : "addExpr(first, NodeUtil.precedence(type));",
      "info" : "ExpressionStatement[6735-6777]:ExpressionStatement[6735-6777]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6786-6792]:BreakStatement[6786-6792]"
    }, {
      "left" : "case Token.NEG:",
      "right" : "case Token.NEG:",
      "info" : "SwitchCase[6808-6823]:SwitchCase[6808-6823]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6824-7351]:Block[6824-7351]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[6834-6876]:ExpressionStatement[6834-6876]"
    }, {
      "left" : "if (n.getFirstChild().getType() == Token.NUMBER)",
      "right" : "if (n.getFirstChild().getType() == Token.NUMBER)",
      "info" : "IfStatement[7084-7327]:IfStatement[7084-7327]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7133-7200]:Block[7133-7200]"
    }, {
      "left" : "cc.addNumber(-n.getFirstChild().getDouble());",
      "right" : "cc.addNumber(-n.getFirstChild().getDouble());",
      "info" : "ExpressionStatement[7145-7190]:ExpressionStatement[7145-7190]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7206-7327]:Block[7206-7327]"
    }, {
      "left" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "right" : "cc.addOp(NodeUtil.opToStrNoFail(type), false);",
      "info" : "ExpressionStatement[7218-7264]:ExpressionStatement[7218-7264]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(type));",
      "right" : "addExpr(first, NodeUtil.precedence(type));",
      "info" : "ExpressionStatement[7275-7317]:ExpressionStatement[7275-7317]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[7337-7343]:BreakStatement[7337-7343]"
    }, {
      "left" : "case Token.HOOK:",
      "right" : "case Token.HOOK:",
      "info" : "SwitchCase[7359-7375]:SwitchCase[7359-7375]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7376-7659]:Block[7376-7659]"
    }, {
      "left" : "Preconditions.checkState(childCount == 3);",
      "right" : "Preconditions.checkState(childCount == 3);",
      "info" : "ExpressionStatement[7386-7428]:ExpressionStatement[7386-7428]"
    }, {
      "left" : "int p = NodeUtil.precedence(type);",
      "right" : "int p = NodeUtil.precedence(type);",
      "info" : "VariableDeclarationStatement[7437-7471]:VariableDeclarationStatement[7437-7471]"
    }, {
      "left" : "addLeftExpr(first, p + 1, context);",
      "right" : "addLeftExpr(first, p + 1, context);",
      "info" : "ExpressionStatement[7480-7515]:ExpressionStatement[7480-7515]"
    }, {
      "left" : "cc.addOp(\"?\", true);",
      "right" : "cc.addOp(\"?\", true);",
      "info" : "ExpressionStatement[7524-7544]:ExpressionStatement[7524-7544]"
    }, {
      "left" : "addExpr(first.getNext(), 1);",
      "right" : "addExpr(first.getNext(), 1);",
      "info" : "ExpressionStatement[7553-7581]:ExpressionStatement[7553-7581]"
    }, {
      "left" : "cc.addOp(\":\", true);",
      "right" : "cc.addOp(\":\", true);",
      "info" : "ExpressionStatement[7590-7610]:ExpressionStatement[7590-7610]"
    }, {
      "left" : "addExpr(last, 1);",
      "right" : "addExpr(last, 1);",
      "info" : "ExpressionStatement[7619-7636]:ExpressionStatement[7619-7636]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[7645-7651]:BreakStatement[7645-7651]"
    }, {
      "left" : "case Token.REGEXP:",
      "right" : "case Token.REGEXP:",
      "info" : "SwitchCase[7667-7685]:SwitchCase[7667-7685]"
    }, {
      "left" : "if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING)",
      "right" : "if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING)",
      "info" : "IfStatement[7694-7850]:IfStatement[7694-7850]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7777-7850]:Block[7777-7850]"
    }, {
      "left" : "throw new Error(\"Expected children to be strings\");",
      "right" : "throw new Error(\"Expected children to be strings\");",
      "info" : "ThrowStatement[7789-7840]:ThrowStatement[7789-7840]"
    }, {
      "left" : "String regexp = regexpEscape(first.getString(), outputCharsetEncoder);",
      "right" : "String regexp = regexpEscape(first.getString(), outputCharsetEncoder);",
      "info" : "VariableDeclarationStatement[7860-7930]:VariableDeclarationStatement[7860-7930]"
    }, {
      "left" : "if (childCount == 2)",
      "right" : "if (childCount == 2)",
      "info" : "IfStatement[7998-8165]:IfStatement[7998-8165]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8019-8072]:Block[8019-8072]"
    }, {
      "left" : "add(regexp + last.getString());",
      "right" : "add(regexp + last.getString());",
      "info" : "ExpressionStatement[8031-8062]:ExpressionStatement[8031-8062]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8078-8165]:Block[8078-8165]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[8090-8132]:ExpressionStatement[8090-8132]"
    }, {
      "left" : "add(regexp);",
      "right" : "add(regexp);",
      "info" : "ExpressionStatement[8143-8155]:ExpressionStatement[8143-8155]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8174-8180]:BreakStatement[8174-8180]"
    }, {
      "left" : "case Token.GET_REF:",
      "right" : "case Token.GET_REF:",
      "info" : "SwitchCase[8188-8207]:SwitchCase[8188-8207]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[8216-8227]:ExpressionStatement[8216-8227]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8236-8242]:BreakStatement[8236-8242]"
    }, {
      "left" : "case Token.REF_SPECIAL:",
      "right" : "case Token.REF_SPECIAL:",
      "info" : "SwitchCase[8250-8273]:SwitchCase[8250-8273]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[8282-8324]:ExpressionStatement[8282-8324]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[8333-8344]:ExpressionStatement[8333-8344]"
    }, {
      "left" : "add(\".\");",
      "right" : "add(\".\");",
      "info" : "ExpressionStatement[8353-8362]:ExpressionStatement[8353-8362]"
    }, {
      "left" : "add((String) n.getProp(Node.NAME_PROP));",
      "right" : "add((String) n.getProp(Node.NAME_PROP));",
      "info" : "ExpressionStatement[8371-8411]:ExpressionStatement[8371-8411]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8420-8426]:BreakStatement[8420-8426]"
    }, {
      "left" : "case Token.FUNCTION:",
      "right" : "case Token.FUNCTION:",
      "info" : "SwitchCase[8434-8454]:SwitchCase[8434-8454]"
    }, {
      "left" : "if (n.getClass() != Node.class)",
      "right" : "if (n.getClass() != Node.class)",
      "info" : "IfStatement[8463-8562]:IfStatement[8463-8562]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8495-8562]:Block[8495-8562]"
    }, {
      "left" : "throw new Error(\"Unexpected Node subclass.\");",
      "right" : "throw new Error(\"Unexpected Node subclass.\");",
      "info" : "ThrowStatement[8507-8552]:ThrowStatement[8507-8552]"
    }, {
      "left" : "Preconditions.checkState(childCount == 3);",
      "right" : "Preconditions.checkState(childCount == 3);",
      "info" : "ExpressionStatement[8571-8613]:ExpressionStatement[8571-8613]"
    }, {
      "left" : "boolean funcNeedsParens = (context == Context.START_OF_EXPR);",
      "right" : "boolean funcNeedsParens = (context == Context.START_OF_EXPR);",
      "info" : "VariableDeclarationStatement[8622-8683]:VariableDeclarationStatement[8622-8683]"
    }, {
      "left" : "if (funcNeedsParens)",
      "right" : "if (funcNeedsParens)",
      "info" : "IfStatement[8692-8744]:IfStatement[8692-8744]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8713-8744]:Block[8713-8744]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[8725-8734]:ExpressionStatement[8725-8734]"
    }, {
      "left" : "add(\"function\");",
      "right" : "add(\"function\");",
      "info" : "ExpressionStatement[8754-8770]:ExpressionStatement[8754-8770]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[8779-8790]:ExpressionStatement[8779-8790]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[8800-8821]:ExpressionStatement[8800-8821]"
    }, {
      "left" : "add(last, Context.PRESERVE_BLOCK);",
      "right" : "add(last, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[8830-8864]:ExpressionStatement[8830-8864]"
    }, {
      "left" : "cc.endFunction(context == Context.STATEMENT);",
      "right" : "cc.endFunction(context == Context.STATEMENT);",
      "info" : "ExpressionStatement[8873-8918]:ExpressionStatement[8873-8918]"
    }, {
      "left" : "if (funcNeedsParens)",
      "right" : "if (funcNeedsParens)",
      "info" : "IfStatement[8928-8980]:IfStatement[8928-8980]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8949-8980]:Block[8949-8980]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[8961-8970]:ExpressionStatement[8961-8970]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8989-8995]:BreakStatement[8989-8995]"
    }, {
      "left" : "case Token.GET:",
      "right" : "case Token.GET:",
      "info" : "SwitchCase[9003-9018]:SwitchCase[9003-9018]"
    }, {
      "left" : "case Token.SET:",
      "right" : "case Token.SET:",
      "info" : "SwitchCase[9025-9040]:SwitchCase[9025-9040]"
    }, {
      "left" : "Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);",
      "right" : "Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);",
      "info" : "ExpressionStatement[9049-9118]:ExpressionStatement[9049-9118]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[9127-9169]:ExpressionStatement[9127-9169]"
    }, {
      "left" : "Preconditions.checkState(first.getType() == Token.FUNCTION);",
      "right" : "Preconditions.checkState(first.getType() == Token.FUNCTION);",
      "info" : "ExpressionStatement[9178-9238]:ExpressionStatement[9178-9238]"
    }, {
      "left" : "Preconditions.checkState(first.getFirstChild().getString().isEmpty());",
      "right" : "Preconditions.checkState(first.getFirstChild().getString().isEmpty());",
      "info" : "ExpressionStatement[9283-9353]:ExpressionStatement[9283-9353]"
    }, {
      "left" : "if (type == Token.GET)",
      "right" : "if (type == Token.GET)",
      "info" : "IfStatement[9362-9702]:IfStatement[9362-9702]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9385-9541]:Block[9385-9541]"
    }, {
      "left" : "Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());",
      "right" : "Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());",
      "info" : "ExpressionStatement[9442-9508]:ExpressionStatement[9442-9508]"
    }, {
      "left" : "add(\"get \");",
      "right" : "add(\"get \");",
      "info" : "ExpressionStatement[9519-9531]:ExpressionStatement[9519-9531]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9547-9702]:Block[9547-9702]"
    }, {
      "left" : "Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());",
      "right" : "Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());",
      "info" : "ExpressionStatement[9604-9669]:ExpressionStatement[9604-9669]"
    }, {
      "left" : "add(\"set \");",
      "right" : "add(\"set \");",
      "info" : "ExpressionStatement[9680-9692]:ExpressionStatement[9680-9692]"
    }, {
      "left" : "String name = n.getString();",
      "right" : "String name = n.getString();",
      "info" : "VariableDeclarationStatement[9759-9787]:VariableDeclarationStatement[9759-9787]"
    }, {
      "left" : "Node fn = first;",
      "right" : "Node fn = first;",
      "info" : "VariableDeclarationStatement[9796-9812]:VariableDeclarationStatement[9796-9812]"
    }, {
      "left" : "Node parameters = fn.getChildAtIndex(1);",
      "right" : "Node parameters = fn.getChildAtIndex(1);",
      "info" : "VariableDeclarationStatement[9821-9861]:VariableDeclarationStatement[9821-9861]"
    }, {
      "left" : "Node body = fn.getLastChild();",
      "right" : "Node body = fn.getLastChild();",
      "info" : "VariableDeclarationStatement[9870-9900]:VariableDeclarationStatement[9870-9900]"
    }, {
      "left" : "if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name))",
      "right" : "if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name))",
      "info" : "IfStatement[9944-10471]:IfStatement[9944-10471]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10163-10195]:Block[10163-10195]"
    }, {
      "left" : "add(name);",
      "right" : "add(name);",
      "info" : "ExpressionStatement[10175-10185]:ExpressionStatement[10175-10185]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10201-10471]:Block[10201-10471]"
    }, {
      "left" : "double d = getSimpleNumber(name);",
      "right" : "double d = getSimpleNumber(name);",
      "info" : "VariableDeclarationStatement[10270-10303]:VariableDeclarationStatement[10270-10303]"
    }, {
      "left" : "if (!Double.isNaN(d))",
      "right" : "if (!Double.isNaN(d))",
      "info" : "IfStatement[10314-10461]:IfStatement[10314-10461]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10336-10378]:Block[10336-10378]"
    }, {
      "left" : "cc.addNumber(d);",
      "right" : "cc.addNumber(d);",
      "info" : "ExpressionStatement[10350-10366]:ExpressionStatement[10350-10366]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10384-10461]:Block[10384-10461]"
    }, {
      "left" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "right" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "info" : "ExpressionStatement[10398-10449]:ExpressionStatement[10398-10449]"
    }, {
      "left" : "add(parameters);",
      "right" : "add(parameters);",
      "info" : "ExpressionStatement[10481-10497]:ExpressionStatement[10481-10497]"
    }, {
      "left" : "add(body, Context.PRESERVE_BLOCK);",
      "right" : "add(body, Context.PRESERVE_BLOCK);",
      "info" : "ExpressionStatement[10506-10540]:ExpressionStatement[10506-10540]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[10549-10555]:BreakStatement[10549-10555]"
    }, {
      "left" : "case Token.SCRIPT:",
      "right" : "case Token.SCRIPT:",
      "info" : "SwitchCase[10563-10581]:SwitchCase[10563-10581]"
    }, {
      "left" : "case Token.BLOCK:",
      "right" : "case Token.BLOCK:",
      "info" : "SwitchCase[10588-10605]:SwitchCase[10588-10605]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10606-11805]:Block[10606-11805]"
    }, {
      "left" : "if (n.getClass() != Node.class)",
      "right" : "if (n.getClass() != Node.class)",
      "info" : "IfStatement[10616-10715]:IfStatement[10616-10715]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10648-10715]:Block[10648-10715]"
    }, {
      "left" : "throw new Error(\"Unexpected Node subclass.\");",
      "right" : "throw new Error(\"Unexpected Node subclass.\");",
      "info" : "ThrowStatement[10660-10705]:ThrowStatement[10660-10705]"
    }, {
      "left" : "boolean preserveBlock = context == Context.PRESERVE_BLOCK;",
      "right" : "boolean preserveBlock = context == Context.PRESERVE_BLOCK;",
      "info" : "VariableDeclarationStatement[10724-10782]:VariableDeclarationStatement[10724-10782]"
    }, {
      "left" : "if (preserveBlock)",
      "right" : "if (preserveBlock)",
      "info" : "IfStatement[10791-10848]:IfStatement[10791-10848]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10810-10848]:Block[10810-10848]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[10822-10838]:ExpressionStatement[10822-10838]"
    }, {
      "left" : "boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);",
      "right" : "boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);",
      "info" : "VariableDeclarationStatement[10858-11089]:VariableDeclarationStatement[10858-11089]"
    }, {
      "left" : "for (Node c = first; c != null; c = c.getNext())",
      "right" : "for (Node c = first; c != null; c = c.getNext())",
      "info" : "ForStatement[11098-11664]:ForStatement[11098-11664]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11147-11664]:Block[11147-11664]"
    }, {
      "left" : "add(c, Context.STATEMENT);",
      "right" : "add(c, Context.STATEMENT);",
      "info" : "ExpressionStatement[11159-11185]:ExpressionStatement[11159-11185]"
    }, {
      "left" : "if (c.getType() == Token.VAR)",
      "right" : "if (c.getType() == Token.VAR)",
      "info" : "IfStatement[11268-11342]:IfStatement[11268-11342]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11298-11342]:Block[11298-11342]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[11312-11330]:ExpressionStatement[11312-11330]"
    }, {
      "left" : "if (c.getType() == Token.FUNCTION)",
      "right" : "if (c.getType() == Token.FUNCTION)",
      "info" : "IfStatement[11354-11435]:IfStatement[11354-11435]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11389-11435]:Block[11389-11435]"
    }, {
      "left" : "cc.maybeLineBreak();",
      "right" : "cc.maybeLineBreak();",
      "info" : "ExpressionStatement[11403-11423]:ExpressionStatement[11403-11423]"
    }, {
      "left" : "if (preferLineBreaks)",
      "right" : "if (preferLineBreaks)",
      "info" : "IfStatement[11578-11654]:IfStatement[11578-11654]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11600-11654]:Block[11600-11654]"
    }, {
      "left" : "cc.notePreferredLineBreak();",
      "right" : "cc.notePreferredLineBreak();",
      "info" : "ExpressionStatement[11614-11642]:ExpressionStatement[11614-11642]"
    }, {
      "left" : "if (preserveBlock)",
      "right" : "if (preserveBlock)",
      "info" : "IfStatement[11673-11782]:IfStatement[11673-11782]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11692-11782]:Block[11692-11782]"
    }, {
      "left" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "right" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "info" : "ExpressionStatement[11704-11772]:ExpressionStatement[11704-11772]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[11791-11797]:BreakStatement[11791-11797]"
    }, {
      "left" : "case Token.FOR:",
      "right" : "case Token.FOR:",
      "info" : "SwitchCase[11813-11828]:SwitchCase[11813-11828]"
    }, {
      "left" : "if (childCount == 4)",
      "right" : "if (childCount == 4)",
      "info" : "IfStatement[11837-12606]:IfStatement[11837-12606]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11858-12316]:Block[11858-12316]"
    }, {
      "left" : "add(\"for(\");",
      "right" : "add(\"for(\");",
      "info" : "ExpressionStatement[11870-11882]:ExpressionStatement[11870-11882]"
    }, {
      "left" : "if (first.getType() == Token.VAR)",
      "right" : "if (first.getType() == Token.VAR)",
      "info" : "IfStatement[11893-12070]:IfStatement[11893-12070]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11927-11992]:Block[11927-11992]"
    }, {
      "left" : "add(first, Context.IN_FOR_INIT_CLAUSE);",
      "right" : "add(first, Context.IN_FOR_INIT_CLAUSE);",
      "info" : "ExpressionStatement[11941-11980]:ExpressionStatement[11941-11980]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11998-12070]:Block[11998-12070]"
    }, {
      "left" : "addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);",
      "right" : "addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);",
      "info" : "ExpressionStatement[12012-12058]:ExpressionStatement[12012-12058]"
    }, {
      "left" : "add(\";\");",
      "right" : "add(\";\");",
      "info" : "ExpressionStatement[12081-12090]:ExpressionStatement[12081-12090]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[12101-12122]:ExpressionStatement[12101-12122]"
    }, {
      "left" : "add(\";\");",
      "right" : "add(\";\");",
      "info" : "ExpressionStatement[12133-12142]:ExpressionStatement[12133-12142]"
    }, {
      "left" : "add(first.getNext().getNext());",
      "right" : "add(first.getNext().getNext());",
      "info" : "ExpressionStatement[12153-12184]:ExpressionStatement[12153-12184]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[12195-12204]:ExpressionStatement[12195-12204]"
    }, {
      "left" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[12215-12306]:ExpressionStatement[12215-12306]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12322-12606]:Block[12322-12606]"
    }, {
      "left" : "Preconditions.checkState(childCount == 3);",
      "right" : "Preconditions.checkState(childCount == 3);",
      "info" : "ExpressionStatement[12334-12376]:ExpressionStatement[12334-12376]"
    }, {
      "left" : "add(\"for(\");",
      "right" : "add(\"for(\");",
      "info" : "ExpressionStatement[12387-12399]:ExpressionStatement[12387-12399]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[12410-12421]:ExpressionStatement[12410-12421]"
    }, {
      "left" : "add(\"in\");",
      "right" : "add(\"in\");",
      "info" : "ExpressionStatement[12432-12442]:ExpressionStatement[12432-12442]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[12453-12474]:ExpressionStatement[12453-12474]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[12485-12494]:ExpressionStatement[12485-12494]"
    }, {
      "left" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[12505-12596]:ExpressionStatement[12505-12596]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[12615-12621]:BreakStatement[12615-12621]"
    }, {
      "left" : "case Token.DO:",
      "right" : "case Token.DO:",
      "info" : "SwitchCase[12629-12643]:SwitchCase[12629-12643]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[12652-12694]:ExpressionStatement[12652-12694]"
    }, {
      "left" : "add(\"do\");",
      "right" : "add(\"do\");",
      "info" : "ExpressionStatement[12703-12713]:ExpressionStatement[12703-12713]"
    }, {
      "left" : "addNonEmptyStatement(first, Context.OTHER, false);",
      "right" : "addNonEmptyStatement(first, Context.OTHER, false);",
      "info" : "ExpressionStatement[12722-12772]:ExpressionStatement[12722-12772]"
    }, {
      "left" : "add(\"while(\");",
      "right" : "add(\"while(\");",
      "info" : "ExpressionStatement[12781-12795]:ExpressionStatement[12781-12795]"
    }, {
      "left" : "add(last);",
      "right" : "add(last);",
      "info" : "ExpressionStatement[12804-12814]:ExpressionStatement[12804-12814]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[12823-12832]:ExpressionStatement[12823-12832]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[12841-12859]:ExpressionStatement[12841-12859]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[12868-12874]:BreakStatement[12868-12874]"
    }, {
      "left" : "case Token.WHILE:",
      "right" : "case Token.WHILE:",
      "info" : "SwitchCase[12882-12899]:SwitchCase[12882-12899]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[12908-12950]:ExpressionStatement[12908-12950]"
    }, {
      "left" : "add(\"while(\");",
      "right" : "add(\"while(\");",
      "info" : "ExpressionStatement[12959-12973]:ExpressionStatement[12959-12973]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[12982-12993]:ExpressionStatement[12982-12993]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[13002-13011]:ExpressionStatement[13002-13011]"
    }, {
      "left" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[13020-13109]:ExpressionStatement[13020-13109]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[13118-13124]:BreakStatement[13118-13124]"
    }, {
      "left" : "case Token.EMPTY:",
      "right" : "case Token.EMPTY:",
      "info" : "SwitchCase[13132-13149]:SwitchCase[13132-13149]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[13158-13200]:ExpressionStatement[13158-13200]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[13209-13215]:BreakStatement[13209-13215]"
    }, {
      "left" : "case Token.GETPROP:",
      "right" : "case Token.GETPROP:",
      "info" : "SwitchCase[13223-13242]:SwitchCase[13223-13242]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13243-13833]:Block[13243-13833]"
    }, {
      "left" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);",
      "right" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);",
      "info" : "ExpressionStatement[13253-13380]:ExpressionStatement[13253-13380]"
    }, {
      "left" : "Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");",
      "right" : "Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");",
      "info" : "ExpressionStatement[13389-13508]:ExpressionStatement[13389-13508]"
    }, {
      "left" : "boolean needsParens = (first.getType() == Token.NUMBER);",
      "right" : "boolean needsParens = (first.getType() == Token.NUMBER);",
      "info" : "VariableDeclarationStatement[13517-13573]:VariableDeclarationStatement[13517-13573]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[13582-13630]:IfStatement[13582-13630]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13599-13630]:Block[13599-13630]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[13611-13620]:ExpressionStatement[13611-13620]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[13639-13694]:ExpressionStatement[13639-13694]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[13703-13751]:IfStatement[13703-13751]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13720-13751]:Block[13720-13751]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[13732-13741]:ExpressionStatement[13732-13741]"
    }, {
      "left" : "add(\".\");",
      "right" : "add(\".\");",
      "info" : "ExpressionStatement[13760-13769]:ExpressionStatement[13760-13769]"
    }, {
      "left" : "addIdentifier(last.getString());",
      "right" : "addIdentifier(last.getString());",
      "info" : "ExpressionStatement[13778-13810]:ExpressionStatement[13778-13810]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[13819-13825]:BreakStatement[13819-13825]"
    }, {
      "left" : "case Token.GETELEM:",
      "right" : "case Token.GETELEM:",
      "info" : "SwitchCase[13841-13860]:SwitchCase[13841-13860]"
    }, {
      "left" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);",
      "right" : "Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);",
      "info" : "ExpressionStatement[13869-13995]:ExpressionStatement[13869-13995]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[14004-14059]:ExpressionStatement[14004-14059]"
    }, {
      "left" : "add(\"[\");",
      "right" : "add(\"[\");",
      "info" : "ExpressionStatement[14068-14077]:ExpressionStatement[14068-14077]"
    }, {
      "left" : "add(first.getNext());",
      "right" : "add(first.getNext());",
      "info" : "ExpressionStatement[14086-14107]:ExpressionStatement[14086-14107]"
    }, {
      "left" : "add(\"]\");",
      "right" : "add(\"]\");",
      "info" : "ExpressionStatement[14116-14125]:ExpressionStatement[14116-14125]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[14134-14140]:BreakStatement[14134-14140]"
    }, {
      "left" : "case Token.WITH:",
      "right" : "case Token.WITH:",
      "info" : "SwitchCase[14148-14164]:SwitchCase[14148-14164]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[14173-14215]:ExpressionStatement[14173-14215]"
    }, {
      "left" : "add(\"with(\");",
      "right" : "add(\"with(\");",
      "info" : "ExpressionStatement[14224-14237]:ExpressionStatement[14224-14237]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[14246-14257]:ExpressionStatement[14246-14257]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[14266-14275]:ExpressionStatement[14266-14275]"
    }, {
      "left" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[14284-14373]:ExpressionStatement[14284-14373]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[14382-14388]:BreakStatement[14382-14388]"
    }, {
      "left" : "case Token.INC:",
      "right" : "case Token.INC:",
      "info" : "SwitchCase[14396-14411]:SwitchCase[14396-14411]"
    }, {
      "left" : "case Token.DEC:",
      "right" : "case Token.DEC:",
      "info" : "SwitchCase[14418-14433]:SwitchCase[14418-14433]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14434-14931]:Block[14434-14931]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[14444-14486]:ExpressionStatement[14444-14486]"
    }, {
      "left" : "String o = type == Token.INC ? \"++\" : \"--\";",
      "right" : "String o = type == Token.INC ? \"++\" : \"--\";",
      "info" : "VariableDeclarationStatement[14495-14538]:VariableDeclarationStatement[14495-14538]"
    }, {
      "left" : "int postProp = n.getIntProp(Node.INCRDECR_PROP);",
      "right" : "int postProp = n.getIntProp(Node.INCRDECR_PROP);",
      "info" : "VariableDeclarationStatement[14547-14595]:VariableDeclarationStatement[14547-14595]"
    }, {
      "left" : "if (postProp != 0)",
      "right" : "if (postProp != 0)",
      "info" : "IfStatement[14713-14908]:IfStatement[14713-14908]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14732-14839]:Block[14732-14839]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[14744-14799]:ExpressionStatement[14744-14799]"
    }, {
      "left" : "cc.addOp(o, false);",
      "right" : "cc.addOp(o, false);",
      "info" : "ExpressionStatement[14810-14829]:ExpressionStatement[14810-14829]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14845-14908]:Block[14845-14908]"
    }, {
      "left" : "cc.addOp(o, false);",
      "right" : "cc.addOp(o, false);",
      "info" : "ExpressionStatement[14857-14876]:ExpressionStatement[14857-14876]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[14887-14898]:ExpressionStatement[14887-14898]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[14917-14923]:BreakStatement[14917-14923]"
    }, {
      "left" : "case Token.CALL:",
      "right" : "case Token.CALL:",
      "info" : "SwitchCase[14939-14955]:SwitchCase[14939-14955]"
    }, {
      "left" : "if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))",
      "right" : "if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))",
      "info" : "IfStatement[15540-15836]:IfStatement[15540-15836]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15640-15753]:Block[15640-15753]"
    }, {
      "left" : "add(\"(0,\");",
      "right" : "add(\"(0,\");",
      "info" : "ExpressionStatement[15652-15663]:ExpressionStatement[15652-15663]"
    }, {
      "left" : "addExpr(first, NodeUtil.precedence(Token.COMMA));",
      "right" : "addExpr(first, NodeUtil.precedence(Token.COMMA));",
      "info" : "ExpressionStatement[15674-15723]:ExpressionStatement[15674-15723]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[15734-15743]:ExpressionStatement[15734-15743]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15759-15836]:Block[15759-15836]"
    }, {
      "left" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "right" : "addLeftExpr(first, NodeUtil.precedence(type), context);",
      "info" : "ExpressionStatement[15771-15826]:ExpressionStatement[15771-15826]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[15845-15854]:ExpressionStatement[15845-15854]"
    }, {
      "left" : "addList(first.getNext());",
      "right" : "addList(first.getNext());",
      "info" : "ExpressionStatement[15863-15888]:ExpressionStatement[15863-15888]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[15897-15906]:ExpressionStatement[15897-15906]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[15915-15921]:BreakStatement[15915-15921]"
    }, {
      "left" : "case Token.IF:",
      "right" : "case Token.IF:",
      "info" : "SwitchCase[15929-15943]:SwitchCase[15929-15943]"
    }, {
      "left" : "boolean hasElse = childCount == 3;",
      "right" : "boolean hasElse = childCount == 3;",
      "info" : "VariableDeclarationStatement[15952-15986]:VariableDeclarationStatement[15952-15986]"
    }, {
      "left" : "boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;",
      "right" : "boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;",
      "info" : "VariableDeclarationStatement[15995-16089]:VariableDeclarationStatement[15995-16089]"
    }, {
      "left" : "if (ambiguousElseClause)",
      "right" : "if (ambiguousElseClause)",
      "info" : "IfStatement[16098-16161]:IfStatement[16098-16161]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16123-16161]:Block[16123-16161]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[16135-16151]:ExpressionStatement[16135-16151]"
    }, {
      "left" : "add(\"if(\");",
      "right" : "add(\"if(\");",
      "info" : "ExpressionStatement[16171-16182]:ExpressionStatement[16171-16182]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[16191-16202]:ExpressionStatement[16191-16202]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[16211-16220]:ExpressionStatement[16211-16220]"
    }, {
      "left" : "if (hasElse)",
      "right" : "if (hasElse)",
      "info" : "IfStatement[16230-16621]:IfStatement[16230-16621]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16243-16480]:Block[16243-16480]"
    }, {
      "left" : "addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);",
      "right" : "addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);",
      "info" : "ExpressionStatement[16255-16345]:ExpressionStatement[16255-16345]"
    }, {
      "left" : "add(\"else\");",
      "right" : "add(\"else\");",
      "info" : "ExpressionStatement[16356-16368]:ExpressionStatement[16356-16368]"
    }, {
      "left" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "right" : "addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);",
      "info" : "ExpressionStatement[16379-16470]:ExpressionStatement[16379-16470]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16486-16621]:Block[16486-16621]"
    }, {
      "left" : "addNonEmptyStatement(first.getNext(), Context.OTHER, false);",
      "right" : "addNonEmptyStatement(first.getNext(), Context.OTHER, false);",
      "info" : "ExpressionStatement[16498-16558]:ExpressionStatement[16498-16558]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[16569-16611]:ExpressionStatement[16569-16611]"
    }, {
      "left" : "if (ambiguousElseClause)",
      "right" : "if (ambiguousElseClause)",
      "info" : "IfStatement[16631-16692]:IfStatement[16631-16692]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16656-16692]:Block[16656-16692]"
    }, {
      "left" : "cc.endBlock();",
      "right" : "cc.endBlock();",
      "info" : "ExpressionStatement[16668-16682]:ExpressionStatement[16668-16682]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16701-16707]:BreakStatement[16701-16707]"
    }, {
      "left" : "case Token.NULL:",
      "right" : "case Token.NULL:",
      "info" : "SwitchCase[16715-16731]:SwitchCase[16715-16731]"
    }, {
      "left" : "case Token.THIS:",
      "right" : "case Token.THIS:",
      "info" : "SwitchCase[16738-16754]:SwitchCase[16738-16754]"
    }, {
      "left" : "case Token.FALSE:",
      "right" : "case Token.FALSE:",
      "info" : "SwitchCase[16761-16778]:SwitchCase[16761-16778]"
    }, {
      "left" : "case Token.TRUE:",
      "right" : "case Token.TRUE:",
      "info" : "SwitchCase[16785-16801]:SwitchCase[16785-16801]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[16810-16852]:ExpressionStatement[16810-16852]"
    }, {
      "left" : "add(Node.tokenToName(type));",
      "right" : "add(Node.tokenToName(type));",
      "info" : "ExpressionStatement[16861-16889]:ExpressionStatement[16861-16889]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16898-16904]:BreakStatement[16898-16904]"
    }, {
      "left" : "case Token.CONTINUE:",
      "right" : "case Token.CONTINUE:",
      "info" : "SwitchCase[16912-16932]:SwitchCase[16912-16932]"
    }, {
      "left" : "Preconditions.checkState(childCount <= 1);",
      "right" : "Preconditions.checkState(childCount <= 1);",
      "info" : "ExpressionStatement[16941-16983]:ExpressionStatement[16941-16983]"
    }, {
      "left" : "add(\"continue\");",
      "right" : "add(\"continue\");",
      "info" : "ExpressionStatement[16992-17008]:ExpressionStatement[16992-17008]"
    }, {
      "left" : "if (childCount == 1)",
      "right" : "if (childCount == 1)",
      "info" : "IfStatement[17017-17233]:IfStatement[17017-17233]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17038-17233]:Block[17038-17233]"
    }, {
      "left" : "if (first.getType() != Token.LABEL_NAME)",
      "right" : "if (first.getType() != Token.LABEL_NAME)",
      "info" : "IfStatement[17050-17181]:IfStatement[17050-17181]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17091-17181]:Block[17091-17181]"
    }, {
      "left" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "right" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "info" : "ThrowStatement[17105-17169]:ThrowStatement[17105-17169]"
    }, {
      "left" : "add(\" \");",
      "right" : "add(\" \");",
      "info" : "ExpressionStatement[17192-17201]:ExpressionStatement[17192-17201]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[17212-17223]:ExpressionStatement[17212-17223]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[17242-17260]:ExpressionStatement[17242-17260]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17269-17275]:BreakStatement[17269-17275]"
    }, {
      "left" : "case Token.DEBUGGER:",
      "right" : "case Token.DEBUGGER:",
      "info" : "SwitchCase[17283-17303]:SwitchCase[17283-17303]"
    }, {
      "left" : "Preconditions.checkState(childCount == 0);",
      "right" : "Preconditions.checkState(childCount == 0);",
      "info" : "ExpressionStatement[17312-17354]:ExpressionStatement[17312-17354]"
    }, {
      "left" : "add(\"debugger\");",
      "right" : "add(\"debugger\");",
      "info" : "ExpressionStatement[17363-17379]:ExpressionStatement[17363-17379]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[17388-17406]:ExpressionStatement[17388-17406]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17415-17421]:BreakStatement[17415-17421]"
    }, {
      "left" : "case Token.BREAK:",
      "right" : "case Token.BREAK:",
      "info" : "SwitchCase[17429-17446]:SwitchCase[17429-17446]"
    }, {
      "left" : "Preconditions.checkState(childCount <= 1);",
      "right" : "Preconditions.checkState(childCount <= 1);",
      "info" : "ExpressionStatement[17455-17497]:ExpressionStatement[17455-17497]"
    }, {
      "left" : "add(\"break\");",
      "right" : "add(\"break\");",
      "info" : "ExpressionStatement[17506-17519]:ExpressionStatement[17506-17519]"
    }, {
      "left" : "if (childCount == 1)",
      "right" : "if (childCount == 1)",
      "info" : "IfStatement[17528-17744]:IfStatement[17528-17744]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17549-17744]:Block[17549-17744]"
    }, {
      "left" : "if (first.getType() != Token.LABEL_NAME)",
      "right" : "if (first.getType() != Token.LABEL_NAME)",
      "info" : "IfStatement[17561-17692]:IfStatement[17561-17692]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17602-17692]:Block[17602-17692]"
    }, {
      "left" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "right" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "info" : "ThrowStatement[17616-17680]:ThrowStatement[17616-17680]"
    }, {
      "left" : "add(\" \");",
      "right" : "add(\" \");",
      "info" : "ExpressionStatement[17703-17712]:ExpressionStatement[17703-17712]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[17723-17734]:ExpressionStatement[17723-17734]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[17753-17771]:ExpressionStatement[17753-17771]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17780-17786]:BreakStatement[17780-17786]"
    }, {
      "left" : "case Token.EXPR_VOID:",
      "right" : "case Token.EXPR_VOID:",
      "info" : "SwitchCase[17794-17815]:SwitchCase[17794-17815]"
    }, {
      "left" : "throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");",
      "right" : "throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");",
      "info" : "ThrowStatement[17824-17888]:ThrowStatement[17824-17888]"
    }, {
      "left" : "case Token.EXPR_RESULT:",
      "right" : "case Token.EXPR_RESULT:",
      "info" : "SwitchCase[17896-17919]:SwitchCase[17896-17919]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[17928-17970]:ExpressionStatement[17928-17970]"
    }, {
      "left" : "add(first, Context.START_OF_EXPR);",
      "right" : "add(first, Context.START_OF_EXPR);",
      "info" : "ExpressionStatement[17979-18013]:ExpressionStatement[17979-18013]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[18022-18040]:ExpressionStatement[18022-18040]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[18049-18055]:BreakStatement[18049-18055]"
    }, {
      "left" : "case Token.NEW:",
      "right" : "case Token.NEW:",
      "info" : "SwitchCase[18063-18078]:SwitchCase[18063-18078]"
    }, {
      "left" : "add(\"new \");",
      "right" : "add(\"new \");",
      "info" : "ExpressionStatement[18087-18099]:ExpressionStatement[18087-18099]"
    }, {
      "left" : "int precedence = NodeUtil.precedence(type);",
      "right" : "int precedence = NodeUtil.precedence(type);",
      "info" : "VariableDeclarationStatement[18108-18151]:VariableDeclarationStatement[18108-18151]"
    }, {
      "left" : "if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction()))",
      "right" : "if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction()))",
      "info" : "IfStatement[18384-18530]:IfStatement[18384-18530]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18454-18530]:Block[18454-18530]"
    }, {
      "left" : "precedence = NodeUtil.precedence(first.getType()) + 1;",
      "right" : "precedence = NodeUtil.precedence(first.getType()) + 1;",
      "info" : "ExpressionStatement[18466-18520]:ExpressionStatement[18466-18520]"
    }, {
      "left" : "addExpr(first, precedence);",
      "right" : "addExpr(first, precedence);",
      "info" : "ExpressionStatement[18539-18566]:ExpressionStatement[18539-18566]"
    }, {
      "left" : "Node next = first.getNext();",
      "right" : "Node next = first.getNext();",
      "info" : "VariableDeclarationStatement[18634-18662]:VariableDeclarationStatement[18634-18662]"
    }, {
      "left" : "if (next != null)",
      "right" : "if (next != null)",
      "info" : "IfStatement[18671-18765]:IfStatement[18671-18765]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18689-18765]:Block[18689-18765]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[18701-18710]:ExpressionStatement[18701-18710]"
    }, {
      "left" : "addList(next);",
      "right" : "addList(next);",
      "info" : "ExpressionStatement[18721-18735]:ExpressionStatement[18721-18735]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[18746-18755]:ExpressionStatement[18746-18755]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[18774-18780]:BreakStatement[18774-18780]"
    }, {
      "left" : "case Token.STRING:",
      "right" : "case Token.STRING:",
      "info" : "SwitchCase[18788-18806]:SwitchCase[18788-18806]"
    }, {
      "left" : "if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0))",
      "right" : "if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0))",
      "info" : "IfStatement[18815-19072]:IfStatement[18815-19072]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18940-19072]:Block[18940-19072]"
    }, {
      "left" : "throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());",
      "right" : "throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());",
      "info" : "ThrowStatement[18952-19062]:ThrowStatement[18952-19062]"
    }, {
      "left" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "right" : "add(jsString(n.getString(), outputCharsetEncoder));",
      "info" : "ExpressionStatement[19081-19132]:ExpressionStatement[19081-19132]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[19141-19147]:BreakStatement[19141-19147]"
    }, {
      "left" : "case Token.DELPROP:",
      "right" : "case Token.DELPROP:",
      "info" : "SwitchCase[19155-19174]:SwitchCase[19155-19174]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[19183-19225]:ExpressionStatement[19183-19225]"
    }, {
      "left" : "add(\"delete \");",
      "right" : "add(\"delete \");",
      "info" : "ExpressionStatement[19234-19249]:ExpressionStatement[19234-19249]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[19258-19269]:ExpressionStatement[19258-19269]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[19278-19284]:BreakStatement[19278-19284]"
    }, {
      "left" : "case Token.OBJECTLIT:",
      "right" : "case Token.OBJECTLIT:",
      "info" : "SwitchCase[19292-19313]:SwitchCase[19292-19313]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19314-20711]:Block[19314-20711]"
    }, {
      "left" : "boolean needsParens = (context == Context.START_OF_EXPR);",
      "right" : "boolean needsParens = (context == Context.START_OF_EXPR);",
      "info" : "VariableDeclarationStatement[19324-19381]:VariableDeclarationStatement[19324-19381]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[19390-19438]:IfStatement[19390-19438]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19407-19438]:Block[19407-19438]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[19419-19428]:ExpressionStatement[19419-19428]"
    }, {
      "left" : "add(\"{\");",
      "right" : "add(\"{\");",
      "info" : "ExpressionStatement[19447-19456]:ExpressionStatement[19447-19456]"
    }, {
      "left" : "for (Node c = first; c != null; c = c.getNext())",
      "right" : "for (Node c = first; c != null; c = c.getNext())",
      "info" : "ForStatement[19465-20613]:ForStatement[19465-20613]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19514-20613]:Block[19514-20613]"
    }, {
      "left" : "if (c != first)",
      "right" : "if (c != first)",
      "info" : "IfStatement[19526-19587]:IfStatement[19526-19587]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19542-19587]:Block[19542-19587]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[19556-19575]:ExpressionStatement[19556-19575]"
    }, {
      "left" : "if (c.getType() == Token.GET || c.getType() == Token.SET)",
      "right" : "if (c.getType() == Token.GET || c.getType() == Token.SET)",
      "info" : "IfStatement[19599-20603]:IfStatement[19599-20603]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19657-19690]:Block[19657-19690]"
    }, {
      "left" : "add(c);",
      "right" : "add(c);",
      "info" : "ExpressionStatement[19671-19678]:ExpressionStatement[19671-19678]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19696-20603]:Block[19696-20603]"
    }, {
      "left" : "Preconditions.checkState(c.getType() == Token.STRING);",
      "right" : "Preconditions.checkState(c.getType() == Token.STRING);",
      "info" : "ExpressionStatement[19710-19764]:ExpressionStatement[19710-19764]"
    }, {
      "left" : "String key = c.getString();",
      "right" : "String key = c.getString();",
      "info" : "VariableDeclarationStatement[19777-19804]:VariableDeclarationStatement[19777-19804]"
    }, {
      "left" : "if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key))",
      "right" : "if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key))",
      "info" : "IfStatement[19937-20526]:IfStatement[19937-20526]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20217-20256]:Block[20217-20256]"
    }, {
      "left" : "add(key);",
      "right" : "add(key);",
      "info" : "ExpressionStatement[20233-20242]:ExpressionStatement[20233-20242]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20262-20526]:Block[20262-20526]"
    }, {
      "left" : "double d = getSimpleNumber(key);",
      "right" : "double d = getSimpleNumber(key);",
      "info" : "VariableDeclarationStatement[20339-20371]:VariableDeclarationStatement[20339-20371]"
    }, {
      "left" : "if (!Double.isNaN(d))",
      "right" : "if (!Double.isNaN(d))",
      "info" : "IfStatement[20386-20512]:IfStatement[20386-20512]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20408-20458]:Block[20408-20458]"
    }, {
      "left" : "cc.addNumber(d);",
      "right" : "cc.addNumber(d);",
      "info" : "ExpressionStatement[20426-20442]:ExpressionStatement[20426-20442]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20464-20512]:Block[20464-20512]"
    }, {
      "left" : "addExpr(c, 1);",
      "right" : "addExpr(c, 1);",
      "info" : "ExpressionStatement[20482-20496]:ExpressionStatement[20482-20496]"
    }, {
      "left" : "add(\":\");",
      "right" : "add(\":\");",
      "info" : "ExpressionStatement[20539-20548]:ExpressionStatement[20539-20548]"
    }, {
      "left" : "addExpr(c.getFirstChild(), 1);",
      "right" : "addExpr(c.getFirstChild(), 1);",
      "info" : "ExpressionStatement[20561-20591]:ExpressionStatement[20561-20591]"
    }, {
      "left" : "add(\"}\");",
      "right" : "add(\"}\");",
      "info" : "ExpressionStatement[20622-20631]:ExpressionStatement[20622-20631]"
    }, {
      "left" : "if (needsParens)",
      "right" : "if (needsParens)",
      "info" : "IfStatement[20640-20688]:IfStatement[20640-20688]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20657-20688]:Block[20657-20688]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[20669-20678]:ExpressionStatement[20669-20678]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[20697-20703]:BreakStatement[20697-20703]"
    }, {
      "left" : "case Token.SWITCH:",
      "right" : "case Token.SWITCH:",
      "info" : "SwitchCase[20719-20737]:SwitchCase[20719-20737]"
    }, {
      "left" : "add(\"switch(\");",
      "right" : "add(\"switch(\");",
      "info" : "ExpressionStatement[20746-20761]:ExpressionStatement[20746-20761]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[20770-20781]:ExpressionStatement[20770-20781]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[20790-20799]:ExpressionStatement[20790-20799]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[20808-20824]:ExpressionStatement[20808-20824]"
    }, {
      "left" : "addAllSiblings(first.getNext());",
      "right" : "addAllSiblings(first.getNext());",
      "info" : "ExpressionStatement[20833-20865]:ExpressionStatement[20833-20865]"
    }, {
      "left" : "cc.endBlock(context == Context.STATEMENT);",
      "right" : "cc.endBlock(context == Context.STATEMENT);",
      "info" : "ExpressionStatement[20874-20916]:ExpressionStatement[20874-20916]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[20925-20931]:BreakStatement[20925-20931]"
    }, {
      "left" : "case Token.CASE:",
      "right" : "case Token.CASE:",
      "info" : "SwitchCase[20939-20955]:SwitchCase[20939-20955]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[20964-21006]:ExpressionStatement[20964-21006]"
    }, {
      "left" : "add(\"case \");",
      "right" : "add(\"case \");",
      "info" : "ExpressionStatement[21015-21028]:ExpressionStatement[21015-21028]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[21037-21048]:ExpressionStatement[21037-21048]"
    }, {
      "left" : "addCaseBody(last);",
      "right" : "addCaseBody(last);",
      "info" : "ExpressionStatement[21057-21075]:ExpressionStatement[21057-21075]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[21084-21090]:BreakStatement[21084-21090]"
    }, {
      "left" : "case Token.DEFAULT:",
      "right" : "case Token.DEFAULT:",
      "info" : "SwitchCase[21098-21117]:SwitchCase[21098-21117]"
    }, {
      "left" : "Preconditions.checkState(childCount == 1);",
      "right" : "Preconditions.checkState(childCount == 1);",
      "info" : "ExpressionStatement[21126-21168]:ExpressionStatement[21126-21168]"
    }, {
      "left" : "add(\"default\");",
      "right" : "add(\"default\");",
      "info" : "ExpressionStatement[21177-21192]:ExpressionStatement[21177-21192]"
    }, {
      "left" : "addCaseBody(first);",
      "right" : "addCaseBody(first);",
      "info" : "ExpressionStatement[21201-21220]:ExpressionStatement[21201-21220]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[21229-21235]:BreakStatement[21229-21235]"
    }, {
      "left" : "case Token.LABEL:",
      "right" : "case Token.LABEL:",
      "info" : "SwitchCase[21243-21260]:SwitchCase[21243-21260]"
    }, {
      "left" : "Preconditions.checkState(childCount == 2);",
      "right" : "Preconditions.checkState(childCount == 2);",
      "info" : "ExpressionStatement[21269-21311]:ExpressionStatement[21269-21311]"
    }, {
      "left" : "if (first.getType() != Token.LABEL_NAME)",
      "right" : "if (first.getType() != Token.LABEL_NAME)",
      "info" : "IfStatement[21320-21447]:IfStatement[21320-21447]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21361-21447]:Block[21361-21447]"
    }, {
      "left" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "right" : "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");",
      "info" : "ThrowStatement[21373-21437]:ThrowStatement[21373-21437]"
    }, {
      "left" : "add(first);",
      "right" : "add(first);",
      "info" : "ExpressionStatement[21456-21467]:ExpressionStatement[21456-21467]"
    }, {
      "left" : "add(\":\");",
      "right" : "add(\":\");",
      "info" : "ExpressionStatement[21476-21485]:ExpressionStatement[21476-21485]"
    }, {
      "left" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);",
      "right" : "addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);",
      "info" : "ExpressionStatement[21494-21582]:ExpressionStatement[21494-21582]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[21591-21597]:BreakStatement[21591-21597]"
    }, {
      "left" : "case Token.SETNAME:",
      "right" : "case Token.SETNAME:",
      "info" : "SwitchCase[21720-21739]:SwitchCase[21720-21739]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[21748-21754]:BreakStatement[21748-21754]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[21762-21770]:SwitchCase[21762-21770]"
    }, {
      "left" : "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());",
      "right" : "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());",
      "info" : "ThrowStatement[21779-21845]:ThrowStatement[21779-21845]"
    }, {
      "left" : "cc.endSourceMapping(n);",
      "right" : "cc.endSourceMapping(n);",
      "info" : "ExpressionStatement[21857-21880]:ExpressionStatement[21857-21880]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21928-22127]:Block[21928-22127]"
    }, {
      "left" : "int len = s.length();",
      "right" : "int len = s.length();",
      "info" : "VariableDeclarationStatement[21934-21955]:VariableDeclarationStatement[21934-21955]"
    }, {
      "left" : "for (int index = 0; index < len; index++)",
      "right" : "for (int index = 0; index < len; index++)",
      "info" : "ForStatement[21960-22103]:ForStatement[21960-22103]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22002-22103]:Block[22002-22103]"
    }, {
      "left" : "char c = s.charAt(index);",
      "right" : "char c = s.charAt(index);",
      "info" : "VariableDeclarationStatement[22010-22035]:VariableDeclarationStatement[22010-22035]"
    }, {
      "left" : "if (c < '0' || c > '9')",
      "right" : "if (c < '0' || c > '9')",
      "info" : "IfStatement[22042-22097]:IfStatement[22042-22097]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22066-22097]:Block[22066-22097]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[22076-22089]:ReturnStatement[22076-22089]"
    }, {
      "left" : "return len > 0;",
      "right" : "return len > 0;",
      "info" : "ReturnStatement[22108-22123]:ReturnStatement[22108-22123]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22171-22348]:Block[22171-22348]"
    }, {
      "left" : "if (isSimpleNumber(s))",
      "right" : "if (isSimpleNumber(s))",
      "info" : "IfStatement[22177-22321]:IfStatement[22177-22321]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22200-22321]:Block[22200-22321]"
    }, {
      "left" : "long l = Long.parseLong(s);",
      "right" : "long l = Long.parseLong(s);",
      "info" : "VariableDeclarationStatement[22208-22235]:VariableDeclarationStatement[22208-22235]"
    }, {
      "left" : "if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER)",
      "right" : "if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER)",
      "info" : "IfStatement[22242-22315]:IfStatement[22242-22315]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22288-22315]:Block[22288-22315]"
    }, {
      "left" : "return l;",
      "right" : "return l;",
      "info" : "ReturnStatement[22298-22307]:ReturnStatement[22298-22307]"
    }, {
      "left" : "return Double.NaN;",
      "right" : "return Double.NaN;",
      "info" : "ReturnStatement[22326-22344]:ReturnStatement[22326-22344]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22454-22576]:Block[22454-22576]"
    }, {
      "left" : "return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);",
      "right" : "return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);",
      "info" : "ReturnStatement[22460-22572]:ReturnStatement[22460-22572]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22947-24736]:Block[22947-24736]"
    }, {
      "left" : "Node nodeToProcess = n;",
      "right" : "Node nodeToProcess = n;",
      "info" : "VariableDeclarationStatement[22953-22976]:VariableDeclarationStatement[22953-22976]"
    }, {
      "left" : "if (!allowNonBlockChild && n.getType() != Token.BLOCK)",
      "right" : "if (!allowNonBlockChild && n.getType() != Token.BLOCK)",
      "info" : "IfStatement[22982-23091]:IfStatement[22982-23091]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23037-23091]:Block[23037-23091]"
    }, {
      "left" : "throw new Error(\"Missing BLOCK child.\");",
      "right" : "throw new Error(\"Missing BLOCK child.\");",
      "info" : "ThrowStatement[23045-23085]:ThrowStatement[23045-23085]"
    }, {
      "left" : "if (n.getType() == Token.BLOCK)",
      "right" : "if (n.getType() == Token.BLOCK)",
      "info" : "IfStatement[23222-24363]:IfStatement[23222-24363]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23254-24363]:Block[23254-24363]"
    }, {
      "left" : "int count = getNonEmptyChildCount(n, 2);",
      "right" : "int count = getNonEmptyChildCount(n, 2);",
      "info" : "VariableDeclarationStatement[23262-23302]:VariableDeclarationStatement[23262-23302]"
    }, {
      "left" : "if (count == 0)",
      "right" : "if (count == 0)",
      "info" : "IfStatement[23309-23562]:IfStatement[23309-23562]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23325-23562]:Block[23325-23562]"
    }, {
      "left" : "if (cc.shouldPreserveExtraBlocks())",
      "right" : "if (cc.shouldPreserveExtraBlocks())",
      "info" : "IfStatement[23335-23538]:IfStatement[23335-23538]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23371-23488]:Block[23371-23488]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[23383-23399]:ExpressionStatement[23383-23399]"
    }, {
      "left" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "right" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "info" : "ExpressionStatement[23410-23478]:ExpressionStatement[23410-23478]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23494-23538]:Block[23494-23538]"
    }, {
      "left" : "cc.endStatement(true);",
      "right" : "cc.endStatement(true);",
      "info" : "ExpressionStatement[23506-23528]:ExpressionStatement[23506-23528]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[23547-23554]:ReturnStatement[23547-23554]"
    }, {
      "left" : "if (count == 1)",
      "right" : "if (count == 1)",
      "info" : "IfStatement[23570-24283]:IfStatement[23570-24283]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23586-24283]:Block[23586-24283]"
    }, {
      "left" : "Node firstAndOnlyChild = getFirstNonEmptyChild(n);",
      "right" : "Node firstAndOnlyChild = getFirstNonEmptyChild(n);",
      "info" : "VariableDeclarationStatement[23754-23804]:VariableDeclarationStatement[23754-23804]"
    }, {
      "left" : "boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();",
      "right" : "boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();",
      "info" : "VariableDeclarationStatement[23813-23872]:VariableDeclarationStatement[23813-23872]"
    }, {
      "left" : "if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild))",
      "right" : "if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild))",
      "info" : "IfStatement[23881-24275]:IfStatement[23881-24275]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23951-24170]:Block[23951-24170]"
    }, {
      "left" : "cc.beginBlock();",
      "right" : "cc.beginBlock();",
      "info" : "ExpressionStatement[23963-23979]:ExpressionStatement[23963-23979]"
    }, {
      "left" : "add(firstAndOnlyChild, Context.STATEMENT);",
      "right" : "add(firstAndOnlyChild, Context.STATEMENT);",
      "info" : "ExpressionStatement[23990-24032]:ExpressionStatement[23990-24032]"
    }, {
      "left" : "cc.maybeLineBreak();",
      "right" : "cc.maybeLineBreak();",
      "info" : "ExpressionStatement[24043-24063]:ExpressionStatement[24043-24063]"
    }, {
      "left" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "right" : "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));",
      "info" : "ExpressionStatement[24074-24142]:ExpressionStatement[24074-24142]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[24153-24160]:ReturnStatement[24153-24160]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24176-24275]:Block[24176-24275]"
    }, {
      "left" : "nodeToProcess = firstAndOnlyChild;",
      "right" : "nodeToProcess = firstAndOnlyChild;",
      "info" : "ExpressionStatement[24231-24265]:ExpressionStatement[24231-24265]"
    }, {
      "left" : "if (count > 1)",
      "right" : "if (count > 1)",
      "info" : "IfStatement[24291-24357]:IfStatement[24291-24357]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24306-24357]:Block[24306-24357]"
    }, {
      "left" : "context = Context.PRESERVE_BLOCK;",
      "right" : "context = Context.PRESERVE_BLOCK;",
      "info" : "ExpressionStatement[24316-24349]:ExpressionStatement[24316-24349]"
    }, {
      "left" : "if (nodeToProcess.getType() == Token.EMPTY)",
      "right" : "if (nodeToProcess.getType() == Token.EMPTY)",
      "info" : "IfStatement[24369-24732]:IfStatement[24369-24732]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24413-24449]:Block[24413-24449]"
    }, {
      "left" : "cc.endStatement(true);",
      "right" : "cc.endStatement(true);",
      "info" : "ExpressionStatement[24421-24443]:ExpressionStatement[24421-24443]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24455-24732]:Block[24455-24732]"
    }, {
      "left" : "add(nodeToProcess, context);",
      "right" : "add(nodeToProcess, context);",
      "info" : "ExpressionStatement[24463-24491]:ExpressionStatement[24463-24491]"
    }, {
      "left" : "if (nodeToProcess.getType() == Token.VAR)",
      "right" : "if (nodeToProcess.getType() == Token.VAR)",
      "info" : "IfStatement[24648-24726]:IfStatement[24648-24726]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24690-24726]:Block[24690-24726]"
    }, {
      "left" : "cc.endStatement();",
      "right" : "cc.endStatement();",
      "info" : "ExpressionStatement[24700-24718]:ExpressionStatement[24700-24718]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24882-25655]:Block[24882-25655]"
    }, {
      "left" : "if (n.getType() == Token.LABEL)",
      "right" : "if (n.getType() == Token.LABEL)",
      "info" : "IfStatement[24888-25651]:IfStatement[24888-25651]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24920-25565]:Block[24920-25565]"
    }, {
      "left" : "Node labeledStatement = n.getLastChild();",
      "right" : "Node labeledStatement = n.getLastChild();",
      "info" : "VariableDeclarationStatement[24928-24969]:VariableDeclarationStatement[24928-24969]"
    }, {
      "left" : "if (labeledStatement.getType() != Token.BLOCK)",
      "right" : "if (labeledStatement.getType() != Token.BLOCK)",
      "info" : "IfStatement[24976-25559]:IfStatement[24976-25559]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25023-25091]:Block[25023-25091]"
    }, {
      "left" : "return isOneExactlyFunctionOrDo(labeledStatement);",
      "right" : "return isOneExactlyFunctionOrDo(labeledStatement);",
      "info" : "ReturnStatement[25033-25083]:ReturnStatement[25033-25083]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25097-25559]:Block[25097-25559]"
    }, {
      "left" : "if (getNonEmptyChildCount(n, 2) == 1)",
      "right" : "if (getNonEmptyChildCount(n, 2) == 1)",
      "info" : "IfStatement[25272-25551]:IfStatement[25272-25551]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25310-25390]:Block[25310-25390]"
    }, {
      "left" : "return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));",
      "right" : "return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));",
      "info" : "ReturnStatement[25322-25380]:ReturnStatement[25322-25380]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25396-25551]:Block[25396-25551]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[25528-25541]:ReturnStatement[25528-25541]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25571-25651]:Block[25571-25651]"
    }, {
      "left" : "return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);",
      "right" : "return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);",
      "info" : "ReturnStatement[25579-25645]:ReturnStatement[25579-25645]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26154-26199]:Block[26154-26199]"
    }, {
      "left" : "addExpr(n, minPrecedence, context);",
      "right" : "addExpr(n, minPrecedence, context);",
      "info" : "ExpressionStatement[26160-26195]:ExpressionStatement[26160-26195]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26243-26294]:Block[26243-26294]"
    }, {
      "left" : "addExpr(n, minPrecedence, Context.OTHER);",
      "right" : "addExpr(n, minPrecedence, Context.OTHER);",
      "info" : "ExpressionStatement[26249-26290]:ExpressionStatement[26249-26290]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26363-26645]:Block[26363-26645]"
    }, {
      "left" : "if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\n        (n.getType() == Token.IN)))",
      "right" : "if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\n        (n.getType() == Token.IN)))",
      "info" : "IfStatement[26369-26641]:IfStatement[26369-26641]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26514-26605]:Block[26514-26605]"
    }, {
      "left" : "add(\"(\");",
      "right" : "add(\"(\");",
      "info" : "ExpressionStatement[26522-26531]:ExpressionStatement[26522-26531]"
    }, {
      "left" : "add(n, clearContextForNoInOperator(context));",
      "right" : "add(n, clearContextForNoInOperator(context));",
      "info" : "ExpressionStatement[26538-26583]:ExpressionStatement[26538-26583]"
    }, {
      "left" : "add(\")\");",
      "right" : "add(\")\");",
      "info" : "ExpressionStatement[26590-26599]:ExpressionStatement[26590-26599]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26611-26641]:Block[26611-26641]"
    }, {
      "left" : "add(n, context);",
      "right" : "add(n, context);",
      "info" : "ExpressionStatement[26619-26635]:ExpressionStatement[26619-26635]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26680-26732]:Block[26680-26732]"
    }, {
      "left" : "addList(firstInList, true, Context.OTHER);",
      "right" : "addList(firstInList, true, Context.OTHER);",
      "info" : "ExpressionStatement[26686-26728]:ExpressionStatement[26686-26728]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26802-26875]:Block[26802-26875]"
    }, {
      "left" : "addList(firstInList, isArrayOrFunctionArgument, Context.OTHER);",
      "right" : "addList(firstInList, isArrayOrFunctionArgument, Context.OTHER);",
      "info" : "ExpressionStatement[26808-26871]:ExpressionStatement[26808-26871]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26980-27292]:Block[26980-27292]"
    }, {
      "left" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "right" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "info" : "ForStatement[26986-27288]:ForStatement[26986-27288]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27041-27288]:Block[27041-27288]"
    }, {
      "left" : "boolean isFirst = n == firstInList;",
      "right" : "boolean isFirst = n == firstInList;",
      "info" : "VariableDeclarationStatement[27049-27084]:VariableDeclarationStatement[27049-27084]"
    }, {
      "left" : "if (isFirst)",
      "right" : "if (isFirst)",
      "info" : "IfStatement[27091-27282]:IfStatement[27091-27282]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27104-27184]:Block[27104-27184]"
    }, {
      "left" : "addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);",
      "right" : "addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);",
      "info" : "ExpressionStatement[27114-27176]:ExpressionStatement[27114-27176]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27190-27282]:Block[27190-27282]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[27200-27219]:ExpressionStatement[27200-27219]"
    }, {
      "left" : "addExpr(n, isArrayOrFunctionArgument ? 1 : 0);",
      "right" : "addExpr(n, isArrayOrFunctionArgument ? 1 : 0);",
      "info" : "ExpressionStatement[27228-27274]:ExpressionStatement[27228-27274]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27683-27982]:Block[27683-27982]"
    }, {
      "left" : "boolean lastWasEmpty = false;",
      "right" : "boolean lastWasEmpty = false;",
      "info" : "VariableDeclarationStatement[27689-27718]:VariableDeclarationStatement[27689-27718]"
    }, {
      "left" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "right" : "for (Node n = firstInList; n != null; n = n.getNext())",
      "info" : "ForStatement[27723-27921]:ForStatement[27723-27921]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27778-27921]:Block[27778-27921]"
    }, {
      "left" : "if (n != firstInList)",
      "right" : "if (n != firstInList)",
      "info" : "IfStatement[27786-27845]:IfStatement[27786-27845]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27808-27845]:Block[27808-27845]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[27818-27837]:ExpressionStatement[27818-27837]"
    }, {
      "left" : "addExpr(n, 1);",
      "right" : "addExpr(n, 1);",
      "info" : "ExpressionStatement[27852-27866]:ExpressionStatement[27852-27866]"
    }, {
      "left" : "lastWasEmpty = n.getType() == Token.EMPTY;",
      "right" : "lastWasEmpty = n.getType() == Token.EMPTY;",
      "info" : "ExpressionStatement[27873-27915]:ExpressionStatement[27873-27915]"
    }, {
      "left" : "if (lastWasEmpty)",
      "right" : "if (lastWasEmpty)",
      "info" : "IfStatement[27927-27978]:IfStatement[27927-27978]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27945-27978]:Block[27945-27978]"
    }, {
      "left" : "cc.listSeparator();",
      "right" : "cc.listSeparator();",
      "info" : "ExpressionStatement[27953-27972]:ExpressionStatement[27953-27972]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28018-28088]:Block[28018-28088]"
    }, {
      "left" : "cc.beginCaseBody();",
      "right" : "cc.beginCaseBody();",
      "info" : "ExpressionStatement[28024-28043]:ExpressionStatement[28024-28043]"
    }, {
      "left" : "add(caseBody);",
      "right" : "add(caseBody);",
      "info" : "ExpressionStatement[28048-28062]:ExpressionStatement[28048-28062]"
    }, {
      "left" : "cc.endCaseBody();",
      "right" : "cc.endCaseBody();",
      "info" : "ExpressionStatement[28067-28084]:ExpressionStatement[28067-28084]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28120-28196]:Block[28120-28196]"
    }, {
      "left" : "for (Node c = n; c != null; c = c.getNext())",
      "right" : "for (Node c = n; c != null; c = c.getNext())",
      "info" : "ForStatement[28126-28192]:ForStatement[28126-28192]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28171-28192]:Block[28171-28192]"
    }, {
      "left" : "add(c);",
      "right" : "add(c);",
      "info" : "ExpressionStatement[28179-28186]:ExpressionStatement[28179-28186]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28350-29069]:Block[28350-29069]"
    }, {
      "left" : "int singleq = 0, doubleq = 0;",
      "right" : "int singleq = 0, doubleq = 0;",
      "info" : "VariableDeclarationStatement[28356-28385]:VariableDeclarationStatement[28356-28385]"
    }, {
      "left" : "for (int i = 0; i < s.length(); i++)",
      "right" : "for (int i = 0; i < s.length(); i++)",
      "info" : "ForStatement[28458-28612]:ForStatement[28458-28612]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28495-28612]:Block[28495-28612]"
    }, {
      "left" : "switch (s.charAt(i)) {\n        case '\"': doubleq++; break;\n        case '\\'': singleq++; break;\n      }",
      "right" : "switch (s.charAt(i)) {\n        case '\"': doubleq++; break;\n        case '\\'': singleq++; break;\n      }",
      "info" : "SwitchStatement[28503-28606]:SwitchStatement[28503-28606]"
    }, {
      "left" : "case '\"':",
      "right" : "case '\"':",
      "info" : "SwitchCase[28534-28543]:SwitchCase[28534-28543]"
    }, {
      "left" : "doubleq++;",
      "right" : "doubleq++;",
      "info" : "ExpressionStatement[28544-28554]:ExpressionStatement[28544-28554]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[28555-28561]:BreakStatement[28555-28561]"
    }, {
      "left" : "case '\\'':",
      "right" : "case '\\'':",
      "info" : "SwitchCase[28570-28580]:SwitchCase[28570-28580]"
    }, {
      "left" : "singleq++;",
      "right" : "singleq++;",
      "info" : "ExpressionStatement[28581-28591]:ExpressionStatement[28581-28591]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[28592-28598]:BreakStatement[28592-28598]"
    }, {
      "left" : "String doublequote, singlequote;",
      "right" : "String doublequote, singlequote;",
      "info" : "VariableDeclarationStatement[28618-28650]:VariableDeclarationStatement[28618-28650]"
    }, {
      "left" : "char quote;",
      "right" : "char quote;",
      "info" : "VariableDeclarationStatement[28655-28666]:VariableDeclarationStatement[28655-28666]"
    }, {
      "left" : "if (singleq < doubleq)",
      "right" : "if (singleq < doubleq)",
      "info" : "IfStatement[28671-28968]:IfStatement[28671-28968]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28694-28831]:Block[28694-28831]"
    }, {
      "left" : "quote = '\\'';",
      "right" : "quote = '\\'';",
      "info" : "ExpressionStatement[28758-28771]:ExpressionStatement[28758-28771]"
    }, {
      "left" : "doublequote = \"\\\"\";",
      "right" : "doublequote = \"\\\"\";",
      "info" : "ExpressionStatement[28778-28797]:ExpressionStatement[28778-28797]"
    }, {
      "left" : "singlequote = \"\\\\\\'\";",
      "right" : "singlequote = \"\\\\\\'\";",
      "info" : "ExpressionStatement[28804-28825]:ExpressionStatement[28804-28825]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28837-28968]:Block[28837-28968]"
    }, {
      "left" : "quote = '\\\"';",
      "right" : "quote = '\\\"';",
      "info" : "ExpressionStatement[28895-28908]:ExpressionStatement[28895-28908]"
    }, {
      "left" : "doublequote = \"\\\\\\\"\";",
      "right" : "doublequote = \"\\\\\\\"\";",
      "info" : "ExpressionStatement[28915-28936]:ExpressionStatement[28915-28936]"
    }, {
      "left" : "singlequote = \"\\'\";",
      "right" : "singlequote = \"\\'\";",
      "info" : "ExpressionStatement[28943-28962]:ExpressionStatement[28943-28962]"
    }, {
      "left" : "return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n        outputCharsetEncoder);",
      "right" : "return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n        outputCharsetEncoder);",
      "info" : "ReturnStatement[28974-29065]:ReturnStatement[28974-29065]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29183-29257]:Block[29183-29257]"
    }, {
      "left" : "return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);",
      "right" : "return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);",
      "info" : "ReturnStatement[29189-29253]:ReturnStatement[29189-29253]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29402-29466]:Block[29402-29466]"
    }, {
      "left" : "return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);",
      "right" : "return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);",
      "info" : "ReturnStatement[29408-29462]:ReturnStatement[29408-29462]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29632-29671]:Block[29632-29671]"
    }, {
      "left" : "return regexpEscape(s, null);",
      "right" : "return regexpEscape(s, null);",
      "info" : "ReturnStatement[29638-29667]:ReturnStatement[29638-29667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32585-33234]:Block[32584-33233]"
    }, {
      "left" : "if (NodeUtil.isLatin(s))",
      "right" : "if (NodeUtil.isLatin(s))",
      "info" : "IfStatement[32666-32714]:IfStatement[32665-32713]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32691-32714]:Block[32690-32713]"
    }, {
      "left" : "return s;",
      "right" : "return s;",
      "info" : "ReturnStatement[32699-32708]:ReturnStatement[32698-32707]"
    }, {
      "left" : "StringBuilder sb = new StringBuilder();",
      "right" : "StringBuilder sb = new StringBuilder();",
      "info" : "VariableDeclarationStatement[32798-32837]:VariableDeclarationStatement[32797-32836]"
    }, {
      "left" : "for (int i = 0; i < s.length(); i++)",
      "right" : "for (int i = 0; i < s.length(); i++)",
      "info" : "ForStatement[32842-33204]:ForStatement[32841-33203]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32879-33204]:Block[32878-33203]"
    }, {
      "left" : "char c = s.charAt(i);",
      "right" : "char c = s.charAt(i);",
      "info" : "VariableDeclarationStatement[32887-32908]:VariableDeclarationStatement[32886-32907]"
    }, {
      "left" : "if (c > 0x1F && c < 0x7F)",
      "right" : "if (c > 0x1F && c < 0x7F)",
      "info" : "IfStatement[33076-33198]:IfStatement[33075-33197]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33102-33133]:Block[33101-33132]"
    }, {
      "left" : "sb.append(c);",
      "right" : "sb.append(c);",
      "info" : "ExpressionStatement[33112-33125]:ExpressionStatement[33111-33124]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33139-33198]:Block[33138-33197]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(sb, c);",
      "right" : "appendHexJavaScriptRepresentation(sb, c);",
      "info" : "ExpressionStatement[33149-33190]:ExpressionStatement[33148-33189]"
    }, {
      "left" : "return sb.toString();",
      "right" : "return sb.toString();",
      "info" : "ReturnStatement[33209-33230]:ReturnStatement[33208-33229]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33466-33754]:Block[33465-33753]"
    }, {
      "left" : "int i = 0;",
      "right" : "int i = 0;",
      "info" : "VariableDeclarationStatement[33472-33482]:VariableDeclarationStatement[33471-33481]"
    }, {
      "left" : "Node c = n.getFirstChild();",
      "right" : "Node c = n.getFirstChild();",
      "info" : "VariableDeclarationStatement[33487-33514]:VariableDeclarationStatement[33486-33513]"
    }, {
      "left" : "for (; c != null && i < maxCount; c = c.getNext())",
      "right" : "for (; c != null && i < maxCount; c = c.getNext())",
      "info" : "ForStatement[33519-33736]:ForStatement[33518-33735]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33570-33736]:Block[33569-33735]"
    }, {
      "left" : "if (c.getType() == Token.BLOCK)",
      "right" : "if (c.getType() == Token.BLOCK)",
      "info" : "IfStatement[33578-33730]:IfStatement[33577-33729]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33610-33670]:Block[33609-33669]"
    }, {
      "left" : "i += getNonEmptyChildCount(c, maxCount-i);",
      "right" : "i += getNonEmptyChildCount(c, maxCount-i);",
      "info" : "ExpressionStatement[33620-33662]:ExpressionStatement[33619-33661]"
    }, {
      "left" : "if (c.getType() != Token.EMPTY)",
      "right" : "if (c.getType() != Token.EMPTY)",
      "info" : "IfStatement[33676-33730]:IfStatement[33675-33729]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33708-33730]:Block[33707-33729]"
    }, {
      "left" : "i++;",
      "right" : "i++;",
      "info" : "ExpressionStatement[33718-33722]:ExpressionStatement[33717-33721]"
    }, {
      "left" : "return i;",
      "right" : "return i;",
      "info" : "ReturnStatement[33741-33750]:ReturnStatement[33740-33749]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33867-34188]:Block[33866-34187]"
    }, {
      "left" : "for (Node c = n.getFirstChild(); c != null; c = c.getNext())",
      "right" : "for (Node c = n.getFirstChild(); c != null; c = c.getNext())",
      "info" : "ForStatement[33873-34167]:ForStatement[33872-34166]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33934-34167]:Block[33933-34166]"
    }, {
      "left" : "if (c.getType() == Token.BLOCK)",
      "right" : "if (c.getType() == Token.BLOCK)",
      "info" : "IfStatement[33942-34161]:IfStatement[33941-34160]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33974-34096]:Block[33973-34095]"
    }, {
      "left" : "Node result = getFirstNonEmptyChild(c);",
      "right" : "Node result = getFirstNonEmptyChild(c);",
      "info" : "VariableDeclarationStatement[33984-34023]:VariableDeclarationStatement[33983-34022]"
    }, {
      "left" : "if (result != null)",
      "right" : "if (result != null)",
      "info" : "IfStatement[34032-34088]:IfStatement[34031-34087]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34052-34088]:Block[34051-34087]"
    }, {
      "left" : "return result;",
      "right" : "return result;",
      "info" : "ReturnStatement[34064-34078]:ReturnStatement[34063-34077]"
    }, {
      "left" : "if (c.getType() != Token.EMPTY)",
      "right" : "if (c.getType() != Token.EMPTY)",
      "info" : "IfStatement[34102-34161]:IfStatement[34101-34160]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34134-34161]:Block[34133-34160]"
    }, {
      "left" : "return c;",
      "right" : "return c;",
      "info" : "ReturnStatement[34144-34153]:ReturnStatement[34143-34152]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[34172-34184]:ReturnStatement[34171-34183]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34871-34990]:Block[34870-34989]"
    }, {
      "left" : "return currentContext == Context.BEFORE_DANGLING_ELSE ?\n        Context.BEFORE_DANGLING_ELSE : Context.OTHER;",
      "right" : "return currentContext == Context.BEFORE_DANGLING_ELSE ?\n        Context.BEFORE_DANGLING_ELSE : Context.OTHER;",
      "info" : "ReturnStatement[34877-34986]:ReturnStatement[34876-34985]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35219-35329]:Block[35218-35328]"
    }, {
      "left" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);",
      "right" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);",
      "info" : "ReturnStatement[35225-35325]:ReturnStatement[35224-35324]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35679-35770]:Block[35678-35769]"
    }, {
      "left" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.OTHER : context);",
      "right" : "return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.OTHER : context);",
      "info" : "ReturnStatement[35685-35766]:ReturnStatement[35684-35765]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35935-36124]:Block[35934-36123]"
    }, {
      "left" : "try{...}",
      "right" : "try{...}",
      "info" : "TryStatement[35941-36120]:TryStatement[35940-36119]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35945-36000]:Block[35944-35999]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(c, sb);",
      "right" : "appendHexJavaScriptRepresentation(c, sb);",
      "info" : "ExpressionStatement[35953-35994]:ExpressionStatement[35952-35993]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36024-36120]:Block[36023-36119]"
    }, {
      "left" : "throw new RuntimeException(ex);",
      "right" : "throw new RuntimeException(ex);",
      "info" : "ThrowStatement[36083-36114]:ThrowStatement[36082-36113]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36476-37214]:Block[36475-37213]"
    }, {
      "left" : "if (Character.isSupplementaryCodePoint(codePoint))",
      "right" : "if (Character.isSupplementaryCodePoint(codePoint))",
      "info" : "IfStatement[36482-36986]:IfStatement[36481-36985]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36533-36986]:Block[36532-36985]"
    }, {
      "left" : "char[] surrogates = Character.toChars(codePoint);",
      "right" : "char[] surrogates = Character.toChars(codePoint);",
      "info" : "VariableDeclarationStatement[36795-36844]:VariableDeclarationStatement[36794-36843]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(surrogates[0], out);",
      "right" : "appendHexJavaScriptRepresentation(surrogates[0], out);",
      "info" : "ExpressionStatement[36851-36905]:ExpressionStatement[36850-36904]"
    }, {
      "left" : "appendHexJavaScriptRepresentation(surrogates[1], out);",
      "right" : "appendHexJavaScriptRepresentation(surrogates[1], out);",
      "info" : "ExpressionStatement[36912-36966]:ExpressionStatement[36911-36965]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[36973-36980]:ReturnStatement[36972-36979]"
    }, {
      "left" : "out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);",
      "right" : "out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);",
      "info" : "ExpressionStatement[36991-37210]:ExpressionStatement[36990-37209]"
    } ]
  },
  "interFileMappings" : { }
}