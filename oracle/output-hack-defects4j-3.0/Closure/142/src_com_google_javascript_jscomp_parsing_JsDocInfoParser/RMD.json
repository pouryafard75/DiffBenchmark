{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "JsDocInfoParser",
      "right" : "JsDocInfoParser",
      "info" : "TypeDeclaration[1370-63565]:TypeDeclaration[1370-63683]"
    }, {
      "left" : "private final JsDocTokenStream stream;",
      "right" : "private final JsDocTokenStream stream;",
      "info" : "FieldDeclaration[1577-1615]:FieldDeclaration[1577-1615]"
    }, {
      "left" : "private final JSTypeRegistry typeRegistry;",
      "right" : "private final JSTypeRegistry typeRegistry;",
      "info" : "FieldDeclaration[1618-1660]:FieldDeclaration[1618-1660]"
    }, {
      "left" : "private final JSDocInfoBuilder jsdocBuilder;",
      "right" : "private final JSDocInfoBuilder jsdocBuilder;",
      "info" : "FieldDeclaration[1663-1707]:FieldDeclaration[1663-1707]"
    }, {
      "left" : "private final String sourceName;",
      "right" : "private final String sourceName;",
      "info" : "FieldDeclaration[1710-1742]:FieldDeclaration[1710-1742]"
    }, {
      "left" : "private final ErrorReporter errorReporter;",
      "right" : "private final ErrorReporter errorReporter;",
      "info" : "FieldDeclaration[1745-1787]:FieldDeclaration[1745-1787]"
    }, {
      "left" : "private final ErrorReporterParser parser = new ErrorReporterParser();",
      "right" : "private final ErrorReporterParser parser = new ErrorReporterParser();",
      "info" : "FieldDeclaration[1790-1859]:FieldDeclaration[1790-1859]"
    }, {
      "left" : "ErrorReporterParser",
      "right" : "ErrorReporterParser",
      "info" : "TypeDeclaration[1863-2315]:TypeDeclaration[1863-2315]"
    }, {
      "left" : "void addWarning(String messageId, String messageArg, int lineno,\n                    int charno)",
      "right" : "void addWarning(String messageId, String messageArg, int lineno,\n                    int charno)",
      "info" : "MethodDeclaration[1903-2130]:MethodDeclaration[1903-2130]"
    }, {
      "left" : "void addWarning(String messageId, int lineno, int charno)",
      "right" : "void addWarning(String messageId, int lineno, int charno)",
      "info" : "MethodDeclaration[2135-2311]:MethodDeclaration[2135-2311]"
    }, {
      "left" : "private JSDocInfo fileOverviewJSDocInfo = null;",
      "right" : "private JSDocInfo fileOverviewJSDocInfo = null;",
      "info" : "FieldDeclaration[2382-2429]:FieldDeclaration[2382-2429]"
    }, {
      "left" : "private State state;",
      "right" : "private State state;",
      "info" : "FieldDeclaration[2432-2452]:FieldDeclaration[2432-2452]"
    }, {
      "left" : "private final Map<String, Annotation> annotationNames;",
      "right" : "private final Map<String, Annotation> annotationNames;",
      "info" : "FieldDeclaration[2456-2510]:FieldDeclaration[2456-2510]"
    }, {
      "left" : "private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;",
      "right" : "private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;",
      "info" : "FieldDeclaration[2514-2571]:FieldDeclaration[2514-2571]"
    }, {
      "left" : "void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder)",
      "right" : "void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder)",
      "info" : "MethodDeclaration[2575-2953]:MethodDeclaration[2575-2953]"
    }, {
      "left" : "void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo)",
      "right" : "void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo)",
      "info" : "MethodDeclaration[2957-3210]:MethodDeclaration[2957-3210]"
    }, {
      "left" : "enum : State",
      "right" : "enum : State",
      "info" : "EnumDeclaration[3214-3310]:EnumDeclaration[3214-3310]"
    }, {
      "left" : "JsDocInfoParser(JsDocTokenStream stream,\n                  String sourceName,\n                  Config config,\n                  ErrorReporter errorReporter)",
      "right" : "JsDocInfoParser(JsDocTokenStream stream,\n                  String sourceName,\n                  Config config,\n                  ErrorReporter errorReporter)",
      "info" : "MethodDeclaration[3314-3748]:MethodDeclaration[3314-3748]"
    }, {
      "left" : "public static Node parseTypeString(String typeString)",
      "right" : "public static Node parseTypeString(String typeString)",
      "info" : "MethodDeclaration[3752-4340]:MethodDeclaration[3752-4340]"
    }, {
      "left" : "boolean parse()",
      "right" : "boolean parse()",
      "info" : "MethodDeclaration[4344-29836]:MethodDeclaration[4344-29836]"
    }, {
      "left" : "private JsDocToken parseSuppressTag(JsDocToken token)",
      "right" : "private JsDocToken parseSuppressTag(JsDocToken token)",
      "info" : "MethodDeclaration[29840-30946]:MethodDeclaration[29840-30946]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token)",
      "info" : "MethodDeclaration[30950-31308]:MethodDeclaration[30950-31308]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC)",
      "info" : "MethodDeclaration[31312-31803]:MethodDeclaration[31312-31803]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n      int startCharno)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n      int startCharno)",
      "info" : "MethodDeclaration[31807-32368]:MethodDeclaration[31807-32368]"
    }, {
      "left" : "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC)",
      "right" : "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC)",
      "info" : "MethodDeclaration[32372-33042]:MethodDeclaration[32372-33042]"
    }, {
      "left" : "private Node parseAndRecordParamTypeNode(JsDocToken token)",
      "right" : "private Node parseAndRecordParamTypeNode(JsDocToken token)",
      "info" : "MethodDeclaration[33046-33915]:MethodDeclaration[33046-33915]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames)",
      "info" : "MethodDeclaration[33919-35239]:MethodDeclaration[33919-35239]"
    }, {
      "left" : "// TODO(nicksantos): Move this into a check pass.\n  private boolean isValidDefineType(Node typeNode)",
      "right" : "// TODO(nicksantos): Move this into a check pass.\n  private boolean isValidDefineType(Node typeNode)",
      "info" : "MethodDeclaration[35243-35630]:MethodDeclaration[35243-35630]"
    }, {
      "left" : "private String toString(JsDocToken token)",
      "right" : "private String toString(JsDocToken token)",
      "info" : "MethodDeclaration[35634-36576]:MethodDeclaration[35634-36576]"
    }, {
      "left" : "private JSTypeExpression createJSTypeExpression(Node n)",
      "right" : "private JSTypeExpression createJSTypeExpression(Node n)",
      "info" : "MethodDeclaration[36580-36825]:MethodDeclaration[36580-36825]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "TypeDeclaration[36829-37328]:TypeDeclaration[36829-37328]"
    }, {
      "left" : "private final String string;",
      "right" : "private final String string;",
      "info" : "FieldDeclaration[37016-37044]:FieldDeclaration[37016-37044]"
    }, {
      "left" : "private final JsDocToken token;",
      "right" : "private final JsDocToken token;",
      "info" : "FieldDeclaration[37049-37080]:FieldDeclaration[37049-37080]"
    }, {
      "left" : "public ExtractionInfo(String string, JsDocToken token)",
      "right" : "public ExtractionInfo(String string, JsDocToken token)",
      "info" : "MethodDeclaration[37086-37202]:MethodDeclaration[37086-37202]"
    }, {
      "left" : "public String getString()",
      "right" : "public String getString()",
      "info" : "MethodDeclaration[37208-37262]:MethodDeclaration[37208-37262]"
    }, {
      "left" : "public JsDocToken getToken()",
      "right" : "public JsDocToken getToken()",
      "info" : "MethodDeclaration[37268-37324]:MethodDeclaration[37268-37324]"
    }, {
      "left" : "private ExtractionInfo extractSingleLineBlock()",
      "right" : "private ExtractionInfo extractSingleLineBlock()",
      "info" : "MethodDeclaration[37332-38067]:MethodDeclaration[37332-38067]"
    }, {
      "left" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token)",
      "right" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token)",
      "info" : "MethodDeclaration[38071-38224]:MethodDeclaration[38071-38224]"
    }, {
      "left" : "enum : WhitespaceOption",
      "right" : "enum : WhitespaceOption",
      "info" : "EnumDeclaration[38228-38554]:EnumDeclaration[38228-38554]"
    }, {
      "left" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option)",
      "right" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option)",
      "info" : "MethodDeclaration[38558-41546]:MethodDeclaration[38558-41664]"
    }, {
      "left" : "private ExtractionInfo extractBlockComment(JsDocToken token)",
      "right" : "private ExtractionInfo extractBlockComment(JsDocToken token)",
      "info" : "MethodDeclaration[41551-43048]:MethodDeclaration[41669-43166]"
    }, {
      "left" : "private static String trimEnd(String s)",
      "right" : "private static String trimEnd(String s)",
      "info" : "MethodDeclaration[43052-43814]:MethodDeclaration[43170-43932]"
    }, {
      "left" : "private Node parseTypeExpressionAnnotation(JsDocToken token)",
      "right" : "private Node parseTypeExpressionAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[44234-44796]:MethodDeclaration[44352-44914]"
    }, {
      "left" : "private Node parseParamTypeExpressionAnnotation(JsDocToken token)",
      "right" : "private Node parseParamTypeExpressionAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[44800-45986]:MethodDeclaration[44918-46104]"
    }, {
      "left" : "private Node parseTypeNameAnnotation(JsDocToken token)",
      "right" : "private Node parseTypeNameAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[45990-46491]:MethodDeclaration[46108-46609]"
    }, {
      "left" : "private Node parseTopLevelTypeExpression(JsDocToken token)",
      "right" : "private Node parseTopLevelTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[46495-47153]:MethodDeclaration[46613-47271]"
    }, {
      "left" : "private Node parseTypeExpressionList(JsDocToken token)",
      "right" : "private Node parseTypeExpressionList(JsDocToken token)",
      "info" : "MethodDeclaration[47157-47778]:MethodDeclaration[47275-47896]"
    }, {
      "left" : "private Node parseTypeExpression(JsDocToken token)",
      "right" : "private Node parseTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[47782-48642]:MethodDeclaration[47900-48760]"
    }, {
      "left" : "private Node parseBasicTypeExpression(JsDocToken token)",
      "right" : "private Node parseBasicTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[48646-49615]:MethodDeclaration[48764-49733]"
    }, {
      "left" : "private Node parseTypeName(JsDocToken token)",
      "right" : "private Node parseTypeName(JsDocToken token)",
      "info" : "MethodDeclaration[49619-50387]:MethodDeclaration[49737-50505]"
    }, {
      "left" : "private Node parseFunctionType(JsDocToken token)",
      "right" : "private Node parseFunctionType(JsDocToken token)",
      "info" : "MethodDeclaration[50391-52191]:MethodDeclaration[50509-52309]"
    }, {
      "left" : "// NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token)",
      "right" : "// NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token)",
      "info" : "MethodDeclaration[52195-55282]:MethodDeclaration[52313-55400]"
    }, {
      "left" : "private Node parseResultType(JsDocToken token)",
      "right" : "private Node parseResultType(JsDocToken token)",
      "info" : "MethodDeclaration[55286-55721]:MethodDeclaration[55404-55839]"
    }, {
      "left" : "private Node parseUnionType(JsDocToken token)",
      "right" : "private Node parseUnionType(JsDocToken token)",
      "info" : "MethodDeclaration[55725-55999]:MethodDeclaration[55843-56117]"
    }, {
      "left" : "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate)",
      "right" : "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate)",
      "info" : "MethodDeclaration[56003-57201]:MethodDeclaration[56121-57319]"
    }, {
      "left" : "private Node parseArrayType(JsDocToken token)",
      "right" : "private Node parseArrayType(JsDocToken token)",
      "info" : "MethodDeclaration[57205-58148]:MethodDeclaration[57323-58266]"
    }, {
      "left" : "private Node parseRecordType(JsDocToken token)",
      "right" : "private Node parseRecordType(JsDocToken token)",
      "info" : "MethodDeclaration[58152-58638]:MethodDeclaration[58270-58756]"
    }, {
      "left" : "private Node parseFieldTypeList(JsDocToken token)",
      "right" : "private Node parseFieldTypeList(JsDocToken token)",
      "info" : "MethodDeclaration[58642-59242]:MethodDeclaration[58760-59360]"
    }, {
      "left" : "private Node parseFieldType(JsDocToken token)",
      "right" : "private Node parseFieldType(JsDocToken token)",
      "info" : "MethodDeclaration[59246-59953]:MethodDeclaration[59364-60071]"
    }, {
      "left" : "private Node parseFieldName(JsDocToken token)",
      "right" : "private Node parseFieldName(JsDocToken token)",
      "info" : "MethodDeclaration[59957-60276]:MethodDeclaration[60075-60394]"
    }, {
      "left" : "private Node wrapNode(int type, Node n)",
      "right" : "private Node wrapNode(int type, Node n)",
      "info" : "MethodDeclaration[60280-60422]:MethodDeclaration[60398-60540]"
    }, {
      "left" : "private Node newNode(int type)",
      "right" : "private Node newNode(int type)",
      "info" : "MethodDeclaration[60426-60529]:MethodDeclaration[60544-60647]"
    }, {
      "left" : "private Node newStringNode(String s)",
      "right" : "private Node newStringNode(String s)",
      "info" : "MethodDeclaration[60533-60645]:MethodDeclaration[60651-60763]"
    }, {
      "left" : "private Node reportTypeSyntaxWarning(String warning)",
      "right" : "private Node reportTypeSyntaxWarning(String warning)",
      "info" : "MethodDeclaration[60649-60796]:MethodDeclaration[60767-60914]"
    }, {
      "left" : "private Node reportGenericTypeSyntaxWarning()",
      "right" : "private Node reportGenericTypeSyntaxWarning()",
      "info" : "MethodDeclaration[60800-60912]:MethodDeclaration[60918-61030]"
    }, {
      "left" : "private JsDocToken eatTokensUntilEOL()",
      "right" : "private JsDocToken eatTokensUntilEOL()",
      "info" : "MethodDeclaration[60916-61138]:MethodDeclaration[61034-61256]"
    }, {
      "left" : "private JsDocToken eatTokensUntilEOL(JsDocToken token)",
      "right" : "private JsDocToken eatTokensUntilEOL(JsDocToken token)",
      "info" : "MethodDeclaration[61142-61568]:MethodDeclaration[61260-61686]"
    }, {
      "left" : "private static final JsDocToken NO_UNREAD_TOKEN = null;",
      "right" : "private static final JsDocToken NO_UNREAD_TOKEN = null;",
      "info" : "FieldDeclaration[61572-61719]:FieldDeclaration[61690-61837]"
    }, {
      "left" : "private JsDocToken unreadToken = NO_UNREAD_TOKEN;",
      "right" : "private JsDocToken unreadToken = NO_UNREAD_TOKEN;",
      "info" : "FieldDeclaration[61723-61807]:FieldDeclaration[61841-61925]"
    }, {
      "left" : "private boolean match(JsDocToken token)",
      "right" : "private boolean match(JsDocToken token)",
      "info" : "MethodDeclaration[61811-62015]:MethodDeclaration[61929-62133]"
    }, {
      "left" : "private boolean match(JsDocToken token1, JsDocToken token2)",
      "right" : "private boolean match(JsDocToken token1, JsDocToken token2)",
      "info" : "MethodDeclaration[62019-62275]:MethodDeclaration[62137-62393]"
    }, {
      "left" : "private JsDocToken next()",
      "right" : "private JsDocToken next()",
      "info" : "MethodDeclaration[62279-62551]:MethodDeclaration[62397-62669]"
    }, {
      "left" : "private JsDocToken current()",
      "right" : "private JsDocToken current()",
      "info" : "MethodDeclaration[62555-62743]:MethodDeclaration[62673-62861]"
    }, {
      "left" : "private void skipEOLs()",
      "right" : "private void skipEOLs()",
      "info" : "MethodDeclaration[62747-63032]:MethodDeclaration[62865-63150]"
    }, {
      "left" : "private boolean hasParsedFileOverviewDocInfo()",
      "right" : "private boolean hasParsedFileOverviewDocInfo()",
      "info" : "MethodDeclaration[63036-63252]:MethodDeclaration[63154-63370]"
    }, {
      "left" : "boolean hasParsedJSDocInfo()",
      "right" : "boolean hasParsedJSDocInfo()",
      "info" : "MethodDeclaration[63256-63329]:MethodDeclaration[63374-63447]"
    }, {
      "left" : "JSDocInfo retrieveAndResetParsedJSDocInfo()",
      "right" : "JSDocInfo retrieveAndResetParsedJSDocInfo()",
      "info" : "MethodDeclaration[63333-63425]:MethodDeclaration[63451-63543]"
    }, {
      "left" : "JSDocInfo getFileOverviewJSDocInfo()",
      "right" : "JSDocInfo getFileOverviewJSDocInfo()",
      "info" : "MethodDeclaration[63429-63563]:MethodDeclaration[63547-63681]"
    } ],
    "mappings" : [
 {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[1537-1543]:Modifier[1537-1543]"
    }, {
      "left" : "final",
      "right" : "final",
      "info" : "Modifier[1544-1549]:Modifier[1544-1549]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[1550-1555]:TYPE_DECLARATION_KIND[1550-1555]"
    }, {
      "left" : "JsDocInfoParser",
      "right" : "JsDocInfoParser",
      "info" : "SimpleName[1556-1571]:SimpleName[1556-1571]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[1863-1870]:Modifier[1863-1870]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[1871-1876]:TYPE_DECLARATION_KIND[1871-1876]"
    }, {
      "left" : "ErrorReporterParser",
      "right" : "ErrorReporterParser",
      "info" : "SimpleName[1877-1896]:SimpleName[1877-1896]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[1903-1907]:PrimitiveType[1903-1907]"
    }, {
      "left" : "addWarning",
      "right" : "addWarning",
      "info" : "SimpleName[1908-1918]:SimpleName[1908-1918]"
    }, {
      "left" : "String messageId",
      "right" : "String messageId",
      "info" : "SingleVariableDeclaration[1919-1935]:SingleVariableDeclaration[1919-1935]"
    }, {
      "left" : "String messageArg",
      "right" : "String messageArg",
      "info" : "SingleVariableDeclaration[1937-1954]:SingleVariableDeclaration[1937-1954]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[1956-1966]:SingleVariableDeclaration[1956-1966]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[1988-1998]:SingleVariableDeclaration[1988-1998]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2000-2130]:Block[2000-2130]"
    }, {
      "left" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          sourceName, lineno, null, charno);",
      "right" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          sourceName, lineno, null, charno);",
      "info" : "ExpressionStatement[2008-2124]:ExpressionStatement[2008-2124]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[2135-2139]:PrimitiveType[2135-2139]"
    }, {
      "left" : "addWarning",
      "right" : "addWarning",
      "info" : "SimpleName[2140-2150]:SimpleName[2140-2150]"
    }, {
      "left" : "String messageId",
      "right" : "String messageId",
      "info" : "SingleVariableDeclaration[2151-2167]:SingleVariableDeclaration[2151-2167]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[2169-2179]:SingleVariableDeclaration[2169-2179]"
    }, {
      "left" : "int charno",
      "right" : "int charno",
      "info" : "SingleVariableDeclaration[2181-2191]:SingleVariableDeclaration[2181-2191]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2193-2311]:Block[2193-2311]"
    }, {
      "left" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          sourceName, lineno, null, charno);",
      "right" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          sourceName, lineno, null, charno);",
      "info" : "ExpressionStatement[2201-2305]:ExpressionStatement[2201-2305]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[2805-2809]:PrimitiveType[2805-2809]"
    }, {
      "left" : "setFileLevelJsDocBuilder",
      "right" : "setFileLevelJsDocBuilder",
      "info" : "SimpleName[2810-2834]:SimpleName[2810-2834]"
    }, {
      "left" : "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder",
      "right" : "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder",
      "info" : "SingleVariableDeclaration[2842-2890]:SingleVariableDeclaration[2842-2890]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2892-2953]:Block[2892-2953]"
    }, {
      "left" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
      "right" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
      "info" : "ExpressionStatement[2898-2949]:ExpressionStatement[2898-2949]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[3086-3090]:PrimitiveType[3086-3090]"
    }, {
      "left" : "setFileOverviewJSDocInfo",
      "right" : "setFileOverviewJSDocInfo",
      "info" : "SimpleName[3091-3115]:SimpleName[3091-3115]"
    }, {
      "left" : "JSDocInfo fileOverviewJSDocInfo",
      "right" : "JSDocInfo fileOverviewJSDocInfo",
      "info" : "SingleVariableDeclaration[3116-3147]:SingleVariableDeclaration[3116-3147]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3149-3210]:Block[3149-3210]"
    }, {
      "left" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
      "right" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
      "info" : "ExpressionStatement[3155-3206]:ExpressionStatement[3155-3206]"
    }, {
      "left" : "JsDocInfoParser",
      "right" : "JsDocInfoParser",
      "info" : "SimpleName[3314-3329]:SimpleName[3314-3329]"
    }, {
      "left" : "JsDocTokenStream stream",
      "right" : "JsDocTokenStream stream",
      "info" : "SingleVariableDeclaration[3330-3353]:SingleVariableDeclaration[3330-3353]"
    }, {
      "left" : "String sourceName",
      "right" : "String sourceName",
      "info" : "SingleVariableDeclaration[3373-3390]:SingleVariableDeclaration[3373-3390]"
    }, {
      "left" : "Config config",
      "right" : "Config config",
      "info" : "SingleVariableDeclaration[3410-3423]:SingleVariableDeclaration[3410-3423]"
    }, {
      "left" : "ErrorReporter errorReporter",
      "right" : "ErrorReporter errorReporter",
      "info" : "SingleVariableDeclaration[3443-3470]:SingleVariableDeclaration[3443-3470]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3472-3748]:Block[3472-3748]"
    }, {
      "left" : "this.stream = stream;",
      "right" : "this.stream = stream;",
      "info" : "ExpressionStatement[3478-3499]:ExpressionStatement[3478-3499]"
    }, {
      "left" : "this.sourceName = sourceName;",
      "right" : "this.sourceName = sourceName;",
      "info" : "ExpressionStatement[3504-3533]:ExpressionStatement[3504-3533]"
    }, {
      "left" : "this.typeRegistry = config.registry;",
      "right" : "this.typeRegistry = config.registry;",
      "info" : "ExpressionStatement[3538-3574]:ExpressionStatement[3538-3574]"
    }, {
      "left" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
      "right" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
      "info" : "ExpressionStatement[3579-3652]:ExpressionStatement[3579-3652]"
    }, {
      "left" : "this.annotationNames = config.annotationNames;",
      "right" : "this.annotationNames = config.annotationNames;",
      "info" : "ExpressionStatement[3657-3703]:ExpressionStatement[3657-3703]"
    }, {
      "left" : "this.errorReporter = errorReporter;",
      "right" : "this.errorReporter = errorReporter;",
      "info" : "ExpressionStatement[3709-3744]:ExpressionStatement[3709-3744]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[3901-3907]:Modifier[3901-3907]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[3908-3914]:Modifier[3908-3914]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[3915-3919]:SimpleType[3915-3919]"
    }, {
      "left" : "parseTypeString",
      "right" : "parseTypeString",
      "info" : "SimpleName[3920-3935]:SimpleName[3920-3935]"
    }, {
      "left" : "String typeString",
      "right" : "String typeString",
      "info" : "SingleVariableDeclaration[3936-3953]:SingleVariableDeclaration[3936-3953]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3955-4340]:Block[3955-4340]"
    }, {
      "left" : "Config config = new Config(\n        new JSTypeRegistry(NullErrorReporter.forOldRhino()),\n        Sets.<String>newHashSet(),\n        false);",
      "right" : "Config config = new Config(\n        new JSTypeRegistry(NullErrorReporter.forOldRhino()),\n        Sets.<String>newHashSet(),\n        false);",
      "info" : "VariableDeclarationStatement[3961-4100]:VariableDeclarationStatement[3961-4100]"
    }, {
      "left" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        \"typeparsing\",\n        config,\n        NullErrorReporter.forNewRhino());",
      "right" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        \"typeparsing\",\n        config,\n        NullErrorReporter.forNewRhino());",
      "info" : "VariableDeclarationStatement[4105-4273]:VariableDeclarationStatement[4105-4273]"
    }, {
      "left" : "return parser.parseTopLevelTypeExpression(parser.next());",
      "right" : "return parser.parseTopLevelTypeExpression(parser.next());",
      "info" : "ReturnStatement[4279-4336]:ReturnStatement[4279-4336]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[4660-4667]:PrimitiveType[4660-4667]"
    }, {
      "left" : "parse",
      "right" : "parse",
      "info" : "SimpleName[4668-4673]:SimpleName[4668-4673]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4676-29836]:Block[4676-29836]"
    }, {
      "left" : "int lineno;",
      "right" : "int lineno;",
      "info" : "VariableDeclarationStatement[4682-4693]:VariableDeclarationStatement[4682-4693]"
    }, {
      "left" : "int charno;",
      "right" : "int charno;",
      "info" : "VariableDeclarationStatement[4698-4709]:VariableDeclarationStatement[4698-4709]"
    }, {
      "left" : "JSTypeExpression type;",
      "right" : "JSTypeExpression type;",
      "info" : "VariableDeclarationStatement[4791-4813]:VariableDeclarationStatement[4791-4813]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[4819-4854]:ExpressionStatement[4819-4854]"
    }, {
      "left" : "JsDocToken token = next();",
      "right" : "JsDocToken token = next();",
      "info" : "VariableDeclarationStatement[4859-4885]:VariableDeclarationStatement[4859-4885]"
    }, {
      "left" : "ExtractionInfo blockInfo = extractBlockComment(token);",
      "right" : "ExtractionInfo blockInfo = extractBlockComment(token);",
      "info" : "VariableDeclarationStatement[4891-4945]:VariableDeclarationStatement[4891-4945]"
    }, {
      "left" : "token = blockInfo.token;",
      "right" : "token = blockInfo.token;",
      "info" : "ExpressionStatement[4950-4974]:ExpressionStatement[4950-4974]"
    }, {
      "left" : "if (blockInfo.string.length() > 0)",
      "right" : "if (blockInfo.string.length() > 0)",
      "info" : "IfStatement[5032-5135]:IfStatement[5032-5135]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5067-5135]:Block[5067-5135]"
    }, {
      "left" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
      "right" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
      "info" : "ExpressionStatement[5075-5129]:ExpressionStatement[5075-5129]"
    }, {
      "left" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
      "right" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
      "info" : "LabeledStatement[5172-29832]:LabeledStatement[5172-29832]"
    }, {
      "left" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
      "right" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
      "info" : "ForStatement[5179-29832]:ForStatement[5179-29832]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5188-29832]:Block[5188-29832]"
    }, {
      "left" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
      "right" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
      "info" : "SwitchStatement[5196-29783]:SwitchStatement[5196-29783]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[5221-5237]:SwitchCase[5221-5237]"
    }, {
      "left" : "if (state == State.SEARCHING_ANNOTATION)",
      "right" : "if (state == State.SEARCHING_ANNOTATION)",
      "info" : "IfStatement[5248-28870]:IfStatement[5248-28870]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5289-28870]:Block[5289-28870]"
    }, {
      "left" : "state = State.SEARCHING_NEWLINE;",
      "right" : "state = State.SEARCHING_NEWLINE;",
      "info" : "ExpressionStatement[5303-5335]:ExpressionStatement[5303-5335]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[5348-5376]:ExpressionStatement[5348-5376]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[5389-5417]:ExpressionStatement[5389-5417]"
    }, {
      "left" : "String annotationName = stream.getString();",
      "right" : "String annotationName = stream.getString();",
      "info" : "VariableDeclarationStatement[5431-5474]:VariableDeclarationStatement[5431-5474]"
    }, {
      "left" : "Annotation annotation = annotationNames.get(annotationName);",
      "right" : "Annotation annotation = annotationNames.get(annotationName);",
      "info" : "VariableDeclarationStatement[5487-5547]:VariableDeclarationStatement[5487-5547]"
    }, {
      "left" : "if (annotation == null)",
      "right" : "if (annotation == null)",
      "info" : "IfStatement[5560-28858]:IfStatement[5560-28858]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5584-5727]:Block[5584-5727]"
    }, {
      "left" : "parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[5600-5713]:ExpressionStatement[5600-5713]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5733-28858]:Block[5733-28858]"
    }, {
      "left" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
      "right" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
      "info" : "ExpressionStatement[5804-5864]:ExpressionStatement[5804-5864]"
    }, {
      "left" : "switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }",
      "right" : "switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }",
      "info" : "SwitchStatement[5880-28844]:SwitchStatement[5880-28844]"
    }, {
      "left" : "case AUTHOR:",
      "right" : "case AUTHOR:",
      "info" : "SwitchCase[5918-5930]:SwitchCase[5918-5930]"
    }, {
      "left" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[5949-6002]:VariableDeclarationStatement[5949-6002]"
    }, {
      "left" : "String author = authorInfo.string;",
      "right" : "String author = authorInfo.string;",
      "info" : "VariableDeclarationStatement[6021-6055]:VariableDeclarationStatement[6021-6055]"
    }, {
      "left" : "if (author.length() == 0)",
      "right" : "if (author.length() == 0)",
      "info" : "IfStatement[6075-6333]:IfStatement[6075-6333]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6101-6254]:Block[6101-6254]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[6123-6234]:ExpressionStatement[6123-6234]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6260-6333]:Block[6260-6333]"
    }, {
      "left" : "jsdocBuilder.addAuthor(author);",
      "right" : "jsdocBuilder.addAuthor(author);",
      "info" : "ExpressionStatement[6282-6313]:ExpressionStatement[6282-6313]"
    }, {
      "left" : "token = authorInfo.token;",
      "right" : "token = authorInfo.token;",
      "info" : "ExpressionStatement[6353-6378]:ExpressionStatement[6353-6378]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[6397-6412]:ContinueStatement[6397-6412]"
    }, {
      "left" : "case CONSTANT:",
      "right" : "case CONSTANT:",
      "info" : "SwitchCase[6430-6444]:SwitchCase[6430-6444]"
    }, {
      "left" : "if (!jsdocBuilder.recordConstancy())",
      "right" : "if (!jsdocBuilder.recordConstancy())",
      "info" : "IfStatement[6463-6643]:IfStatement[6463-6643]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6500-6643]:Block[6500-6643]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[6522-6623]:ExpressionStatement[6522-6623]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[6662-6690]:ExpressionStatement[6662-6690]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[6709-6724]:ContinueStatement[6709-6724]"
    }, {
      "left" : "case CONSTRUCTOR:",
      "right" : "case CONSTRUCTOR:",
      "info" : "SwitchCase[6742-6759]:SwitchCase[6742-6759]"
    }, {
      "left" : "if (!jsdocBuilder.recordConstructor())",
      "right" : "if (!jsdocBuilder.recordConstructor())",
      "info" : "IfStatement[6778-7227]:IfStatement[6778-7227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6817-7227]:Block[6817-7227]"
    }, {
      "left" : "if (jsdocBuilder.isInterfaceRecorded())",
      "right" : "if (jsdocBuilder.isInterfaceRecorded())",
      "info" : "IfStatement[6839-7207]:IfStatement[6839-7207]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6879-7044]:Block[6879-7044]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[6903-7022]:ExpressionStatement[6903-7022]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7050-7207]:Block[7050-7207]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[7074-7185]:ExpressionStatement[7074-7185]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[7246-7274]:ExpressionStatement[7246-7274]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[7293-7308]:ContinueStatement[7293-7308]"
    }, {
      "left" : "case DEPRECATED:",
      "right" : "case DEPRECATED:",
      "info" : "SwitchCase[7326-7342]:SwitchCase[7326-7342]"
    }, {
      "left" : "if (!jsdocBuilder.recordDeprecated())",
      "right" : "if (!jsdocBuilder.recordDeprecated())",
      "info" : "IfStatement[7361-7547]:IfStatement[7361-7547]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7399-7547]:Block[7399-7547]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[7421-7527]:ExpressionStatement[7421-7527]"
    }, {
      "left" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[7625-7711]:VariableDeclarationStatement[7625-7711]"
    }, {
      "left" : "String reason = reasonInfo.string;",
      "right" : "String reason = reasonInfo.string;",
      "info" : "VariableDeclarationStatement[7731-7765]:VariableDeclarationStatement[7731-7765]"
    }, {
      "left" : "if (reason.length() > 0)",
      "right" : "if (reason.length() > 0)",
      "info" : "IfStatement[7785-7897]:IfStatement[7785-7897]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7810-7897]:Block[7810-7897]"
    }, {
      "left" : "jsdocBuilder.recordDeprecationReason(reason);",
      "right" : "jsdocBuilder.recordDeprecationReason(reason);",
      "info" : "ExpressionStatement[7832-7877]:ExpressionStatement[7832-7877]"
    }, {
      "left" : "token = reasonInfo.token;",
      "right" : "token = reasonInfo.token;",
      "info" : "ExpressionStatement[7917-7942]:ExpressionStatement[7917-7942]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[7961-7976]:ContinueStatement[7961-7976]"
    }, {
      "left" : "case INTERFACE:",
      "right" : "case INTERFACE:",
      "info" : "SwitchCase[7994-8009]:SwitchCase[7994-8009]"
    }, {
      "left" : "if (!jsdocBuilder.recordInterface())",
      "right" : "if (!jsdocBuilder.recordInterface())",
      "info" : "IfStatement[8028-8477]:IfStatement[8028-8477]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8065-8477]:Block[8065-8477]"
    }, {
      "left" : "if (jsdocBuilder.isConstructorRecorded())",
      "right" : "if (jsdocBuilder.isConstructorRecorded())",
      "info" : "IfStatement[8087-8457]:IfStatement[8087-8457]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8129-8294]:Block[8129-8294]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8153-8272]:ExpressionStatement[8153-8272]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8300-8457]:Block[8300-8457]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8324-8435]:ExpressionStatement[8324-8435]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[8496-8524]:ExpressionStatement[8496-8524]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[8543-8558]:ContinueStatement[8543-8558]"
    }, {
      "left" : "case DESC:",
      "right" : "case DESC:",
      "info" : "SwitchCase[8576-8586]:SwitchCase[8576-8586]"
    }, {
      "left" : "if (jsdocBuilder.isDescriptionRecorded())",
      "right" : "if (jsdocBuilder.isDescriptionRecorded())",
      "info" : "IfStatement[8605-9240]:IfStatement[8605-9240]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8647-8880]:Block[8647-8880]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8669-8775]:ExpressionStatement[8669-8775]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[8796-8824]:ExpressionStatement[8796-8824]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[8845-8860]:ContinueStatement[8845-8860]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8886-9240]:Block[8886-9240]"
    }, {
      "left" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[8908-9001]:VariableDeclarationStatement[8908-9001]"
    }, {
      "left" : "String description = descriptionInfo.string;",
      "right" : "String description = descriptionInfo.string;",
      "info" : "VariableDeclarationStatement[9023-9067]:VariableDeclarationStatement[9023-9067]"
    }, {
      "left" : "jsdocBuilder.recordDescription(description);",
      "right" : "jsdocBuilder.recordDescription(description);",
      "info" : "ExpressionStatement[9089-9133]:ExpressionStatement[9089-9133]"
    }, {
      "left" : "token = descriptionInfo.token;",
      "right" : "token = descriptionInfo.token;",
      "info" : "ExpressionStatement[9154-9184]:ExpressionStatement[9154-9184]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[9205-9220]:ContinueStatement[9205-9220]"
    }, {
      "left" : "case FILE_OVERVIEW:",
      "right" : "case FILE_OVERVIEW:",
      "info" : "SwitchCase[9258-9277]:SwitchCase[9258-9277]"
    }, {
      "left" : "ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);",
      "right" : "ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);",
      "info" : "VariableDeclarationStatement[9296-9462]:VariableDeclarationStatement[9296-9462]"
    }, {
      "left" : "String fileOverview = fileOverviewInfo.string;",
      "right" : "String fileOverview = fileOverviewInfo.string;",
      "info" : "VariableDeclarationStatement[9482-9528]:VariableDeclarationStatement[9482-9528]"
    }, {
      "left" : "if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null)",
      "right" : "if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null)",
      "info" : "IfStatement[9548-9811]:IfStatement[9548-9811]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9655-9811]:Block[9655-9811]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[9677-9791]:ExpressionStatement[9677-9791]"
    }, {
      "left" : "token = fileOverviewInfo.token;",
      "right" : "token = fileOverviewInfo.token;",
      "info" : "ExpressionStatement[9830-9861]:ExpressionStatement[9830-9861]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[9880-9895]:ContinueStatement[9880-9895]"
    }, {
      "left" : "case LICENSE:",
      "right" : "case LICENSE:",
      "info" : "SwitchCase[9913-9926]:SwitchCase[9913-9926]"
    }, {
      "left" : "case PRESERVE:",
      "right" : "case PRESERVE:",
      "info" : "SwitchCase[9943-9957]:SwitchCase[9943-9957]"
    }, {
      "left" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
      "right" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
      "info" : "VariableDeclarationStatement[9976-10142]:VariableDeclarationStatement[9976-10142]"
    }, {
      "left" : "String preserve = preserveInfo.string;",
      "right" : "String preserve = preserveInfo.string;",
      "info" : "VariableDeclarationStatement[10162-10200]:VariableDeclarationStatement[10162-10200]"
    }, {
      "left" : "if (preserve.length() > 0)",
      "right" : "if (preserve.length() > 0)",
      "info" : "IfStatement[10220-10409]:IfStatement[10220-10409]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10247-10409]:Block[10247-10409]"
    }, {
      "left" : "if (fileLevelJsDocBuilder != null)",
      "right" : "if (fileLevelJsDocBuilder != null)",
      "info" : "IfStatement[10269-10389]:IfStatement[10269-10389]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10304-10389]:Block[10304-10389]"
    }, {
      "left" : "fileLevelJsDocBuilder.append(preserve);",
      "right" : "fileLevelJsDocBuilder.append(preserve);",
      "info" : "ExpressionStatement[10328-10367]:ExpressionStatement[10328-10367]"
    }, {
      "left" : "token = preserveInfo.token;",
      "right" : "token = preserveInfo.token;",
      "info" : "ExpressionStatement[10429-10456]:ExpressionStatement[10429-10456]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[10475-10490]:ContinueStatement[10475-10490]"
    }, {
      "left" : "case ENUM:",
      "right" : "case ENUM:",
      "info" : "SwitchCase[10508-10518]:SwitchCase[10508-10518]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[10537-10552]:ExpressionStatement[10537-10552]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[10571-10599]:ExpressionStatement[10571-10599]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[10618-10646]:ExpressionStatement[10618-10646]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[10666-10678]:ExpressionStatement[10666-10678]"
    }, {
      "left" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
      "info" : "IfStatement[10697-10881]:IfStatement[10697-10881]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10753-10881]:Block[10753-10881]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "info" : "ExpressionStatement[10775-10861]:ExpressionStatement[10775-10861]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[10901-11016]:IfStatement[10901-11016]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10919-11016]:Block[10919-11016]"
    }, {
      "left" : "type = createJSTypeExpression(newStringNode(\"number\"));",
      "right" : "type = createJSTypeExpression(newStringNode(\"number\"));",
      "info" : "ExpressionStatement[10941-10996]:ExpressionStatement[10941-10996]"
    }, {
      "left" : "if (!jsdocBuilder.recordEnumParameterType(type))",
      "right" : "if (!jsdocBuilder.recordEnumParameterType(type))",
      "info" : "IfStatement[11035-11187]:IfStatement[11035-11187]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11084-11187]:Block[11084-11187]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[11106-11167]:ExpressionStatement[11106-11167]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[11206-11239]:ExpressionStatement[11206-11239]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[11258-11273]:ContinueStatement[11258-11273]"
    }, {
      "left" : "case EXPORT:",
      "right" : "case EXPORT:",
      "info" : "SwitchCase[11291-11303]:SwitchCase[11291-11303]"
    }, {
      "left" : "if (!jsdocBuilder.recordExport())",
      "right" : "if (!jsdocBuilder.recordExport())",
      "info" : "IfStatement[11322-11500]:IfStatement[11322-11500]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11356-11500]:Block[11356-11500]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[11378-11480]:ExpressionStatement[11378-11480]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[11519-11547]:ExpressionStatement[11519-11547]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[11566-11581]:ContinueStatement[11566-11581]"
    }, {
      "left" : "case EXTERNS:",
      "right" : "case EXTERNS:",
      "info" : "SwitchCase[11599-11612]:SwitchCase[11599-11612]"
    }, {
      "left" : "if (!jsdocBuilder.recordExterns())",
      "right" : "if (!jsdocBuilder.recordExterns())",
      "info" : "IfStatement[11631-11811]:IfStatement[11631-11811]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11666-11811]:Block[11666-11811]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[11688-11791]:ExpressionStatement[11688-11791]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[11830-11858]:ExpressionStatement[11830-11858]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[11877-11892]:ContinueStatement[11877-11892]"
    }, {
      "left" : "case JAVA_DISPATCH:",
      "right" : "case JAVA_DISPATCH:",
      "info" : "SwitchCase[11910-11929]:SwitchCase[11910-11929]"
    }, {
      "left" : "if (!jsdocBuilder.recordJavaDispatch())",
      "right" : "if (!jsdocBuilder.recordJavaDispatch())",
      "info" : "IfStatement[11948-12138]:IfStatement[11948-12138]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11988-12138]:Block[11988-12138]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[12010-12118]:ExpressionStatement[12010-12118]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[12157-12185]:ExpressionStatement[12157-12185]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[12204-12219]:ContinueStatement[12204-12219]"
    }, {
      "left" : "case EXTENDS:",
      "right" : "case EXTENDS:",
      "info" : "SwitchCase[12237-12250]:SwitchCase[12237-12250]"
    }, {
      "left" : "case IMPLEMENTS:",
      "right" : "case IMPLEMENTS:",
      "info" : "SwitchCase[12267-12283]:SwitchCase[12267-12283]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[12302-12313]:ExpressionStatement[12302-12313]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[12332-12347]:ExpressionStatement[12332-12347]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[12366-12394]:ExpressionStatement[12366-12394]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[12413-12441]:ExpressionStatement[12413-12441]"
    }, {
      "left" : "boolean matchingRc = false;",
      "right" : "boolean matchingRc = false;",
      "info" : "VariableDeclarationStatement[12460-12487]:VariableDeclarationStatement[12460-12487]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[12507-12631]:IfStatement[12507-12631]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12535-12631]:Block[12535-12631]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[12557-12572]:ExpressionStatement[12557-12572]"
    }, {
      "left" : "matchingRc = true;",
      "right" : "matchingRc = true;",
      "info" : "ExpressionStatement[12593-12611]:ExpressionStatement[12593-12611]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[12651-14538]:IfStatement[12651-14538]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12683-14436]:Block[12683-14436]"
    }, {
      "left" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
      "right" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
      "info" : "VariableDeclarationStatement[12705-12808]:VariableDeclarationStatement[12705-12808]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[12830-12858]:ExpressionStatement[12830-12858]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[12879-12907]:ExpressionStatement[12879-12907]"
    }, {
      "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "info" : "ExpressionStatement[12929-12971]:ExpressionStatement[12929-12971]"
    }, {
      "left" : "if (typeNode != null && !matchingRc)",
      "right" : "if (typeNode != null && !matchingRc)",
      "info" : "IfStatement[12992-13126]:IfStatement[12992-13126]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13029-13126]:Block[13029-13126]"
    }, {
      "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "info" : "ExpressionStatement[13053-13104]:ExpressionStatement[13053-13104]"
    }, {
      "left" : "type = createJSTypeExpression(typeNode);",
      "right" : "type = createJSTypeExpression(typeNode);",
      "info" : "ExpressionStatement[13147-13187]:ExpressionStatement[13147-13187]"
    }, {
      "left" : "if (annotation == Annotation.EXTENDS)",
      "right" : "if (annotation == Annotation.EXTENDS)",
      "info" : "IfStatement[13209-13835]:IfStatement[13209-13835]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13247-13473]:Block[13247-13473]"
    }, {
      "left" : "if (!jsdocBuilder.recordBaseType(type))",
      "right" : "if (!jsdocBuilder.recordBaseType(type))",
      "info" : "IfStatement[13271-13451]:IfStatement[13271-13451]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13311-13451]:Block[13311-13451]"
    }, {
      "left" : "parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[13337-13427]:ExpressionStatement[13337-13427]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13479-13835]:Block[13479-13835]"
    }, {
      "left" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
      "right" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
      "info" : "ExpressionStatement[13503-13592]:ExpressionStatement[13503-13592]"
    }, {
      "left" : "if (!jsdocBuilder.recordImplementedInterface(type))",
      "right" : "if (!jsdocBuilder.recordImplementedInterface(type))",
      "info" : "IfStatement[13615-13813]:IfStatement[13615-13813]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13667-13813]:Block[13667-13813]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
      "right" : "parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
      "info" : "ExpressionStatement[13693-13789]:ExpressionStatement[13693-13789]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[13856-13871]:ExpressionStatement[13856-13871]"
    }, {
      "left" : "if (matchingRc)",
      "right" : "if (matchingRc)",
      "info" : "IfStatement[13892-14416]:IfStatement[13892-14416]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13908-14142]:Block[13908-14142]"
    }, {
      "left" : "if (token != JsDocToken.RC)",
      "right" : "if (token != JsDocToken.RC)",
      "info" : "IfStatement[13932-14120]:IfStatement[13932-14120]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13960-14120]:Block[13960-14120]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[13986-14096]:ExpressionStatement[13986-14096]"
    }, {
      "left" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
      "info" : "IfStatement[14148-14416]:IfStatement[14148-14416]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14255-14416]:Block[14255-14416]"
    }, {
      "left" : "parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[14279-14394]:ExpressionStatement[14279-14394]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14442-14538]:Block[14442-14538]"
    }, {
      "left" : "parser.addWarning(\"msg.no.type.name\", lineno, charno);",
      "right" : "parser.addWarning(\"msg.no.type.name\", lineno, charno);",
      "info" : "ExpressionStatement[14464-14518]:ExpressionStatement[14464-14518]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[14557-14590]:ExpressionStatement[14557-14590]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[14609-14624]:ContinueStatement[14609-14624]"
    }, {
      "left" : "case HIDDEN:",
      "right" : "case HIDDEN:",
      "info" : "SwitchCase[14642-14654]:SwitchCase[14642-14654]"
    }, {
      "left" : "if (!jsdocBuilder.recordHiddenness())",
      "right" : "if (!jsdocBuilder.recordHiddenness())",
      "info" : "IfStatement[14673-14855]:IfStatement[14673-14855]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14711-14855]:Block[14711-14855]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[14733-14835]:ExpressionStatement[14733-14835]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[14874-14902]:ExpressionStatement[14874-14902]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[14921-14936]:ContinueStatement[14921-14936]"
    }, {
      "left" : "case NO_ALIAS:",
      "right" : "case NO_ALIAS:",
      "info" : "SwitchCase[14954-14968]:SwitchCase[14954-14968]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoAlias())",
      "right" : "if (!jsdocBuilder.recordNoAlias())",
      "info" : "IfStatement[14987-15167]:IfStatement[14987-15167]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15022-15167]:Block[15022-15167]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[15044-15147]:ExpressionStatement[15044-15147]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[15186-15214]:ExpressionStatement[15186-15214]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[15233-15248]:ContinueStatement[15233-15248]"
    }, {
      "left" : "case NO_TYPE_CHECK:",
      "right" : "case NO_TYPE_CHECK:",
      "info" : "SwitchCase[15266-15285]:SwitchCase[15266-15285]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoTypeCheck())",
      "right" : "if (!jsdocBuilder.recordNoTypeCheck())",
      "info" : "IfStatement[15304-15488]:IfStatement[15304-15488]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15343-15488]:Block[15343-15488]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[15365-15468]:ExpressionStatement[15365-15468]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[15507-15535]:ExpressionStatement[15507-15535]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[15554-15569]:ContinueStatement[15554-15569]"
    }, {
      "left" : "case NOT_IMPLEMENTED:",
      "right" : "case NOT_IMPLEMENTED:",
      "info" : "SwitchCase[15587-15608]:SwitchCase[15587-15608]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[15627-15655]:ExpressionStatement[15627-15655]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[15674-15689]:ContinueStatement[15674-15689]"
    }, {
      "left" : "case INHERIT_DOC:",
      "right" : "case INHERIT_DOC:",
      "info" : "SwitchCase[15707-15724]:SwitchCase[15707-15724]"
    }, {
      "left" : "case OVERRIDE:",
      "right" : "case OVERRIDE:",
      "info" : "SwitchCase[15741-15755]:SwitchCase[15741-15755]"
    }, {
      "left" : "if (!jsdocBuilder.recordOverride())",
      "right" : "if (!jsdocBuilder.recordOverride())",
      "info" : "IfStatement[15774-15956]:IfStatement[15774-15956]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15810-15956]:Block[15810-15956]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[15832-15936]:ExpressionStatement[15832-15936]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[15975-16003]:ExpressionStatement[15975-16003]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[16022-16037]:ContinueStatement[16022-16037]"
    }, {
      "left" : "case THROWS:",
      "right" : "case THROWS:",
      "info" : "SwitchCase[16055-16067]:SwitchCase[16055-16067]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[16086-16097]:ExpressionStatement[16086-16097]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[16116-16131]:ExpressionStatement[16116-16131]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[16150-16178]:ExpressionStatement[16150-16178]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[16197-16225]:ExpressionStatement[16197-16225]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[16244-16256]:ExpressionStatement[16244-16256]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[16276-16701]:IfStatement[16276-16701]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16304-16701]:Block[16304-16701]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "info" : "ExpressionStatement[16326-16412]:ExpressionStatement[16326-16412]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[16434-16681]:IfStatement[16434-16681]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16452-16681]:Block[16452-16681]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[16593-16621]:ExpressionStatement[16593-16621]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[16644-16659]:ContinueStatement[16644-16659]"
    }, {
      "left" : "token = current();",
      "right" : "token = current();",
      "info" : "ExpressionStatement[16796-16814]:ExpressionStatement[16796-16814]"
    }, {
      "left" : "jsdocBuilder.recordThrowType(type);",
      "right" : "jsdocBuilder.recordThrowType(type);",
      "info" : "ExpressionStatement[16876-16911]:ExpressionStatement[16876-16911]"
    }, {
      "left" : "ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[16998-17089]:VariableDeclarationStatement[16998-17089]"
    }, {
      "left" : "String description = descriptionInfo.string;",
      "right" : "String description = descriptionInfo.string;",
      "info" : "VariableDeclarationStatement[17109-17153]:VariableDeclarationStatement[17109-17153]"
    }, {
      "left" : "if (description.length() > 0)",
      "right" : "if (description.length() > 0)",
      "info" : "IfStatement[17173-17300]:IfStatement[17173-17300]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17203-17300]:Block[17203-17300]"
    }, {
      "left" : "jsdocBuilder.recordThrowDescription(type, description);",
      "right" : "jsdocBuilder.recordThrowDescription(type, description);",
      "info" : "ExpressionStatement[17225-17280]:ExpressionStatement[17225-17280]"
    }, {
      "left" : "token = descriptionInfo.token;",
      "right" : "token = descriptionInfo.token;",
      "info" : "ExpressionStatement[17320-17350]:ExpressionStatement[17320-17350]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[17369-17384]:ContinueStatement[17369-17384]"
    }, {
      "left" : "case PARAM:",
      "right" : "case PARAM:",
      "info" : "SwitchCase[17402-17413]:SwitchCase[17402-17413]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[17432-17443]:ExpressionStatement[17432-17443]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[17462-17477]:ExpressionStatement[17462-17477]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[17496-17524]:ExpressionStatement[17496-17524]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[17543-17571]:ExpressionStatement[17543-17571]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[17590-17602]:ExpressionStatement[17590-17602]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[17622-18218]:IfStatement[17622-18218]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17650-18218]:Block[17650-18218]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
      "info" : "ExpressionStatement[17672-17763]:ExpressionStatement[17672-17763]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[17785-18032]:IfStatement[17785-18032]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17803-18032]:Block[17803-18032]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[17944-17972]:ExpressionStatement[17944-17972]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[17995-18010]:ContinueStatement[17995-18010]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[18053-18064]:ExpressionStatement[18053-18064]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[18085-18100]:ExpressionStatement[18085-18100]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[18121-18149]:ExpressionStatement[18121-18149]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[18170-18198]:ExpressionStatement[18170-18198]"
    }, {
      "left" : "String name = null;",
      "right" : "String name = null;",
      "info" : "VariableDeclarationStatement[18238-18257]:VariableDeclarationStatement[18238-18257]"
    }, {
      "left" : "boolean isBracketedParam = JsDocToken.LB == token;",
      "right" : "boolean isBracketedParam = JsDocToken.LB == token;",
      "info" : "VariableDeclarationStatement[18276-18326]:VariableDeclarationStatement[18276-18326]"
    }, {
      "left" : "if (isBracketedParam)",
      "right" : "if (isBracketedParam)",
      "info" : "IfStatement[18345-18424]:IfStatement[18345-18424]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18367-18424]:Block[18367-18424]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[18389-18404]:ExpressionStatement[18389-18404]"
    }, {
      "left" : "if (JsDocToken.STRING != token)",
      "right" : "if (JsDocToken.STRING != token)",
      "info" : "IfStatement[18444-20304]:IfStatement[18444-20304]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18476-18605]:Block[18476-18605]"
    }, {
      "left" : "parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
      "right" : "parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
      "info" : "ExpressionStatement[18498-18585]:ExpressionStatement[18498-18585]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18611-20304]:Block[18611-20304]"
    }, {
      "left" : "name = stream.getString();",
      "right" : "name = stream.getString();",
      "info" : "ExpressionStatement[18633-18659]:ExpressionStatement[18633-18659]"
    }, {
      "left" : "if (isBracketedParam)",
      "right" : "if (isBracketedParam)",
      "info" : "IfStatement[18681-19539]:IfStatement[18681-19539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18703-19539]:Block[18703-19539]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[18727-18742]:ExpressionStatement[18727-18742]"
    }, {
      "left" : "if (JsDocToken.EQUALS == token)",
      "right" : "if (JsDocToken.EQUALS == token)",
      "info" : "IfStatement[18914-19137]:IfStatement[18914-19137]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18946-19137]:Block[18946-19137]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[18972-18987]:ExpressionStatement[18972-18987]"
    }, {
      "left" : "if (JsDocToken.STRING == token)",
      "right" : "if (JsDocToken.STRING == token)",
      "info" : "IfStatement[19012-19113]:IfStatement[19012-19113]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19044-19113]:Block[19044-19113]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[19072-19087]:ExpressionStatement[19072-19087]"
    }, {
      "left" : "if (JsDocToken.RB != token)",
      "right" : "if (JsDocToken.RB != token)",
      "info" : "IfStatement[19161-19517]:IfStatement[19161-19517]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19189-19287]:Block[19189-19287]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ExpressionStatement[19215-19263]:ExpressionStatement[19215-19263]"
    }, {
      "left" : "if (type != null)",
      "right" : "if (type != null)",
      "info" : "IfStatement[19293-19517]:IfStatement[19293-19517]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19311-19517]:Block[19311-19517]"
    }, {
      "left" : "type = JSTypeExpression.makeOptionalArg(type);",
      "right" : "type = JSTypeExpression.makeOptionalArg(type);",
      "info" : "ExpressionStatement[19447-19493]:ExpressionStatement[19447-19493]"
    }, {
      "left" : "if (name.indexOf('.') > -1)",
      "right" : "if (name.indexOf('.') > -1)",
      "info" : "IfStatement[19768-20284]:IfStatement[19768-20284]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19796-19854]:Block[19796-19854]"
    }, {
      "left" : "name = null;",
      "right" : "name = null;",
      "info" : "ExpressionStatement[19820-19832]:ExpressionStatement[19820-19832]"
    }, {
      "left" : "if (!jsdocBuilder.recordParameter(name, type))",
      "right" : "if (!jsdocBuilder.recordParameter(name, type))",
      "info" : "IfStatement[19860-20284]:IfStatement[19860-20284]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19907-20284]:Block[19907-20284]"
    }, {
      "left" : "if (jsdocBuilder.hasParameter(name))",
      "right" : "if (jsdocBuilder.hasParameter(name))",
      "info" : "IfStatement[19931-20262]:IfStatement[19931-20262]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19968-20111]:Block[19968-20111]"
    }, {
      "left" : "parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
      "right" : "parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
      "info" : "ExpressionStatement[19994-20087]:ExpressionStatement[19994-20087]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20117-20262]:Block[20117-20262]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
      "right" : "parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
      "info" : "ExpressionStatement[20143-20238]:ExpressionStatement[20143-20238]"
    }, {
      "left" : "if (name == null)",
      "right" : "if (name == null)",
      "info" : "IfStatement[20324-20453]:IfStatement[20324-20453]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20342-20453]:Block[20342-20453]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[20364-20397]:ExpressionStatement[20364-20397]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[20418-20433]:ContinueStatement[20418-20433]"
    }, {
      "left" : "jsdocBuilder.markName(name, lineno, charno);",
      "right" : "jsdocBuilder.markName(name, lineno, charno);",
      "info" : "ExpressionStatement[20473-20517]:ExpressionStatement[20473-20517]"
    }, {
      "left" : "ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[20608-20704]:VariableDeclarationStatement[20608-20704]"
    }, {
      "left" : "String paramDescription = paramDescriptionInfo.string;",
      "right" : "String paramDescription = paramDescriptionInfo.string;",
      "info" : "VariableDeclarationStatement[20724-20778]:VariableDeclarationStatement[20724-20778]"
    }, {
      "left" : "if (paramDescription.length() > 0)",
      "right" : "if (paramDescription.length() > 0)",
      "info" : "IfStatement[20798-20999]:IfStatement[20798-20999]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20833-20999]:Block[20833-20999]"
    }, {
      "left" : "jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);",
      "right" : "jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);",
      "info" : "ExpressionStatement[20855-20979]:ExpressionStatement[20855-20979]"
    }, {
      "left" : "token = paramDescriptionInfo.token;",
      "right" : "token = paramDescriptionInfo.token;",
      "info" : "ExpressionStatement[21019-21054]:ExpressionStatement[21019-21054]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21073-21088]:ContinueStatement[21073-21088]"
    }, {
      "left" : "case PRESERVE_TRY:",
      "right" : "case PRESERVE_TRY:",
      "info" : "SwitchCase[21106-21124]:SwitchCase[21106-21124]"
    }, {
      "left" : "if (!jsdocBuilder.recordPreserveTry())",
      "right" : "if (!jsdocBuilder.recordPreserveTry())",
      "info" : "IfStatement[21143-21332]:IfStatement[21143-21332]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21182-21332]:Block[21182-21332]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[21204-21312]:ExpressionStatement[21204-21312]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[21351-21379]:ExpressionStatement[21351-21379]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21398-21413]:ContinueStatement[21398-21413]"
    }, {
      "left" : "case PRIVATE:",
      "right" : "case PRIVATE:",
      "info" : "SwitchCase[21431-21444]:SwitchCase[21431-21444]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
      "info" : "IfStatement[21463-21675]:IfStatement[21463-21675]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21519-21675]:Block[21519-21675]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[21541-21655]:ExpressionStatement[21541-21655]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[21694-21722]:ExpressionStatement[21694-21722]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21741-21756]:ContinueStatement[21741-21756]"
    }, {
      "left" : "case PROTECTED:",
      "right" : "case PROTECTED:",
      "info" : "SwitchCase[21774-21789]:SwitchCase[21774-21789]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
      "info" : "IfStatement[21808-22024]:IfStatement[21808-22024]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21866-22024]:Block[21866-22024]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[21888-22004]:ExpressionStatement[21888-22004]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[22043-22071]:ExpressionStatement[22043-22071]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[22090-22105]:ContinueStatement[22090-22105]"
    }, {
      "left" : "case PUBLIC:",
      "right" : "case PUBLIC:",
      "info" : "SwitchCase[22123-22135]:SwitchCase[22123-22135]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
      "info" : "IfStatement[22154-22364]:IfStatement[22154-22364]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22209-22364]:Block[22209-22364]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[22231-22344]:ExpressionStatement[22231-22344]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[22383-22411]:ExpressionStatement[22383-22411]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[22430-22445]:ContinueStatement[22430-22445]"
    }, {
      "left" : "case NO_SHADOW:",
      "right" : "case NO_SHADOW:",
      "info" : "SwitchCase[22463-22478]:SwitchCase[22463-22478]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoShadow())",
      "right" : "if (!jsdocBuilder.recordNoShadow())",
      "info" : "IfStatement[22497-22679]:IfStatement[22497-22679]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22533-22679]:Block[22533-22679]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[22555-22659]:ExpressionStatement[22555-22659]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[22698-22726]:ExpressionStatement[22698-22726]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[22745-22760]:ContinueStatement[22745-22760]"
    }, {
      "left" : "case NO_SIDE_EFFECTS:",
      "right" : "case NO_SIDE_EFFECTS:",
      "info" : "SwitchCase[22778-22799]:SwitchCase[22778-22799]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoSideEffects())",
      "right" : "if (!jsdocBuilder.recordNoSideEffects())",
      "info" : "IfStatement[22818-23010]:IfStatement[22818-23010]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22859-23010]:Block[22859-23010]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[22881-22990]:ExpressionStatement[22881-22990]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[23029-23057]:ExpressionStatement[23029-23057]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[23076-23091]:ContinueStatement[23076-23091]"
    }, {
      "left" : "case IMPLICIT_CAST:",
      "right" : "case IMPLICIT_CAST:",
      "info" : "SwitchCase[23109-23128]:SwitchCase[23109-23128]"
    }, {
      "left" : "if (!jsdocBuilder.recordImplicitCast())",
      "right" : "if (!jsdocBuilder.recordImplicitCast())",
      "info" : "IfStatement[23147-23337]:IfStatement[23147-23337]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23187-23337]:Block[23187-23337]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[23209-23317]:ExpressionStatement[23209-23317]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[23356-23384]:ExpressionStatement[23356-23384]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[23403-23418]:ContinueStatement[23403-23418]"
    }, {
      "left" : "case SEE:",
      "right" : "case SEE:",
      "info" : "SwitchCase[23436-23445]:SwitchCase[23436-23445]"
    }, {
      "left" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[23464-23520]:VariableDeclarationStatement[23464-23520]"
    }, {
      "left" : "String reference = referenceInfo.string;",
      "right" : "String reference = referenceInfo.string;",
      "info" : "VariableDeclarationStatement[23539-23579]:VariableDeclarationStatement[23539-23579]"
    }, {
      "left" : "if (reference.length() == 0)",
      "right" : "if (reference.length() == 0)",
      "info" : "IfStatement[23599-23863]:IfStatement[23599-23863]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23628-23778]:Block[23628-23778]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[23650-23758]:ExpressionStatement[23650-23758]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23784-23863]:Block[23784-23863]"
    }, {
      "left" : "jsdocBuilder.addReference(reference);",
      "right" : "jsdocBuilder.addReference(reference);",
      "info" : "ExpressionStatement[23806-23843]:ExpressionStatement[23806-23843]"
    }, {
      "left" : "token = referenceInfo.token;",
      "right" : "token = referenceInfo.token;",
      "info" : "ExpressionStatement[23883-23911]:ExpressionStatement[23883-23911]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[23930-23945]:ContinueStatement[23930-23945]"
    }, {
      "left" : "case SUPPRESS:",
      "right" : "case SUPPRESS:",
      "info" : "SwitchCase[23963-23977]:SwitchCase[23963-23977]"
    }, {
      "left" : "token = parseSuppressTag(next());",
      "right" : "token = parseSuppressTag(next());",
      "info" : "ExpressionStatement[23996-24029]:ExpressionStatement[23996-24029]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[24048-24063]:ContinueStatement[24048-24063]"
    }, {
      "left" : "case TEMPLATE:",
      "right" : "case TEMPLATE:",
      "info" : "SwitchCase[24081-24095]:SwitchCase[24081-24095]"
    }, {
      "left" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[24114-24169]:VariableDeclarationStatement[24114-24169]"
    }, {
      "left" : "String templateTypeName = templateInfo.string;",
      "right" : "String templateTypeName = templateInfo.string;",
      "info" : "VariableDeclarationStatement[24188-24234]:VariableDeclarationStatement[24188-24234]"
    }, {
      "left" : "if (templateTypeName.length() == 0)",
      "right" : "if (templateTypeName.length() == 0)",
      "info" : "IfStatement[24254-24693]:IfStatement[24254-24693]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24290-24445]:Block[24290-24445]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[24312-24425]:ExpressionStatement[24312-24425]"
    }, {
      "left" : "if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName))",
      "right" : "if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName))",
      "info" : "IfStatement[24451-24693]:IfStatement[24451-24693]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24534-24693]:Block[24534-24693]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[24556-24673]:ExpressionStatement[24556-24673]"
    }, {
      "left" : "token = templateInfo.token;",
      "right" : "token = templateInfo.token;",
      "info" : "ExpressionStatement[24713-24740]:ExpressionStatement[24713-24740]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[24759-24774]:ContinueStatement[24759-24774]"
    }, {
      "left" : "case VERSION:",
      "right" : "case VERSION:",
      "info" : "SwitchCase[24792-24805]:SwitchCase[24792-24805]"
    }, {
      "left" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[24824-24878]:VariableDeclarationStatement[24824-24878]"
    }, {
      "left" : "String version = versionInfo.string;",
      "right" : "String version = versionInfo.string;",
      "info" : "VariableDeclarationStatement[24897-24933]:VariableDeclarationStatement[24897-24933]"
    }, {
      "left" : "if (version.length() == 0)",
      "right" : "if (version.length() == 0)",
      "info" : "IfStatement[24953-25381]:IfStatement[24953-25381]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24980-25134]:Block[24980-25134]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[25002-25114]:ExpressionStatement[25002-25114]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25140-25381]:Block[25140-25381]"
    }, {
      "left" : "if (!jsdocBuilder.recordVersion(version))",
      "right" : "if (!jsdocBuilder.recordVersion(version))",
      "info" : "IfStatement[25162-25361]:IfStatement[25162-25361]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25204-25361]:Block[25204-25361]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[25229-25339]:ExpressionStatement[25229-25339]"
    }, {
      "left" : "token = versionInfo.token;",
      "right" : "token = versionInfo.token;",
      "info" : "ExpressionStatement[25401-25427]:ExpressionStatement[25401-25427]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[25446-25461]:ContinueStatement[25446-25461]"
    }, {
      "left" : "case DEFINE:",
      "right" : "case DEFINE:",
      "info" : "SwitchCase[25479-25491]:SwitchCase[25479-25491]"
    }, {
      "left" : "case RETURN:",
      "right" : "case RETURN:",
      "info" : "SwitchCase[25508-25520]:SwitchCase[25508-25520]"
    }, {
      "left" : "case THIS:",
      "right" : "case THIS:",
      "info" : "SwitchCase[25537-25547]:SwitchCase[25537-25547]"
    }, {
      "left" : "case TYPE:",
      "right" : "case TYPE:",
      "info" : "SwitchCase[25564-25574]:SwitchCase[25564-25574]"
    }, {
      "left" : "case TYPEDEF:",
      "right" : "case TYPEDEF:",
      "info" : "SwitchCase[25591-25604]:SwitchCase[25591-25604]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[25623-25634]:ExpressionStatement[25623-25634]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[25653-25681]:ExpressionStatement[25653-25681]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[25700-25728]:ExpressionStatement[25700-25728]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[25748-25763]:ExpressionStatement[25748-25763]"
    }, {
      "left" : "Node typeNode = parseAndRecordTypeNode(token, lineno, charno);",
      "right" : "Node typeNode = parseAndRecordTypeNode(token, lineno, charno);",
      "info" : "VariableDeclarationStatement[25783-25845]:VariableDeclarationStatement[25783-25845]"
    }, {
      "left" : "if (annotation == Annotation.THIS)",
      "right" : "if (annotation == Annotation.THIS)",
      "info" : "IfStatement[25865-26150]:IfStatement[25865-26150]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25900-26150]:Block[25900-26150]"
    }, {
      "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "info" : "ExpressionStatement[25922-25964]:ExpressionStatement[25922-25964]"
    }, {
      "left" : "if (typeNode != null && token != JsDocToken.LC)",
      "right" : "if (typeNode != null && token != JsDocToken.LC)",
      "info" : "IfStatement[25985-26130]:IfStatement[25985-26130]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26033-26130]:Block[26033-26130]"
    }, {
      "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "info" : "ExpressionStatement[26057-26108]:ExpressionStatement[26057-26108]"
    }, {
      "left" : "type = createJSTypeExpression(typeNode);",
      "right" : "type = createJSTypeExpression(typeNode);",
      "info" : "ExpressionStatement[26169-26209]:ExpressionStatement[26169-26209]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[26229-28794]:IfStatement[26229-28794]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26247-26373]:Block[26247-26373]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26379-28794]:Block[26379-28794]"
    }, {
      "left" : "switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
      "right" : "switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
      "info" : "SwitchStatement[26401-28724]:SwitchStatement[26401-28724]"
    }, {
      "left" : "case DEFINE:",
      "right" : "case DEFINE:",
      "info" : "SwitchCase[26445-26457]:SwitchCase[26445-26457]"
    }, {
      "left" : "if (!isValidDefineType(typeNode))",
      "right" : "if (!isValidDefineType(typeNode))",
      "info" : "IfStatement[26482-26848]:IfStatement[26482-26848]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26516-26662]:Block[26516-26662]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);",
      "right" : "parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);",
      "info" : "ExpressionStatement[26544-26636]:ExpressionStatement[26544-26636]"
    }, {
      "left" : "if (!jsdocBuilder.recordDefineType(type))",
      "right" : "if (!jsdocBuilder.recordDefineType(type))",
      "info" : "IfStatement[26668-26848]:IfStatement[26668-26848]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26710-26848]:Block[26710-26848]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
      "right" : "parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
      "info" : "ExpressionStatement[26738-26822]:ExpressionStatement[26738-26822]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[26873-26879]:BreakStatement[26873-26879]"
    }, {
      "left" : "case RETURN:",
      "right" : "case RETURN:",
      "info" : "SwitchCase[26903-26915]:SwitchCase[26903-26915]"
    }, {
      "left" : "if (!jsdocBuilder.recordReturnType(type))",
      "right" : "if (!jsdocBuilder.recordReturnType(type))",
      "info" : "IfStatement[26940-27161]:IfStatement[26940-27161]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26982-27161]:Block[26982-27161]"
    }, {
      "left" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[27010-27102]:ExpressionStatement[27010-27102]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[27129-27135]:BreakStatement[27129-27135]"
    }, {
      "left" : "token = current();",
      "right" : "token = current();",
      "info" : "ExpressionStatement[27268-27286]:ExpressionStatement[27268-27286]"
    }, {
      "left" : "ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[27386-27489]:VariableDeclarationStatement[27386-27489]"
    }, {
      "left" : "String returnDescription = returnDescriptionInfo.string;",
      "right" : "String returnDescription = returnDescriptionInfo.string;",
      "info" : "VariableDeclarationStatement[27515-27571]:VariableDeclarationStatement[27515-27571]"
    }, {
      "left" : "if (returnDescription.length() > 0)",
      "right" : "if (returnDescription.length() > 0)",
      "info" : "IfStatement[27597-27774]:IfStatement[27597-27774]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27633-27774]:Block[27633-27774]"
    }, {
      "left" : "jsdocBuilder.recordReturnDescription(\n                              returnDescription);",
      "right" : "jsdocBuilder.recordReturnDescription(\n                              returnDescription);",
      "info" : "ExpressionStatement[27661-27748]:ExpressionStatement[27661-27748]"
    }, {
      "left" : "token = returnDescriptionInfo.token;",
      "right" : "token = returnDescriptionInfo.token;",
      "info" : "ExpressionStatement[27800-27836]:ExpressionStatement[27800-27836]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[27861-27876]:ContinueStatement[27861-27876]"
    }, {
      "left" : "case THIS:",
      "right" : "case THIS:",
      "info" : "SwitchCase[27900-27910]:SwitchCase[27900-27910]"
    }, {
      "left" : "if (!jsdocBuilder.recordThisType(type))",
      "right" : "if (!jsdocBuilder.recordThisType(type))",
      "info" : "IfStatement[27935-28121]:IfStatement[27935-28121]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27975-28121]:Block[27975-28121]"
    }, {
      "left" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[28003-28095]:ExpressionStatement[28003-28095]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[28146-28152]:BreakStatement[28146-28152]"
    }, {
      "left" : "case TYPE:",
      "right" : "case TYPE:",
      "info" : "SwitchCase[28176-28186]:SwitchCase[28176-28186]"
    }, {
      "left" : "if (!jsdocBuilder.recordType(type))",
      "right" : "if (!jsdocBuilder.recordType(type))",
      "info" : "IfStatement[28211-28393]:IfStatement[28211-28393]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28247-28393]:Block[28247-28393]"
    }, {
      "left" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[28275-28367]:ExpressionStatement[28275-28367]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[28418-28424]:BreakStatement[28418-28424]"
    }, {
      "left" : "case TYPEDEF:",
      "right" : "case TYPEDEF:",
      "info" : "SwitchCase[28448-28461]:SwitchCase[28448-28461]"
    }, {
      "left" : "if (!jsdocBuilder.recordTypedef(type))",
      "right" : "if (!jsdocBuilder.recordTypedef(type))",
      "info" : "IfStatement[28486-28671]:IfStatement[28486-28671]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28525-28671]:Block[28525-28671]"
    }, {
      "left" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[28553-28645]:ExpressionStatement[28553-28645]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[28696-28702]:BreakStatement[28696-28702]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[28746-28774]:ExpressionStatement[28746-28774]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[28813-28828]:ContinueStatement[28813-28828]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[28881-28887]:BreakStatement[28881-28887]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[28897-28906]:SwitchCase[28897-28906]"
    }, {
      "left" : "if (hasParsedFileOverviewDocInfo())",
      "right" : "if (hasParsedFileOverviewDocInfo())",
      "info" : "IfStatement[28917-29037]:IfStatement[28917-29037]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28953-29037]:Block[28953-29037]"
    }, {
      "left" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
      "right" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
      "info" : "ExpressionStatement[28967-29025]:ExpressionStatement[28967-29025]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[29049-29061]:ReturnStatement[29049-29061]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[29071-29080]:SwitchCase[29071-29080]"
    }, {
      "left" : "jsdocBuilder.build(null);",
      "right" : "jsdocBuilder.build(null);",
      "info" : "ExpressionStatement[29140-29165]:ExpressionStatement[29140-29165]"
    }, {
      "left" : "parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[29176-29270]:ExpressionStatement[29176-29270]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[29281-29294]:ReturnStatement[29281-29294]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[29304-29313]:SwitchCase[29304-29313]"
    }, {
      "left" : "if (state == State.SEARCHING_NEWLINE)",
      "right" : "if (state == State.SEARCHING_NEWLINE)",
      "info" : "IfStatement[29324-29423]:IfStatement[29324-29423]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29362-29423]:Block[29362-29423]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[29376-29411]:ExpressionStatement[29376-29411]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[29434-29449]:ExpressionStatement[29434-29449]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[29460-29475]:ContinueStatement[29460-29475]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[29485-29493]:SwitchCase[29485-29493]"
    }, {
      "left" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
      "right" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
      "info" : "IfStatement[29504-29775]:IfStatement[29504-29775]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29573-29642]:Block[29573-29642]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[29587-29602]:ExpressionStatement[29587-29602]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[29615-29630]:ContinueStatement[29615-29630]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29648-29775]:Block[29648-29775]"
    }, {
      "left" : "state = State.SEARCHING_NEWLINE;",
      "right" : "state = State.SEARCHING_NEWLINE;",
      "info" : "ExpressionStatement[29662-29694]:ExpressionStatement[29662-29694]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[29707-29735]:ExpressionStatement[29707-29735]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[29748-29763]:ContinueStatement[29748-29763]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[29811-29826]:ExpressionStatement[29811-29826]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[29994-30001]:Modifier[29994-30001]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[30002-30012]:SimpleType[30002-30012]"
    }, {
      "left" : "parseSuppressTag",
      "right" : "parseSuppressTag",
      "info" : "SimpleName[30013-30029]:SimpleName[30013-30029]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[30030-30046]:SingleVariableDeclaration[30030-30046]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30048-30946]:Block[30048-30946]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[30054-30924]:IfStatement[30054-30924]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30082-30924]:Block[30082-30924]"
    }, {
      "left" : "Set<String> suppressions = new HashSet<String>();",
      "right" : "Set<String> suppressions = new HashSet<String>();",
      "info" : "VariableDeclarationStatement[30090-30139]:VariableDeclarationStatement[30090-30139]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[30146-30547]:WhileStatement[30146-30547]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30159-30547]:Block[30159-30547]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[30169-30430]:IfStatement[30169-30430]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30199-30284]:Block[30199-30284]"
    }, {
      "left" : "suppressions.add(stream.getString());",
      "right" : "suppressions.add(stream.getString());",
      "info" : "ExpressionStatement[30211-30248]:ExpressionStatement[30211-30248]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[30259-30274]:ExpressionStatement[30259-30274]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30290-30430]:Block[30290-30430]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[30302-30396]:ExpressionStatement[30302-30396]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[30407-30420]:ReturnStatement[30407-30420]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[30440-30539]:IfStatement[30440-30539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30468-30505]:Block[30468-30505]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[30480-30495]:ExpressionStatement[30480-30495]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30511-30539]:Block[30511-30539]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[30523-30529]:BreakStatement[30523-30529]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[30555-30918]:IfStatement[30555-30918]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30582-30692]:Block[30582-30692]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[30592-30684]:ExpressionStatement[30592-30684]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30698-30918]:Block[30698-30918]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[30708-30723]:ExpressionStatement[30708-30723]"
    }, {
      "left" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
      "right" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
      "info" : "IfStatement[30732-30910]:IfStatement[30732-30910]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30784-30910]:Block[30784-30910]"
    }, {
      "left" : "parser.addWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[30796-30900]:ExpressionStatement[30796-30900]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[30929-30942]:ReturnStatement[30929-30942]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[31183-31190]:Modifier[31183-31190]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[31191-31195]:SimpleType[31191-31195]"
    }, {
      "left" : "parseAndRecordTypeNode",
      "right" : "parseAndRecordTypeNode",
      "info" : "SimpleName[31196-31218]:SimpleName[31196-31218]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[31219-31235]:SingleVariableDeclaration[31219-31235]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31237-31308]:Block[31237-31308]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
      "right" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
      "info" : "ReturnStatement[31243-31304]:ReturnStatement[31243-31304]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[31615-31622]:Modifier[31615-31622]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[31623-31627]:SimpleType[31623-31627]"
    }, {
      "left" : "parseAndRecordTypeNode",
      "right" : "parseAndRecordTypeNode",
      "info" : "SimpleName[31628-31650]:SimpleName[31628-31650]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[31651-31667]:SingleVariableDeclaration[31651-31667]"
    }, {
      "left" : "boolean matchingLC",
      "right" : "boolean matchingLC",
      "info" : "SingleVariableDeclaration[31669-31687]:SingleVariableDeclaration[31669-31687]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31689-31803]:Block[31689-31803]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
      "right" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
      "info" : "ReturnStatement[31695-31799]:ReturnStatement[31695-31799]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[32172-32179]:Modifier[32172-32179]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[32180-32184]:SimpleType[32180-32184]"
    }, {
      "left" : "parseAndRecordTypeNode",
      "right" : "parseAndRecordTypeNode",
      "info" : "SimpleName[32185-32207]:SimpleName[32185-32207]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[32208-32224]:SingleVariableDeclaration[32208-32224]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[32226-32236]:SingleVariableDeclaration[32226-32236]"
    }, {
      "left" : "int startCharno",
      "right" : "int startCharno",
      "info" : "SingleVariableDeclaration[32244-32259]:SingleVariableDeclaration[32244-32259]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32261-32368]:Block[32261-32368]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, lineno, startCharno,\n        token == JsDocToken.LC, false);",
      "right" : "return parseAndRecordTypeNode(token, lineno, startCharno,\n        token == JsDocToken.LC, false);",
      "info" : "ReturnStatement[32267-32364]:ReturnStatement[32267-32364]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[32807-32814]:Modifier[32807-32814]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[32815-32819]:SimpleType[32815-32819]"
    }, {
      "left" : "parseAndRecordTypeNameNode",
      "right" : "parseAndRecordTypeNameNode",
      "info" : "SimpleName[32820-32846]:SimpleName[32820-32846]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[32847-32863]:SingleVariableDeclaration[32847-32863]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[32865-32875]:SingleVariableDeclaration[32865-32875]"
    }, {
      "left" : "int startCharno",
      "right" : "int startCharno",
      "info" : "SingleVariableDeclaration[32919-32934]:SingleVariableDeclaration[32919-32934]"
    }, {
      "left" : "boolean matchingLC",
      "right" : "boolean matchingLC",
      "info" : "SingleVariableDeclaration[32936-32954]:SingleVariableDeclaration[32936-32954]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32956-33042]:Block[32956-33042]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
      "right" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
      "info" : "ReturnStatement[32962-33038]:ReturnStatement[32962-33038]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[33502-33509]:Modifier[33502-33509]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[33510-33514]:SimpleType[33510-33514]"
    }, {
      "left" : "parseAndRecordParamTypeNode",
      "right" : "parseAndRecordParamTypeNode",
      "info" : "SimpleName[33515-33542]:SimpleName[33515-33542]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[33543-33559]:SingleVariableDeclaration[33543-33559]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33561-33915]:Block[33561-33915]"
    }, {
      "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "info" : "ExpressionStatement[33567-33619]:ExpressionStatement[33567-33619]"
    }, {
      "left" : "int lineno = stream.getLineno();",
      "right" : "int lineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[33624-33656]:VariableDeclarationStatement[33624-33656]"
    }, {
      "left" : "int startCharno = stream.getCharno();",
      "right" : "int startCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[33661-33698]:VariableDeclarationStatement[33661-33698]"
    }, {
      "left" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
      "right" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
      "info" : "VariableDeclarationStatement[33704-33762]:VariableDeclarationStatement[33704-33762]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[33767-33802]:VariableDeclarationStatement[33767-33802]"
    }, {
      "left" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        true);",
      "right" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        true);",
      "info" : "ExpressionStatement[33808-33890]:ExpressionStatement[33808-33890]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[33895-33911]:ReturnStatement[33895-33911]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[34540-34547]:Modifier[34540-34547]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[34548-34552]:SimpleType[34548-34552]"
    }, {
      "left" : "parseAndRecordTypeNode",
      "right" : "parseAndRecordTypeNode",
      "info" : "SimpleName[34553-34575]:SimpleName[34553-34575]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[34576-34592]:SingleVariableDeclaration[34576-34592]"
    }, {
      "left" : "int lineno",
      "right" : "int lineno",
      "info" : "SingleVariableDeclaration[34594-34604]:SingleVariableDeclaration[34594-34604]"
    }, {
      "left" : "int startCharno",
      "right" : "int startCharno",
      "info" : "SingleVariableDeclaration[34644-34659]:SingleVariableDeclaration[34644-34659]"
    }, {
      "left" : "boolean matchingLC",
      "right" : "boolean matchingLC",
      "info" : "SingleVariableDeclaration[34699-34717]:SingleVariableDeclaration[34699-34717]"
    }, {
      "left" : "boolean onlyParseSimpleNames",
      "right" : "boolean onlyParseSimpleNames",
      "info" : "SingleVariableDeclaration[34757-34785]:SingleVariableDeclaration[34757-34785]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34787-35239]:Block[34787-35239]"
    }, {
      "left" : "Node typeNode = null;",
      "right" : "Node typeNode = null;",
      "info" : "VariableDeclarationStatement[34793-34814]:VariableDeclarationStatement[34793-34814]"
    }, {
      "left" : "if (onlyParseSimpleNames)",
      "right" : "if (onlyParseSimpleNames)",
      "info" : "IfStatement[34820-34970]:IfStatement[34820-34970]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34846-34902]:Block[34846-34902]"
    }, {
      "left" : "typeNode = parseTypeNameAnnotation(token);",
      "right" : "typeNode = parseTypeNameAnnotation(token);",
      "info" : "ExpressionStatement[34854-34896]:ExpressionStatement[34854-34896]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34908-34970]:Block[34908-34970]"
    }, {
      "left" : "typeNode = parseTypeExpressionAnnotation(token);",
      "right" : "typeNode = parseTypeExpressionAnnotation(token);",
      "info" : "ExpressionStatement[34916-34964]:ExpressionStatement[34916-34964]"
    }, {
      "left" : "if (typeNode != null && !matchingLC)",
      "right" : "if (typeNode != null && !matchingLC)",
      "info" : "IfStatement[34976-35078]:IfStatement[34976-35078]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35013-35078]:Block[35013-35078]"
    }, {
      "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "info" : "ExpressionStatement[35021-35072]:ExpressionStatement[35021-35072]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[35084-35119]:VariableDeclarationStatement[35084-35119]"
    }, {
      "left" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        matchingLC);",
      "right" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        matchingLC);",
      "info" : "ExpressionStatement[35125-35213]:ExpressionStatement[35125-35213]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[35219-35235]:ReturnStatement[35219-35235]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[35379-35386]:Modifier[35379-35386]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[35387-35394]:PrimitiveType[35387-35394]"
    }, {
      "left" : "isValidDefineType",
      "right" : "isValidDefineType",
      "info" : "SimpleName[35395-35412]:SimpleName[35395-35412]"
    }, {
      "left" : "Node typeNode",
      "right" : "Node typeNode",
      "info" : "SingleVariableDeclaration[35413-35426]:SingleVariableDeclaration[35413-35426]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35428-35630]:Block[35428-35630]"
    }, {
      "left" : "JSType type = typeRegistry.createFromTypeNodes(typeNode, \"\", null);",
      "right" : "JSType type = typeRegistry.createFromTypeNodes(typeNode, \"\", null);",
      "info" : "VariableDeclarationStatement[35434-35501]:VariableDeclarationStatement[35434-35501]"
    }, {
      "left" : "return !type.isUnknownType() && type.isSubtype(\n        typeRegistry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN));",
      "right" : "return !type.isUnknownType() && type.isSubtype(\n        typeRegistry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN));",
      "info" : "ReturnStatement[35506-35626]:ReturnStatement[35506-35626]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[35704-35711]:Modifier[35704-35711]"
    }, {
      "left" : "String",
      "right" : "String",
      "info" : "SimpleType[35712-35718]:SimpleType[35712-35718]"
    }, {
      "left" : "toString",
      "right" : "toString",
      "info" : "SimpleName[35719-35727]:SimpleName[35719-35727]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[35728-35744]:SingleVariableDeclaration[35728-35744]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35746-36576]:Block[35746-36576]"
    }, {
      "left" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
      "right" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
      "info" : "SwitchStatement[35752-36572]:SwitchStatement[35752-36572]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[35775-35791]:SwitchCase[35775-35791]"
    }, {
      "left" : "return \"@\" + stream.getString();",
      "right" : "return \"@\" + stream.getString();",
      "info" : "ReturnStatement[35800-35832]:ReturnStatement[35800-35832]"
    }, {
      "left" : "case BANG:",
      "right" : "case BANG:",
      "info" : "SwitchCase[35840-35850]:SwitchCase[35840-35850]"
    }, {
      "left" : "return \"!\";",
      "right" : "return \"!\";",
      "info" : "ReturnStatement[35859-35870]:ReturnStatement[35859-35870]"
    }, {
      "left" : "case COMMA:",
      "right" : "case COMMA:",
      "info" : "SwitchCase[35878-35889]:SwitchCase[35878-35889]"
    }, {
      "left" : "return \",\";",
      "right" : "return \",\";",
      "info" : "ReturnStatement[35898-35909]:ReturnStatement[35898-35909]"
    }, {
      "left" : "case COLON:",
      "right" : "case COLON:",
      "info" : "SwitchCase[35917-35928]:SwitchCase[35917-35928]"
    }, {
      "left" : "return \":\";",
      "right" : "return \":\";",
      "info" : "ReturnStatement[35937-35948]:ReturnStatement[35937-35948]"
    }, {
      "left" : "case GT:",
      "right" : "case GT:",
      "info" : "SwitchCase[35956-35964]:SwitchCase[35956-35964]"
    }, {
      "left" : "return \">\";",
      "right" : "return \">\";",
      "info" : "ReturnStatement[35973-35984]:ReturnStatement[35973-35984]"
    }, {
      "left" : "case LB:",
      "right" : "case LB:",
      "info" : "SwitchCase[35992-36000]:SwitchCase[35992-36000]"
    }, {
      "left" : "return \"[\";",
      "right" : "return \"[\";",
      "info" : "ReturnStatement[36009-36020]:ReturnStatement[36009-36020]"
    }, {
      "left" : "case LC:",
      "right" : "case LC:",
      "info" : "SwitchCase[36028-36036]:SwitchCase[36028-36036]"
    }, {
      "left" : "return \"{\";",
      "right" : "return \"{\";",
      "info" : "ReturnStatement[36045-36056]:ReturnStatement[36045-36056]"
    }, {
      "left" : "case LP:",
      "right" : "case LP:",
      "info" : "SwitchCase[36064-36072]:SwitchCase[36064-36072]"
    }, {
      "left" : "return \"(\";",
      "right" : "return \"(\";",
      "info" : "ReturnStatement[36081-36092]:ReturnStatement[36081-36092]"
    }, {
      "left" : "case LT:",
      "right" : "case LT:",
      "info" : "SwitchCase[36100-36108]:SwitchCase[36100-36108]"
    }, {
      "left" : "return \".<\";",
      "right" : "return \".<\";",
      "info" : "ReturnStatement[36117-36129]:ReturnStatement[36117-36129]"
    }, {
      "left" : "case QMARK:",
      "right" : "case QMARK:",
      "info" : "SwitchCase[36137-36148]:SwitchCase[36137-36148]"
    }, {
      "left" : "return \"?\";",
      "right" : "return \"?\";",
      "info" : "ReturnStatement[36157-36168]:ReturnStatement[36157-36168]"
    }, {
      "left" : "case PIPE:",
      "right" : "case PIPE:",
      "info" : "SwitchCase[36176-36186]:SwitchCase[36176-36186]"
    }, {
      "left" : "return \"|\";",
      "right" : "return \"|\";",
      "info" : "ReturnStatement[36195-36206]:ReturnStatement[36195-36206]"
    }, {
      "left" : "case RB:",
      "right" : "case RB:",
      "info" : "SwitchCase[36214-36222]:SwitchCase[36214-36222]"
    }, {
      "left" : "return \"]\";",
      "right" : "return \"]\";",
      "info" : "ReturnStatement[36231-36242]:ReturnStatement[36231-36242]"
    }, {
      "left" : "case RC:",
      "right" : "case RC:",
      "info" : "SwitchCase[36250-36258]:SwitchCase[36250-36258]"
    }, {
      "left" : "return \"}\";",
      "right" : "return \"}\";",
      "info" : "ReturnStatement[36267-36278]:ReturnStatement[36267-36278]"
    }, {
      "left" : "case RP:",
      "right" : "case RP:",
      "info" : "SwitchCase[36286-36294]:SwitchCase[36286-36294]"
    }, {
      "left" : "return \")\";",
      "right" : "return \")\";",
      "info" : "ReturnStatement[36303-36314]:ReturnStatement[36303-36314]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[36322-36332]:SwitchCase[36322-36332]"
    }, {
      "left" : "return \"*\";",
      "right" : "return \"*\";",
      "info" : "ReturnStatement[36341-36352]:ReturnStatement[36341-36352]"
    }, {
      "left" : "case ELLIPSIS:",
      "right" : "case ELLIPSIS:",
      "info" : "SwitchCase[36360-36374]:SwitchCase[36360-36374]"
    }, {
      "left" : "return \"...\";",
      "right" : "return \"...\";",
      "info" : "ReturnStatement[36383-36396]:ReturnStatement[36383-36396]"
    }, {
      "left" : "case EQUALS:",
      "right" : "case EQUALS:",
      "info" : "SwitchCase[36404-36416]:SwitchCase[36404-36416]"
    }, {
      "left" : "return \"=\";",
      "right" : "return \"=\";",
      "info" : "ReturnStatement[36425-36436]:ReturnStatement[36425-36436]"
    }, {
      "left" : "case STRING:",
      "right" : "case STRING:",
      "info" : "SwitchCase[36444-36456]:SwitchCase[36444-36456]"
    }, {
      "left" : "return stream.getString();",
      "right" : "return stream.getString();",
      "info" : "ReturnStatement[36465-36491]:ReturnStatement[36465-36491]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[36499-36507]:SwitchCase[36499-36507]"
    }, {
      "left" : "throw new IllegalStateException(token.toString());",
      "right" : "throw new IllegalStateException(token.toString());",
      "info" : "ThrowStatement[36516-36566]:ThrowStatement[36516-36566]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[36675-36682]:Modifier[36675-36682]"
    }, {
      "left" : "JSTypeExpression",
      "right" : "JSTypeExpression",
      "info" : "SimpleType[36683-36699]:SimpleType[36683-36699]"
    }, {
      "left" : "createJSTypeExpression",
      "right" : "createJSTypeExpression",
      "info" : "SimpleName[36700-36722]:SimpleName[36700-36722]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[36723-36729]:SingleVariableDeclaration[36723-36729]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36731-36825]:Block[36731-36825]"
    }, {
      "left" : "return n == null ? null :\n        new JSTypeExpression(n, sourceName, typeRegistry);",
      "right" : "return n == null ? null :\n        new JSTypeExpression(n, sourceName, typeRegistry);",
      "info" : "ReturnStatement[36737-36821]:ReturnStatement[36737-36821]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[36974-36981]:Modifier[36974-36981]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[36982-36988]:Modifier[36982-36988]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[36989-36994]:TYPE_DECLARATION_KIND[36989-36994]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleName[36995-37009]:SimpleName[36995-37009]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[37086-37092]:Modifier[37086-37092]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleName[37093-37107]:SimpleName[37093-37107]"
    }, {
      "left" : "String string",
      "right" : "String string",
      "info" : "SingleVariableDeclaration[37108-37121]:SingleVariableDeclaration[37108-37121]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[37123-37139]:SingleVariableDeclaration[37123-37139]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37141-37202]:Block[37141-37202]"
    }, {
      "left" : "this.string = string;",
      "right" : "this.string = string;",
      "info" : "ExpressionStatement[37149-37170]:ExpressionStatement[37149-37170]"
    }, {
      "left" : "this.token = token;",
      "right" : "this.token = token;",
      "info" : "ExpressionStatement[37177-37196]:ExpressionStatement[37177-37196]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[37208-37214]:Modifier[37208-37214]"
    }, {
      "left" : "String",
      "right" : "String",
      "info" : "SimpleType[37215-37221]:SimpleType[37215-37221]"
    }, {
      "left" : "getString",
      "right" : "getString",
      "info" : "SimpleName[37222-37231]:SimpleName[37222-37231]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37234-37262]:Block[37234-37262]"
    }, {
      "left" : "return string;",
      "right" : "return string;",
      "info" : "ReturnStatement[37242-37256]:ReturnStatement[37242-37256]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[37268-37274]:Modifier[37268-37274]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[37275-37285]:SimpleType[37275-37285]"
    }, {
      "left" : "getToken",
      "right" : "getToken",
      "info" : "SimpleName[37286-37294]:SimpleName[37286-37294]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37297-37324]:Block[37297-37324]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[37305-37318]:ReturnStatement[37305-37318]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[37585-37592]:Modifier[37585-37592]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[37593-37607]:SimpleType[37593-37607]"
    }, {
      "left" : "extractSingleLineBlock",
      "right" : "extractSingleLineBlock",
      "info" : "SimpleName[37608-37630]:SimpleName[37608-37630]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37633-38067]:Block[37633-38067]"
    }, {
      "left" : "stream.update();",
      "right" : "stream.update();",
      "info" : "ExpressionStatement[37679-37695]:ExpressionStatement[37679-37695]"
    }, {
      "left" : "int lineno = stream.getLineno();",
      "right" : "int lineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[37700-37732]:VariableDeclarationStatement[37700-37732]"
    }, {
      "left" : "int charno = stream.getCharno() + 1;",
      "right" : "int charno = stream.getCharno() + 1;",
      "info" : "VariableDeclarationStatement[37737-37773]:VariableDeclarationStatement[37737-37773]"
    }, {
      "left" : "String line = stream.getRemainingJSDocLine().trim();",
      "right" : "String line = stream.getRemainingJSDocLine().trim();",
      "info" : "VariableDeclarationStatement[37779-37831]:VariableDeclarationStatement[37779-37831]"
    }, {
      "left" : "if (line.length() > 0)",
      "right" : "if (line.length() > 0)",
      "info" : "IfStatement[37876-38017]:IfStatement[37876-38017]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37899-38017]:Block[37899-38017]"
    }, {
      "left" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
      "right" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
      "info" : "ExpressionStatement[37907-38011]:ExpressionStatement[37907-38011]"
    }, {
      "left" : "return new ExtractionInfo(line, next());",
      "right" : "return new ExtractionInfo(line, next());",
      "info" : "ReturnStatement[38023-38063]:ReturnStatement[38023-38063]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[38071-38078]:Modifier[38071-38078]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[38079-38093]:SimpleType[38079-38093]"
    }, {
      "left" : "extractMultilineTextualBlock",
      "right" : "extractMultilineTextualBlock",
      "info" : "SimpleName[38094-38122]:SimpleName[38094-38122]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[38123-38139]:SingleVariableDeclaration[38123-38139]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38141-38224]:Block[38141-38224]"
    }, {
      "left" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
      "right" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
      "info" : "ReturnStatement[38147-38220]:ReturnStatement[38147-38220]"
    }, {
      "left" : "@SuppressWarnings(\"fallthrough\")",
      "right" : "@SuppressWarnings(\"fallthrough\")",
      "info" : "SingleMemberAnnotation[39133-39165]:SingleMemberAnnotation[39133-39165]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[39168-39175]:Modifier[39168-39175]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[39176-39190]:SimpleType[39176-39190]"
    }, {
      "left" : "extractMultilineTextualBlock",
      "right" : "extractMultilineTextualBlock",
      "info" : "SimpleName[39191-39219]:SimpleName[39191-39219]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[39220-39236]:SingleVariableDeclaration[39220-39236]"
    }, {
      "left" : "WhitespaceOption option",
      "right" : "WhitespaceOption option",
      "info" : "SingleVariableDeclaration[39292-39315]:SingleVariableDeclaration[39292-39315]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39317-41546]:Block[39317-41664]"
    }, {
      "left" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
      "right" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
      "info" : "IfStatement[39324-39466]:IfStatement[39324-39466]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39415-39466]:Block[39415-39466]"
    }, {
      "left" : "return new ExtractionInfo(\"\", token);",
      "right" : "return new ExtractionInfo(\"\", token);",
      "info" : "ReturnStatement[39423-39460]:ReturnStatement[39423-39460]"
    }, {
      "left" : "stream.update();",
      "right" : "stream.update();",
      "info" : "ExpressionStatement[39472-39488]:ExpressionStatement[39472-39488]"
    }, {
      "left" : "int startLineno = stream.getLineno();",
      "right" : "int startLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[39493-39530]:VariableDeclarationStatement[39493-39530]"
    }, {
      "left" : "int startCharno = stream.getCharno() + 1;",
      "right" : "int startCharno = stream.getCharno() + 1;",
      "info" : "VariableDeclarationStatement[39535-39576]:VariableDeclarationStatement[39535-39576]"
    }, {
      "left" : "String line = stream.getRemainingJSDocLine();",
      "right" : "String line = stream.getRemainingJSDocLine();",
      "info" : "VariableDeclarationStatement[39627-39672]:VariableDeclarationStatement[39627-39672]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[39678-39752]:IfStatement[39678-39752]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39719-39752]:Block[39719-39752]"
    }, {
      "left" : "line = line.trim();",
      "right" : "line = line.trim();",
      "info" : "ExpressionStatement[39727-39746]:ExpressionStatement[39727-39746]"
    }, {
      "left" : "StringBuilder builder = new StringBuilder();",
      "right" : "StringBuilder builder = new StringBuilder();",
      "info" : "VariableDeclarationStatement[39758-39802]:VariableDeclarationStatement[39758-39802]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[39807-39828]:ExpressionStatement[39807-39828]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[39834-39869]:ExpressionStatement[39834-39869]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[39874-39889]:ExpressionStatement[39874-39889]"
    }, {
      "left" : "boolean ignoreStar = false;",
      "right" : "boolean ignoreStar = false;",
      "info" : "VariableDeclarationStatement[39895-39922]:VariableDeclarationStatement[39895-39922]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[39928-41542]:DoStatement[39928-41660]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39931-41528]:Block[39931-41646]"
    }, {
      "left" : "switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
      "right" : "switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n          if (!(option == WhitespaceOption.PRESERVE &&\n                token == JsDocToken.ANNOTATION)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
      "info" : "SwitchStatement[39939-41522]:SwitchStatement[39939-41640]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[39964-39974]:SwitchCase[39964-39974]"
    }, {
      "left" : "if (!ignoreStar)",
      "right" : "if (!ignoreStar)",
      "info" : "IfStatement[39985-40138]:IfStatement[39985-40138]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40002-40138]:Block[40002-40138]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[40016-40092]:IfStatement[40016-40092]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40042-40092]:Block[40042-40092]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[40058-40078]:ExpressionStatement[40058-40078]"
    }, {
      "left" : "builder.append('*');",
      "right" : "builder.append('*');",
      "info" : "ExpressionStatement[40106-40126]:ExpressionStatement[40106-40126]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[40150-40165]:ExpressionStatement[40150-40165]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[40176-40185]:ContinueStatement[40176-40185]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[40195-40204]:SwitchCase[40195-40204]"
    }, {
      "left" : "if (option != WhitespaceOption.SINGLE_LINE)",
      "right" : "if (option != WhitespaceOption.SINGLE_LINE)",
      "info" : "IfStatement[40215-40306]:IfStatement[40215-40306]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40259-40306]:Block[40259-40306]"
    }, {
      "left" : "builder.append(\"\\n\");",
      "right" : "builder.append(\"\\n\");",
      "info" : "ExpressionStatement[40273-40294]:ExpressionStatement[40273-40294]"
    }, {
      "left" : "ignoreStar = true;",
      "right" : "ignoreStar = true;",
      "info" : "ExpressionStatement[40318-40336]:ExpressionStatement[40318-40336]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[40347-40362]:ExpressionStatement[40347-40362]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[40373-40382]:ContinueStatement[40373-40382]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[40392-40408]:SwitchCase[40392-40408]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[40417-40426]:SwitchCase[40417-40426]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[40435-40444]:SwitchCase[40435-40444]"
    }, {
      "left" : "String multilineText = builder.toString();",
      "right" : "String multilineText = builder.toString();",
      "info" : "VariableDeclarationStatement[40554-40596]:VariableDeclarationStatement[40660-40702]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[40610-40718]:IfStatement[40716-40824]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40651-40718]:Block[40757-40824]"
    }, {
      "left" : "multilineText = multilineText.trim();",
      "right" : "multilineText = multilineText.trim();",
      "info" : "ExpressionStatement[40667-40704]:ExpressionStatement[40773-40810]"
    }, {
      "left" : "int endLineno = stream.getLineno();",
      "right" : "int endLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[40732-40767]:VariableDeclarationStatement[40838-40873]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[40780-40815]:VariableDeclarationStatement[40886-40921]"
    }, {
      "left" : "if (multilineText.length() > 0)",
      "right" : "if (multilineText.length() > 0)",
      "info" : "IfStatement[40829-40994]:IfStatement[40935-41100]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40861-40994]:Block[40967-41100]"
    }, {
      "left" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
      "right" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
      "info" : "ExpressionStatement[40877-40980]:ExpressionStatement[40983-41086]"
    }, {
      "left" : "return new ExtractionInfo(multilineText, token);",
      "right" : "return new ExtractionInfo(multilineText, token);",
      "info" : "ReturnStatement[41008-41056]:ReturnStatement[41114-41162]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[41093-41101]:SwitchCase[41211-41219]"
    }, {
      "left" : "ignoreStar = false;",
      "right" : "ignoreStar = false;",
      "info" : "ExpressionStatement[41112-41131]:ExpressionStatement[41230-41249]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[41142-41177]:ExpressionStatement[41260-41295]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[41189-41261]:IfStatement[41307-41379]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41215-41261]:Block[41333-41379]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[41229-41249]:ExpressionStatement[41347-41367]"
    }, {
      "left" : "builder.append(toString(token));",
      "right" : "builder.append(toString(token));",
      "info" : "ExpressionStatement[41273-41305]:ExpressionStatement[41391-41423]"
    }, {
      "left" : "line = stream.getRemainingJSDocLine();",
      "right" : "line = stream.getRemainingJSDocLine();",
      "info" : "ExpressionStatement[41317-41355]:ExpressionStatement[41435-41473]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[41367-41455]:IfStatement[41485-41573]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[41408-41455]:Block[41526-41573]"
    }, {
      "left" : "line = trimEnd(line);",
      "right" : "line = trimEnd(line);",
      "info" : "ExpressionStatement[41422-41443]:ExpressionStatement[41540-41561]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[41467-41488]:ExpressionStatement[41585-41606]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[41499-41514]:ExpressionStatement[41617-41632]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[42013-42020]:Modifier[42131-42138]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "SimpleType[42021-42035]:SimpleType[42139-42153]"
    }, {
      "left" : "extractBlockComment",
      "right" : "extractBlockComment",
      "info" : "SimpleName[42036-42055]:SimpleName[42154-42173]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[42056-42072]:SingleVariableDeclaration[42174-42190]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42074-43048]:Block[42192-43166]"
    }, {
      "left" : "StringBuilder builder = new StringBuilder();",
      "right" : "StringBuilder builder = new StringBuilder();",
      "info" : "VariableDeclarationStatement[42080-42124]:VariableDeclarationStatement[42198-42242]"
    }, {
      "left" : "boolean ignoreStar = true;",
      "right" : "boolean ignoreStar = true;",
      "info" : "VariableDeclarationStatement[42130-42156]:VariableDeclarationStatement[42248-42274]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[42162-43044]:DoStatement[42280-43162]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42165-43030]:Block[42283-43148]"
    }, {
      "left" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
      "right" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
      "info" : "SwitchStatement[42173-43024]:SwitchStatement[42291-43142]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[42198-42214]:SwitchCase[42316-42332]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[42223-42232]:SwitchCase[42341-42350]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[42241-42250]:SwitchCase[42359-42368]"
    }, {
      "left" : "return new ExtractionInfo(builder.toString().trim(), token);",
      "right" : "return new ExtractionInfo(builder.toString().trim(), token);",
      "info" : "ReturnStatement[42261-42321]:ReturnStatement[42379-42439]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[42331-42341]:SwitchCase[42449-42459]"
    }, {
      "left" : "if (!ignoreStar)",
      "right" : "if (!ignoreStar)",
      "info" : "IfStatement[42352-42505]:IfStatement[42470-42623]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42369-42505]:Block[42487-42623]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[42383-42459]:IfStatement[42501-42577]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42409-42459]:Block[42527-42577]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[42425-42445]:ExpressionStatement[42543-42563]"
    }, {
      "left" : "builder.append('*');",
      "right" : "builder.append('*');",
      "info" : "ExpressionStatement[42473-42493]:ExpressionStatement[42591-42611]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[42517-42532]:ExpressionStatement[42635-42650]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[42543-42552]:ContinueStatement[42661-42670]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[42562-42571]:SwitchCase[42680-42689]"
    }, {
      "left" : "ignoreStar = true;",
      "right" : "ignoreStar = true;",
      "info" : "ExpressionStatement[42582-42600]:ExpressionStatement[42700-42718]"
    }, {
      "left" : "builder.append('\\n');",
      "right" : "builder.append('\\n');",
      "info" : "ExpressionStatement[42611-42632]:ExpressionStatement[42729-42750]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[42643-42658]:ExpressionStatement[42761-42776]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[42669-42678]:ContinueStatement[42787-42796]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[42688-42696]:SwitchCase[42806-42814]"
    }, {
      "left" : "if (!ignoreStar && builder.length() > 0)",
      "right" : "if (!ignoreStar && builder.length() > 0)",
      "info" : "IfStatement[42707-42794]:IfStatement[42825-42912]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42748-42794]:Block[42866-42912]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[42762-42782]:ExpressionStatement[42880-42900]"
    }, {
      "left" : "ignoreStar = false;",
      "right" : "ignoreStar = false;",
      "info" : "ExpressionStatement[42806-42825]:ExpressionStatement[42924-42943]"
    }, {
      "left" : "builder.append(toString(token));",
      "right" : "builder.append(toString(token));",
      "info" : "ExpressionStatement[42837-42869]:ExpressionStatement[42955-42987]"
    }, {
      "left" : "String line = stream.getRemainingJSDocLine();",
      "right" : "String line = stream.getRemainingJSDocLine();",
      "info" : "VariableDeclarationStatement[42881-42926]:VariableDeclarationStatement[42999-43044]"
    }, {
      "left" : "line = trimEnd(line);",
      "right" : "line = trimEnd(line);",
      "info" : "ExpressionStatement[42937-42958]:ExpressionStatement[43055-43076]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[42969-42990]:ExpressionStatement[43087-43108]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[43001-43016]:ExpressionStatement[43119-43134]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[43450-43457]:Modifier[43568-43575]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[43458-43464]:Modifier[43576-43582]"
    }, {
      "left" : "String",
      "right" : "String",
      "info" : "SimpleType[43465-43471]:SimpleType[43583-43589]"
    }, {
      "left" : "trimEnd",
      "right" : "trimEnd",
      "info" : "SimpleName[43472-43479]:SimpleName[43590-43597]"
    }, {
      "left" : "String s",
      "right" : "String s",
      "info" : "SingleVariableDeclaration[43480-43488]:SingleVariableDeclaration[43598-43606]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43490-43814]:Block[43608-43932]"
    }, {
      "left" : "int trimCount = 0;",
      "right" : "int trimCount = 0;",
      "info" : "VariableDeclarationStatement[43496-43514]:VariableDeclarationStatement[43614-43632]"
    }, {
      "left" : "while (trimCount < s.length())",
      "right" : "while (trimCount < s.length())",
      "info" : "WhileStatement[43519-43710]:WhileStatement[43637-43828]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43550-43710]:Block[43668-43828]"
    }, {
      "left" : "char ch = s.charAt(s.length() - trimCount - 1);",
      "right" : "char ch = s.charAt(s.length() - trimCount - 1);",
      "info" : "VariableDeclarationStatement[43558-43605]:VariableDeclarationStatement[43676-43723]"
    }, {
      "left" : "if (Character.isWhitespace(ch))",
      "right" : "if (Character.isWhitespace(ch))",
      "info" : "IfStatement[43612-43704]:IfStatement[43730-43822]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43644-43674]:Block[43762-43792]"
    }, {
      "left" : "trimCount++;",
      "right" : "trimCount++;",
      "info" : "ExpressionStatement[43654-43666]:ExpressionStatement[43772-43784]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43680-43704]:Block[43798-43822]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[43690-43696]:BreakStatement[43808-43814]"
    }, {
      "left" : "if (trimCount == 0)",
      "right" : "if (trimCount == 0)",
      "info" : "IfStatement[43716-43759]:IfStatement[43834-43877]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43736-43759]:Block[43854-43877]"
    }, {
      "left" : "return s;",
      "right" : "return s;",
      "info" : "ReturnStatement[43744-43753]:ReturnStatement[43862-43871]"
    }, {
      "left" : "return s.substring(0, s.length() - trimCount);",
      "right" : "return s.substring(0, s.length() - trimCount);",
      "info" : "ReturnStatement[43764-43810]:ReturnStatement[43882-43928]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[44336-44343]:Modifier[44454-44461]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[44344-44348]:SimpleType[44462-44466]"
    }, {
      "left" : "parseTypeExpressionAnnotation",
      "right" : "parseTypeExpressionAnnotation",
      "info" : "SimpleName[44349-44378]:SimpleName[44467-44496]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[44379-44395]:SingleVariableDeclaration[44497-44513]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44397-44796]:Block[44515-44914]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[44403-44792]:IfStatement[44521-44910]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44431-44738]:Block[44549-44856]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[44439-44450]:ExpressionStatement[44557-44568]"
    }, {
      "left" : "Node typeNode = parseTopLevelTypeExpression(next());",
      "right" : "Node typeNode = parseTopLevelTypeExpression(next());",
      "info" : "VariableDeclarationStatement[44457-44509]:VariableDeclarationStatement[44575-44627]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[44516-44708]:IfStatement[44634-44826]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44538-44708]:Block[44656-44826]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[44548-44559]:ExpressionStatement[44666-44677]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[44568-44700]:IfStatement[44686-44818]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44595-44665]:Block[44713-44783]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[44607-44655]:ExpressionStatement[44725-44773]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44671-44700]:Block[44789-44818]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[44683-44690]:ExpressionStatement[44801-44808]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[44716-44732]:ReturnStatement[44834-44850]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44744-44792]:Block[44862-44910]"
    }, {
      "left" : "return parseTypeExpression(token);",
      "right" : "return parseTypeExpression(token);",
      "info" : "ReturnStatement[44752-44786]:ReturnStatement[44870-44904]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[45050-45057]:Modifier[45168-45175]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[45058-45062]:SimpleType[45176-45180]"
    }, {
      "left" : "parseParamTypeExpressionAnnotation",
      "right" : "parseParamTypeExpressionAnnotation",
      "info" : "SimpleName[45063-45097]:SimpleName[45181-45215]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[45098-45114]:SingleVariableDeclaration[45216-45232]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45116-45986]:Block[45234-46104]"
    }, {
      "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "info" : "ExpressionStatement[45122-45174]:ExpressionStatement[45240-45292]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[45180-45191]:ExpressionStatement[45298-45309]"
    }, {
      "left" : "boolean restArg = false;",
      "right" : "boolean restArg = false;",
      "info" : "VariableDeclarationStatement[45197-45221]:VariableDeclarationStatement[45315-45339]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[45226-45241]:ExpressionStatement[45344-45359]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[45246-45501]:IfStatement[45364-45619]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45280-45501]:Block[45398-45619]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[45288-45303]:ExpressionStatement[45406-45421]"
    }, {
      "left" : "if (token == JsDocToken.RC)",
      "right" : "if (token == JsDocToken.RC)",
      "info" : "IfStatement[45310-45473]:IfStatement[45428-45591]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45338-45473]:Block[45456-45591]"
    }, {
      "left" : "return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));",
      "right" : "return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));",
      "info" : "ReturnStatement[45410-45465]:ReturnStatement[45528-45583]"
    }, {
      "left" : "restArg = true;",
      "right" : "restArg = true;",
      "info" : "ExpressionStatement[45480-45495]:ExpressionStatement[45598-45613]"
    }, {
      "left" : "Node typeNode = parseTopLevelTypeExpression(token);",
      "right" : "Node typeNode = parseTopLevelTypeExpression(token);",
      "info" : "VariableDeclarationStatement[45507-45558]:VariableDeclarationStatement[45625-45676]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[45563-45960]:IfStatement[45681-46078]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45585-45960]:Block[45703-46078]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[45593-45604]:ExpressionStatement[45711-45722]"
    }, {
      "left" : "if (restArg)",
      "right" : "if (restArg)",
      "info" : "IfStatement[45611-45822]:IfStatement[45729-45940]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45624-45688]:Block[45742-45806]"
    }, {
      "left" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
      "right" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
      "info" : "ExpressionStatement[45634-45680]:ExpressionStatement[45752-45798]"
    }, {
      "left" : "if (match(JsDocToken.EQUALS))",
      "right" : "if (match(JsDocToken.EQUALS))",
      "info" : "IfStatement[45694-45822]:IfStatement[45812-45940]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45724-45822]:Block[45842-45940]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[45734-45741]:ExpressionStatement[45852-45859]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[45750-45761]:ExpressionStatement[45868-45879]"
    }, {
      "left" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
      "right" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
      "info" : "ExpressionStatement[45770-45814]:ExpressionStatement[45888-45932]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[45830-45954]:IfStatement[45948-46072]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45857-45923]:Block[45975-46041]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[45867-45915]:ExpressionStatement[45985-46033]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45929-45954]:Block[46047-46072]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[45939-45946]:ExpressionStatement[46057-46064]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[45966-45982]:ReturnStatement[46084-46100]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[46057-46064]:Modifier[46175-46182]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[46065-46069]:SimpleType[46183-46187]"
    }, {
      "left" : "parseTypeNameAnnotation",
      "right" : "parseTypeNameAnnotation",
      "info" : "SimpleName[46070-46093]:SimpleName[46188-46211]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[46094-46110]:SingleVariableDeclaration[46212-46228]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46112-46491]:Block[46230-46609]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[46118-46487]:IfStatement[46236-46605]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46146-46439]:Block[46264-46557]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[46154-46165]:ExpressionStatement[46272-46283]"
    }, {
      "left" : "Node typeNode = parseTypeName(next());",
      "right" : "Node typeNode = parseTypeName(next());",
      "info" : "VariableDeclarationStatement[46172-46210]:VariableDeclarationStatement[46290-46328]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[46217-46409]:IfStatement[46335-46527]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46239-46409]:Block[46357-46527]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[46249-46260]:ExpressionStatement[46367-46378]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[46269-46401]:IfStatement[46387-46519]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46296-46366]:Block[46414-46484]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[46308-46356]:ExpressionStatement[46426-46474]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46372-46401]:Block[46490-46519]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[46384-46391]:ExpressionStatement[46502-46509]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[46417-46433]:ReturnStatement[46535-46551]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46445-46487]:Block[46563-46605]"
    }, {
      "left" : "return parseTypeName(token);",
      "right" : "return parseTypeName(token);",
      "info" : "ReturnStatement[46453-46481]:ReturnStatement[46571-46599]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[46651-46658]:Modifier[46769-46776]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[46659-46663]:SimpleType[46777-46781]"
    }, {
      "left" : "parseTopLevelTypeExpression",
      "right" : "parseTopLevelTypeExpression",
      "info" : "SimpleName[46664-46691]:SimpleName[46782-46809]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[46692-46708]:SingleVariableDeclaration[46810-46826]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46710-47153]:Block[46828-47271]"
    }, {
      "left" : "Node typeExpr = parseTypeExpression(token);",
      "right" : "Node typeExpr = parseTypeExpression(token);",
      "info" : "VariableDeclarationStatement[46716-46759]:VariableDeclarationStatement[46834-46877]"
    }, {
      "left" : "if (typeExpr != null)",
      "right" : "if (typeExpr != null)",
      "info" : "IfStatement[46764-47128]:IfStatement[46882-47246]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46786-47128]:Block[46904-47246]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[46832-47122]:IfStatement[46950-47240]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46860-47122]:Block[46978-47240]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[46870-46877]:ExpressionStatement[46988-46995]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[46886-47009]:IfStatement[47004-47127]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46914-47009]:Block[47032-47127]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[46992-46999]:ExpressionStatement[47110-47117]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[47018-47029]:ExpressionStatement[47136-47147]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[47038-47053]:ExpressionStatement[47156-47171]"
    }, {
      "left" : "return parseUnionTypeWithAlternate(token, typeExpr);",
      "right" : "return parseUnionTypeWithAlternate(token, typeExpr);",
      "info" : "ReturnStatement[47062-47114]:ReturnStatement[47180-47232]"
    }, {
      "left" : "return typeExpr;",
      "right" : "return typeExpr;",
      "info" : "ReturnStatement[47133-47149]:ReturnStatement[47251-47267]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[47276-47283]:Modifier[47394-47401]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[47284-47288]:SimpleType[47402-47406]"
    }, {
      "left" : "parseTypeExpressionList",
      "right" : "parseTypeExpressionList",
      "info" : "SimpleName[47289-47312]:SimpleName[47407-47430]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[47313-47329]:SingleVariableDeclaration[47431-47447]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47331-47778]:Block[47449-47896]"
    }, {
      "left" : "Node typeExpr = parseTopLevelTypeExpression(token);",
      "right" : "Node typeExpr = parseTopLevelTypeExpression(token);",
      "info" : "VariableDeclarationStatement[47337-47388]:VariableDeclarationStatement[47455-47506]"
    }, {
      "left" : "if (typeExpr == null)",
      "right" : "if (typeExpr == null)",
      "info" : "IfStatement[47393-47441]:IfStatement[47511-47559]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47415-47441]:Block[47533-47559]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[47423-47435]:ReturnStatement[47541-47553]"
    }, {
      "left" : "Node typeList = new Node(Token.BLOCK);",
      "right" : "Node typeList = new Node(Token.BLOCK);",
      "info" : "VariableDeclarationStatement[47446-47484]:VariableDeclarationStatement[47564-47602]"
    }, {
      "left" : "typeList.addChildToBack(typeExpr);",
      "right" : "typeList.addChildToBack(typeExpr);",
      "info" : "ExpressionStatement[47489-47523]:ExpressionStatement[47607-47641]"
    }, {
      "left" : "while (match(JsDocToken.COMMA))",
      "right" : "while (match(JsDocToken.COMMA))",
      "info" : "WhileStatement[47528-47753]:WhileStatement[47646-47871]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47560-47753]:Block[47678-47871]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[47568-47575]:ExpressionStatement[47686-47693]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[47582-47593]:ExpressionStatement[47700-47711]"
    }, {
      "left" : "typeExpr = parseTopLevelTypeExpression(next());",
      "right" : "typeExpr = parseTopLevelTypeExpression(next());",
      "info" : "ExpressionStatement[47600-47647]:ExpressionStatement[47718-47765]"
    }, {
      "left" : "if (typeExpr == null)",
      "right" : "if (typeExpr == null)",
      "info" : "IfStatement[47654-47706]:IfStatement[47772-47824]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47676-47706]:Block[47794-47824]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[47686-47698]:ReturnStatement[47804-47816]"
    }, {
      "left" : "typeList.addChildToBack(typeExpr);",
      "right" : "typeList.addChildToBack(typeExpr);",
      "info" : "ExpressionStatement[47713-47747]:ExpressionStatement[47831-47865]"
    }, {
      "left" : "return typeList;",
      "right" : "return typeList;",
      "info" : "ReturnStatement[47758-47774]:ReturnStatement[47876-47892]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[47977-47984]:Modifier[48095-48102]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[47985-47989]:SimpleType[48103-48107]"
    }, {
      "left" : "parseTypeExpression",
      "right" : "parseTypeExpression",
      "info" : "SimpleName[47990-48009]:SimpleName[48108-48127]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[48010-48026]:SingleVariableDeclaration[48128-48144]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48028-48642]:Block[48146-48760]"
    }, {
      "left" : "if (token == JsDocToken.QMARK)",
      "right" : "if (token == JsDocToken.QMARK)",
      "info" : "IfStatement[48034-48638]:IfStatement[48152-48756]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48065-48142]:Block[48183-48260]"
    }, {
      "left" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(next()));",
      "right" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(next()));",
      "info" : "ReturnStatement[48073-48136]:ReturnStatement[48191-48254]"
    }, {
      "left" : "if (token == JsDocToken.BANG)",
      "right" : "if (token == JsDocToken.BANG)",
      "info" : "IfStatement[48148-48638]:IfStatement[48266-48756]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48178-48254]:Block[48296-48372]"
    }, {
      "left" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
      "right" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
      "info" : "ReturnStatement[48186-48248]:ReturnStatement[48304-48366]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48260-48638]:Block[48378-48756]"
    }, {
      "left" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
      "right" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
      "info" : "VariableDeclarationStatement[48268-48321]:VariableDeclarationStatement[48386-48439]"
    }, {
      "left" : "if (basicTypeExpr != null)",
      "right" : "if (basicTypeExpr != null)",
      "info" : "IfStatement[48328-48603]:IfStatement[48446-48721]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48355-48603]:Block[48473-48721]"
    }, {
      "left" : "if (match(JsDocToken.QMARK))",
      "right" : "if (match(JsDocToken.QMARK))",
      "info" : "IfStatement[48365-48595]:IfStatement[48483-48713]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48394-48478]:Block[48512-48596]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[48406-48413]:ExpressionStatement[48524-48531]"
    }, {
      "left" : "return wrapNode(Token.QMARK, basicTypeExpr);",
      "right" : "return wrapNode(Token.QMARK, basicTypeExpr);",
      "info" : "ReturnStatement[48424-48468]:ReturnStatement[48542-48586]"
    }, {
      "left" : "if (match(JsDocToken.BANG))",
      "right" : "if (match(JsDocToken.BANG))",
      "info" : "IfStatement[48484-48595]:IfStatement[48602-48713]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48512-48595]:Block[48630-48713]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[48524-48531]:ExpressionStatement[48642-48649]"
    }, {
      "left" : "return wrapNode(Token.BANG, basicTypeExpr);",
      "right" : "return wrapNode(Token.BANG, basicTypeExpr);",
      "info" : "ReturnStatement[48542-48585]:ReturnStatement[48660-48703]"
    }, {
      "left" : "return basicTypeExpr;",
      "right" : "return basicTypeExpr;",
      "info" : "ReturnStatement[48611-48632]:ReturnStatement[48729-48750]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[48785-48792]:Modifier[48903-48910]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[48793-48797]:SimpleType[48911-48915]"
    }, {
      "left" : "parseBasicTypeExpression",
      "right" : "parseBasicTypeExpression",
      "info" : "SimpleName[48798-48822]:SimpleName[48916-48940]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[48823-48839]:SingleVariableDeclaration[48941-48957]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48841-49615]:Block[48959-49733]"
    }, {
      "left" : "if (token == JsDocToken.STAR)",
      "right" : "if (token == JsDocToken.STAR)",
      "info" : "IfStatement[48847-49565]:IfStatement[48965-49683]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48877-48918]:Block[48995-49036]"
    }, {
      "left" : "return newNode(Token.STAR);",
      "right" : "return newNode(Token.STAR);",
      "info" : "ReturnStatement[48885-48912]:ReturnStatement[49003-49030]"
    }, {
      "left" : "if (token == JsDocToken.LB)",
      "right" : "if (token == JsDocToken.LB)",
      "info" : "IfStatement[48924-49565]:IfStatement[49042-49683]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48952-49014]:Block[49070-49132]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[48960-48971]:ExpressionStatement[49078-49089]"
    }, {
      "left" : "return parseArrayType(next());",
      "right" : "return parseArrayType(next());",
      "info" : "ReturnStatement[48978-49008]:ReturnStatement[49096-49126]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[49020-49565]:IfStatement[49138-49683]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49048-49111]:Block[49166-49229]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[49056-49067]:ExpressionStatement[49174-49185]"
    }, {
      "left" : "return parseRecordType(next());",
      "right" : "return parseRecordType(next());",
      "info" : "ReturnStatement[49074-49105]:ReturnStatement[49192-49223]"
    }, {
      "left" : "if (token == JsDocToken.LP)",
      "right" : "if (token == JsDocToken.LP)",
      "info" : "IfStatement[49117-49565]:IfStatement[49235-49683]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49145-49207]:Block[49263-49325]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[49153-49164]:ExpressionStatement[49271-49282]"
    }, {
      "left" : "return parseUnionType(next());",
      "right" : "return parseUnionType(next());",
      "info" : "ReturnStatement[49171-49201]:ReturnStatement[49289-49319]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[49213-49565]:IfStatement[49331-49683]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49245-49565]:Block[49363-49683]"
    }, {
      "left" : "String string = stream.getString();",
      "right" : "String string = stream.getString();",
      "info" : "VariableDeclarationStatement[49253-49288]:VariableDeclarationStatement[49371-49406]"
    }, {
      "left" : "if (\"function\".equals(string))",
      "right" : "if (\"function\".equals(string))",
      "info" : "IfStatement[49295-49559]:IfStatement[49413-49677]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49326-49397]:Block[49444-49515]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[49336-49347]:ExpressionStatement[49454-49465]"
    }, {
      "left" : "return parseFunctionType(next());",
      "right" : "return parseFunctionType(next());",
      "info" : "ReturnStatement[49356-49389]:ReturnStatement[49474-49507]"
    }, {
      "left" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
      "right" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
      "info" : "IfStatement[49403-49559]:IfStatement[49521-49677]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49460-49507]:Block[49578-49625]"
    }, {
      "left" : "return newStringNode(string);",
      "right" : "return newStringNode(string);",
      "info" : "ReturnStatement[49470-49499]:ReturnStatement[49588-49617]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49513-49559]:Block[49631-49677]"
    }, {
      "left" : "return parseTypeName(token);",
      "right" : "return parseTypeName(token);",
      "info" : "ReturnStatement[49523-49551]:ReturnStatement[49641-49669]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[49571-49611]:ReturnStatement[49689-49729]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[49805-49812]:Modifier[49923-49930]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[49813-49817]:SimpleType[49931-49935]"
    }, {
      "left" : "parseTypeName",
      "right" : "parseTypeName",
      "info" : "SimpleName[49818-49831]:SimpleName[49936-49949]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[49832-49848]:SingleVariableDeclaration[49950-49966]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49850-50387]:Block[49968-50505]"
    }, {
      "left" : "if (token != JsDocToken.STRING)",
      "right" : "if (token != JsDocToken.STRING)",
      "info" : "IfStatement[49856-49942]:IfStatement[49974-50060]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49888-49942]:Block[50006-50060]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[49896-49936]:ReturnStatement[50014-50054]"
    }, {
      "left" : "Node typeName = newStringNode(stream.getString());",
      "right" : "Node typeName = newStringNode(stream.getString());",
      "info" : "VariableDeclarationStatement[49948-49998]:VariableDeclarationStatement[50066-50116]"
    }, {
      "left" : "if (match(JsDocToken.LT))",
      "right" : "if (match(JsDocToken.LT))",
      "info" : "IfStatement[50003-50362]:IfStatement[50121-50480]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50029-50362]:Block[50147-50480]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[50037-50044]:ExpressionStatement[50155-50162]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[50051-50062]:ExpressionStatement[50169-50180]"
    }, {
      "left" : "Node memberType = parseTypeExpressionList(next());",
      "right" : "Node memberType = parseTypeExpressionList(next());",
      "info" : "VariableDeclarationStatement[50069-50119]:VariableDeclarationStatement[50187-50237]"
    }, {
      "left" : "if (memberType != null)",
      "right" : "if (memberType != null)",
      "info" : "IfStatement[50126-50356]:IfStatement[50244-50474]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50150-50356]:Block[50268-50474]"
    }, {
      "left" : "typeName.addChildToFront(memberType);",
      "right" : "typeName.addChildToFront(memberType);",
      "info" : "ExpressionStatement[50160-50197]:ExpressionStatement[50278-50315]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[50207-50218]:ExpressionStatement[50325-50336]"
    }, {
      "left" : "if (!match(JsDocToken.GT))",
      "right" : "if (!match(JsDocToken.GT))",
      "info" : "IfStatement[50227-50331]:IfStatement[50345-50449]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50254-50331]:Block[50372-50449]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
      "info" : "ReturnStatement[50266-50321]:ReturnStatement[50384-50439]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[50341-50348]:ExpressionStatement[50459-50466]"
    }, {
      "left" : "return typeName;",
      "right" : "return typeName;",
      "info" : "ReturnStatement[50367-50383]:ReturnStatement[50485-50501]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[50565-50572]:Modifier[50683-50690]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[50573-50577]:SimpleType[50691-50695]"
    }, {
      "left" : "parseFunctionType",
      "right" : "parseFunctionType",
      "info" : "SimpleName[50578-50595]:SimpleName[50696-50713]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[50596-50612]:SingleVariableDeclaration[50714-50730]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50614-52191]:Block[50732-52309]"
    }, {
      "left" : "if (token != JsDocToken.LP)",
      "right" : "if (token != JsDocToken.LP)",
      "info" : "IfStatement[50733-50830]:IfStatement[50851-50948]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50761-50830]:Block[50879-50948]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
      "info" : "ReturnStatement[50769-50824]:ReturnStatement[50887-50942]"
    }, {
      "left" : "Node functionType = newNode(Token.FUNCTION);",
      "right" : "Node functionType = newNode(Token.FUNCTION);",
      "info" : "VariableDeclarationStatement[50836-50880]:VariableDeclarationStatement[50954-50998]"
    }, {
      "left" : "Node parameters = null;",
      "right" : "Node parameters = null;",
      "info" : "VariableDeclarationStatement[50885-50908]:VariableDeclarationStatement[51003-51026]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[50913-50924]:ExpressionStatement[51031-51042]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[50929-51781]:IfStatement[51047-51899]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50956-51781]:Block[51074-51899]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[50964-50979]:ExpressionStatement[51082-51097]"
    }, {
      "left" : "boolean hasParams = true;",
      "right" : "boolean hasParams = true;",
      "info" : "VariableDeclarationStatement[50987-51012]:VariableDeclarationStatement[51105-51130]"
    }, {
      "left" : "if (token == JsDocToken.STRING && \"this\".equals(stream.getString()))",
      "right" : "if (token == JsDocToken.STRING && \"this\".equals(stream.getString()))",
      "info" : "IfStatement[51019-51627]:IfStatement[51137-51745]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51088-51627]:Block[51206-51745]"
    }, {
      "left" : "if (match(JsDocToken.COLON))",
      "right" : "if (match(JsDocToken.COLON))",
      "info" : "IfStatement[51098-51457]:IfStatement[51216-51575]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51127-51371]:Block[51245-51489]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[51139-51146]:ExpressionStatement[51257-51264]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[51157-51168]:ExpressionStatement[51275-51286]"
    }, {
      "left" : "Node thisType = wrapNode(Token.THIS, parseTypeName(next()));",
      "right" : "Node thisType = wrapNode(Token.THIS, parseTypeName(next()));",
      "info" : "VariableDeclarationStatement[51179-51239]:VariableDeclarationStatement[51297-51357]"
    }, {
      "left" : "if (thisType == null)",
      "right" : "if (thisType == null)",
      "info" : "IfStatement[51250-51310]:IfStatement[51368-51428]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51272-51310]:Block[51390-51428]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[51286-51298]:ReturnStatement[51404-51416]"
    }, {
      "left" : "functionType.addChildToFront(thisType);",
      "right" : "functionType.addChildToFront(thisType);",
      "info" : "ExpressionStatement[51322-51361]:ExpressionStatement[51440-51479]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51377-51457]:Block[51495-51575]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
      "info" : "ReturnStatement[51389-51447]:ReturnStatement[51507-51565]"
    }, {
      "left" : "if (match(JsDocToken.COMMA))",
      "right" : "if (match(JsDocToken.COMMA))",
      "info" : "IfStatement[51467-51619]:IfStatement[51585-51737]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51496-51573]:Block[51614-51691]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[51508-51515]:ExpressionStatement[51626-51633]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[51526-51537]:ExpressionStatement[51644-51655]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[51548-51563]:ExpressionStatement[51666-51681]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51579-51619]:Block[51697-51737]"
    }, {
      "left" : "hasParams = false;",
      "right" : "hasParams = false;",
      "info" : "ExpressionStatement[51591-51609]:ExpressionStatement[51709-51727]"
    }, {
      "left" : "if (hasParams)",
      "right" : "if (hasParams)",
      "info" : "IfStatement[51635-51775]:IfStatement[51753-51893]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51650-51775]:Block[51768-51893]"
    }, {
      "left" : "parameters = parseParametersType(token);",
      "right" : "parameters = parseParametersType(token);",
      "info" : "ExpressionStatement[51660-51700]:ExpressionStatement[51778-51818]"
    }, {
      "left" : "if (parameters == null)",
      "right" : "if (parameters == null)",
      "info" : "IfStatement[51709-51767]:IfStatement[51827-51885]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51733-51767]:Block[51851-51885]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[51745-51757]:ReturnStatement[51863-51875]"
    }, {
      "left" : "if (parameters != null)",
      "right" : "if (parameters != null)",
      "info" : "IfStatement[51787-51865]:IfStatement[51905-51983]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51811-51865]:Block[51929-51983]"
    }, {
      "left" : "functionType.addChildToBack(parameters);",
      "right" : "functionType.addChildToBack(parameters);",
      "info" : "ExpressionStatement[51819-51859]:ExpressionStatement[51937-51977]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[51871-51882]:ExpressionStatement[51989-52000]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[51887-51983]:IfStatement[52005-52101]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51914-51983]:Block[52032-52101]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "info" : "ReturnStatement[51922-51977]:ReturnStatement[52040-52095]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[51989-52000]:ExpressionStatement[52107-52118]"
    }, {
      "left" : "Node resultType = parseResultType(next());",
      "right" : "Node resultType = parseResultType(next());",
      "info" : "VariableDeclarationStatement[52005-52047]:VariableDeclarationStatement[52123-52165]"
    }, {
      "left" : "if (resultType == null)",
      "right" : "if (resultType == null)",
      "info" : "IfStatement[52052-52162]:IfStatement[52170-52280]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52076-52102]:Block[52194-52220]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[52084-52096]:ReturnStatement[52202-52214]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52108-52162]:Block[52226-52280]"
    }, {
      "left" : "functionType.addChildToBack(resultType);",
      "right" : "functionType.addChildToBack(resultType);",
      "info" : "ExpressionStatement[52116-52156]:ExpressionStatement[52234-52274]"
    }, {
      "left" : "return functionType;",
      "right" : "return functionType;",
      "info" : "ReturnStatement[52167-52187]:ReturnStatement[52285-52305]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[53386-53393]:Modifier[53504-53511]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[53394-53398]:SimpleType[53512-53516]"
    }, {
      "left" : "parseParametersType",
      "right" : "parseParametersType",
      "info" : "SimpleName[53399-53418]:SimpleName[53517-53536]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[53419-53435]:SingleVariableDeclaration[53537-53553]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53437-55282]:Block[53555-55400]"
    }, {
      "left" : "Node paramsType = newNode(Token.LP);",
      "right" : "Node paramsType = newNode(Token.LP);",
      "info" : "VariableDeclarationStatement[53443-53479]:VariableDeclarationStatement[53561-53597]"
    }, {
      "left" : "boolean isVarArgs = false;",
      "right" : "boolean isVarArgs = false;",
      "info" : "VariableDeclarationStatement[53484-53510]:VariableDeclarationStatement[53602-53628]"
    }, {
      "left" : "Node paramType = null;",
      "right" : "Node paramType = null;",
      "info" : "VariableDeclarationStatement[53515-53537]:VariableDeclarationStatement[53633-53655]"
    }, {
      "left" : "if (token != JsDocToken.RP)",
      "right" : "if (token != JsDocToken.RP)",
      "info" : "IfStatement[53542-55070]:IfStatement[53660-55188]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53570-55070]:Block[53688-55188]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[53578-55064]:DoStatement[53696-55182]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53581-55031]:Block[53699-55149]"
    }, {
      "left" : "if (paramType != null)",
      "right" : "if (paramType != null)",
      "info" : "IfStatement[53591-53724]:IfStatement[53709-53842]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53614-53724]:Block[53732-53842]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[53659-53666]:ExpressionStatement[53777-53784]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[53677-53688]:ExpressionStatement[53795-53806]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[53699-53714]:ExpressionStatement[53817-53832]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[53734-54858]:IfStatement[53852-54976]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53768-54634]:Block[53886-54752]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54000-54011]:ExpressionStatement[54118-54129]"
    }, {
      "left" : "if (match(JsDocToken.RP))",
      "right" : "if (match(JsDocToken.RP))",
      "info" : "IfStatement[54022-54595]:IfStatement[54140-54713]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54048-54110]:Block[54166-54228]"
    }, {
      "left" : "paramType = newNode(Token.ELLIPSIS);",
      "right" : "paramType = newNode(Token.ELLIPSIS);",
      "info" : "ExpressionStatement[54062-54098]:ExpressionStatement[54180-54216]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54116-54595]:Block[54234-54713]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54130-54141]:ExpressionStatement[54248-54259]"
    }, {
      "left" : "if (!match(JsDocToken.LB))",
      "right" : "if (!match(JsDocToken.LB))",
      "info" : "IfStatement[54154-54266]:IfStatement[54272-54384]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54181-54266]:Block[54299-54384]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
      "info" : "ReturnStatement[54197-54252]:ReturnStatement[54315-54370]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[54280-54287]:ExpressionStatement[54398-54405]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54300-54311]:ExpressionStatement[54418-54429]"
    }, {
      "left" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "right" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "info" : "ExpressionStatement[54324-54390]:ExpressionStatement[54442-54508]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54403-54414]:ExpressionStatement[54521-54532]"
    }, {
      "left" : "if (!match(JsDocToken.RB))",
      "right" : "if (!match(JsDocToken.RB))",
      "info" : "IfStatement[54427-54539]:IfStatement[54545-54657]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54454-54539]:Block[54572-54657]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ReturnStatement[54470-54525]:ReturnStatement[54588-54643]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54552-54563]:ExpressionStatement[54670-54681]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[54576-54583]:ExpressionStatement[54694-54701]"
    }, {
      "left" : "isVarArgs = true;",
      "right" : "isVarArgs = true;",
      "info" : "ExpressionStatement[54607-54624]:ExpressionStatement[54725-54742]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54640-54858]:Block[54758-54976]"
    }, {
      "left" : "paramType = parseTypeExpression(token);",
      "right" : "paramType = parseTypeExpression(token);",
      "info" : "ExpressionStatement[54652-54691]:ExpressionStatement[54770-54809]"
    }, {
      "left" : "if (match(JsDocToken.EQUALS))",
      "right" : "if (match(JsDocToken.EQUALS))",
      "info" : "IfStatement[54702-54848]:IfStatement[54820-54966]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54732-54848]:Block[54850-54966]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54746-54757]:ExpressionStatement[54864-54875]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[54770-54777]:ExpressionStatement[54888-54895]"
    }, {
      "left" : "paramType = wrapNode(Token.EQUALS, paramType);",
      "right" : "paramType = wrapNode(Token.EQUALS, paramType);",
      "info" : "ExpressionStatement[54790-54836]:ExpressionStatement[54908-54954]"
    }, {
      "left" : "if (paramType == null)",
      "right" : "if (paramType == null)",
      "info" : "IfStatement[54868-54925]:IfStatement[54986-55043]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54891-54925]:Block[55009-55043]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[54903-54915]:ReturnStatement[55021-55033]"
    }, {
      "left" : "paramsType.addChildToBack(paramType);",
      "right" : "paramsType.addChildToBack(paramType);",
      "info" : "ExpressionStatement[54934-54971]:ExpressionStatement[55052-55089]"
    }, {
      "left" : "if (isVarArgs)",
      "right" : "if (isVarArgs)",
      "info" : "IfStatement[54980-55023]:IfStatement[55098-55141]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54995-55023]:Block[55113-55141]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[55007-55013]:BreakStatement[55125-55131]"
    }, {
      "left" : "if (isVarArgs && match(JsDocToken.COMMA))",
      "right" : "if (isVarArgs && match(JsDocToken.COMMA))",
      "info" : "IfStatement[55076-55193]:IfStatement[55194-55311]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55118-55193]:Block[55236-55311]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
      "info" : "ReturnStatement[55126-55187]:ReturnStatement[55244-55305]"
    }, {
      "left" : "return paramsType;",
      "right" : "return paramsType;",
      "info" : "ReturnStatement[55260-55278]:ReturnStatement[55378-55396]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[55357-55364]:Modifier[55475-55482]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[55365-55369]:SimpleType[55483-55487]"
    }, {
      "left" : "parseResultType",
      "right" : "parseResultType",
      "info" : "SimpleName[55370-55385]:SimpleName[55488-55503]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[55386-55402]:SingleVariableDeclaration[55504-55520]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55404-55721]:Block[55522-55839]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[55410-55421]:ExpressionStatement[55528-55539]"
    }, {
      "left" : "if (!match(JsDocToken.COLON))",
      "right" : "if (!match(JsDocToken.COLON))",
      "info" : "IfStatement[55426-55498]:IfStatement[55544-55616]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55456-55498]:Block[55574-55616]"
    }, {
      "left" : "return newNode(Token.EMPTY);",
      "right" : "return newNode(Token.EMPTY);",
      "info" : "ReturnStatement[55464-55492]:ReturnStatement[55582-55610]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[55504-55519]:ExpressionStatement[55622-55637]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[55524-55535]:ExpressionStatement[55642-55653]"
    }, {
      "left" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
      "right" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
      "info" : "IfStatement[55540-55717]:IfStatement[55658-55835]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55607-55662]:Block[55725-55780]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[55615-55622]:ExpressionStatement[55733-55740]"
    }, {
      "left" : "return newNode(Token.VOID);",
      "right" : "return newNode(Token.VOID);",
      "info" : "ReturnStatement[55629-55656]:ReturnStatement[55747-55774]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55668-55717]:Block[55786-55835]"
    }, {
      "left" : "return parseTypeExpression(next());",
      "right" : "return parseTypeExpression(next());",
      "info" : "ReturnStatement[55676-55711]:ReturnStatement[55794-55829]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[55895-55902]:Modifier[56013-56020]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[55903-55907]:SimpleType[56021-56025]"
    }, {
      "left" : "parseUnionType",
      "right" : "parseUnionType",
      "info" : "SimpleName[55908-55922]:SimpleName[56026-56040]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[55923-55939]:SingleVariableDeclaration[56041-56057]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55941-55999]:Block[56059-56117]"
    }, {
      "left" : "return parseUnionTypeWithAlternate(token, null);",
      "right" : "return parseUnionTypeWithAlternate(token, null);",
      "info" : "ReturnStatement[55947-55995]:ReturnStatement[56065-56113]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[56125-56132]:Modifier[56243-56250]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[56133-56137]:SimpleType[56251-56255]"
    }, {
      "left" : "parseUnionTypeWithAlternate",
      "right" : "parseUnionTypeWithAlternate",
      "info" : "SimpleName[56138-56165]:SimpleName[56256-56283]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[56166-56182]:SingleVariableDeclaration[56284-56300]"
    }, {
      "left" : "Node alternate",
      "right" : "Node alternate",
      "info" : "SingleVariableDeclaration[56184-56198]:SingleVariableDeclaration[56302-56316]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56200-57201]:Block[56318-57319]"
    }, {
      "left" : "Node union = newNode(Token.PIPE);",
      "right" : "Node union = newNode(Token.PIPE);",
      "info" : "VariableDeclarationStatement[56206-56239]:VariableDeclarationStatement[56324-56357]"
    }, {
      "left" : "if (alternate != null)",
      "right" : "if (alternate != null)",
      "info" : "IfStatement[56244-56313]:IfStatement[56362-56431]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56267-56313]:Block[56385-56431]"
    }, {
      "left" : "union.addChildToBack(alternate);",
      "right" : "union.addChildToBack(alternate);",
      "info" : "ExpressionStatement[56275-56307]:ExpressionStatement[56393-56425]"
    }, {
      "left" : "Node expr = null;",
      "right" : "Node expr = null;",
      "info" : "VariableDeclarationStatement[56319-56336]:VariableDeclarationStatement[56437-56454]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[56341-57004]:DoStatement[56459-57122]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56344-56954]:Block[56462-57072]"
    }, {
      "left" : "if (expr != null)",
      "right" : "if (expr != null)",
      "info" : "IfStatement[56352-56762]:IfStatement[56470-56880]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56370-56762]:Block[56488-56880]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[56380-56391]:ExpressionStatement[56498-56509]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[56400-56415]:ExpressionStatement[56518-56533]"
    }, {
      "left" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
      "right" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
      "info" : "ExpressionStatement[56424-56517]:ExpressionStatement[56542-56635]"
    }, {
      "left" : "boolean isPipe = token == JsDocToken.PIPE;",
      "right" : "boolean isPipe = token == JsDocToken.PIPE;",
      "info" : "VariableDeclarationStatement[56527-56569]:VariableDeclarationStatement[56645-56687]"
    }, {
      "left" : "if (isPipe && match(JsDocToken.PIPE))",
      "right" : "if (isPipe && match(JsDocToken.PIPE))",
      "info" : "IfStatement[56578-56710]:IfStatement[56696-56828]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56616-56710]:Block[56734-56828]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[56693-56700]:ExpressionStatement[56811-56818]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[56719-56730]:ExpressionStatement[56837-56848]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[56739-56754]:ExpressionStatement[56857-56872]"
    }, {
      "left" : "expr = parseTypeExpression(token);",
      "right" : "expr = parseTypeExpression(token);",
      "info" : "ExpressionStatement[56769-56803]:ExpressionStatement[56887-56921]"
    }, {
      "left" : "if (expr == null)",
      "right" : "if (expr == null)",
      "info" : "IfStatement[56810-56858]:IfStatement[56928-56976]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56828-56858]:Block[56946-56976]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[56838-56850]:ReturnStatement[56956-56968]"
    }, {
      "left" : "union.addChildToBack(expr);",
      "right" : "union.addChildToBack(expr);",
      "info" : "ExpressionStatement[56866-56893]:ExpressionStatement[56984-57011]"
    }, {
      "left" : "if (alternate == null)",
      "right" : "if (alternate == null)",
      "info" : "IfStatement[57010-57179]:IfStatement[57128-57297]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57033-57179]:Block[57151-57297]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57041-57052]:ExpressionStatement[57159-57170]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[57059-57159]:IfStatement[57177-57277]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57086-57159]:Block[57204-57277]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "info" : "ReturnStatement[57096-57151]:ReturnStatement[57214-57269]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[57166-57173]:ExpressionStatement[57284-57291]"
    }, {
      "left" : "return union;",
      "right" : "return union;",
      "info" : "ReturnStatement[57184-57197]:ReturnStatement[57302-57315]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[57377-57384]:Modifier[57495-57502]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[57385-57389]:SimpleType[57503-57507]"
    }, {
      "left" : "parseArrayType",
      "right" : "parseArrayType",
      "info" : "SimpleName[57390-57404]:SimpleName[57508-57522]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[57405-57421]:SingleVariableDeclaration[57523-57539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57423-58148]:Block[57541-58266]"
    }, {
      "left" : "Node array = newNode(Token.LB);",
      "right" : "Node array = newNode(Token.LB);",
      "info" : "VariableDeclarationStatement[57429-57460]:VariableDeclarationStatement[57547-57578]"
    }, {
      "left" : "Node arg = null;",
      "right" : "Node arg = null;",
      "info" : "VariableDeclarationStatement[57465-57481]:VariableDeclarationStatement[57583-57599]"
    }, {
      "left" : "boolean hasVarArgs = false;",
      "right" : "boolean hasVarArgs = false;",
      "info" : "VariableDeclarationStatement[57486-57513]:VariableDeclarationStatement[57604-57631]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[57519-58012]:DoStatement[57637-58130]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57522-57979]:Block[57640-58097]"
    }, {
      "left" : "if (arg != null)",
      "right" : "if (arg != null)",
      "info" : "IfStatement[57530-57616]:IfStatement[57648-57734]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57547-57616]:Block[57665-57734]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[57557-57564]:ExpressionStatement[57675-57682]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57573-57584]:ExpressionStatement[57691-57702]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[57593-57608]:ExpressionStatement[57711-57726]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[57623-57819]:IfStatement[57741-57937]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57657-57762]:Block[57775-57880]"
    }, {
      "left" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "right" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "info" : "ExpressionStatement[57667-57727]:ExpressionStatement[57785-57845]"
    }, {
      "left" : "hasVarArgs = true;",
      "right" : "hasVarArgs = true;",
      "info" : "ExpressionStatement[57736-57754]:ExpressionStatement[57854-57872]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57768-57819]:Block[57886-57937]"
    }, {
      "left" : "arg = parseTypeExpression(token);",
      "right" : "arg = parseTypeExpression(token);",
      "info" : "ExpressionStatement[57778-57811]:ExpressionStatement[57896-57929]"
    }, {
      "left" : "if (arg == null)",
      "right" : "if (arg == null)",
      "info" : "IfStatement[57827-57874]:IfStatement[57945-57992]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57844-57874]:Block[57962-57992]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[57854-57866]:ReturnStatement[57972-57984]"
    }, {
      "left" : "array.addChildToBack(arg);",
      "right" : "array.addChildToBack(arg);",
      "info" : "ExpressionStatement[57882-57908]:ExpressionStatement[58000-58026]"
    }, {
      "left" : "if (hasVarArgs)",
      "right" : "if (hasVarArgs)",
      "info" : "IfStatement[57915-57955]:IfStatement[58033-58073]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57931-57955]:Block[58049-58073]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[57941-57947]:BreakStatement[58059-58065]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57962-57973]:ExpressionStatement[58080-58091]"
    }, {
      "left" : "if (!match(JsDocToken.RB))",
      "right" : "if (!match(JsDocToken.RB))",
      "info" : "IfStatement[58018-58114]:IfStatement[58136-58232]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58045-58114]:Block[58163-58232]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ReturnStatement[58053-58108]:ReturnStatement[58171-58226]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[58119-58126]:ExpressionStatement[58237-58244]"
    }, {
      "left" : "return array;",
      "right" : "return array;",
      "info" : "ReturnStatement[58131-58144]:ReturnStatement[58249-58262]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[58205-58212]:Modifier[58323-58330]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[58213-58217]:SimpleType[58331-58335]"
    }, {
      "left" : "parseRecordType",
      "right" : "parseRecordType",
      "info" : "SimpleName[58218-58233]:SimpleName[58336-58351]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[58234-58250]:SingleVariableDeclaration[58352-58368]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58252-58638]:Block[58370-58756]"
    }, {
      "left" : "Node recordType = newNode(Token.LC);",
      "right" : "Node recordType = newNode(Token.LC);",
      "info" : "VariableDeclarationStatement[58258-58294]:VariableDeclarationStatement[58376-58412]"
    }, {
      "left" : "Node fieldTypeList = parseFieldTypeList(token);",
      "right" : "Node fieldTypeList = parseFieldTypeList(token);",
      "info" : "VariableDeclarationStatement[58299-58346]:VariableDeclarationStatement[58417-58464]"
    }, {
      "left" : "if (fieldTypeList == null)",
      "right" : "if (fieldTypeList == null)",
      "info" : "IfStatement[58352-58433]:IfStatement[58470-58551]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58379-58433]:Block[58497-58551]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[58387-58427]:ReturnStatement[58505-58545]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58439-58450]:ExpressionStatement[58557-58568]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[58455-58551]:IfStatement[58573-58669]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58482-58551]:Block[58600-58669]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ReturnStatement[58490-58545]:ReturnStatement[58608-58663]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[58557-58564]:ExpressionStatement[58675-58682]"
    }, {
      "left" : "recordType.addChildToBack(fieldTypeList);",
      "right" : "recordType.addChildToBack(fieldTypeList);",
      "info" : "ExpressionStatement[58570-58611]:ExpressionStatement[58688-58729]"
    }, {
      "left" : "return recordType;",
      "right" : "return recordType;",
      "info" : "ReturnStatement[58616-58634]:ReturnStatement[58734-58752]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[58716-58723]:Modifier[58834-58841]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[58724-58728]:SimpleType[58842-58846]"
    }, {
      "left" : "parseFieldTypeList",
      "right" : "parseFieldTypeList",
      "info" : "SimpleName[58729-58747]:SimpleName[58847-58865]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[58748-58764]:SingleVariableDeclaration[58866-58882]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58766-59242]:Block[58884-59360]"
    }, {
      "left" : "Node fieldTypeList = newNode(Token.LB);",
      "right" : "Node fieldTypeList = newNode(Token.LB);",
      "info" : "VariableDeclarationStatement[58772-58811]:VariableDeclarationStatement[58890-58929]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[58817-59211]:DoStatement[58935-59329]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58820-59197]:Block[58938-59315]"
    }, {
      "left" : "Node fieldType = parseFieldType(token);",
      "right" : "Node fieldType = parseFieldType(token);",
      "info" : "VariableDeclarationStatement[58828-58867]:VariableDeclarationStatement[58946-58985]"
    }, {
      "left" : "if (fieldType == null)",
      "right" : "if (fieldType == null)",
      "info" : "IfStatement[58875-58928]:IfStatement[58993-59046]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58898-58928]:Block[59016-59046]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[58908-58920]:ReturnStatement[59026-59038]"
    }, {
      "left" : "fieldTypeList.addChildToBack(fieldType);",
      "right" : "fieldTypeList.addChildToBack(fieldType);",
      "info" : "ExpressionStatement[58936-58976]:ExpressionStatement[59054-59094]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58984-58995]:ExpressionStatement[59102-59113]"
    }, {
      "left" : "if (!match(JsDocToken.COMMA))",
      "right" : "if (!match(JsDocToken.COMMA))",
      "info" : "IfStatement[59002-59056]:IfStatement[59120-59174]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59032-59056]:Block[59150-59174]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[59042-59048]:BreakStatement[59160-59166]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[59098-59105]:ExpressionStatement[59216-59223]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[59158-59169]:ExpressionStatement[59276-59287]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[59176-59191]:ExpressionStatement[59294-59309]"
    }, {
      "left" : "return fieldTypeList;",
      "right" : "return fieldTypeList;",
      "info" : "ReturnStatement[59217-59238]:ReturnStatement[59335-59356]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[59317-59324]:Modifier[59435-59442]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[59325-59329]:SimpleType[59443-59447]"
    }, {
      "left" : "parseFieldType",
      "right" : "parseFieldType",
      "info" : "SimpleName[59330-59344]:SimpleName[59448-59462]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[59345-59361]:SingleVariableDeclaration[59463-59479]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59363-59953]:Block[59481-60071]"
    }, {
      "left" : "Node fieldName = parseFieldName(token);",
      "right" : "Node fieldName = parseFieldName(token);",
      "info" : "VariableDeclarationStatement[59369-59408]:VariableDeclarationStatement[59487-59526]"
    }, {
      "left" : "if (fieldName == null)",
      "right" : "if (fieldName == null)",
      "info" : "IfStatement[59414-59463]:IfStatement[59532-59581]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59437-59463]:Block[59555-59581]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[59445-59457]:ReturnStatement[59563-59575]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[59469-59480]:ExpressionStatement[59587-59598]"
    }, {
      "left" : "if (!match(JsDocToken.COLON))",
      "right" : "if (!match(JsDocToken.COLON))",
      "info" : "IfStatement[59485-59546]:IfStatement[59603-59664]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59515-59546]:Block[59633-59664]"
    }, {
      "left" : "return fieldName;",
      "right" : "return fieldName;",
      "info" : "ReturnStatement[59523-59540]:ReturnStatement[59641-59658]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[59578-59585]:ExpressionStatement[59696-59703]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[59670-59681]:ExpressionStatement[59788-59799]"
    }, {
      "left" : "Node typeExpression = parseTypeExpression(next());",
      "right" : "Node typeExpression = parseTypeExpression(next());",
      "info" : "VariableDeclarationStatement[59686-59736]:VariableDeclarationStatement[59804-59854]"
    }, {
      "left" : "if (typeExpression == null)",
      "right" : "if (typeExpression == null)",
      "info" : "IfStatement[59742-59796]:IfStatement[59860-59914]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59770-59796]:Block[59888-59914]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[59778-59790]:ReturnStatement[59896-59908]"
    }, {
      "left" : "Node fieldType = newNode(Token.COLON);",
      "right" : "Node fieldType = newNode(Token.COLON);",
      "info" : "VariableDeclarationStatement[59802-59840]:VariableDeclarationStatement[59920-59958]"
    }, {
      "left" : "fieldType.addChildToBack(fieldName);",
      "right" : "fieldType.addChildToBack(fieldName);",
      "info" : "ExpressionStatement[59845-59881]:ExpressionStatement[59963-59999]"
    }, {
      "left" : "fieldType.addChildToBack(typeExpression);",
      "right" : "fieldType.addChildToBack(typeExpression);",
      "info" : "ExpressionStatement[59886-59927]:ExpressionStatement[60004-60045]"
    }, {
      "left" : "return fieldType;",
      "right" : "return fieldType;",
      "info" : "ReturnStatement[59932-59949]:ReturnStatement[60050-60067]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[60060-60067]:Modifier[60178-60185]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[60068-60072]:SimpleType[60186-60190]"
    }, {
      "left" : "parseFieldName",
      "right" : "parseFieldName",
      "info" : "SimpleName[60073-60087]:SimpleName[60191-60205]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[60088-60104]:SingleVariableDeclaration[60206-60222]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60106-60276]:Block[60224-60394]"
    }, {
      "left" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
      "right" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
      "info" : "SwitchStatement[60112-60272]:SwitchStatement[60230-60390]"
    }, {
      "left" : "case STRING:",
      "right" : "case STRING:",
      "info" : "SwitchCase[60135-60147]:SwitchCase[60253-60265]"
    }, {
      "left" : "String string = stream.getString();",
      "right" : "String string = stream.getString();",
      "info" : "VariableDeclarationStatement[60156-60191]:VariableDeclarationStatement[60274-60309]"
    }, {
      "left" : "return newStringNode(string);",
      "right" : "return newStringNode(string);",
      "info" : "ReturnStatement[60200-60229]:ReturnStatement[60318-60347]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[60237-60245]:SwitchCase[60355-60363]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[60254-60266]:ReturnStatement[60372-60384]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[60280-60287]:Modifier[60398-60405]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[60288-60292]:SimpleType[60406-60410]"
    }, {
      "left" : "wrapNode",
      "right" : "wrapNode",
      "info" : "SimpleName[60293-60301]:SimpleName[60411-60419]"
    }, {
      "left" : "int type",
      "right" : "int type",
      "info" : "SingleVariableDeclaration[60302-60310]:SingleVariableDeclaration[60420-60428]"
    }, {
      "left" : "Node n",
      "right" : "Node n",
      "info" : "SingleVariableDeclaration[60312-60318]:SingleVariableDeclaration[60430-60436]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60320-60422]:Block[60438-60540]"
    }, {
      "left" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(), stream.getCharno());",
      "right" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(), stream.getCharno());",
      "info" : "ReturnStatement[60326-60418]:ReturnStatement[60444-60536]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[60426-60433]:Modifier[60544-60551]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[60434-60438]:SimpleType[60552-60556]"
    }, {
      "left" : "newNode",
      "right" : "newNode",
      "info" : "SimpleName[60439-60446]:SimpleName[60557-60564]"
    }, {
      "left" : "int type",
      "right" : "int type",
      "info" : "SingleVariableDeclaration[60447-60455]:SingleVariableDeclaration[60565-60573]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60457-60529]:Block[60575-60647]"
    }, {
      "left" : "return new Node(type, stream.getLineno(), stream.getCharno());",
      "right" : "return new Node(type, stream.getLineno(), stream.getCharno());",
      "info" : "ReturnStatement[60463-60525]:ReturnStatement[60581-60643]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[60533-60540]:Modifier[60651-60658]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[60541-60545]:SimpleType[60659-60663]"
    }, {
      "left" : "newStringNode",
      "right" : "newStringNode",
      "info" : "SimpleName[60546-60559]:SimpleName[60664-60677]"
    }, {
      "left" : "String s",
      "right" : "String s",
      "info" : "SingleVariableDeclaration[60560-60568]:SingleVariableDeclaration[60678-60686]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60570-60645]:Block[60688-60763]"
    }, {
      "left" : "return Node.newString(s, stream.getLineno(), stream.getCharno());",
      "right" : "return Node.newString(s, stream.getLineno(), stream.getCharno());",
      "info" : "ReturnStatement[60576-60641]:ReturnStatement[60694-60759]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[60649-60656]:Modifier[60767-60774]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[60657-60661]:SimpleType[60775-60779]"
    }, {
      "left" : "reportTypeSyntaxWarning",
      "right" : "reportTypeSyntaxWarning",
      "info" : "SimpleName[60662-60685]:SimpleName[60780-60803]"
    }, {
      "left" : "String warning",
      "right" : "String warning",
      "info" : "SingleVariableDeclaration[60686-60700]:SingleVariableDeclaration[60804-60818]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60702-60796]:Block[60820-60914]"
    }, {
      "left" : "parser.addWarning(warning, stream.getLineno(), stream.getCharno());",
      "right" : "parser.addWarning(warning, stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[60708-60775]:ExpressionStatement[60826-60893]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[60780-60792]:ReturnStatement[60898-60910]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[60800-60807]:Modifier[60918-60925]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[60808-60812]:SimpleType[60926-60930]"
    }, {
      "left" : "reportGenericTypeSyntaxWarning",
      "right" : "reportGenericTypeSyntaxWarning",
      "info" : "SimpleName[60813-60843]:SimpleName[60931-60961]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60846-60912]:Block[60964-61030]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
      "info" : "ReturnStatement[60852-60908]:ReturnStatement[60970-61026]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[61056-61063]:Modifier[61174-61181]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[61064-61074]:SimpleType[61182-61192]"
    }, {
      "left" : "eatTokensUntilEOL",
      "right" : "eatTokensUntilEOL",
      "info" : "SimpleName[61075-61092]:SimpleName[61193-61210]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61095-61138]:Block[61213-61256]"
    }, {
      "left" : "return eatTokensUntilEOL(next());",
      "right" : "return eatTokensUntilEOL(next());",
      "info" : "ReturnStatement[61101-61134]:ReturnStatement[61219-61252]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[61282-61289]:Modifier[61400-61407]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[61290-61300]:SimpleType[61408-61418]"
    }, {
      "left" : "eatTokensUntilEOL",
      "right" : "eatTokensUntilEOL",
      "info" : "SimpleName[61301-61318]:SimpleName[61419-61436]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[61319-61335]:SingleVariableDeclaration[61437-61453]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61337-61568]:Block[61455-61686]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[61343-61564]:DoStatement[61461-61682]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61346-61550]:Block[61464-61668]"
    }, {
      "left" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
      "right" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
      "info" : "IfStatement[61354-61522]:IfStatement[61472-61640]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61447-61522]:Block[61565-61640]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[61457-61492]:ExpressionStatement[61575-61610]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[61501-61514]:ReturnStatement[61619-61632]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[61529-61544]:ExpressionStatement[61647-61662]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[61911-61918]:Modifier[62029-62036]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[61919-61926]:PrimitiveType[62037-62044]"
    }, {
      "left" : "match",
      "right" : "match",
      "info" : "SimpleName[61927-61932]:SimpleName[62045-62050]"
    }, {
      "left" : "JsDocToken token",
      "right" : "JsDocToken token",
      "info" : "SingleVariableDeclaration[61933-61949]:SingleVariableDeclaration[62051-62067]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[61951-62015]:Block[62069-62133]"
    }, {
      "left" : "unreadToken = next();",
      "right" : "unreadToken = next();",
      "info" : "ExpressionStatement[61957-61978]:ExpressionStatement[62075-62096]"
    }, {
      "left" : "return unreadToken == token;",
      "right" : "return unreadToken == token;",
      "info" : "ReturnStatement[61983-62011]:ReturnStatement[62101-62129]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[62125-62132]:Modifier[62243-62250]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[62133-62140]:PrimitiveType[62251-62258]"
    }, {
      "left" : "match",
      "right" : "match",
      "info" : "SimpleName[62141-62146]:SimpleName[62259-62264]"
    }, {
      "left" : "JsDocToken token1",
      "right" : "JsDocToken token1",
      "info" : "SingleVariableDeclaration[62147-62164]:SingleVariableDeclaration[62265-62282]"
    }, {
      "left" : "JsDocToken token2",
      "right" : "JsDocToken token2",
      "info" : "SingleVariableDeclaration[62166-62183]:SingleVariableDeclaration[62284-62301]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62185-62275]:Block[62303-62393]"
    }, {
      "left" : "unreadToken = next();",
      "right" : "unreadToken = next();",
      "info" : "ExpressionStatement[62191-62212]:ExpressionStatement[62309-62330]"
    }, {
      "left" : "return unreadToken == token1 || unreadToken == token2;",
      "right" : "return unreadToken == token1 || unreadToken == token2;",
      "info" : "ReturnStatement[62217-62271]:ReturnStatement[62335-62389]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[62398-62405]:Modifier[62516-62523]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[62406-62416]:SimpleType[62524-62534]"
    }, {
      "left" : "next",
      "right" : "next",
      "info" : "SimpleName[62417-62421]:SimpleName[62535-62539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62424-62551]:Block[62542-62669]"
    }, {
      "left" : "if (unreadToken == NO_UNREAD_TOKEN)",
      "right" : "if (unreadToken == NO_UNREAD_TOKEN)",
      "info" : "IfStatement[62430-62547]:IfStatement[62548-62665]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62466-62510]:Block[62584-62628]"
    }, {
      "left" : "return stream.getJsDocToken();",
      "right" : "return stream.getJsDocToken();",
      "info" : "ReturnStatement[62474-62504]:ReturnStatement[62592-62622]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62516-62547]:Block[62634-62665]"
    }, {
      "left" : "return current();",
      "right" : "return current();",
      "info" : "ReturnStatement[62524-62541]:ReturnStatement[62642-62659]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[62628-62635]:Modifier[62746-62753]"
    }, {
      "left" : "JsDocToken",
      "right" : "JsDocToken",
      "info" : "SimpleType[62636-62646]:SimpleType[62754-62764]"
    }, {
      "left" : "current",
      "right" : "current",
      "info" : "SimpleName[62647-62654]:SimpleName[62765-62772]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62657-62743]:Block[62775-62861]"
    }, {
      "left" : "JsDocToken t = unreadToken;",
      "right" : "JsDocToken t = unreadToken;",
      "info" : "VariableDeclarationStatement[62663-62690]:VariableDeclarationStatement[62781-62808]"
    }, {
      "left" : "unreadToken = NO_UNREAD_TOKEN;",
      "right" : "unreadToken = NO_UNREAD_TOKEN;",
      "info" : "ExpressionStatement[62695-62725]:ExpressionStatement[62813-62843]"
    }, {
      "left" : "return t;",
      "right" : "return t;",
      "info" : "ReturnStatement[62730-62739]:ReturnStatement[62848-62857]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[62887-62894]:Modifier[63005-63012]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[62895-62899]:PrimitiveType[63013-63017]"
    }, {
      "left" : "skipEOLs",
      "right" : "skipEOLs",
      "info" : "SimpleName[62900-62908]:SimpleName[63018-63026]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62911-63032]:Block[63029-63150]"
    }, {
      "left" : "while (match(JsDocToken.EOL))",
      "right" : "while (match(JsDocToken.EOL))",
      "info" : "WhileStatement[62917-63028]:WhileStatement[63035-63146]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62947-63028]:Block[63065-63146]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[62955-62962]:ExpressionStatement[63073-63080]"
    }, {
      "left" : "if (match(JsDocToken.STAR))",
      "right" : "if (match(JsDocToken.STAR))",
      "info" : "IfStatement[62969-63022]:IfStatement[63087-63140]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62997-63022]:Block[63115-63140]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[63007-63014]:ExpressionStatement[63125-63132]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[63145-63152]:Modifier[63263-63270]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[63153-63160]:PrimitiveType[63271-63278]"
    }, {
      "left" : "hasParsedFileOverviewDocInfo",
      "right" : "hasParsedFileOverviewDocInfo",
      "info" : "SimpleName[63161-63189]:SimpleName[63279-63307]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63192-63252]:Block[63310-63370]"
    }, {
      "left" : "return jsdocBuilder.isPopulatedWithFileOverview();",
      "right" : "return jsdocBuilder.isPopulatedWithFileOverview();",
      "info" : "ReturnStatement[63198-63248]:ReturnStatement[63316-63366]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[63256-63263]:PrimitiveType[63374-63381]"
    }, {
      "left" : "hasParsedJSDocInfo",
      "right" : "hasParsedJSDocInfo",
      "info" : "SimpleName[63264-63282]:SimpleName[63382-63400]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63285-63329]:Block[63403-63447]"
    }, {
      "left" : "return jsdocBuilder.isPopulated();",
      "right" : "return jsdocBuilder.isPopulated();",
      "info" : "ReturnStatement[63291-63325]:ReturnStatement[63409-63443]"
    }, {
      "left" : "JSDocInfo",
      "right" : "JSDocInfo",
      "info" : "SimpleType[63333-63342]:SimpleType[63451-63460]"
    }, {
      "left" : "retrieveAndResetParsedJSDocInfo",
      "right" : "retrieveAndResetParsedJSDocInfo",
      "info" : "SimpleName[63343-63374]:SimpleName[63461-63492]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63377-63425]:Block[63495-63543]"
    }, {
      "left" : "return jsdocBuilder.build(sourceName);",
      "right" : "return jsdocBuilder.build(sourceName);",
      "info" : "ReturnStatement[63383-63421]:ReturnStatement[63501-63539]"
    }, {
      "left" : "JSDocInfo",
      "right" : "JSDocInfo",
      "info" : "SimpleType[63487-63496]:SimpleType[63605-63614]"
    }, {
      "left" : "getFileOverviewJSDocInfo",
      "right" : "getFileOverviewJSDocInfo",
      "info" : "SimpleName[63497-63521]:SimpleName[63615-63639]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63524-63563]:Block[63642-63681]"
    }, {
      "left" : "return fileOverviewJSDocInfo;",
      "right" : "return fileOverviewJSDocInfo;",
      "info" : "ReturnStatement[63530-63559]:ReturnStatement[63648-63677]"
    } ]
  },
  "interFileMappings" : { }
}