{
  "matchedElements" : [
 {
    "left" : "",
    "right" : "",
    "info" : "TypeDeclaration[1646-91767]:TypeDeclaration[1646-92627]"
  }, {
    "left" : "private static final Logger log = LoggerFactory.getLogger(Peer.class);",
    "right" : "private static final Logger log = LoggerFactory.getLogger(Peer.class);",
    "info" : "FieldDeclaration[2147-2217]:FieldDeclaration[2147-2217]"
  }, {
    "left" : "protected final ReentrantLock lock = Threading.lock(\"peer\");",
    "right" : "protected final ReentrantLock lock = Threading.lock(\"peer\");",
    "info" : "FieldDeclaration[2223-2283]:FieldDeclaration[2223-2283]"
  }, {
    "left" : "private final NetworkParameters params;",
    "right" : "private final NetworkParameters params;",
    "info" : "FieldDeclaration[2289-2328]:FieldDeclaration[2289-2328]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[2333-2377]:FieldDeclaration[2333-2377]"
  }, {
    "left" : "private final Context context;",
    "right" : "private final Context context;",
    "info" : "FieldDeclaration[2382-2412]:FieldDeclaration[2382-2412]"
  }, {
    "left" : "static class PeerListenerRegistration extends ListenerRegistration<PeerEventListener> {\n        boolean callOnDisconnect = true;\n        public PeerListenerRegistration(PeerEventListener listener, Executor executor) {\n            super(listener, executor);\n        }\n\n        public PeerListenerRegistration(PeerEventListener listener, Executor executor, boolean callOnDisconnect) {\n            this(listener, executor);\n            this.callOnDisconnect = callOnDisconnect;\n        }\n    }",
    "right" : "static class PeerListenerRegistration extends ListenerRegistration<PeerEventListener> {\n        boolean callOnDisconnect = true;\n        public PeerListenerRegistration(PeerEventListener listener, Executor executor) {\n            super(listener, executor);\n        }\n\n        public PeerListenerRegistration(PeerEventListener listener, Executor executor, boolean callOnDisconnect) {\n            this(listener, executor);\n            this.callOnDisconnect = callOnDisconnect;\n        }\n    }",
    "info" : "TypeDeclaration[2685-3175]:TypeDeclaration[2685-3175]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[2781-2813]:FieldDeclaration[2781-2813]"
  }, {
    "left" : "public listener PeerEventListener, executor Executor)",
    "right" : "public listener PeerEventListener, executor Executor)",
    "info" : "MethodDeclaration[2822-2951]:MethodDeclaration[2822-2951]"
  }, {
    "left" : "public PeerListenerRegistration(PeerEventListener listener, Executor executor, boolean callOnDisconnect) {\n            this(listener, executor);\n            this.callOnDisconnect = callOnDisconnect;\n        }",
    "right" : "public PeerListenerRegistration(PeerEventListener listener, Executor executor, boolean callOnDisconnect) {\n            this(listener, executor);\n            this.callOnDisconnect = callOnDisconnect;\n        }",
    "info" : "MethodDeclaration[2961-3169]:MethodDeclaration[2961-3169]"
  }, {
    "left" : "private final CopyOnWriteArrayList<PeerListenerRegistration> eventListeners;",
    "right" : "private final CopyOnWriteArrayList<PeerListenerRegistration> eventListeners;",
    "info" : "FieldDeclaration[3180-3256]:FieldDeclaration[3180-3256]"
  }, {
    "left" : "private volatile boolean vDownloadData;",
    "right" : "private volatile boolean vDownloadData;",
    "info" : "FieldDeclaration[3503-3542]:FieldDeclaration[3503-3542]"
  }, {
    "left" : "private final VersionMessage versionMessage;",
    "right" : "private final VersionMessage versionMessage;",
    "info" : "FieldDeclaration[3701-3745]:FieldDeclaration[3701-3745]"
  }, {
    "left" : "private volatile boolean vDownloadTxDependencies;",
    "right" : "private volatile boolean vDownloadTxDependencies;",
    "info" : "FieldDeclaration[3823-3872]:FieldDeclaration[3823-3872]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[4236-4302]:FieldDeclaration[4236-4302]"
  }, {
    "left" : "private final CopyOnWriteArrayList<Wallet> wallets;",
    "right" : "private final CopyOnWriteArrayList<Wallet> wallets;",
    "info" : "FieldDeclaration[4393-4444]:FieldDeclaration[4393-4444]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[4551-4603]:FieldDeclaration[4551-4603]"
  }, {
    "left" : "@GuardedBy(\"lock\") private boolean downloadBlockBodies = true;",
    "right" : "@GuardedBy(\"lock\") private boolean downloadBlockBodies = true;",
    "info" : "FieldDeclaration[4949-5011]:FieldDeclaration[4949-5011]"
  }, {
    "left" : "@GuardedBy(\"lock\") private boolean useFilteredBlocks = false;",
    "right" : "@GuardedBy(\"lock\") private boolean useFilteredBlocks = false;",
    "info" : "FieldDeclaration[5122-5183]:FieldDeclaration[5122-5183]"
  }, {
    "left" : "private volatile BloomFilter vBloomFilter;",
    "right" : "private volatile BloomFilter vBloomFilter;",
    "info" : "FieldDeclaration[5302-5344]:FieldDeclaration[5302-5344]"
  }, {
    "left" : "private FilteredBlock currentFilteredBlock = null;",
    "right" : "private FilteredBlock currentFilteredBlock = null;",
    "info" : "FieldDeclaration[5441-5491]:FieldDeclaration[5441-5491]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[5887-5922]:FieldDeclaration[5887-5922]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[6219-6293]:FieldDeclaration[6219-6293]"
  }, {
    "left" : "private static final int RESEND_BLOOM_FILTER_BLOCK_COUNT = 25000;",
    "right" : "private static final int RESEND_BLOOM_FILTER_BLOCK_COUNT = 25000;",
    "info" : "FieldDeclaration[6516-6581]:FieldDeclaration[6516-6581]"
  }, {
    "left" : "private final HashSet<Sha256Hash> pendingBlockDownloads = new HashSet<Sha256Hash>();",
    "right" : "private final HashSet<Sha256Hash> pendingBlockDownloads = new HashSet<Sha256Hash>();",
    "info" : "FieldDeclaration[7135-7219]:FieldDeclaration[7135-7219]"
  }, {
    "left" : "@SuppressWarnings(\"MismatchedQueryAndUpdateOfCollection\")\n    private final HashSet<TransactionConfidence> pendingTxDownloads = new HashSet<TransactionConfidence>();",
    "right" : "@SuppressWarnings(\"MismatchedQueryAndUpdateOfCollection\")\n    private final HashSet<TransactionConfidence> pendingTxDownloads = new HashSet<TransactionConfidence>();",
    "info" : "FieldDeclaration[7741-7906]:FieldDeclaration[7741-7906]"
  }, {
    "left" : "private volatile int vMinProtocolVersion = Pong.MIN_PROTOCOL_VERSION;",
    "right" : "private volatile int vMinProtocolVersion = Pong.MIN_PROTOCOL_VERSION;",
    "info" : "FieldDeclaration[8025-8094]:FieldDeclaration[8025-8094]"
  }, {
    "left" : "private static class GetDataRequest {\n        Sha256Hash hash;\n        SettableFuture future;\n    }",
    "right" : "private static class GetDataRequest {\n        Sha256Hash hash;\n        SettableFuture future;\n    }",
    "info" : "TypeDeclaration[8298-8397]:TypeDeclaration[8298-8397]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[8344-8360]:FieldDeclaration[8344-8360]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[8369-8391]:FieldDeclaration[8369-8391]"
  }, {
    "left" : "private final CopyOnWriteArrayList<GetDataRequest> getDataFutures;",
    "right" : "private final CopyOnWriteArrayList<GetDataRequest> getDataFutures;",
    "info" : "FieldDeclaration[8463-8529]:FieldDeclaration[8463-8529]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[8534-8635]:FieldDeclaration[8534-8635]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[8640-8733]:FieldDeclaration[8640-8733]"
  }, {
    "left" : "private final ReentrantLock lastPingTimesLock = new ReentrantLock();",
    "right" : "private final ReentrantLock lastPingTimesLock = new ReentrantLock();",
    "info" : "FieldDeclaration[8826-8894]:FieldDeclaration[8826-8894]"
  }, {
    "left" : "@GuardedBy(\"lastPingTimesLock\") private long[] lastPingTimes = null;",
    "right" : "@GuardedBy(\"lastPingTimesLock\") private long[] lastPingTimes = null;",
    "info" : "FieldDeclaration[8899-8967]:FieldDeclaration[8899-8967]"
  }, {
    "left" : "private final CopyOnWriteArrayList<PendingPing> pendingPings;",
    "right" : "private final CopyOnWriteArrayList<PendingPing> pendingPings;",
    "info" : "FieldDeclaration[8972-9033]:FieldDeclaration[8972-9033]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[9038-9095]:FieldDeclaration[9038-9095]"
  }, {
    "left" : "private volatile VersionMessage vPeerVersionMessage;",
    "right" : "private volatile VersionMessage vPeerVersionMessage;",
    "info" : "FieldDeclaration[9101-9153]:FieldDeclaration[9101-9153]"
  }, {
    "left" : "private boolean isAcked;",
    "right" : "private boolean isAcked;",
    "info" : "FieldDeclaration[9158-9182]:FieldDeclaration[9158-9182]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[9269-9351]:FieldDeclaration[9269-9351]"
  }, {
    "left" : "private final SettableFuture<Peer> versionHandshakeFuture = SettableFuture.create();",
    "right" : "private final SettableFuture<Peer> versionHandshakeFuture = SettableFuture.create();",
    "info" : "FieldDeclaration[9356-9440]:FieldDeclaration[9356-9440]"
  }, {
    "left" : "public params NetworkParameters, ver VersionMessage, chain AbstractBlockChain, remoteAddress PeerAddress)",
    "right" : "public params NetworkParameters, ver VersionMessage, chain AbstractBlockChain, remoteAddress PeerAddress)",
    "info" : "MethodDeclaration[9446-10406]:MethodDeclaration[9446-10406]"
  }, {
    "left" : "/**\n     * <p>Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}\n     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that\n     * the transaction is valid.</p>\n     *\n     * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a\n     * connection. If you want to create a one-off connection, create a Peer and pass it to\n     * {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, org.bitcoinj.net.StreamParser)}\n     * or\n     * {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, org.bitcoinj.net.StreamParser, int)}.</p>\n     *\n     * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is\n     * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>\n     */\n    public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress,\n                @Nullable AbstractBlockChain chain) {\n        this(params, ver, remoteAddress, chain, true);\n    }",
    "right" : "/**\n     * <p>Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}\n     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that\n     * the transaction is valid.</p>\n     *\n     * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a\n     * connection. If you want to create a one-off connection, create a Peer and pass it to\n     * {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, org.bitcoinj.net.StreamParser)}\n     * or\n     * {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, org.bitcoinj.net.StreamParser, int)}.</p>\n     *\n     * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is\n     * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>\n     */\n    public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress,\n                @Nullable AbstractBlockChain chain) {\n        this(params, ver, remoteAddress, chain, true);\n    }",
    "info" : "MethodDeclaration[10412-11610]:MethodDeclaration[10412-11610]"
  }, {
    "left" : "/**\n     * <p>Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}\n     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that\n     * the transaction is valid.</p>\n     *\n     * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a\n     * connection. If you want to create a one-off connection, create a Peer and pass it to\n     * {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, org.bitcoinj.net.StreamParser)}\n     * or\n     * {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, org.bitcoinj.net.StreamParser, int)}.</p>\n     *\n     * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is\n     * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>\n     */\n    public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress,\n                @Nullable AbstractBlockChain chain, boolean downloadTxDependencies) {\n        super(params, remoteAddress);\n        this.params = Preconditions.checkNotNull(params);\n        this.versionMessage = Preconditions.checkNotNull(ver);\n        this.vDownloadTxDependencies = chain != null && downloadTxDependencies;\n        this.blockChain = chain;  // Allowed to be null.\n        this.vDownloadData = chain != null;\n        this.getDataFutures = new CopyOnWriteArrayList<GetDataRequest>();\n        this.eventListeners = new CopyOnWriteArrayList<PeerListenerRegistration>();\n        this.getAddrFutures = new LinkedList<SettableFuture<AddressMessage>>();\n        this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();\n        this.isAcked = false;\n        this.pendingPings = new CopyOnWriteArrayList<PendingPing>();\n        this.wallets = new CopyOnWriteArrayList<Wallet>();\n        this.context = Context.get();\n    }",
    "right" : "/**\n     * <p>Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}\n     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that\n     * the transaction is valid.</p>\n     *\n     * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a\n     * connection. If you want to create a one-off connection, create a Peer and pass it to\n     * {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, org.bitcoinj.net.StreamParser)}\n     * or\n     * {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, org.bitcoinj.net.StreamParser, int)}.</p>\n     *\n     * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is\n     * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>\n     */\n    public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress,\n                @Nullable AbstractBlockChain chain, boolean downloadTxDependencies) {\n        super(params, remoteAddress);\n        this.params = Preconditions.checkNotNull(params);\n        this.versionMessage = Preconditions.checkNotNull(ver);\n        this.vDownloadTxDependencies = chain != null && downloadTxDependencies;\n        this.blockChain = chain;  // Allowed to be null.\n        this.vDownloadData = chain != null;\n        this.getDataFutures = new CopyOnWriteArrayList<GetDataRequest>();\n        this.eventListeners = new CopyOnWriteArrayList<PeerListenerRegistration>();\n        this.getAddrFutures = new LinkedList<SettableFuture<AddressMessage>>();\n        this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();\n        this.isAcked = false;\n        this.pendingPings = new CopyOnWriteArrayList<PendingPing>();\n        this.wallets = new CopyOnWriteArrayList<Wallet>();\n        this.context = Context.get();\n    }",
    "info" : "MethodDeclaration[11616-13643]:MethodDeclaration[11616-13643]"
  }, {
    "left" : "/**\n     * <p>Construct a peer that reads/writes from the given chain. Automatically creates a VersionMessage for you from\n     * the given software name/version strings, which should be something like \"MySimpleTool\", \"1.0\" and which will tell\n     * the remote node to relay transaction inv messages before it has received a filter.</p>\n     *\n     * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a\n     * connection. If you want to create a one-off connection, create a Peer and pass it to\n     * {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, org.bitcoinj.net.StreamParser)}\n     * or\n     * {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, org.bitcoinj.net.StreamParser, int)}.</p>\n     *\n     * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is\n     * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>\n     */\n    public Peer(NetworkParameters params, AbstractBlockChain blockChain, PeerAddress peerAddress, String thisSoftwareName, String thisSoftwareVersion) {\n        this(params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress);\n        this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, null);\n    }",
    "right" : "/**\n     * <p>Construct a peer that reads/writes from the given chain. Automatically creates a VersionMessage for you from\n     * the given software name/version strings, which should be something like \"MySimpleTool\", \"1.0\" and which will tell\n     * the remote node to relay transaction inv messages before it has received a filter.</p>\n     *\n     * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a\n     * connection. If you want to create a one-off connection, create a Peer and pass it to\n     * {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, org.bitcoinj.net.StreamParser)}\n     * or\n     * {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, org.bitcoinj.net.StreamParser, int)}.</p>\n     *\n     * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is\n     * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>\n     */\n    public Peer(NetworkParameters params, AbstractBlockChain blockChain, PeerAddress peerAddress, String thisSoftwareName, String thisSoftwareVersion) {\n        this(params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress);\n        this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, null);\n    }",
    "info" : "MethodDeclaration[13649-15040]:MethodDeclaration[13649-15040]"
  }, {
    "left" : "/**\n     * Registers the given object as an event listener that will be invoked on the user thread. Note that listeners\n     * added this way will <b>not</b> receive {@link PeerEventListener#getData(Peer, GetDataMessage)} or\n     * {@link PeerEventListener#onPreMessageReceived(Peer, Message)} calls because those require that the listener\n     * be added using {@link Threading#SAME_THREAD}, which requires the other addListener form.\n     */\n    public void addEventListener(PeerEventListener listener) {\n        addEventListener(listener, Threading.USER_THREAD);\n    }",
    "right" : "/**\n     * Registers the given object as an event listener that will be invoked on the user thread. Note that listeners\n     * added this way will <b>not</b> receive {@link PeerEventListener#getData(Peer, GetDataMessage)} or\n     * {@link PeerEventListener#onPreMessageReceived(Peer, Message)} calls because those require that the listener\n     * be added using {@link Threading#SAME_THREAD}, which requires the other addListener form.\n     */\n    public void addEventListener(PeerEventListener listener) {\n        addEventListener(listener, Threading.USER_THREAD);\n    }",
    "info" : "MethodDeclaration[15046-15617]:MethodDeclaration[15046-15617]"
  }, {
    "left" : "/**\n     * Registers the given object as an event listener that will be invoked by the given executor. Note that listeners\n     * added using any other executor than {@link Threading#SAME_THREAD} will <b>not</b> receive\n     * {@link PeerEventListener#getData(Peer, GetDataMessage)} or\n     * {@link PeerEventListener#onPreMessageReceived(Peer, Message)} calls because this class is not willing to cross\n     * threads in order to get the results of those hook methods.\n     */\n    public void addEventListener(PeerEventListener listener, Executor executor) {\n        eventListeners.add(new PeerListenerRegistration(listener, executor));\n    }",
    "right" : "/**\n     * Registers the given object as an event listener that will be invoked by the given executor. Note that listeners\n     * added using any other executor than {@link Threading#SAME_THREAD} will <b>not</b> receive\n     * {@link PeerEventListener#getData(Peer, GetDataMessage)} or\n     * {@link PeerEventListener#onPreMessageReceived(Peer, Message)} calls because this class is not willing to cross\n     * threads in order to get the results of those hook methods.\n     */\n    public void addEventListener(PeerEventListener listener, Executor executor) {\n        eventListeners.add(new PeerListenerRegistration(listener, executor));\n    }",
    "info" : "MethodDeclaration[15623-16266]:MethodDeclaration[15623-16266]"
  }, {
    "left" : "package listener PeerEventListener, executor Executor) : void",
    "right" : "package listener PeerEventListener, executor Executor) : void",
    "info" : "MethodDeclaration[16315-16495]:MethodDeclaration[16315-16495]"
  }, {
    "left" : "public listener PeerEventListener) : boolean",
    "right" : "public listener PeerEventListener) : boolean",
    "info" : "MethodDeclaration[16501-16649]:MethodDeclaration[16501-16649]"
  }, {
    "left" : "public ) : String",
    "right" : "public ) : String",
    "info" : "MethodDeclaration[16655-16866]:MethodDeclaration[16655-16866]"
  }, {
    "left" : "@Override\n    protected void timeoutOccurred() {\n        super.timeoutOccurred();\n        if (!connectionOpenFuture.isDone()) {\n            connectionClosed();  // Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.\n        }\n    }",
    "right" : "@Override\n    protected void timeoutOccurred() {\n        super.timeoutOccurred();\n        if (!connectionOpenFuture.isDone()) {\n            connectionClosed();  // Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.\n        }\n    }",
    "info" : "MethodDeclaration[16872-17144]:MethodDeclaration[16872-17144]"
  }, {
    "left" : "@Override\n    public void connectionClosed() {\n        for (final PeerListenerRegistration registration : eventListeners) {\n            if (registration.callOnDisconnect)\n                registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onPeerDisconnected(Peer.this, 0);\n                    }\n                });\n        }\n    }",
    "right" : "@Override\n    public void connectionClosed() {\n        for (final PeerListenerRegistration registration : eventListeners) {\n            if (registration.callOnDisconnect)\n                registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onPeerDisconnected(Peer.this, 0);\n                    }\n                });\n        }\n    }",
    "info" : "MethodDeclaration[17150-17591]:MethodDeclaration[17150-17591]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[17404-17555]:MethodDeclaration[17404-17555]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[17597-18257]:MethodDeclaration[17597-18257]"
  }, {
    "left" : "/**\n     * Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not\n     * mean that protocol handshake has occurred.\n     */\n    public ListenableFuture<Peer> getConnectionOpenFuture() {\n        return connectionOpenFuture;\n    }",
    "right" : "/**\n     * Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not\n     * mean that protocol handshake has occurred.\n     */\n    public ListenableFuture<Peer> getConnectionOpenFuture() {\n        return connectionOpenFuture;\n    }",
    "info" : "MethodDeclaration[18263-18546]:MethodDeclaration[18263-18546]"
  }, {
    "left" : "public ) : ListenableFuture<Peer>",
    "right" : "public ) : ListenableFuture<Peer>",
    "info" : "MethodDeclaration[18552-18656]:MethodDeclaration[18552-18656]"
  }, {
    "left" : "protected m Message) : void",
    "right" : "protected m Message) : void",
    "info" : "MethodDeclaration[18662-22956]:MethodDeclaration[18662-22956]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[21944-22092]:MethodDeclaration[21944-22092]"
  }, {
    "left" : "private void processUTXOMessage(UTXOsMessage m) {\n        SettableFuture<UTXOsMessage> future = null;\n        lock.lock();\n        try {\n            if (getutxoFutures != null)\n                future = getutxoFutures.pollFirst();\n        } finally {\n            lock.unlock();\n        }\n        if (future != null)\n            future.set(m);\n    }",
    "right" : "private void processUTXOMessage(UTXOsMessage m) {\n        SettableFuture<UTXOsMessage> future = null;\n        lock.lock();\n        try {\n            if (getutxoFutures != null)\n                future = getutxoFutures.pollFirst();\n        } finally {\n            lock.unlock();\n        }\n        if (future != null)\n            future.set(m);\n    }",
    "info" : "MethodDeclaration[22962-23309]:MethodDeclaration[22962-23309]"
  }, {
    "left" : "private void processAddressMessage(AddressMessage m) {\n        SettableFuture<AddressMessage> future;\n        synchronized (getAddrFutures) {\n            future = getAddrFutures.poll();\n            if (future == null)  // Not an addr message we are waiting for.\n                return;\n        }\n        future.set(m);\n    }",
    "right" : "private void processAddressMessage(AddressMessage m) {\n        SettableFuture<AddressMessage> future;\n        synchronized (getAddrFutures) {\n            future = getAddrFutures.poll();\n            if (future == null)  // Not an addr message we are waiting for.\n                return;\n        }\n        future.set(m);\n    }",
    "info" : "MethodDeclaration[23315-23639]:MethodDeclaration[23315-23639]"
  }, {
    "left" : "private void processVersionMessage(VersionMessage m) throws ProtocolException {\n        if (vPeerVersionMessage != null)\n            throw new ProtocolException(\"Got two version messages from peer\");\n        vPeerVersionMessage = m;\n        // Switch to the new protocol version.\n        int peerVersion = vPeerVersionMessage.clientVersion;\n        PeerAddress peerAddress = getAddress();\n        long peerTime = vPeerVersionMessage.time * 1000;\n        log.info(\"Connected to {}: version={}, subVer='{}', services=0x{}, time={}, blocks={}\",\n                peerAddress == null ? \"Peer\" : peerAddress.getAddr().getHostAddress(),\n                peerVersion,\n                vPeerVersionMessage.subVer,\n                vPeerVersionMessage.localServices,\n                String.format(\"%tF %tT\", peerTime, peerTime),\n                vPeerVersionMessage.bestHeight);\n        // Now it's our turn ...\n        // Send an ACK message stating we accept the peers protocol version.\n        sendMessage(new VersionAck());\n        // bitcoinj is a client mode implementation. That means there's not much point in us talking to other client\n        // mode nodes because we can't download the data from them we need to find/verify transactions. Some bogus\n        // implementations claim to have a block chain in their services field but then report a height of zero, filter\n        // them out here.\n        if (!vPeerVersionMessage.hasBlockChain() ||\n                (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight <= 0)) {\n            // Shut down the channel\n            throw new ProtocolException(\"Peer does not have a copy of the block chain.\");\n        }\n        versionHandshakeFuture.set(this);\n    }",
    "right" : "private void processVersionMessage(VersionMessage m) throws ProtocolException {\n        if (vPeerVersionMessage != null)\n            throw new ProtocolException(\"Got two version messages from peer\");\n        vPeerVersionMessage = m;\n        // Switch to the new protocol version.\n        int peerVersion = vPeerVersionMessage.clientVersion;\n        PeerAddress peerAddress = getAddress();\n        long peerTime = vPeerVersionMessage.time * 1000;\n        log.info(\"Connected to {}: version={}, subVer='{}', services=0x{}, time={}, blocks={}\",\n                peerAddress == null ? \"Peer\" : peerAddress.getAddr().getHostAddress(),\n                peerVersion,\n                vPeerVersionMessage.subVer,\n                vPeerVersionMessage.localServices,\n                String.format(\"%tF %tT\", peerTime, peerTime),\n                vPeerVersionMessage.bestHeight);\n        // Now it's our turn ...\n        // Send an ACK message stating we accept the peers protocol version.\n        sendMessage(new VersionAck());\n        // bitcoinj is a client mode implementation. That means there's not much point in us talking to other client\n        // mode nodes because we can't download the data from them we need to find/verify transactions. Some bogus\n        // implementations claim to have a block chain in their services field but then report a height of zero, filter\n        // them out here.\n        if (!vPeerVersionMessage.hasBlockChain() ||\n                (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight <= 0)) {\n            // Shut down the channel\n            throw new ProtocolException(\"Peer does not have a copy of the block chain.\");\n        }\n        versionHandshakeFuture.set(this);\n    }",
    "info" : "MethodDeclaration[23645-25362]:MethodDeclaration[23645-25362]"
  }, {
    "left" : "private m FilteredBlock) : void",
    "right" : "private m FilteredBlock) : void",
    "info" : "MethodDeclaration[25368-26359]:MethodDeclaration[25368-26359]"
  }, {
    "left" : "private m NotFoundMessage) : void",
    "right" : "private m NotFoundMessage) : void",
    "info" : "MethodDeclaration[26365-27310]:MethodDeclaration[26365-27310]"
  }, {
    "left" : "private void processAlert(AlertMessage m) {\n        try {\n            if (m.isSignatureValid()) {\n                log.info(\"Received alert from peer {}: {}\", this, m.getStatusBar());\n            } else {\n                log.warn(\"Received alert with invalid signature from peer {}: {}\", this, m.getStatusBar());\n            }\n        } catch (Throwable t) {\n            // Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their\n            // BigInteger implementations! See issue 160 for discussion. As alerts are just optional and not that\n            // useful, we just swallow the error here.\n            log.error(\"Failed to check signature: bug in platform libraries?\", t);\n        }\n    }",
    "right" : "private void processAlert(AlertMessage m) {\n        try {\n            if (m.isSignatureValid()) {\n                log.info(\"Received alert from peer {}: {}\", this, m.getStatusBar());\n            } else {\n                log.warn(\"Received alert with invalid signature from peer {}: {}\", this, m.getStatusBar());\n            }\n        } catch (Throwable t) {\n            // Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their\n            // BigInteger implementations! See issue 160 for discussion. As alerts are just optional and not that\n            // useful, we just swallow the error here.\n            log.error(\"Failed to check signature: bug in platform libraries?\", t);\n        }\n    }",
    "info" : "MethodDeclaration[27316-28056]:MethodDeclaration[27316-28056]"
  }, {
    "left" : "private void processHeaders(HeadersMessage m) throws ProtocolException {\n        // Runs in network loop thread for this peer.\n        //\n        // This method can run if a peer just randomly sends us a \"headers\" message (should never happen), or more\n        // likely when we've requested them as part of chain download using fast catchup. We need to add each block to\n        // the chain if it pre-dates the fast catchup time. If we go past it, we can stop processing the headers and\n        // request the full blocks from that point on instead.\n        boolean downloadBlockBodies;\n        long fastCatchupTimeSecs;\n\n        lock.lock();\n        try {\n            if (blockChain == null) {\n                // Can happen if we are receiving unrequested data, or due to programmer error.\n                log.warn(\"Received headers when Peer is not configured with a chain.\");\n                return;\n            }\n            fastCatchupTimeSecs = this.fastCatchupTimeSecs;\n            downloadBlockBodies = this.downloadBlockBodies;\n        } finally {\n            lock.unlock();\n        }\n\n        try {\n            checkState(!downloadBlockBodies, toString());\n            for (int i = 0; i < m.getBlockHeaders().size(); i++) {\n                Block header = m.getBlockHeaders().get(i);\n                // Process headers until we pass the fast catchup time, or are about to catch up with the head\n                // of the chain - always process the last block as a full/filtered block to kick us out of the\n                // fast catchup mode (in which we ignore new blocks).\n                boolean passedTime = header.getTimeSeconds() >= fastCatchupTimeSecs;\n                boolean reachedTop = blockChain.getBestChainHeight() >= vPeerVersionMessage.bestHeight;\n                if (!passedTime && !reachedTop) {\n                    if (!vDownloadData) {\n                        // Not download peer anymore, some other peer probably became better.\n                        log.info(\"Lost download peer status, throwing away downloaded headers.\");\n                        return;\n                    }\n                    if (blockChain.add(header)) {\n                        // The block was successfully linked into the chain. Notify the user of our progress.\n                        invokeOnBlocksDownloaded(header, null);\n                    } else {\n                        // This block is unconnected - we don't know how to get from it back to the genesis block yet.\n                        // That must mean that the peer is buggy or malicious because we specifically requested for\n                        // headers that are part of the best chain.\n                        throw new ProtocolException(\"Got unconnected header from peer: \" + header.getHashAsString());\n                    }\n                } else {\n                    lock.lock();\n                    try {\n                        log.info(\"Passed the fast catchup time, discarding {} headers and requesting full blocks\",\n                                m.getBlockHeaders().size() - i);\n                        this.downloadBlockBodies = true;\n                        // Prevent this request being seen as a duplicate.\n                        this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH;\n                        blockChainDownloadLocked(Sha256Hash.ZERO_HASH);\n                    } finally {\n                        lock.unlock();\n                    }\n                    return;\n                }\n            }\n            // We added all headers in the message to the chain. Request some more if we got up to the limit, otherwise\n            // we are at the end of the chain.\n            if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS) {\n                lock.lock();\n                try {\n                    blockChainDownloadLocked(Sha256Hash.ZERO_HASH);\n                } finally {\n                    lock.unlock();\n                }\n            }\n        } catch (VerificationException e) {\n            log.warn(\"Block header verification failed\", e);\n        } catch (PrunedException e) {\n            // Unreachable when in SPV mode.\n            throw new RuntimeException(e);\n        }\n    }",
    "right" : "private void processHeaders(HeadersMessage m) throws ProtocolException {\n        // Runs in network loop thread for this peer.\n        //\n        // This method can run if a peer just randomly sends us a \"headers\" message (should never happen), or more\n        // likely when we've requested them as part of chain download using fast catchup. We need to add each block to\n        // the chain if it pre-dates the fast catchup time. If we go past it, we can stop processing the headers and\n        // request the full blocks from that point on instead.\n        boolean downloadBlockBodies;\n        long fastCatchupTimeSecs;\n\n        lock.lock();\n        try {\n            if (blockChain == null) {\n                // Can happen if we are receiving unrequested data, or due to programmer error.\n                log.warn(\"Received headers when Peer is not configured with a chain.\");\n                return;\n            }\n            fastCatchupTimeSecs = this.fastCatchupTimeSecs;\n            downloadBlockBodies = this.downloadBlockBodies;\n        } finally {\n            lock.unlock();\n        }\n\n        try {\n            checkState(!downloadBlockBodies, toString());\n            for (int i = 0; i < m.getBlockHeaders().size(); i++) {\n                Block header = m.getBlockHeaders().get(i);\n                // Process headers until we pass the fast catchup time, or are about to catch up with the head\n                // of the chain - always process the last block as a full/filtered block to kick us out of the\n                // fast catchup mode (in which we ignore new blocks).\n                boolean passedTime = header.getTimeSeconds() >= fastCatchupTimeSecs;\n                boolean reachedTop = blockChain.getBestChainHeight() >= vPeerVersionMessage.bestHeight;\n                if (!passedTime && !reachedTop) {\n                    if (!vDownloadData) {\n                        // Not download peer anymore, some other peer probably became better.\n                        log.info(\"Lost download peer status, throwing away downloaded headers.\");\n                        return;\n                    }\n                    if (blockChain.add(header)) {\n                        // The block was successfully linked into the chain. Notify the user of our progress.\n                        invokeOnBlocksDownloaded(header, null);\n                    } else {\n                        // This block is unconnected - we don't know how to get from it back to the genesis block yet.\n                        // That must mean that the peer is buggy or malicious because we specifically requested for\n                        // headers that are part of the best chain.\n                        throw new ProtocolException(\"Got unconnected header from peer: \" + header.getHashAsString());\n                    }\n                } else {\n                    lock.lock();\n                    try {\n                        log.info(\"Passed the fast catchup time, discarding {} headers and requesting full blocks\",\n                                m.getBlockHeaders().size() - i);\n                        this.downloadBlockBodies = true;\n                        // Prevent this request being seen as a duplicate.\n                        this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH;\n                        blockChainDownloadLocked(Sha256Hash.ZERO_HASH);\n                    } finally {\n                        lock.unlock();\n                    }\n                    return;\n                }\n            }\n            // We added all headers in the message to the chain. Request some more if we got up to the limit, otherwise\n            // we are at the end of the chain.\n            if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS) {\n                lock.lock();\n                try {\n                    blockChainDownloadLocked(Sha256Hash.ZERO_HASH);\n                } finally {\n                    lock.unlock();\n                }\n            }\n        } catch (VerificationException e) {\n            log.warn(\"Block header verification failed\", e);\n        } catch (PrunedException e) {\n            // Unreachable when in SPV mode.\n            throw new RuntimeException(e);\n        }\n    }",
    "info" : "MethodDeclaration[28062-32268]:MethodDeclaration[28062-32268]"
  }, {
    "left" : "private getdata GetDataMessage) : void",
    "right" : "private getdata GetDataMessage) : void",
    "info" : "MethodDeclaration[32274-33073]:MethodDeclaration[32274-33073]"
  }, {
    "left" : "private void processTransaction(final Transaction tx) throws VerificationException {\n        // Check a few basic syntax issues to ensure the received TX isn't nonsense.\n        tx.verify();\n        lock.lock();\n        try {\n            log.debug(\"{}: Received tx {}\", getAddress(), tx.getHashAsString());\n            // Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,\n            // etc). This helps the wallet decide how to risk analyze it later.\n            //\n            // Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning\n            // we can stop holding a reference to the confidence object ourselves. It's up to event listeners on the\n            // Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation\n            // and so on.\n            TransactionConfidence confidence = tx.getConfidence();\n            confidence.setSource(TransactionConfidence.Source.NETWORK);\n            pendingTxDownloads.remove(confidence);\n            if (maybeHandleRequestedData(tx)) {\n                return;\n            }\n            if (currentFilteredBlock != null) {\n                if (!currentFilteredBlock.provideTransaction(tx)) {\n                    // Got a tx that didn't fit into the filtered block, so we must have received everything.\n                    endFilteredBlock(currentFilteredBlock);\n                    currentFilteredBlock = null;\n                }\n                // Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is\n                // fully downloaded instead.\n                return;\n            }\n            // It's a broadcast transaction. Tell all wallets about this tx so they can check if it's relevant or not.\n            for (final Wallet wallet : wallets) {\n                try {\n                    if (wallet.isPendingTransactionRelevant(tx)) {\n                        if (vDownloadTxDependencies) {\n                            // This transaction seems interesting to us, so let's download its dependencies. This has\n                            // several purposes: we can check that the sender isn't attacking us by engaging in protocol\n                            // abuse games, like depending on a time-locked transaction that will never confirm, or\n                            // building huge chains of unconfirmed transactions (again - so they don't confirm and the\n                            // money can be taken back with a Finney attack). Knowing the dependencies also lets us\n                            // store them in a serialized wallet so we always have enough data to re-announce to the\n                            // network and get the payment into the chain, in case the sender goes away and the network\n                            // starts to forget.\n                            //\n                            // TODO: Not all the above things are implemented.\n                            //\n                            // Note that downloading of dependencies can end up walking around 15 minutes back even\n                            // through transactions that have confirmed, as getdata on the remote peer also checks\n                            // relay memory not only the mempool. Unfortunately we have no way to know that here. In\n                            // practice it should not matter much.\n                            Futures.addCallback(downloadDependencies(tx), new FutureCallback<List<Transaction>>() {\n                                @Override\n                                public void onSuccess(List<Transaction> dependencies) {\n                                    try {\n                                        log.info(\"{}: Dependency download complete!\", getAddress());\n                                        wallet.receivePending(tx, dependencies);\n                                    } catch (VerificationException e) {\n                                        log.error(\"{}: Wallet failed to process pending transaction {}\", getAddress(), tx.getHash());\n                                        log.error(\"Error was: \", e);\n                                        // Not much more we can do at this point.\n                                    }\n                                }\n\n                                @Override\n                                public void onFailure(Throwable throwable) {\n                                    log.error(\"Could not download dependencies of tx {}\", tx.getHashAsString());\n                                    log.error(\"Error was: \", throwable);\n                                    // Not much more we can do at this point.\n                                }\n                            });\n                        } else {\n                            wallet.receivePending(tx, null);\n                        }\n                    }\n                } catch (VerificationException e) {\n                    log.error(\"Wallet failed to verify tx\", e);\n                    // Carry on, listeners may still want to know.\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        // Tell all listeners about this tx so they can decide whether to keep it or not. If no listener keeps a\n        // reference around then the memory pool will forget about it after a while too because it uses weak references.\n        for (final ListenerRegistration<PeerEventListener> registration : eventListeners) {\n            registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onTransaction(Peer.this, tx);\n                }\n            });\n        }\n    }",
    "right" : "private void processTransaction(final Transaction tx) throws VerificationException {\n        // Check a few basic syntax issues to ensure the received TX isn't nonsense.\n        tx.verify();\n        lock.lock();\n        try {\n            log.debug(\"{}: Received tx {}\", getAddress(), tx.getHashAsString());\n            // Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,\n            // etc). This helps the wallet decide how to risk analyze it later.\n            //\n            // Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning\n            // we can stop holding a reference to the confidence object ourselves. It's up to event listeners on the\n            // Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation\n            // and so on.\n            TransactionConfidence confidence = tx.getConfidence();\n            confidence.setSource(TransactionConfidence.Source.NETWORK);\n            pendingTxDownloads.remove(confidence);\n            if (maybeHandleRequestedData(tx)) {\n                return;\n            }\n            if (currentFilteredBlock != null) {\n                if (!currentFilteredBlock.provideTransaction(tx)) {\n                    // Got a tx that didn't fit into the filtered block, so we must have received everything.\n                    endFilteredBlock(currentFilteredBlock);\n                    currentFilteredBlock = null;\n                }\n                // Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is\n                // fully downloaded instead.\n                return;\n            }\n            // It's a broadcast transaction. Tell all wallets about this tx so they can check if it's relevant or not.\n            for (final Wallet wallet : wallets) {\n                try {\n                    if (wallet.isPendingTransactionRelevant(tx)) {\n                        if (vDownloadTxDependencies) {\n                            // This transaction seems interesting to us, so let's download its dependencies. This has\n                            // several purposes: we can check that the sender isn't attacking us by engaging in protocol\n                            // abuse games, like depending on a time-locked transaction that will never confirm, or\n                            // building huge chains of unconfirmed transactions (again - so they don't confirm and the\n                            // money can be taken back with a Finney attack). Knowing the dependencies also lets us\n                            // store them in a serialized wallet so we always have enough data to re-announce to the\n                            // network and get the payment into the chain, in case the sender goes away and the network\n                            // starts to forget.\n                            //\n                            // TODO: Not all the above things are implemented.\n                            //\n                            // Note that downloading of dependencies can end up walking around 15 minutes back even\n                            // through transactions that have confirmed, as getdata on the remote peer also checks\n                            // relay memory not only the mempool. Unfortunately we have no way to know that here. In\n                            // practice it should not matter much.\n                            Futures.addCallback(downloadDependencies(tx), new FutureCallback<List<Transaction>>() {\n                                @Override\n                                public void onSuccess(List<Transaction> dependencies) {\n                                    try {\n                                        log.info(\"{}: Dependency download complete!\", getAddress());\n                                        wallet.receivePending(tx, dependencies);\n                                    } catch (VerificationException e) {\n                                        log.error(\"{}: Wallet failed to process pending transaction {}\", getAddress(), tx.getHash());\n                                        log.error(\"Error was: \", e);\n                                        // Not much more we can do at this point.\n                                    }\n                                }\n\n                                @Override\n                                public void onFailure(Throwable throwable) {\n                                    log.error(\"Could not download dependencies of tx {}\", tx.getHashAsString());\n                                    log.error(\"Error was: \", throwable);\n                                    // Not much more we can do at this point.\n                                }\n                            });\n                        } else {\n                            wallet.receivePending(tx, null);\n                        }\n                    }\n                } catch (VerificationException e) {\n                    log.error(\"Wallet failed to verify tx\", e);\n                    // Carry on, listeners may still want to know.\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        // Tell all listeners about this tx so they can decide whether to keep it or not. If no listener keeps a\n        // reference around then the memory pool will forget about it after a while too because it uses weak references.\n        for (final ListenerRegistration<PeerEventListener> registration : eventListeners) {\n            registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onTransaction(Peer.this, tx);\n                }\n            });\n        }\n    }",
    "info" : "MethodDeclaration[33079-38891]:MethodDeclaration[33079-38891]"
  }, {
    "left" : "public dependencies List<Transaction>) : void",
    "right" : "public dependencies List<Transaction>) : void",
    "info" : "MethodDeclaration[36708-37458]:MethodDeclaration[36708-37458]"
  }, {
    "left" : "public throwable Throwable) : void",
    "right" : "public throwable Throwable) : void",
    "info" : "MethodDeclaration[37492-37876]:MethodDeclaration[37492-37876]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[38724-38859]:MethodDeclaration[38724-38859]"
  }, {
    "left" : "/**\n     * <p>Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.\n     * Only transactions in peers memory pools are included; the recursion stops at transactions that are in the\n     * current best chain. So it doesn't make much sense to provide a tx that was already in the best chain and\n     * a precondition checks this.</p>\n     *\n     * <p>For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and\n     * has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D\n     * that is in the chain, then this method will return either {B, C} or {C, B}. No ordering is guaranteed.</p>\n     *\n     * <p>This method is useful for apps that want to learn about how long an unconfirmed transaction might take\n     * to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying\n     * transactions that depend on unconfirmed free transactions.</p>\n     *\n     * <p>Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.</p>\n     */\n    public ListenableFuture<List<Transaction>> downloadDependencies(Transaction tx) {\n        TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence().getConfidenceType();\n        Preconditions.checkArgument(txConfidence != TransactionConfidence.ConfidenceType.BUILDING);\n        log.info(\"{}: Downloading dependencies of {}\", getAddress(), tx.getHashAsString());\n        final LinkedList<Transaction> results = new LinkedList<Transaction>();\n        // future will be invoked when the entire dependency tree has been walked and the results compiled.\n        final ListenableFuture<Object> future = downloadDependenciesInternal(tx, new Object(), results);\n        final SettableFuture<List<Transaction>> resultFuture = SettableFuture.create();\n        Futures.addCallback(future, new FutureCallback<Object>() {\n            @Override\n            public void onSuccess(Object ignored) {\n                resultFuture.set(results);\n            }\n\n            @Override\n            public void onFailure(Throwable throwable) {\n                resultFuture.setException(throwable);\n            }\n        });\n        return resultFuture;\n    }",
    "right" : "/**\n     * <p>Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.\n     * Only transactions in peers memory pools are included; the recursion stops at transactions that are in the\n     * current best chain. So it doesn't make much sense to provide a tx that was already in the best chain and\n     * a precondition checks this.</p>\n     *\n     * <p>For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and\n     * has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D\n     * that is in the chain, then this method will return either {B, C} or {C, B}. No ordering is guaranteed.</p>\n     *\n     * <p>This method is useful for apps that want to learn about how long an unconfirmed transaction might take\n     * to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying\n     * transactions that depend on unconfirmed free transactions.</p>\n     *\n     * <p>Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.</p>\n     */\n    public ListenableFuture<List<Transaction>> downloadDependencies(Transaction tx) {\n        TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence().getConfidenceType();\n        Preconditions.checkArgument(txConfidence != TransactionConfidence.ConfidenceType.BUILDING);\n        log.info(\"{}: Downloading dependencies of {}\", getAddress(), tx.getHashAsString());\n        final LinkedList<Transaction> results = new LinkedList<Transaction>();\n        // future will be invoked when the entire dependency tree has been walked and the results compiled.\n        final ListenableFuture<Object> future = downloadDependenciesInternal(tx, new Object(), results);\n        final SettableFuture<List<Transaction>> resultFuture = SettableFuture.create();\n        Futures.addCallback(future, new FutureCallback<Object>() {\n            @Override\n            public void onSuccess(Object ignored) {\n                resultFuture.set(results);\n            }\n\n            @Override\n            public void onFailure(Throwable throwable) {\n                resultFuture.setException(throwable);\n            }\n        });\n        return resultFuture;\n    }",
    "info" : "MethodDeclaration[38897-41228]:MethodDeclaration[38897-41228]"
  }, {
    "left" : "public ignored Object) : void",
    "right" : "public ignored Object) : void",
    "info" : "MethodDeclaration[40915-41033]:MethodDeclaration[40915-41033]"
  }, {
    "left" : "public throwable Throwable) : void",
    "right" : "public throwable Throwable) : void",
    "info" : "MethodDeclaration[41047-41181]:MethodDeclaration[41047-41181]"
  }, {
    "left" : "private tx Transaction, marker Object, results List<Transaction>) : ListenableFuture<Object>",
    "right" : "private tx Transaction, marker Object, results List<Transaction>) : ListenableFuture<Object>",
    "info" : "MethodDeclaration[41349-45783]:MethodDeclaration[41349-45783]"
  }, {
    "left" : "public transactions List<Transaction>) : void",
    "right" : "public transactions List<Transaction>) : void",
    "info" : "MethodDeclaration[43359-45234]:MethodDeclaration[43359-45234]"
  }, {
    "left" : "public objects List<Object>) : void",
    "right" : "public objects List<Object>) : void",
    "info" : "MethodDeclaration[44783-44954]:MethodDeclaration[44783-44954]"
  }, {
    "left" : "public throwable Throwable) : void",
    "right" : "public throwable Throwable) : void",
    "info" : "MethodDeclaration[44984-45166]:MethodDeclaration[44984-45166]"
  }, {
    "left" : "public throwable Throwable) : void",
    "right" : "public throwable Throwable) : void",
    "info" : "MethodDeclaration[45252-45398]:MethodDeclaration[45252-45398]"
  }, {
    "left" : "private m Block) : void",
    "right" : "private m Block) : void",
    "info" : "MethodDeclaration[45789-49305]:MethodDeclaration[45789-49305]"
  }, {
    "left" : "private void endFilteredBlock(FilteredBlock m) {\n        if (log.isDebugEnabled())\n            log.debug(\"{}: Received broadcast filtered block {}\", getAddress(), m.getHash().toString());\n        if (!vDownloadData) {\n            log.debug(\"{}: Received block we did not ask for: {}\", getAddress(), m.getHash().toString());\n            return;\n        }\n        if (blockChain == null) {\n            log.warn(\"Received filtered block but was not configured with an AbstractBlockChain\");\n            return;\n        }\n        // Note that we currently do nothing about peers which maliciously do not include transactions which\n        // actually match our filter or which simply do not send us all the transactions we need: it can be fixed\n        // by cross-checking peers against each other.\n        pendingBlockDownloads.remove(m.getBlockHeader().getHash());\n        try {\n            // It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.\n            // The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset\n            // of the hashes (those that were sent to us by the remote peer). Any hashes that haven't had a tx\n            // provided in processTransaction are ones that were announced to us previously via an 'inv' so the\n            // assumption is we have already downloaded them and either put them in the wallet, or threw them away\n            // for being false positives.\n            //\n            // TODO: Fix the following protocol race.\n            // It is possible for this code to go wrong such that we miss a confirmation. If the remote peer announces\n            // a relevant transaction via an 'inv' and then it immediately announces the block that confirms\n            // the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we\n            // will add the block to the chain here without the tx being in the wallet and thus it will miss its\n            // confirmation and become stuck forever. The fix is to notice that there's a pending getdata for a tx\n            // that appeared in this block and delay processing until it arrived ... it's complicated by the fact that\n            // the data may be requested by a different peer to this one.\n\n            // Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items\n            // (keys/addresses) that were used to calculate the previous filter. If so, then it's possible this block\n            // is only partial. Check for discarding first so we don't check for exhaustion on blocks we already know\n            // we're going to discard, otherwise redundant filters might end up being queued and calculated.\n            lock.lock();\n            try {\n                if (awaitingFreshFilter != null) {\n                    log.info(\"Discarding block {} because we're still waiting for a fresh filter\", m.getHash());\n                    // We must record the hashes of blocks we discard because you cannot do getblocks twice on the same\n                    // range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting\n                    // CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.\n                    awaitingFreshFilter.add(m.getHash());\n                    return;   // Chain download process is restarted via a call to setBloomFilter.\n                } else if (checkForFilterExhaustion(m)) {\n                    // Yes, so we must abandon the attempt to process this block and any further blocks we receive,\n                    // then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge\n                    // that the new filter is now in use (which we have to simulate with a ping/pong), and then we can\n                    // safely restart the chain download with the new filter that contains a new set of lookahead keys.\n                    log.info(\"Bloom filter exhausted whilst processing block {}, discarding\", m.getHash());\n                    awaitingFreshFilter = new LinkedList<Sha256Hash>();\n                    awaitingFreshFilter.add(m.getHash());\n                    awaitingFreshFilter.addAll(blockChain.drainOrphanBlocks());\n                    return;   // Chain download process is restarted via a call to setBloomFilter.\n                }\n            } finally {\n                lock.unlock();\n            }\n\n            if (blockChain.add(m)) {\n                // The block was successfully linked into the chain. Notify the user of our progress.\n                invokeOnBlocksDownloaded(m.getBlockHeader(), m);\n            } else {\n                // This block is an orphan - we don't know how to get from it back to the genesis block yet. That\n                // must mean that there are blocks we are missing, so do another getblocks with a new block locator\n                // to ask the peer to send them to us. This can happen during the initial block chain download where\n                // the peer will only send us 500 at a time and then sends us the head block expecting us to request\n                // the others.\n                //\n                // We must do two things here:\n                // (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set\n                // (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).\n                //\n                // The reason for (1) is that otherwise if new blocks were solved during the middle of chain download\n                // we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the\n                // chain twice (or more!) on the same connection! The block chain would filter out the duplicates but\n                // only at a huge speed penalty. By finding the orphan root we ensure every getblocks looks the same\n                // no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.\n                lock.lock();\n                try {\n                    final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));\n                    blockChainDownloadLocked(orphanRoot.getHash());\n                } finally {\n                    lock.unlock();\n                }\n            }\n        } catch (VerificationException e) {\n            // We don't want verification failures to kill the thread.\n            log.warn(\"{}: FilteredBlock verification failed\", getAddress(), e);\n        } catch (PrunedException e) {\n            // We pruned away some of the data we need to properly handle this block. We need to request the needed\n            // data from the remote peer and fix things. Or just give up.\n            // TODO: Request e.getHash() and submit it to the block store before any other blocks\n            throw new RuntimeException(e);\n        }\n    }",
    "right" : "private void endFilteredBlock(FilteredBlock m) {\n        if (log.isDebugEnabled())\n            log.debug(\"{}: Received broadcast filtered block {}\", getAddress(), m.getHash().toString());\n        if (!vDownloadData) {\n            log.debug(\"{}: Received block we did not ask for: {}\", getAddress(), m.getHash().toString());\n            return;\n        }\n        if (blockChain == null) {\n            log.warn(\"Received filtered block but was not configured with an AbstractBlockChain\");\n            return;\n        }\n        // Note that we currently do nothing about peers which maliciously do not include transactions which\n        // actually match our filter or which simply do not send us all the transactions we need: it can be fixed\n        // by cross-checking peers against each other.\n        pendingBlockDownloads.remove(m.getBlockHeader().getHash());\n        try {\n            // It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.\n            // The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset\n            // of the hashes (those that were sent to us by the remote peer). Any hashes that haven't had a tx\n            // provided in processTransaction are ones that were announced to us previously via an 'inv' so the\n            // assumption is we have already downloaded them and either put them in the wallet, or threw them away\n            // for being false positives.\n            //\n            // TODO: Fix the following protocol race.\n            // It is possible for this code to go wrong such that we miss a confirmation. If the remote peer announces\n            // a relevant transaction via an 'inv' and then it immediately announces the block that confirms\n            // the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we\n            // will add the block to the chain here without the tx being in the wallet and thus it will miss its\n            // confirmation and become stuck forever. The fix is to notice that there's a pending getdata for a tx\n            // that appeared in this block and delay processing until it arrived ... it's complicated by the fact that\n            // the data may be requested by a different peer to this one.\n\n            // Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items\n            // (keys/addresses) that were used to calculate the previous filter. If so, then it's possible this block\n            // is only partial. Check for discarding first so we don't check for exhaustion on blocks we already know\n            // we're going to discard, otherwise redundant filters might end up being queued and calculated.\n            lock.lock();\n            try {\n                if (awaitingFreshFilter != null) {\n                    log.info(\"Discarding block {} because we're still waiting for a fresh filter\", m.getHash());\n                    // We must record the hashes of blocks we discard because you cannot do getblocks twice on the same\n                    // range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting\n                    // CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.\n                    awaitingFreshFilter.add(m.getHash());\n                    return;   // Chain download process is restarted via a call to setBloomFilter.\n                } else if (checkForFilterExhaustion(m)) {\n                    // Yes, so we must abandon the attempt to process this block and any further blocks we receive,\n                    // then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge\n                    // that the new filter is now in use (which we have to simulate with a ping/pong), and then we can\n                    // safely restart the chain download with the new filter that contains a new set of lookahead keys.\n                    log.info(\"Bloom filter exhausted whilst processing block {}, discarding\", m.getHash());\n                    awaitingFreshFilter = new LinkedList<Sha256Hash>();\n                    awaitingFreshFilter.add(m.getHash());\n                    awaitingFreshFilter.addAll(blockChain.drainOrphanBlocks());\n                    return;   // Chain download process is restarted via a call to setBloomFilter.\n                }\n            } finally {\n                lock.unlock();\n            }\n\n            if (blockChain.add(m)) {\n                // The block was successfully linked into the chain. Notify the user of our progress.\n                invokeOnBlocksDownloaded(m.getBlockHeader(), m);\n            } else {\n                // This block is an orphan - we don't know how to get from it back to the genesis block yet. That\n                // must mean that there are blocks we are missing, so do another getblocks with a new block locator\n                // to ask the peer to send them to us. This can happen during the initial block chain download where\n                // the peer will only send us 500 at a time and then sends us the head block expecting us to request\n                // the others.\n                //\n                // We must do two things here:\n                // (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set\n                // (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).\n                //\n                // The reason for (1) is that otherwise if new blocks were solved during the middle of chain download\n                // we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the\n                // chain twice (or more!) on the same connection! The block chain would filter out the duplicates but\n                // only at a huge speed penalty. By finding the orphan root we ensure every getblocks looks the same\n                // no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.\n                lock.lock();\n                try {\n                    final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));\n                    blockChainDownloadLocked(orphanRoot.getHash());\n                } finally {\n                    lock.unlock();\n                }\n            }\n        } catch (VerificationException e) {\n            // We don't want verification failures to kill the thread.\n            log.warn(\"{}: FilteredBlock verification failed\", getAddress(), e);\n        } catch (PrunedException e) {\n            // We pruned away some of the data we need to properly handle this block. We need to request the needed\n            // data from the remote peer and fix things. Or just give up.\n            // TODO: Request e.getHash() and submit it to the block store before any other blocks\n            throw new RuntimeException(e);\n        }\n    }",
    "info" : "MethodDeclaration[49346-56372]:MethodDeclaration[49346-56372]"
  }, {
    "left" : "private m FilteredBlock) : boolean",
    "right" : "private m FilteredBlock) : boolean",
    "info" : "MethodDeclaration[56378-56615]:MethodDeclaration[56378-56615]"
  }, {
    "left" : "private boolean maybeHandleRequestedData(Message m) {\n        boolean found = false;\n        Sha256Hash hash = m.getHash();\n        for (GetDataRequest req : getDataFutures) {\n            if (hash.equals(req.hash)) {\n                req.future.set(m);\n                getDataFutures.remove(req);\n                found = true;\n                // Keep going in case there are more.\n            }\n        }\n        return found;\n    }",
    "right" : "private boolean maybeHandleRequestedData(Message m) {\n        boolean found = false;\n        Sha256Hash hash = m.getHash();\n        for (GetDataRequest req : getDataFutures) {\n            if (hash.equals(req.hash)) {\n                req.future.set(m);\n                getDataFutures.remove(req);\n                found = true;\n                // Keep going in case there are more.\n            }\n        }\n        return found;\n    }",
    "info" : "MethodDeclaration[56621-57052]:MethodDeclaration[56621-57052]"
  }, {
    "left" : "private void invokeOnBlocksDownloaded(final Block block, @Nullable final FilteredBlock fb) {\n        // It is possible for the peer block height difference to be negative when blocks have been solved and broadcast\n        // since the time we first connected to the peer. However, it's weird and unexpected to receive a callback\n        // with negative \"blocks left\" in this case, so we clamp to zero so the API user doesn't have to think about it.\n        final int blocksLeft = Math.max(0, (int) vPeerVersionMessage.bestHeight - checkNotNull(blockChain).getBestChainHeight());\n        for (final ListenerRegistration<PeerEventListener> registration : eventListeners) {\n            registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);\n                }\n            });\n        }\n    }",
    "right" : "private void invokeOnBlocksDownloaded(final Block block, @Nullable final FilteredBlock fb) {\n        // It is possible for the peer block height difference to be negative when blocks have been solved and broadcast\n        // since the time we first connected to the peer. However, it's weird and unexpected to receive a callback\n        // with negative \"blocks left\" in this case, so we clamp to zero so the API user doesn't have to think about it.\n        final int blocksLeft = Math.max(0, (int) vPeerVersionMessage.bestHeight - checkNotNull(blockChain).getBestChainHeight());\n        for (final ListenerRegistration<PeerEventListener> registration : eventListeners) {\n            registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);\n                }\n            });\n        }\n    }",
    "info" : "MethodDeclaration[57058-57996]:MethodDeclaration[57058-57996]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[57805-57964]:MethodDeclaration[57805-57964]"
  }, {
    "left" : "private void processInv(InventoryMessage inv) {\n        List<InventoryItem> items = inv.getItems();\n\n        // Separate out the blocks and transactions, we'll handle them differently\n        List<InventoryItem> transactions = new LinkedList<InventoryItem>();\n        List<InventoryItem> blocks = new LinkedList<InventoryItem>();\n\n        for (InventoryItem item : items) {\n            switch (item.type) {\n                case Transaction:\n                    transactions.add(item);\n                    break;\n                case Block:\n                    blocks.add(item);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Not implemented: \" + item.type);\n            }\n        }\n\n        final boolean downloadData = this.vDownloadData;\n\n        if (transactions.size() == 0 && blocks.size() == 1) {\n            // Single block announcement. If we're downloading the chain this is just a tickle to make us continue\n            // (the block chain download protocol is very implicit and not well thought out). If we're not downloading\n            // the chain then this probably means a new block was solved and the peer believes it connects to the best\n            // chain, so count it. This way getBestChainHeight() can be accurate.\n            if (downloadData && blockChain != null) {\n                if (!blockChain.isOrphan(blocks.get(0).hash)) {\n                    blocksAnnounced.incrementAndGet();\n                }\n            } else {\n                blocksAnnounced.incrementAndGet();\n            }\n        }\n\n        GetDataMessage getdata = new GetDataMessage(params);\n\n        Iterator<InventoryItem> it = transactions.iterator();\n        while (it.hasNext()) {\n            InventoryItem item = it.next();\n            // Only download the transaction if we are the first peer that saw it be advertised. Other peers will also\n            // see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool. We could\n            // potentially download transactions faster by always asking every peer for a tx when advertised, as remote\n            // peers run at different speeds. However to conserve bandwidth on mobile devices we try to only download a\n            // transaction once. This means we can miss broadcasts if the peer disconnects between sending us an inv and\n            // sending us the transaction: currently we'll never try to re-fetch after a timeout.\n            //\n            // The line below can trigger confidence listeners.\n            TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress());\n            if (conf.numBroadcastPeers() > 1) {\n                // Some other peer already announced this so don't download.\n                it.remove();\n            } else if (conf.getSource().equals(TransactionConfidence.Source.SELF)) {\n                // We created this transaction ourselves, so don't download.\n                it.remove();\n            } else {\n                log.debug(\"{}: getdata on tx {}\", getAddress(), item.hash);\n                getdata.addItem(item);\n                // Register with the garbage collector that we care about the confidence data for a while.\n                pendingTxDownloads.add(conf);\n            }\n        }\n\n        // If we are requesting filteredblocks we have to send a ping after the getdata so that we have a clear\n        // end to the final FilteredBlock's transactions (in the form of a pong) sent to us\n        boolean pingAfterGetData = false;\n\n        lock.lock();\n        try {\n            if (blocks.size() > 0 && downloadData && blockChain != null) {\n                // Ideally, we'd only ask for the data here if we actually needed it. However that can imply a lot of\n                // disk IO to figure out what we've got. Normally peers will not send us inv for things we already have\n                // so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.\n                for (InventoryItem item : blocks) {\n                    if (blockChain.isOrphan(item.hash) && downloadBlockBodies) {\n                        // If an orphan was re-advertised, ask for more blocks unless we are not currently downloading\n                        // full block data because we have a getheaders outstanding.\n                        final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(item.hash));\n                        blockChainDownloadLocked(orphanRoot.getHash());\n                    } else {\n                        // Don't re-request blocks we already requested. Normally this should not happen. However there is\n                        // an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle\n                        // whilst other parts of the chain are streaming in, then the new getblocks request won't match the\n                        // previous one: whilst the stopHash is the same (because we use the orphan root), the start hash\n                        // will be different and so the getblocks req won't be dropped as a duplicate. We'll end up\n                        // requesting a subset of what we already requested, which can lead to parallel chain downloads\n                        // and other nastyness. So we just do a quick removal of redundant getdatas here too.\n                        //\n                        // Note that as of June 2012 the Satoshi client won't actually ever interleave blocks pushed as\n                        // part of chain download with newly announced blocks, so it should always be taken care of by\n                        // the duplicate check in blockChainDownloadLocked(). But the satoshi client may change in future so\n                        // it's better to be safe here.\n                        if (!pendingBlockDownloads.contains(item.hash)) {\n                            if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks) {\n                                getdata.addFilteredBlock(item.hash);\n                                pingAfterGetData = true;\n                            } else {\n                                getdata.addItem(item);\n                            }\n                            pendingBlockDownloads.add(item.hash);\n                        }\n                    }\n                }\n                // If we're downloading the chain, doing a getdata on the last block we were told about will cause the\n                // peer to advertize the head block to us in a single-item inv. When we download THAT, it will be an\n                // orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the\n                // current best block we have and the orphan block. If more blocks arrive in the meantime they'll also\n                // become orphan.\n            }\n        } finally {\n            lock.unlock();\n        }\n\n        if (!getdata.getItems().isEmpty()) {\n            // This will cause us to receive a bunch of block or tx messages.\n            sendMessage(getdata);\n        }\n\n        if (pingAfterGetData)\n            sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));\n    }",
    "right" : "private void processInv(InventoryMessage inv) {\n        List<InventoryItem> items = inv.getItems();\n\n        // Separate out the blocks and transactions, we'll handle them differently\n        List<InventoryItem> transactions = new LinkedList<InventoryItem>();\n        List<InventoryItem> blocks = new LinkedList<InventoryItem>();\n\n        for (InventoryItem item : items) {\n            switch (item.type) {\n                case Transaction:\n                    transactions.add(item);\n                    break;\n                case Block:\n                    blocks.add(item);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Not implemented: \" + item.type);\n            }\n        }\n\n        final boolean downloadData = this.vDownloadData;\n\n        if (transactions.size() == 0 && blocks.size() == 1) {\n            // Single block announcement. If we're downloading the chain this is just a tickle to make us continue\n            // (the block chain download protocol is very implicit and not well thought out). If we're not downloading\n            // the chain then this probably means a new block was solved and the peer believes it connects to the best\n            // chain, so count it. This way getBestChainHeight() can be accurate.\n            if (downloadData && blockChain != null) {\n                if (!blockChain.isOrphan(blocks.get(0).hash)) {\n                    blocksAnnounced.incrementAndGet();\n                }\n            } else {\n                blocksAnnounced.incrementAndGet();\n            }\n        }\n\n        GetDataMessage getdata = new GetDataMessage(params);\n\n        Iterator<InventoryItem> it = transactions.iterator();\n        while (it.hasNext()) {\n            InventoryItem item = it.next();\n            // Only download the transaction if we are the first peer that saw it be advertised. Other peers will also\n            // see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool. We could\n            // potentially download transactions faster by always asking every peer for a tx when advertised, as remote\n            // peers run at different speeds. However to conserve bandwidth on mobile devices we try to only download a\n            // transaction once. This means we can miss broadcasts if the peer disconnects between sending us an inv and\n            // sending us the transaction: currently we'll never try to re-fetch after a timeout.\n            //\n            // The line below can trigger confidence listeners.\n            TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress());\n            if (conf.numBroadcastPeers() > 1) {\n                // Some other peer already announced this so don't download.\n                it.remove();\n            } else if (conf.getSource().equals(TransactionConfidence.Source.SELF)) {\n                // We created this transaction ourselves, so don't download.\n                it.remove();\n            } else {\n                log.debug(\"{}: getdata on tx {}\", getAddress(), item.hash);\n                getdata.addItem(item);\n                // Register with the garbage collector that we care about the confidence data for a while.\n                pendingTxDownloads.add(conf);\n            }\n        }\n\n        // If we are requesting filteredblocks we have to send a ping after the getdata so that we have a clear\n        // end to the final FilteredBlock's transactions (in the form of a pong) sent to us\n        boolean pingAfterGetData = false;\n\n        lock.lock();\n        try {\n            if (blocks.size() > 0 && downloadData && blockChain != null) {\n                // Ideally, we'd only ask for the data here if we actually needed it. However that can imply a lot of\n                // disk IO to figure out what we've got. Normally peers will not send us inv for things we already have\n                // so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.\n                for (InventoryItem item : blocks) {\n                    if (blockChain.isOrphan(item.hash) && downloadBlockBodies) {\n                        // If an orphan was re-advertised, ask for more blocks unless we are not currently downloading\n                        // full block data because we have a getheaders outstanding.\n                        final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(item.hash));\n                        blockChainDownloadLocked(orphanRoot.getHash());\n                    } else {\n                        // Don't re-request blocks we already requested. Normally this should not happen. However there is\n                        // an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle\n                        // whilst other parts of the chain are streaming in, then the new getblocks request won't match the\n                        // previous one: whilst the stopHash is the same (because we use the orphan root), the start hash\n                        // will be different and so the getblocks req won't be dropped as a duplicate. We'll end up\n                        // requesting a subset of what we already requested, which can lead to parallel chain downloads\n                        // and other nastyness. So we just do a quick removal of redundant getdatas here too.\n                        //\n                        // Note that as of June 2012 the Satoshi client won't actually ever interleave blocks pushed as\n                        // part of chain download with newly announced blocks, so it should always be taken care of by\n                        // the duplicate check in blockChainDownloadLocked(). But the satoshi client may change in future so\n                        // it's better to be safe here.\n                        if (!pendingBlockDownloads.contains(item.hash)) {\n                            if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks) {\n                                getdata.addFilteredBlock(item.hash);\n                                pingAfterGetData = true;\n                            } else {\n                                getdata.addItem(item);\n                            }\n                            pendingBlockDownloads.add(item.hash);\n                        }\n                    }\n                }\n                // If we're downloading the chain, doing a getdata on the last block we were told about will cause the\n                // peer to advertize the head block to us in a single-item inv. When we download THAT, it will be an\n                // orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the\n                // current best block we have and the orphan block. If more blocks arrive in the meantime they'll also\n                // become orphan.\n            }\n        } finally {\n            lock.unlock();\n        }\n\n        if (!getdata.getItems().isEmpty()) {\n            // This will cause us to receive a bunch of block or tx messages.\n            sendMessage(getdata);\n        }\n\n        if (pingAfterGetData)\n            sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));\n    }",
    "info" : "MethodDeclaration[58002-65282]:MethodDeclaration[58002-65282]"
  }, {
    "left" : "/**\n     * Asks the connected peer for the block of the given hash, and returns a future representing the answer.\n     * If you want the block right away and don't mind waiting for it, just call .get() on the result. Your thread\n     * will block until the peer answers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning\n    // ListenableFuture instead of ListenableFuture<Block>. This is okay as sendSingleGetData() actually returns\n    // ListenableFuture<Block> in this context. Note that sendSingleGetData() is also used for Transactions.\n    public ListenableFuture<Block> getBlock(Sha256Hash blockHash) {\n        // This does not need to be locked.\n        log.info(\"Request to fetch block {}\", blockHash);\n        GetDataMessage getdata = new GetDataMessage(params);\n        getdata.addBlock(blockHash);\n        return sendSingleGetData(getdata);\n    }",
    "right" : "/**\n     * Asks the connected peer for the block of the given hash, and returns a future representing the answer.\n     * If you want the block right away and don't mind waiting for it, just call .get() on the result. Your thread\n     * will block until the peer answers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning\n    // ListenableFuture instead of ListenableFuture<Block>. This is okay as sendSingleGetData() actually returns\n    // ListenableFuture<Block> in this context. Note that sendSingleGetData() is also used for Transactions.\n    public ListenableFuture<Block> getBlock(Sha256Hash blockHash) {\n        // This does not need to be locked.\n        log.info(\"Request to fetch block {}\", blockHash);\n        GetDataMessage getdata = new GetDataMessage(params);\n        getdata.addBlock(blockHash);\n        return sendSingleGetData(getdata);\n    }",
    "info" : "MethodDeclaration[65288-66258]:MethodDeclaration[65288-66258]"
  }, {
    "left" : "/**\n     * Asks the connected peer for the given transaction from its memory pool. Transactions in the chain cannot be\n     * retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,\n     * in future many peers will delete old transaction data they don't need.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning\n    // ListenableFuture instead of ListenableFuture<Transaction>. This is okay as sendSingleGetData() actually returns\n    // ListenableFuture<Transaction> in this context. Note that sendSingleGetData() is also used for Blocks.\n    public ListenableFuture<Transaction> getPeerMempoolTransaction(Sha256Hash hash) {\n        // This does not need to be locked.\n        // TODO: Unit test this method.\n        log.info(\"Request to fetch peer mempool tx  {}\", hash);\n        GetDataMessage getdata = new GetDataMessage(params);\n        getdata.addTransaction(hash);\n        return sendSingleGetData(getdata);\n    }",
    "right" : "/**\n     * Asks the connected peer for the given transaction from its memory pool. Transactions in the chain cannot be\n     * retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,\n     * in future many peers will delete old transaction data they don't need.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning\n    // ListenableFuture instead of ListenableFuture<Transaction>. This is okay as sendSingleGetData() actually returns\n    // ListenableFuture<Transaction> in this context. Note that sendSingleGetData() is also used for Blocks.\n    public ListenableFuture<Transaction> getPeerMempoolTransaction(Sha256Hash hash) {\n        // This does not need to be locked.\n        // TODO: Unit test this method.\n        log.info(\"Request to fetch peer mempool tx  {}\", hash);\n        GetDataMessage getdata = new GetDataMessage(params);\n        getdata.addTransaction(hash);\n        return sendSingleGetData(getdata);\n    }",
    "info" : "MethodDeclaration[66264-67346]:MethodDeclaration[66264-67346]"
  }, {
    "left" : "private getdata GetDataMessage) : ListenableFuture",
    "right" : "private getdata GetDataMessage) : ListenableFuture",
    "info" : "MethodDeclaration[67352-67830]:MethodDeclaration[67352-67830]"
  }, {
    "left" : "/** Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. */\n    public ListenableFuture<AddressMessage> getAddr() {\n        SettableFuture<AddressMessage> future = SettableFuture.create();\n        synchronized (getAddrFutures) {\n            getAddrFutures.add(future);\n        }\n        sendMessage(new GetAddrMessage(params));\n        return future;\n    }",
    "right" : "/** Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. */\n    public ListenableFuture<AddressMessage> getAddr() {\n        SettableFuture<AddressMessage> future = SettableFuture.create();\n        synchronized (getAddrFutures) {\n            getAddrFutures.add(future);\n        }\n        sendMessage(new GetAddrMessage(params));\n        return future;\n    }",
    "info" : "MethodDeclaration[67836-68254]:MethodDeclaration[67836-68254]"
  }, {
    "left" : "/**\n     * When downloading the block chain, the bodies will be skipped for blocks created before the given date. Any\n     * transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such\n     * transactions it doesn't matter and can save a lot of bandwidth and processing time. Note that the times of blocks\n     * isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded\n     * twice using this scheme, but this optimization can still be a large win for newly created wallets.\n     *\n     * @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.\n     */\n    public void setDownloadParameters(long secondsSinceEpoch, boolean useFilteredBlocks) {\n        lock.lock();\n        try {\n            if (secondsSinceEpoch == 0) {\n                fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();\n                downloadBlockBodies = true;\n            } else {\n                fastCatchupTimeSecs = secondsSinceEpoch;\n                // If the given time is before the current chains head block time, then this has no effect (we already\n                // downloaded everything we need).\n                if (blockChain != null && fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds())\n                    downloadBlockBodies = false;\n            }\n            this.useFilteredBlocks = useFilteredBlocks;\n        } finally {\n            lock.unlock();\n        }\n    }",
    "right" : "/**\n     * When downloading the block chain, the bodies will be skipped for blocks created before the given date. Any\n     * transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such\n     * transactions it doesn't matter and can save a lot of bandwidth and processing time. Note that the times of blocks\n     * isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded\n     * twice using this scheme, but this optimization can still be a large win for newly created wallets.\n     *\n     * @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.\n     */\n    public void setDownloadParameters(long secondsSinceEpoch, boolean useFilteredBlocks) {\n        lock.lock();\n        try {\n            if (secondsSinceEpoch == 0) {\n                fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();\n                downloadBlockBodies = true;\n            } else {\n                fastCatchupTimeSecs = secondsSinceEpoch;\n                // If the given time is before the current chains head block time, then this has no effect (we already\n                // downloaded everything we need).\n                if (blockChain != null && fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds())\n                    downloadBlockBodies = false;\n            }\n            this.useFilteredBlocks = useFilteredBlocks;\n        } finally {\n            lock.unlock();\n        }\n    }",
    "info" : "MethodDeclaration[68260-69809]:MethodDeclaration[68260-69809]"
  }, {
    "left" : "/**\n     * Links the given wallet to this peer. If you have multiple peers, you should use a {@link PeerGroup} to manage\n     * them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer\n     * independently, otherwise the wallet will receive duplicate notifications.\n     */\n    public void addWallet(Wallet wallet) {\n        wallets.add(wallet);\n    }",
    "right" : "/**\n     * Links the given wallet to this peer. If you have multiple peers, you should use a {@link PeerGroup} to manage\n     * them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer\n     * independently, otherwise the wallet will receive duplicate notifications.\n     */\n    public void addWallet(Wallet wallet) {\n        wallets.add(wallet);\n    }",
    "info" : "MethodDeclaration[69815-70218]:MethodDeclaration[69815-70218]"
  }, {
    "left" : "/** Unlinks the given wallet from peer. See {@link Peer#addWallet(Wallet)}. */\n    public void removeWallet(Wallet wallet) {\n        wallets.remove(wallet);\n    }",
    "right" : "/** Unlinks the given wallet from peer. See {@link Peer#addWallet(Wallet)}. */\n    public void removeWallet(Wallet wallet) {\n        wallets.remove(wallet);\n    }",
    "info" : "MethodDeclaration[70224-70386]:MethodDeclaration[70224-70386]"
  }, {
    "left" : "@GuardedBy(\"lock\")\n    private Sha256Hash lastGetBlocksBegin, lastGetBlocksEnd;",
    "right" : "@GuardedBy(\"lock\")\n    private Sha256Hash lastGetBlocksBegin, lastGetBlocksEnd;",
    "info" : "FieldDeclaration[70543-70622]:FieldDeclaration[70543-70622]"
  }, {
    "left" : "@GuardedBy(\"lock\")\n    private void blockChainDownloadLocked(Sha256Hash toHash) {\n        checkState(lock.isHeldByCurrentThread());\n        // The block chain download process is a bit complicated. Basically, we start with one or more blocks in a\n        // chain that we have from a previous session. We want to catch up to the head of the chain BUT we don't know\n        // where that chain is up to or even if the top block we have is even still in the chain - we\n        // might have got ourselves onto a fork that was later resolved by the network.\n        //\n        // To solve this, we send the peer a block locator which is just a list of block hashes. It contains the\n        // blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up\n        // on a fork and if so, what the earliest still valid block we know about is likely to be.\n        //\n        // Once it has decided which blocks we need, it will send us an inv with up to 500 block messages. We may\n        // have some of them already if we already have a block chain and just need to catch up. Once we request the\n        // last block, if there are still more to come it sends us an \"inv\" containing only the hash of the head\n        // block.\n        //\n        // That causes us to download the head block but then we find (in processBlock) that we can't connect\n        // it to the chain yet because we don't have the intermediate blocks. So we rerun this function building a\n        // new block locator describing where we're up to.\n        //\n        // The getblocks with the new locator gets us another inv with another bunch of blocks. We download them once\n        // again. This time when the peer sends us an inv with the head block, we already have it so we won't download\n        // it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the\n        // process.\n        //\n        // So this is a complicated process but it has the advantage that we can download a chain of enormous length\n        // in a relatively stateless manner and with constant memory usage.\n        //\n        // All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the\n        // 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet. Because\n        // we know there are no transactions using our keys before that date, we need only the headers. To do that we\n        // use the \"getheaders\" command. Once we find we've gone past the target date, we throw away the downloaded\n        // headers and then request the blocks from that point onwards. \"getheaders\" does not send us an inv, it just\n        // sends us the data we requested in a \"headers\" message.\n\n        // TODO: Block locators should be abstracted out rather than special cased here.\n        List<Sha256Hash> blockLocator = new ArrayList<Sha256Hash>(51);\n        // For now we don't do the exponential thinning as suggested here:\n        //\n        //   https://en.bitcoin.it/wiki/Protocol_specification#getblocks\n        //\n        // This is because it requires scanning all the block chain headers, which is very slow. Instead we add the top\n        // 100 block headers. If there is a re-org deeper than that, we'll end up downloading the entire chain. We\n        // must always put the genesis block as the first entry.\n        BlockStore store = checkNotNull(blockChain).getBlockStore();\n        StoredBlock chainHead = blockChain.getChainHead();\n        Sha256Hash chainHeadHash = chainHead.getHeader().getHash();\n        // Did we already make this request? If so, don't do it again.\n        if (Objects.equal(lastGetBlocksBegin, chainHeadHash) && Objects.equal(lastGetBlocksEnd, toHash)) {\n            log.info(\"blockChainDownloadLocked({}): ignoring duplicated request: {}\", toHash, chainHeadHash);\n            for (Sha256Hash hash : pendingBlockDownloads)\n                log.info(\"Pending block download: {}\", hash);\n            log.info(Throwables.getStackTraceAsString(new Throwable()));\n            return;\n        }\n        if (log.isDebugEnabled())\n            log.debug(\"{}: blockChainDownloadLocked({}) current head = {}\",\n                    this, toHash, chainHead.getHeader().getHashAsString());\n        StoredBlock cursor = chainHead;\n        for (int i = 100; cursor != null && i > 0; i--) {\n            blockLocator.add(cursor.getHeader().getHash());\n            try {\n                cursor = cursor.getPrev(store);\n            } catch (BlockStoreException e) {\n                log.error(\"Failed to walk the block chain whilst constructing a locator\");\n                throw new RuntimeException(e);\n            }\n        }\n        // Only add the locator if we didn't already do so. If the chain is < 50 blocks we already reached it.\n        if (cursor != null)\n            blockLocator.add(params.getGenesisBlock().getHash());\n\n        // Record that we requested this range of blocks so we can filter out duplicate requests in the event of a\n        // block being solved during chain download.\n        lastGetBlocksBegin = chainHeadHash;\n        lastGetBlocksEnd = toHash;\n\n        if (downloadBlockBodies) {\n            GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash);\n            sendMessage(message);\n        } else {\n            // Downloading headers for a while instead of full blocks.\n            GetHeadersMessage message = new GetHeadersMessage(params, blockLocator, toHash);\n            sendMessage(message);\n        }\n    }",
    "right" : "@GuardedBy(\"lock\")\n    private void blockChainDownloadLocked(Sha256Hash toHash) {\n        checkState(lock.isHeldByCurrentThread());\n        // The block chain download process is a bit complicated. Basically, we start with one or more blocks in a\n        // chain that we have from a previous session. We want to catch up to the head of the chain BUT we don't know\n        // where that chain is up to or even if the top block we have is even still in the chain - we\n        // might have got ourselves onto a fork that was later resolved by the network.\n        //\n        // To solve this, we send the peer a block locator which is just a list of block hashes. It contains the\n        // blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up\n        // on a fork and if so, what the earliest still valid block we know about is likely to be.\n        //\n        // Once it has decided which blocks we need, it will send us an inv with up to 500 block messages. We may\n        // have some of them already if we already have a block chain and just need to catch up. Once we request the\n        // last block, if there are still more to come it sends us an \"inv\" containing only the hash of the head\n        // block.\n        //\n        // That causes us to download the head block but then we find (in processBlock) that we can't connect\n        // it to the chain yet because we don't have the intermediate blocks. So we rerun this function building a\n        // new block locator describing where we're up to.\n        //\n        // The getblocks with the new locator gets us another inv with another bunch of blocks. We download them once\n        // again. This time when the peer sends us an inv with the head block, we already have it so we won't download\n        // it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the\n        // process.\n        //\n        // So this is a complicated process but it has the advantage that we can download a chain of enormous length\n        // in a relatively stateless manner and with constant memory usage.\n        //\n        // All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the\n        // 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet. Because\n        // we know there are no transactions using our keys before that date, we need only the headers. To do that we\n        // use the \"getheaders\" command. Once we find we've gone past the target date, we throw away the downloaded\n        // headers and then request the blocks from that point onwards. \"getheaders\" does not send us an inv, it just\n        // sends us the data we requested in a \"headers\" message.\n\n        // TODO: Block locators should be abstracted out rather than special cased here.\n        List<Sha256Hash> blockLocator = new ArrayList<Sha256Hash>(51);\n        // For now we don't do the exponential thinning as suggested here:\n        //\n        //   https://en.bitcoin.it/wiki/Protocol_specification#getblocks\n        //\n        // This is because it requires scanning all the block chain headers, which is very slow. Instead we add the top\n        // 100 block headers. If there is a re-org deeper than that, we'll end up downloading the entire chain. We\n        // must always put the genesis block as the first entry.\n        BlockStore store = checkNotNull(blockChain).getBlockStore();\n        StoredBlock chainHead = blockChain.getChainHead();\n        Sha256Hash chainHeadHash = chainHead.getHeader().getHash();\n        // Did we already make this request? If so, don't do it again.\n        if (Objects.equal(lastGetBlocksBegin, chainHeadHash) && Objects.equal(lastGetBlocksEnd, toHash)) {\n            log.info(\"blockChainDownloadLocked({}): ignoring duplicated request: {}\", toHash, chainHeadHash);\n            for (Sha256Hash hash : pendingBlockDownloads)\n                log.info(\"Pending block download: {}\", hash);\n            log.info(Throwables.getStackTraceAsString(new Throwable()));\n            return;\n        }\n        if (log.isDebugEnabled())\n            log.debug(\"{}: blockChainDownloadLocked({}) current head = {}\",\n                    this, toHash, chainHead.getHeader().getHashAsString());\n        StoredBlock cursor = chainHead;\n        for (int i = 100; cursor != null && i > 0; i--) {\n            blockLocator.add(cursor.getHeader().getHash());\n            try {\n                cursor = cursor.getPrev(store);\n            } catch (BlockStoreException e) {\n                log.error(\"Failed to walk the block chain whilst constructing a locator\");\n                throw new RuntimeException(e);\n            }\n        }\n        // Only add the locator if we didn't already do so. If the chain is < 50 blocks we already reached it.\n        if (cursor != null)\n            blockLocator.add(params.getGenesisBlock().getHash());\n\n        // Record that we requested this range of blocks so we can filter out duplicate requests in the event of a\n        // block being solved during chain download.\n        lastGetBlocksBegin = chainHeadHash;\n        lastGetBlocksEnd = toHash;\n\n        if (downloadBlockBodies) {\n            GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash);\n            sendMessage(message);\n        } else {\n            // Downloading headers for a while instead of full blocks.\n            GetHeadersMessage message = new GetHeadersMessage(params, blockLocator, toHash);\n            sendMessage(message);\n        }\n    }",
    "info" : "MethodDeclaration[70628-76248]:MethodDeclaration[70628-76248]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[76254-77472]:MethodDeclaration[76254-77472]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[76985-77149]:MethodDeclaration[76985-77149]"
  }, {
    "left" : "private class PendingPing {\n        // The future that will be invoked when the pong is heard back.\n        public SettableFuture<Long> future;\n        // The random nonce that lets us tell apart overlapping pings/pongs.\n        public final long nonce;\n        // Measurement of the time elapsed.\n        public final long startTimeMsec;\n\n        public PendingPing(long nonce) {\n            future = SettableFuture.create();\n            this.nonce = nonce;\n            startTimeMsec = Utils.currentTimeMillis();\n        }\n\n        public void complete() {\n            if (!future.isDone()) {\n                Long elapsed = Utils.currentTimeMillis() - startTimeMsec;\n                Peer.this.addPingTimeData(elapsed);\n                log.debug(\"{}: ping time is {} msec\", Peer.this.toString(), elapsed);\n                future.set(elapsed);\n            }\n        }\n    }",
    "right" : "private class PendingPing {\n        // The future that will be invoked when the pong is heard back.\n        public SettableFuture<Long> future;\n        // The random nonce that lets us tell apart overlapping pings/pongs.\n        public final long nonce;\n        // Measurement of the time elapsed.\n        public final long startTimeMsec;\n\n        public PendingPing(long nonce) {\n            future = SettableFuture.create();\n            this.nonce = nonce;\n            startTimeMsec = Utils.currentTimeMillis();\n        }\n\n        public void complete() {\n            if (!future.isDone()) {\n                Long elapsed = Utils.currentTimeMillis() - startTimeMsec;\n                Peer.this.addPingTimeData(elapsed);\n                log.debug(\"{}: ping time is {} msec\", Peer.this.toString(), elapsed);\n                future.set(elapsed);\n            }\n        }\n    }",
    "info" : "TypeDeclaration[77478-78350]:TypeDeclaration[77478-78350]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[77586-77621]:FieldDeclaration[77586-77621]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[77707-77731]:FieldDeclaration[77707-77731]"
  }, {
    "left" : "",
    "right" : "",
    "info" : "FieldDeclaration[77784-77816]:FieldDeclaration[77784-77816]"
  }, {
    "left" : "public nonce long)",
    "right" : "public nonce long)",
    "info" : "MethodDeclaration[77826-78001]:MethodDeclaration[77826-78001]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[78011-78344]:MethodDeclaration[78011-78344]"
  }, {
    "left" : "/** Adds a ping time sample to the averaging window. */\n    private void addPingTimeData(long sample) {\n        lastPingTimesLock.lock();\n        try {\n            if (lastPingTimes == null) {\n                lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW];\n                // Initialize the averaging window to the first sample.\n                Arrays.fill(lastPingTimes, sample);\n            } else {\n                // Shift all elements backwards by one.\n                System.arraycopy(lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1);\n                // And append the new sample to the end.\n                lastPingTimes[lastPingTimes.length - 1] = sample;\n            }\n        } finally {\n            lastPingTimesLock.unlock();\n        }\n    }",
    "right" : "/** Adds a ping time sample to the averaging window. */\n    private void addPingTimeData(long sample) {\n        lastPingTimesLock.lock();\n        try {\n            if (lastPingTimes == null) {\n                lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW];\n                // Initialize the averaging window to the first sample.\n                Arrays.fill(lastPingTimes, sample);\n            } else {\n                // Shift all elements backwards by one.\n                System.arraycopy(lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1);\n                // And append the new sample to the end.\n                lastPingTimes[lastPingTimes.length - 1] = sample;\n            }\n        } finally {\n            lastPingTimesLock.unlock();\n        }\n    }",
    "info" : "MethodDeclaration[78356-79128]:MethodDeclaration[78356-79128]"
  }, {
    "left" : "/**\n     * Sends the peer a ping message and returns a future that will be invoked when the pong is received back.\n     * The future provides a number which is the number of milliseconds elapsed between the ping and the pong.\n     * Once the pong is received the value returned by {@link org.bitcoinj.core.Peer#getLastPingTime()} is\n     * updated.\n     * @throws ProtocolException if the peer version is too low to support measurable pings.\n     */\n    public ListenableFuture<Long> ping() throws ProtocolException {\n        return ping((long) (Math.random() * Long.MAX_VALUE));\n    }",
    "right" : "/**\n     * Sends the peer a ping message and returns a future that will be invoked when the pong is received back.\n     * The future provides a number which is the number of milliseconds elapsed between the ping and the pong.\n     * Once the pong is received the value returned by {@link org.bitcoinj.core.Peer#getLastPingTime()} is\n     * updated.\n     * @throws ProtocolException if the peer version is too low to support measurable pings.\n     */\n    public ListenableFuture<Long> ping() throws ProtocolException {\n        return ping((long) (Math.random() * Long.MAX_VALUE));\n    }",
    "info" : "MethodDeclaration[79134-79719]:MethodDeclaration[79134-79719]"
  }, {
    "left" : "protected ListenableFuture<Long> ping(long nonce) throws ProtocolException {\n        final VersionMessage ver = vPeerVersionMessage;\n        if (!ver.isPingPongSupported())\n            throw new ProtocolException(\"Peer version is too low for measurable pings: \" + ver);\n        PendingPing pendingPing = new PendingPing(nonce);\n        pendingPings.add(pendingPing);\n        sendMessage(new Ping(pendingPing.nonce));\n        return pendingPing.future;\n    }",
    "right" : "protected ListenableFuture<Long> ping(long nonce) throws ProtocolException {\n        final VersionMessage ver = vPeerVersionMessage;\n        if (!ver.isPingPongSupported())\n            throw new ProtocolException(\"Peer version is too low for measurable pings: \" + ver);\n        PendingPing pendingPing = new PendingPing(nonce);\n        pendingPings.add(pendingPing);\n        sendMessage(new Ping(pendingPing.nonce));\n        return pendingPing.future;\n    }",
    "info" : "MethodDeclaration[79725-80182]:MethodDeclaration[79725-80182]"
  }, {
    "left" : "/**\n     * Returns the elapsed time of the last ping/pong cycle. If {@link org.bitcoinj.core.Peer#ping()} has never\n     * been called or we did not hear back the \"pong\" message yet, returns {@link Long#MAX_VALUE}.\n     */\n    public long getLastPingTime() {\n        lastPingTimesLock.lock();\n        try {\n            if (lastPingTimes == null)\n                return Long.MAX_VALUE;\n            return lastPingTimes[lastPingTimes.length - 1];\n        } finally {\n            lastPingTimesLock.unlock();\n        }\n    }",
    "right" : "/**\n     * Returns the elapsed time of the last ping/pong cycle. If {@link org.bitcoinj.core.Peer#ping()} has never\n     * been called or we did not hear back the \"pong\" message yet, returns {@link Long#MAX_VALUE}.\n     */\n    public long getLastPingTime() {\n        lastPingTimesLock.lock();\n        try {\n            if (lastPingTimes == null)\n                return Long.MAX_VALUE;\n            return lastPingTimes[lastPingTimes.length - 1];\n        } finally {\n            lastPingTimesLock.unlock();\n        }\n    }",
    "info" : "MethodDeclaration[80188-80708]:MethodDeclaration[80188-80708]"
  }, {
    "left" : "/**\n     * Returns a moving average of the last N ping/pong cycles. If {@link org.bitcoinj.core.Peer#ping()} has never\n     * been called or we did not hear back the \"pong\" message yet, returns {@link Long#MAX_VALUE}. The moving average\n     * window is 5 buckets.\n     */\n    public long getPingTime() {\n        lastPingTimesLock.lock();\n        try {\n            if (lastPingTimes == null)\n                return Long.MAX_VALUE;\n            long sum = 0;\n            for (long i : lastPingTimes) sum += i;\n            return (long)((double) sum / lastPingTimes.length);\n        } finally {\n            lastPingTimesLock.unlock();\n        }\n    }",
    "right" : "/**\n     * Returns a moving average of the last N ping/pong cycles. If {@link org.bitcoinj.core.Peer#ping()} has never\n     * been called or we did not hear back the \"pong\" message yet, returns {@link Long#MAX_VALUE}. The moving average\n     * window is 5 buckets.\n     */\n    public long getPingTime() {\n        lastPingTimesLock.lock();\n        try {\n            if (lastPingTimes == null)\n                return Long.MAX_VALUE;\n            long sum = 0;\n            for (long i : lastPingTimes) sum += i;\n            return (long)((double) sum / lastPingTimes.length);\n        } finally {\n            lastPingTimesLock.unlock();\n        }\n    }",
    "info" : "MethodDeclaration[80714-81361]:MethodDeclaration[80714-81361]"
  }, {
    "left" : "private void processPong(Pong m) {\n        // Iterates over a snapshot of the list, so we can run unlocked here.\n        for (PendingPing ping : pendingPings) {\n            if (m.getNonce() == ping.nonce) {\n                pendingPings.remove(ping);\n                // This line may trigger an event listener that re-runs ping().\n                ping.complete();\n                return;\n            }\n        }\n    }",
    "right" : "private void processPong(Pong m) {\n        // Iterates over a snapshot of the list, so we can run unlocked here.\n        for (PendingPing ping : pendingPings) {\n            if (m.getNonce() == ping.nonce) {\n                pendingPings.remove(ping);\n                // This line may trigger an event listener that re-runs ping().\n                ping.complete();\n                return;\n            }\n        }\n    }",
    "info" : "MethodDeclaration[81367-81783]:MethodDeclaration[81367-81783]"
  }, {
    "left" : "/**\n     * Returns the difference between our best chain height and the peers, which can either be positive if we are\n     * behind the peer, or negative if the peer is ahead of us.\n     */\n    public int getPeerBlockHeightDifference() {\n        checkNotNull(blockChain, \"No block chain configured\");\n        // Chain will overflow signed int blocks in ~41,000 years.\n        int chainHeight = (int) getBestHeight();\n        // chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another\n        // client-mode node, nor should it be unconnected. If that happens it means the user overrode us somewhere or\n        // there is a bug in the peer management code.\n        checkState(params.allowEmptyPeerChain() || chainHeight > 0, \"Connected to peer with zero/negative chain height\", chainHeight);\n        return chainHeight - blockChain.getBestChainHeight();\n    }",
    "right" : "/**\n     * Returns the difference between our best chain height and the peers, which can either be positive if we are\n     * behind the peer, or negative if the peer is ahead of us.\n     */\n    public int getPeerBlockHeightDifference() {\n        checkNotNull(blockChain, \"No block chain configured\");\n        // Chain will overflow signed int blocks in ~41,000 years.\n        int chainHeight = (int) getBestHeight();\n        // chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another\n        // client-mode node, nor should it be unconnected. If that happens it means the user overrode us somewhere or\n        // there is a bug in the peer management code.\n        checkState(params.allowEmptyPeerChain() || chainHeight > 0, \"Connected to peer with zero/negative chain height\", chainHeight);\n        return chainHeight - blockChain.getBestChainHeight();\n    }",
    "info" : "MethodDeclaration[81789-82699]:MethodDeclaration[81789-82699]"
  }, {
    "left" : "private boolean isNotFoundMessageSupported() {\n        return vPeerVersionMessage.clientVersion >= NotFoundMessage.MIN_PROTOCOL_VERSION;\n    }",
    "right" : "private boolean isNotFoundMessageSupported() {\n        return vPeerVersionMessage.clientVersion >= NotFoundMessage.MIN_PROTOCOL_VERSION;\n    }",
    "info" : "MethodDeclaration[82705-82847]:MethodDeclaration[82705-82847]"
  }, {
    "left" : "/**\n     * Returns true if this peer will try and download things it is sent in \"inv\" messages. Normally you only need\n     * one peer to be downloading data. Defaults to true.\n     */\n    public boolean getDownloadData() {\n        return vDownloadData;\n    }",
    "right" : "/**\n     * Returns true if this peer will try and download things it is sent in \"inv\" messages. Normally you only need\n     * one peer to be downloading data. Defaults to true.\n     */\n    public boolean getDownloadData() {\n        return vDownloadData;\n    }",
    "info" : "MethodDeclaration[82853-83112]:MethodDeclaration[82853-83112]"
  }, {
    "left" : "/**\n     * If set to false, the peer won't try and fetch blocks and transactions it hears about. Normally, only one\n     * peer should download missing blocks. Defaults to true. Changing this value from false to true may trigger\n     * a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.\n     */\n    public void setDownloadData(boolean downloadData) {\n        this.vDownloadData = downloadData;\n    }",
    "right" : "/**\n     * If set to false, the peer won't try and fetch blocks and transactions it hears about. Normally, only one\n     * peer should download missing blocks. Defaults to true. Changing this value from false to true may trigger\n     * a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.\n     */\n    public void setDownloadData(boolean downloadData) {\n        this.vDownloadData = downloadData;\n    }",
    "info" : "MethodDeclaration[83118-83562]:MethodDeclaration[83118-83562]"
  }, {
    "left" : "/** Returns version data announced by the remote peer. */\n    public VersionMessage getPeerVersionMessage() {\n        return vPeerVersionMessage;\n    }",
    "right" : "/** Returns version data announced by the remote peer. */\n    public VersionMessage getPeerVersionMessage() {\n        return vPeerVersionMessage;\n    }",
    "info" : "MethodDeclaration[83568-83719]:MethodDeclaration[83568-83719]"
  }, {
    "left" : "/** Returns version data we announce to our remote peers. */\n    public VersionMessage getVersionMessage() {\n        return versionMessage;\n    }",
    "right" : "/** Returns version data we announce to our remote peers. */\n    public VersionMessage getVersionMessage() {\n        return versionMessage;\n    }",
    "info" : "MethodDeclaration[83725-83870]:MethodDeclaration[83725-83870]"
  }, {
    "left" : "/**\n     * @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.\n     */\n    public long getBestHeight() {\n        return vPeerVersionMessage.bestHeight + blocksAnnounced.get();\n    }",
    "right" : "/**\n     * @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.\n     */\n    public long getBestHeight() {\n        return vPeerVersionMessage.bestHeight + blocksAnnounced.get();\n    }",
    "info" : "MethodDeclaration[83876-84118]:MethodDeclaration[83876-84118]"
  }, {
    "left" : "public minProtocolVersion int) : boolean",
    "right" : "public minProtocolVersion int) : boolean",
    "info" : "MethodDeclaration[84124-84721]:MethodDeclaration[84124-84721]"
  }, {
    "left" : "/**\n     * <p>Sets a Bloom filter on this connection. This will cause the given {@link BloomFilter} object to be sent to the\n     * remote peer and if either a memory pool has been set using the constructor or the\n     * vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any\n     * pending transactions that may be relevant.</p>\n     *\n     * <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.\n     * This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers\n     * and multiple wallets together.</p>\n     *\n     * <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}. It is called for you.</p>\n     *\n     * <p>If the remote peer doesn't support Bloom filtering, then this call is ignored. Once set you presently cannot\n     * unset a filter, though the underlying p2p protocol does support it.</p>\n     */\n    public void setBloomFilter(BloomFilter filter) {\n        setBloomFilter(filter, true);\n    }",
    "right" : "/**\n     * <p>Sets a Bloom filter on this connection. This will cause the given {@link BloomFilter} object to be sent to the\n     * remote peer and if either a memory pool has been set using the constructor or the\n     * vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any\n     * pending transactions that may be relevant.</p>\n     *\n     * <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.\n     * This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers\n     * and multiple wallets together.</p>\n     *\n     * <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}. It is called for you.</p>\n     *\n     * <p>If the remote peer doesn't support Bloom filtering, then this call is ignored. Once set you presently cannot\n     * unset a filter, though the underlying p2p protocol does support it.</p>\n     */\n    public void setBloomFilter(BloomFilter filter) {\n        setBloomFilter(filter, true);\n    }",
    "info" : "MethodDeclaration[84727-85828]:MethodDeclaration[84727-85828]"
  }, {
    "left" : "/**\n     * <p>Sets a Bloom filter on this connection. This will cause the given {@link BloomFilter} object to be sent to the\n     * remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any\n     * pending transactions that may be relevant.</p>\n     *\n     * <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.\n     * This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers\n     * and multiple wallets together.</p>\n     *\n     * <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}. It is called for you.</p>\n     *\n     * <p>If the remote peer doesn't support Bloom filtering, then this call is ignored. Once set you presently cannot\n     * unset a filter, though the underlying p2p protocol does support it.</p>\n     */\n    public void setBloomFilter(BloomFilter filter, boolean andQueryMemPool) {\n        checkNotNull(filter, \"Clearing filters is not currently supported\");\n        final VersionMessage ver = vPeerVersionMessage;\n        if (ver == null || !ver.isBloomFilteringSupported())\n            return;\n        vBloomFilter = filter;\n        log.debug(\"{}: Sending Bloom filter{}\", this, andQueryMemPool ? \" and querying mempool\" : \"\");\n        sendMessage(filter);\n        if (andQueryMemPool)\n            sendMessage(new MemoryPoolMessage());\n        maybeRestartChainDownload();\n    }",
    "right" : "/**\n     * <p>Sets a Bloom filter on this connection. This will cause the given {@link BloomFilter} object to be sent to the\n     * remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any\n     * pending transactions that may be relevant.</p>\n     *\n     * <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.\n     * This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers\n     * and multiple wallets together.</p>\n     *\n     * <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}. It is called for you.</p>\n     *\n     * <p>If the remote peer doesn't support Bloom filtering, then this call is ignored. Once set you presently cannot\n     * unset a filter, though the underlying p2p protocol does support it.</p>\n     */\n    public void setBloomFilter(BloomFilter filter, boolean andQueryMemPool) {\n        checkNotNull(filter, \"Clearing filters is not currently supported\");\n        final VersionMessage ver = vPeerVersionMessage;\n        if (ver == null || !ver.isBloomFilteringSupported())\n            return;\n        vBloomFilter = filter;\n        log.debug(\"{}: Sending Bloom filter{}\", this, andQueryMemPool ? \" and querying mempool\" : \"\");\n        sendMessage(filter);\n        if (andQueryMemPool)\n            sendMessage(new MemoryPoolMessage());\n        maybeRestartChainDownload();\n    }",
    "info" : "MethodDeclaration[85834-87324]:MethodDeclaration[85834-87324]"
  }, {
    "left" : "private void maybeRestartChainDownload() {\n        lock.lock();\n        try {\n            if (awaitingFreshFilter == null)\n                return;\n            if (!vDownloadData) {\n                // This branch should be harmless but I want to know how often it happens in reality.\n                log.warn(\"Lost download peer status whilst awaiting fresh filter.\");\n                return;\n            }\n            // Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and\n            // discarded.\n            ping().addListener(new Runnable() {\n                @Override\n                public void run() {\n                    lock.lock();\n                    checkNotNull(awaitingFreshFilter);\n                    GetDataMessage getdata = new GetDataMessage(params);\n                    for (Sha256Hash hash : awaitingFreshFilter)\n                        getdata.addFilteredBlock(hash);\n                    awaitingFreshFilter = null;\n                    lock.unlock();\n\n                    log.info(\"Restarting chain download\");\n                    sendMessage(getdata);\n                    // TODO: This bizarre ping-after-getdata hack probably isn't necessary.\n                    // It's to ensure we know when the end of a filtered block stream of txns is, but we should just be\n                    // able to match txns with the merkleblock. Ask Matt why it's written this way.\n                    sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));\n                }\n            }, Threading.SAME_THREAD);\n        } finally {\n            lock.unlock();\n        }\n    }",
    "right" : "private void maybeRestartChainDownload() {\n        lock.lock();\n        try {\n            if (awaitingFreshFilter == null)\n                return;\n            if (!vDownloadData) {\n                // This branch should be harmless but I want to know how often it happens in reality.\n                log.warn(\"Lost download peer status whilst awaiting fresh filter.\");\n                return;\n            }\n            // Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and\n            // discarded.\n            ping().addListener(new Runnable() {\n                @Override\n                public void run() {\n                    lock.lock();\n                    checkNotNull(awaitingFreshFilter);\n                    GetDataMessage getdata = new GetDataMessage(params);\n                    for (Sha256Hash hash : awaitingFreshFilter)\n                        getdata.addFilteredBlock(hash);\n                    awaitingFreshFilter = null;\n                    lock.unlock();\n\n                    log.info(\"Restarting chain download\");\n                    sendMessage(getdata);\n                    // TODO: This bizarre ping-after-getdata hack probably isn't necessary.\n                    // It's to ensure we know when the end of a filtered block stream of txns is, but we should just be\n                    // able to match txns with the merkleblock. Ask Matt why it's written this way.\n                    sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));\n                }\n            }, Threading.SAME_THREAD);\n        } finally {\n            lock.unlock();\n        }\n    }",
    "info" : "MethodDeclaration[87330-88964]:MethodDeclaration[87330-88964]"
  }, {
    "left" : "public ) : void",
    "right" : "public ) : void",
    "info" : "MethodDeclaration[87937-88862]:MethodDeclaration[87937-88862]"
  }, {
    "left" : "/**\n     * Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}. Bloom filters tell\n     * the remote node what transactions to send us, in a compact manner.\n     */\n    public BloomFilter getBloomFilter() {\n        return vBloomFilter;\n    }",
    "right" : "/**\n     * Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}. Bloom filters tell\n     * the remote node what transactions to send us, in a compact manner.\n     */\n    public BloomFilter getBloomFilter() {\n        return vBloomFilter;\n    }",
    "info" : "MethodDeclaration[88970-89244]:MethodDeclaration[88970-89244]"
  }, {
    "left" : "public outPoints List<TransactionOutPoint>) : ListenableFuture<UTXOsMessage>",
    "right" : "public outPoints List<TransactionOutPoint>, includeMempool boolean) : ListenableFuture<UTXOsMessage>",
    "info" : "MethodDeclaration[89250-90900]:MethodDeclaration[89990-91760]"
  }, {
    "left" : "public ) : boolean",
    "right" : "public ) : boolean",
    "info" : "MethodDeclaration[90906-91331]:MethodDeclaration[91766-92191]"
  }, {
    "left" : "/**\n     * Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies\n     * before handing the transaction off to the wallet. The wallet can do risk analysis on pending/recent transactions\n     * to try and discover if a pending tx might be at risk of double spending.\n     */\n    public void setDownloadTxDependencies(boolean value) {\n        vDownloadTxDependencies = value;\n    }",
    "right" : "/**\n     * Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies\n     * before handing the transaction off to the wallet. The wallet can do risk analysis on pending/recent transactions\n     * to try and discover if a pending tx might be at risk of double spending.\n     */\n    public void setDownloadTxDependencies(boolean value) {\n        vDownloadTxDependencies = value;\n    }",
    "info" : "MethodDeclaration[91337-91765]:MethodDeclaration[92197-92625]"
  } ],
  "mappings" : [
 {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[2097-2103]:Modifier[2097-2103]"
  }, {
    "left" : "PeerSocketHandler",
    "right" : "PeerSocketHandler",
    "info" : "SimpleType[2123-2140]:SimpleType[2123-2140]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[2685-2691]:Modifier[2685-2691]"
  }, {
    "left" : "ListenerRegistration<PeerEventListener>",
    "right" : "ListenerRegistration<PeerEventListener>",
    "info" : "ParameterizedType[2731-2770]:ParameterizedType[2731-2770]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[2822-2828]:Modifier[2822-2828]"
  }, {
    "left" : "PeerEventListener listener",
    "right" : "PeerEventListener listener",
    "info" : "SingleVariableDeclaration[2854-2880]:SingleVariableDeclaration[2854-2880]"
  }, {
    "left" : "Executor executor",
    "right" : "Executor executor",
    "info" : "SingleVariableDeclaration[2882-2899]:SingleVariableDeclaration[2882-2899]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[2901-2951]:Block[2901-2951]"
  }, {
    "left" : "super(listener, executor);",
    "right" : "super(listener, executor);",
    "info" : "SuperConstructorInvocation[2915-2941]:SuperConstructorInvocation[2915-2941]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[2961-2967]:Modifier[2961-2967]"
  }, {
    "left" : "PeerEventListener listener",
    "right" : "PeerEventListener listener",
    "info" : "SingleVariableDeclaration[2993-3019]:SingleVariableDeclaration[2993-3019]"
  }, {
    "left" : "Executor executor",
    "right" : "Executor executor",
    "info" : "SingleVariableDeclaration[3021-3038]:SingleVariableDeclaration[3021-3038]"
  }, {
    "left" : "boolean callOnDisconnect",
    "right" : "boolean callOnDisconnect",
    "info" : "SingleVariableDeclaration[3040-3064]:SingleVariableDeclaration[3040-3064]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[3066-3169]:Block[3066-3169]"
  }, {
    "left" : "this(listener, executor);",
    "right" : "this(listener, executor);",
    "info" : "ConstructorInvocation[3080-3105]:ConstructorInvocation[3080-3105]"
  }, {
    "left" : "this.callOnDisconnect = callOnDisconnect;",
    "right" : "this.callOnDisconnect = callOnDisconnect;",
    "info" : "ExpressionStatement[3118-3159]:ExpressionStatement[3118-3159]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[8298-8305]:Modifier[8298-8305]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[8306-8312]:Modifier[8306-8312]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[10229-10235]:Modifier[10229-10235]"
  }, {
    "left" : "NetworkParameters params",
    "right" : "NetworkParameters params",
    "info" : "SingleVariableDeclaration[10241-10265]:SingleVariableDeclaration[10241-10265]"
  }, {
    "left" : "VersionMessage ver",
    "right" : "VersionMessage ver",
    "info" : "SingleVariableDeclaration[10267-10285]:SingleVariableDeclaration[10267-10285]"
  }, {
    "left" : "@Nullable AbstractBlockChain chain",
    "right" : "@Nullable AbstractBlockChain chain",
    "info" : "SingleVariableDeclaration[10287-10321]:SingleVariableDeclaration[10287-10321]"
  }, {
    "left" : "PeerAddress remoteAddress",
    "right" : "PeerAddress remoteAddress",
    "info" : "SingleVariableDeclaration[10323-10348]:SingleVariableDeclaration[10323-10348]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[10350-10406]:Block[10350-10406]"
  }, {
    "left" : "this(params, ver, remoteAddress, chain);",
    "right" : "this(params, ver, remoteAddress, chain);",
    "info" : "ConstructorInvocation[10360-10400]:ConstructorInvocation[10360-10400]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[11411-11417]:Modifier[11411-11417]"
  }, {
    "left" : "NetworkParameters params",
    "right" : "NetworkParameters params",
    "info" : "SingleVariableDeclaration[11423-11447]:SingleVariableDeclaration[11423-11447]"
  }, {
    "left" : "VersionMessage ver",
    "right" : "VersionMessage ver",
    "info" : "SingleVariableDeclaration[11449-11467]:SingleVariableDeclaration[11449-11467]"
  }, {
    "left" : "PeerAddress remoteAddress",
    "right" : "PeerAddress remoteAddress",
    "info" : "SingleVariableDeclaration[11469-11494]:SingleVariableDeclaration[11469-11494]"
  }, {
    "left" : "@Nullable AbstractBlockChain chain",
    "right" : "@Nullable AbstractBlockChain chain",
    "info" : "SingleVariableDeclaration[11512-11546]:SingleVariableDeclaration[11512-11546]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[11548-11610]:Block[11548-11610]"
  }, {
    "left" : "this(params, ver, remoteAddress, chain, true);",
    "right" : "this(params, ver, remoteAddress, chain, true);",
    "info" : "ConstructorInvocation[11558-11604]:ConstructorInvocation[11558-11604]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[12615-12621]:Modifier[12615-12621]"
  }, {
    "left" : "NetworkParameters params",
    "right" : "NetworkParameters params",
    "info" : "SingleVariableDeclaration[12627-12651]:SingleVariableDeclaration[12627-12651]"
  }, {
    "left" : "VersionMessage ver",
    "right" : "VersionMessage ver",
    "info" : "SingleVariableDeclaration[12653-12671]:SingleVariableDeclaration[12653-12671]"
  }, {
    "left" : "PeerAddress remoteAddress",
    "right" : "PeerAddress remoteAddress",
    "info" : "SingleVariableDeclaration[12673-12698]:SingleVariableDeclaration[12673-12698]"
  }, {
    "left" : "@Nullable AbstractBlockChain chain",
    "right" : "@Nullable AbstractBlockChain chain",
    "info" : "SingleVariableDeclaration[12716-12750]:SingleVariableDeclaration[12716-12750]"
  }, {
    "left" : "boolean downloadTxDependencies",
    "right" : "boolean downloadTxDependencies",
    "info" : "SingleVariableDeclaration[12752-12782]:SingleVariableDeclaration[12752-12782]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12784-13643]:Block[12784-13643]"
  }, {
    "left" : "super(params, remoteAddress);",
    "right" : "super(params, remoteAddress);",
    "info" : "SuperConstructorInvocation[12794-12823]:SuperConstructorInvocation[12794-12823]"
  }, {
    "left" : "this.params = Preconditions.checkNotNull(params);",
    "right" : "this.params = Preconditions.checkNotNull(params);",
    "info" : "ExpressionStatement[12832-12881]:ExpressionStatement[12832-12881]"
  }, {
    "left" : "this.versionMessage = Preconditions.checkNotNull(ver);",
    "right" : "this.versionMessage = Preconditions.checkNotNull(ver);",
    "info" : "ExpressionStatement[12890-12944]:ExpressionStatement[12890-12944]"
  }, {
    "left" : "this.vDownloadTxDependencies = chain != null && downloadTxDependencies;",
    "right" : "this.vDownloadTxDependencies = chain != null && downloadTxDependencies;",
    "info" : "ExpressionStatement[12953-13024]:ExpressionStatement[12953-13024]"
  }, {
    "left" : "this.blockChain = chain;",
    "right" : "this.blockChain = chain;",
    "info" : "ExpressionStatement[13033-13057]:ExpressionStatement[13033-13057]"
  }, {
    "left" : "this.vDownloadData = chain != null;",
    "right" : "this.vDownloadData = chain != null;",
    "info" : "ExpressionStatement[13090-13125]:ExpressionStatement[13090-13125]"
  }, {
    "left" : "this.getDataFutures = new CopyOnWriteArrayList<GetDataRequest>();",
    "right" : "this.getDataFutures = new CopyOnWriteArrayList<GetDataRequest>();",
    "info" : "ExpressionStatement[13134-13199]:ExpressionStatement[13134-13199]"
  }, {
    "left" : "this.eventListeners = new CopyOnWriteArrayList<PeerListenerRegistration>();",
    "right" : "this.eventListeners = new CopyOnWriteArrayList<PeerListenerRegistration>();",
    "info" : "ExpressionStatement[13208-13283]:ExpressionStatement[13208-13283]"
  }, {
    "left" : "this.getAddrFutures = new LinkedList<SettableFuture<AddressMessage>>();",
    "right" : "this.getAddrFutures = new LinkedList<SettableFuture<AddressMessage>>();",
    "info" : "ExpressionStatement[13292-13363]:ExpressionStatement[13292-13363]"
  }, {
    "left" : "this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();",
    "right" : "this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();",
    "info" : "ExpressionStatement[13372-13441]:ExpressionStatement[13372-13441]"
  }, {
    "left" : "this.isAcked = false;",
    "right" : "this.isAcked = false;",
    "info" : "ExpressionStatement[13450-13471]:ExpressionStatement[13450-13471]"
  }, {
    "left" : "this.pendingPings = new CopyOnWriteArrayList<PendingPing>();",
    "right" : "this.pendingPings = new CopyOnWriteArrayList<PendingPing>();",
    "info" : "ExpressionStatement[13480-13540]:ExpressionStatement[13480-13540]"
  }, {
    "left" : "this.wallets = new CopyOnWriteArrayList<Wallet>();",
    "right" : "this.wallets = new CopyOnWriteArrayList<Wallet>();",
    "info" : "ExpressionStatement[13549-13599]:ExpressionStatement[13549-13599]"
  }, {
    "left" : "this.context = Context.get();",
    "right" : "this.context = Context.get();",
    "info" : "ExpressionStatement[13608-13637]:ExpressionStatement[13608-13637]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[14689-14695]:Modifier[14689-14695]"
  }, {
    "left" : "NetworkParameters params",
    "right" : "NetworkParameters params",
    "info" : "SingleVariableDeclaration[14701-14725]:SingleVariableDeclaration[14701-14725]"
  }, {
    "left" : "AbstractBlockChain blockChain",
    "right" : "AbstractBlockChain blockChain",
    "info" : "SingleVariableDeclaration[14727-14756]:SingleVariableDeclaration[14727-14756]"
  }, {
    "left" : "PeerAddress peerAddress",
    "right" : "PeerAddress peerAddress",
    "info" : "SingleVariableDeclaration[14758-14781]:SingleVariableDeclaration[14758-14781]"
  }, {
    "left" : "String thisSoftwareName",
    "right" : "String thisSoftwareName",
    "info" : "SingleVariableDeclaration[14783-14806]:SingleVariableDeclaration[14783-14806]"
  }, {
    "left" : "String thisSoftwareVersion",
    "right" : "String thisSoftwareVersion",
    "info" : "SingleVariableDeclaration[14808-14834]:SingleVariableDeclaration[14808-14834]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14836-15040]:Block[14836-15040]"
  }, {
    "left" : "this(params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress);",
    "right" : "this(params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress);",
    "info" : "ConstructorInvocation[14846-14945]:ConstructorInvocation[14846-14945]"
  }, {
    "left" : "this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, null);",
    "right" : "this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, null);",
    "info" : "ExpressionStatement[14954-15034]:ExpressionStatement[14954-15034]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[15494-15500]:Modifier[15494-15500]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[15501-15505]:PrimitiveType[15501-15505]"
  }, {
    "left" : "PeerEventListener listener",
    "right" : "PeerEventListener listener",
    "info" : "SingleVariableDeclaration[15523-15549]:SingleVariableDeclaration[15523-15549]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[15551-15617]:Block[15551-15617]"
  }, {
    "left" : "addEventListener(listener, Threading.USER_THREAD);",
    "right" : "addEventListener(listener, Threading.USER_THREAD);",
    "info" : "ExpressionStatement[15561-15611]:ExpressionStatement[15561-15611]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[16105-16111]:Modifier[16105-16111]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[16112-16116]:PrimitiveType[16112-16116]"
  }, {
    "left" : "PeerEventListener listener",
    "right" : "PeerEventListener listener",
    "info" : "SingleVariableDeclaration[16134-16160]:SingleVariableDeclaration[16134-16160]"
  }, {
    "left" : "Executor executor",
    "right" : "Executor executor",
    "info" : "SingleVariableDeclaration[16162-16179]:SingleVariableDeclaration[16162-16179]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16181-16266]:Block[16181-16266]"
  }, {
    "left" : "eventListeners.add(new PeerListenerRegistration(listener, executor));",
    "right" : "eventListeners.add(new PeerListenerRegistration(listener, executor));",
    "info" : "ExpressionStatement[16191-16260]:ExpressionStatement[16191-16260]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[16315-16319]:PrimitiveType[16315-16319]"
  }, {
    "left" : "PeerEventListener listener",
    "right" : "PeerEventListener listener",
    "info" : "SingleVariableDeclaration[16356-16382]:SingleVariableDeclaration[16356-16382]"
  }, {
    "left" : "Executor executor",
    "right" : "Executor executor",
    "info" : "SingleVariableDeclaration[16384-16401]:SingleVariableDeclaration[16384-16401]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16403-16495]:Block[16403-16495]"
  }, {
    "left" : "eventListeners.add(new PeerListenerRegistration(listener, executor, false));",
    "right" : "eventListeners.add(new PeerListenerRegistration(listener, executor, false));",
    "info" : "ExpressionStatement[16413-16489]:ExpressionStatement[16413-16489]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[16501-16507]:Modifier[16501-16507]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[16508-16515]:PrimitiveType[16508-16515]"
  }, {
    "left" : "PeerEventListener listener",
    "right" : "PeerEventListener listener",
    "info" : "SingleVariableDeclaration[16536-16562]:SingleVariableDeclaration[16536-16562]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16564-16649]:Block[16564-16649]"
  }, {
    "left" : "return ListenerRegistration.removeFromList(listener, eventListeners);",
    "right" : "return ListenerRegistration.removeFromList(listener, eventListeners);",
    "info" : "ReturnStatement[16574-16643]:ReturnStatement[16574-16643]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[16655-16664]:MarkerAnnotation[16655-16664]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[16669-16675]:Modifier[16669-16675]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[16676-16682]:SimpleType[16676-16682]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16694-16866]:Block[16694-16866]"
  }, {
    "left" : "PeerAddress addr = getAddress();",
    "right" : "PeerAddress addr = getAddress();",
    "info" : "VariableDeclarationStatement[16704-16736]:VariableDeclarationStatement[16704-16736]"
  }, {
    "left" : "return addr == null ? \"Peer()\" : addr.toString();",
    "right" : "return addr == null ? \"Peer()\" : addr.toString();",
    "info" : "ReturnStatement[16811-16860]:ReturnStatement[16811-16860]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[16872-16881]:MarkerAnnotation[16872-16881]"
  }, {
    "left" : "protected",
    "right" : "protected",
    "info" : "Modifier[16886-16895]:Modifier[16886-16895]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[16896-16900]:PrimitiveType[16896-16900]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16919-17144]:Block[16919-17144]"
  }, {
    "left" : "super.timeoutOccurred();",
    "right" : "super.timeoutOccurred();",
    "info" : "ExpressionStatement[16929-16953]:ExpressionStatement[16929-16953]"
  }, {
    "left" : "if (!connectionOpenFuture.isDone())",
    "right" : "if (!connectionOpenFuture.isDone())",
    "info" : "IfStatement[16962-17138]:IfStatement[16962-17138]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16998-17138]:Block[16998-17138]"
  }, {
    "left" : "connectionClosed();",
    "right" : "connectionClosed();",
    "info" : "ExpressionStatement[17012-17031]:ExpressionStatement[17012-17031]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[17150-17159]:MarkerAnnotation[17150-17159]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[17164-17170]:Modifier[17164-17170]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[17171-17175]:PrimitiveType[17171-17175]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17195-17591]:Block[17195-17591]"
  }, {
    "left" : "for (final PeerListenerRegistration registration : eventListeners)",
    "right" : "for (final PeerListenerRegistration registration : eventListeners)",
    "info" : "EnhancedForStatement[17205-17585]:EnhancedForStatement[17205-17585]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17272-17585]:Block[17272-17585]"
  }, {
    "left" : "if (registration.callOnDisconnect)",
    "right" : "if (registration.callOnDisconnect)",
    "info" : "IfStatement[17286-17575]:IfStatement[17286-17575]"
  }, {
    "left" : "registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onPeerDisconnected(Peer.this, 0);\n                    }\n                });",
    "right" : "registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onPeerDisconnected(Peer.this, 0);\n                    }\n                });",
    "info" : "ExpressionStatement[17337-17575]:ExpressionStatement[17337-17575]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[17404-17413]:MarkerAnnotation[17404-17413]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[17434-17440]:Modifier[17434-17440]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[17441-17445]:PrimitiveType[17441-17445]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17452-17555]:Block[17452-17555]"
  }, {
    "left" : "registration.listener.onPeerDisconnected(Peer.this, 0);",
    "right" : "registration.listener.onPeerDisconnected(Peer.this, 0);",
    "info" : "ExpressionStatement[17478-17533]:ExpressionStatement[17478-17533]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[17597-17606]:MarkerAnnotation[17597-17606]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[17611-17617]:Modifier[17611-17617]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[17618-17622]:PrimitiveType[17618-17622]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17642-18257]:Block[17642-18257]"
  }, {
    "left" : "PeerAddress address = getAddress();",
    "right" : "PeerAddress address = getAddress();",
    "info" : "VariableDeclarationStatement[17827-17862]:VariableDeclarationStatement[17827-17862]"
  }, {
    "left" : "log.info(\"Announcing to {} as: {}\", address == null ? \"Peer\" : address.toSocketAddress(), versionMessage.subVer);",
    "right" : "log.info(\"Announcing to {} as: {}\", address == null ? \"Peer\" : address.toSocketAddress(), versionMessage.subVer);",
    "info" : "ExpressionStatement[17871-17984]:ExpressionStatement[17871-17984]"
  }, {
    "left" : "sendMessage(versionMessage);",
    "right" : "sendMessage(versionMessage);",
    "info" : "ExpressionStatement[17993-18021]:ExpressionStatement[17993-18021]"
  }, {
    "left" : "connectionOpenFuture.set(this);",
    "right" : "connectionOpenFuture.set(this);",
    "info" : "ExpressionStatement[18030-18061]:ExpressionStatement[18030-18061]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[18446-18452]:Modifier[18446-18452]"
  }, {
    "left" : "ListenableFuture<Peer>",
    "right" : "ListenableFuture<Peer>",
    "info" : "ParameterizedType[18453-18475]:ParameterizedType[18453-18475]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18502-18546]:Block[18502-18546]"
  }, {
    "left" : "return connectionOpenFuture;",
    "right" : "return connectionOpenFuture;",
    "info" : "ReturnStatement[18512-18540]:ReturnStatement[18512-18540]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[18552-18558]:Modifier[18552-18558]"
  }, {
    "left" : "ListenableFuture<Peer>",
    "right" : "ListenableFuture<Peer>",
    "info" : "ParameterizedType[18559-18581]:ParameterizedType[18559-18581]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18610-18656]:Block[18610-18656]"
  }, {
    "left" : "return versionHandshakeFuture;",
    "right" : "return versionHandshakeFuture;",
    "info" : "ReturnStatement[18620-18650]:ReturnStatement[18620-18650]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[18662-18671]:MarkerAnnotation[18662-18671]"
  }, {
    "left" : "protected",
    "right" : "protected",
    "info" : "Modifier[18676-18685]:Modifier[18676-18685]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[18686-18690]:PrimitiveType[18686-18690]"
  }, {
    "left" : "Message m",
    "right" : "Message m",
    "info" : "SingleVariableDeclaration[18706-18715]:SingleVariableDeclaration[18706-18715]"
  }, {
    "left" : "Exception",
    "right" : "Exception",
    "info" : "SimpleType[18724-18733]:SimpleType[18724-18733]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18734-22956]:Block[18734-22956]"
  }, {
    "left" : "for (ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "right" : "for (ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "info" : "EnhancedForStatement[18876-19325]:EnhancedForStatement[18876-19325]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18952-19325]:Block[18952-19325]"
  }, {
    "left" : "if (registration.executor == Threading.SAME_THREAD)",
    "right" : "if (registration.executor == Threading.SAME_THREAD)",
    "info" : "IfStatement[19137-19315]:IfStatement[19137-19315]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19189-19315]:Block[19189-19315]"
  }, {
    "left" : "m = registration.listener.onPreMessageReceived(this, m);",
    "right" : "m = registration.listener.onPreMessageReceived(this, m);",
    "info" : "ExpressionStatement[19207-19263]:ExpressionStatement[19207-19263]"
  }, {
    "left" : "if (m == null)",
    "right" : "if (m == null)",
    "info" : "IfStatement[19280-19301]:IfStatement[19280-19301]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[19295-19301]:BreakStatement[19295-19301]"
  }, {
    "left" : "if (m == null)",
    "right" : "if (m == null)",
    "info" : "IfStatement[19334-19356]:IfStatement[19334-19356]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[19349-19356]:ReturnStatement[19349-19356]"
  }, {
    "left" : "if (currentFilteredBlock != null && !(m instanceof Transaction))",
    "right" : "if (currentFilteredBlock != null && !(m instanceof Transaction))",
    "info" : "IfStatement[19561-19730]:IfStatement[19561-19730]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19626-19730]:Block[19626-19730]"
  }, {
    "left" : "endFilteredBlock(currentFilteredBlock);",
    "right" : "endFilteredBlock(currentFilteredBlock);",
    "info" : "ExpressionStatement[19640-19679]:ExpressionStatement[19640-19679]"
  }, {
    "left" : "currentFilteredBlock = null;",
    "right" : "currentFilteredBlock = null;",
    "info" : "ExpressionStatement[19692-19720]:ExpressionStatement[19692-19720]"
  }, {
    "left" : "if (m instanceof Ping)",
    "right" : "if (m instanceof Ping)",
    "info" : "IfStatement[19740-22950]:IfStatement[19740-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19763-19875]:Block[19763-19875]"
  }, {
    "left" : "if (((Ping) m).hasNonce())",
    "right" : "if (((Ping) m).hasNonce())",
    "info" : "IfStatement[19777-19865]:IfStatement[19777-19865]"
  }, {
    "left" : "sendMessage(new Pong(((Ping) m).getNonce()));",
    "right" : "sendMessage(new Pong(((Ping) m).getNonce()));",
    "info" : "ExpressionStatement[19820-19865]:ExpressionStatement[19820-19865]"
  }, {
    "left" : "if (m instanceof Pong)",
    "right" : "if (m instanceof Pong)",
    "info" : "IfStatement[19881-22950]:IfStatement[19881-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19904-19950]:Block[19904-19950]"
  }, {
    "left" : "processPong((Pong) m);",
    "right" : "processPong((Pong) m);",
    "info" : "ExpressionStatement[19918-19940]:ExpressionStatement[19918-19940]"
  }, {
    "left" : "if (m instanceof NotFoundMessage)",
    "right" : "if (m instanceof NotFoundMessage)",
    "info" : "IfStatement[19956-22950]:IfStatement[19956-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19990-20290]:Block[19990-20290]"
  }, {
    "left" : "processNotFoundMessage((NotFoundMessage) m);",
    "right" : "processNotFoundMessage((NotFoundMessage) m);",
    "info" : "ExpressionStatement[20236-20280]:ExpressionStatement[20236-20280]"
  }, {
    "left" : "if (m instanceof InventoryMessage)",
    "right" : "if (m instanceof InventoryMessage)",
    "info" : "IfStatement[20296-22950]:IfStatement[20296-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20331-20388]:Block[20331-20388]"
  }, {
    "left" : "processInv((InventoryMessage) m);",
    "right" : "processInv((InventoryMessage) m);",
    "info" : "ExpressionStatement[20345-20378]:ExpressionStatement[20345-20378]"
  }, {
    "left" : "if (m instanceof Block)",
    "right" : "if (m instanceof Block)",
    "info" : "IfStatement[20394-22950]:IfStatement[20394-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20418-20466]:Block[20418-20466]"
  }, {
    "left" : "processBlock((Block) m);",
    "right" : "processBlock((Block) m);",
    "info" : "ExpressionStatement[20432-20456]:ExpressionStatement[20432-20456]"
  }, {
    "left" : "if (m instanceof FilteredBlock)",
    "right" : "if (m instanceof FilteredBlock)",
    "info" : "IfStatement[20472-22950]:IfStatement[20472-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20504-20566]:Block[20504-20566]"
  }, {
    "left" : "startFilteredBlock((FilteredBlock) m);",
    "right" : "startFilteredBlock((FilteredBlock) m);",
    "info" : "ExpressionStatement[20518-20556]:ExpressionStatement[20518-20556]"
  }, {
    "left" : "if (m instanceof Transaction)",
    "right" : "if (m instanceof Transaction)",
    "info" : "IfStatement[20572-22950]:IfStatement[20572-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20602-20662]:Block[20602-20662]"
  }, {
    "left" : "processTransaction((Transaction) m);",
    "right" : "processTransaction((Transaction) m);",
    "info" : "ExpressionStatement[20616-20652]:ExpressionStatement[20616-20652]"
  }, {
    "left" : "if (m instanceof GetDataMessage)",
    "right" : "if (m instanceof GetDataMessage)",
    "info" : "IfStatement[20668-22950]:IfStatement[20668-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20701-20760]:Block[20701-20760]"
  }, {
    "left" : "processGetData((GetDataMessage) m);",
    "right" : "processGetData((GetDataMessage) m);",
    "info" : "ExpressionStatement[20715-20750]:ExpressionStatement[20715-20750]"
  }, {
    "left" : "if (m instanceof AddressMessage)",
    "right" : "if (m instanceof AddressMessage)",
    "info" : "IfStatement[20766-22950]:IfStatement[20766-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20799-21101]:Block[20799-21101]"
  }, {
    "left" : "processAddressMessage((AddressMessage) m);",
    "right" : "processAddressMessage((AddressMessage) m);",
    "info" : "ExpressionStatement[21049-21091]:ExpressionStatement[21049-21091]"
  }, {
    "left" : "if (m instanceof HeadersMessage)",
    "right" : "if (m instanceof HeadersMessage)",
    "info" : "IfStatement[21107-22950]:IfStatement[21107-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21140-21199]:Block[21140-21199]"
  }, {
    "left" : "processHeaders((HeadersMessage) m);",
    "right" : "processHeaders((HeadersMessage) m);",
    "info" : "ExpressionStatement[21154-21189]:ExpressionStatement[21154-21189]"
  }, {
    "left" : "if (m instanceof AlertMessage)",
    "right" : "if (m instanceof AlertMessage)",
    "info" : "IfStatement[21205-22950]:IfStatement[21205-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21236-21291]:Block[21236-21291]"
  }, {
    "left" : "processAlert((AlertMessage) m);",
    "right" : "processAlert((AlertMessage) m);",
    "info" : "ExpressionStatement[21250-21281]:ExpressionStatement[21250-21281]"
  }, {
    "left" : "if (m instanceof VersionMessage)",
    "right" : "if (m instanceof VersionMessage)",
    "info" : "IfStatement[21297-22950]:IfStatement[21297-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21330-21396]:Block[21330-21396]"
  }, {
    "left" : "processVersionMessage((VersionMessage) m);",
    "right" : "processVersionMessage((VersionMessage) m);",
    "info" : "ExpressionStatement[21344-21386]:ExpressionStatement[21344-21386]"
  }, {
    "left" : "if (m instanceof VersionAck)",
    "right" : "if (m instanceof VersionAck)",
    "info" : "IfStatement[21402-22950]:IfStatement[21402-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21431-22631]:Block[21431-22631]"
  }, {
    "left" : "if (vPeerVersionMessage == null)",
    "right" : "if (vPeerVersionMessage == null)",
    "info" : "IfStatement[21445-21574]:IfStatement[21445-21574]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21478-21574]:Block[21478-21574]"
  }, {
    "left" : "throw new ProtocolException(\"got a version ack before version\");",
    "right" : "throw new ProtocolException(\"got a version ack before version\");",
    "info" : "ThrowStatement[21496-21560]:ThrowStatement[21496-21560]"
  }, {
    "left" : "if (isAcked)",
    "right" : "if (isAcked)",
    "info" : "IfStatement[21587-21693]:IfStatement[21587-21693]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21600-21693]:Block[21600-21693]"
  }, {
    "left" : "throw new ProtocolException(\"got more than one version ack\");",
    "right" : "throw new ProtocolException(\"got more than one version ack\");",
    "info" : "ThrowStatement[21618-21679]:ThrowStatement[21618-21679]"
  }, {
    "left" : "isAcked = true;",
    "right" : "isAcked = true;",
    "info" : "ExpressionStatement[21706-21721]:ExpressionStatement[21706-21721]"
  }, {
    "left" : "this.setTimeoutEnabled(false);",
    "right" : "this.setTimeoutEnabled(false);",
    "info" : "ExpressionStatement[21734-21764]:ExpressionStatement[21734-21764]"
  }, {
    "left" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "right" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "info" : "EnhancedForStatement[21777-22126]:EnhancedForStatement[21777-22126]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21859-22126]:Block[21859-22126]"
  }, {
    "left" : "registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onPeerConnected(Peer.this, 1);\n                    }\n                });",
    "right" : "registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onPeerConnected(Peer.this, 1);\n                    }\n                });",
    "info" : "ExpressionStatement[21877-22112]:ExpressionStatement[21877-22112]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[21944-21953]:MarkerAnnotation[21944-21953]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[21974-21980]:Modifier[21974-21980]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[21981-21985]:PrimitiveType[21981-21985]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21992-22092]:Block[21992-22092]"
  }, {
    "left" : "registration.listener.onPeerConnected(Peer.this, 1);",
    "right" : "registration.listener.onPeerConnected(Peer.this, 1);",
    "info" : "ExpressionStatement[22018-22070]:ExpressionStatement[22018-22070]"
  }, {
    "left" : "final int version = vMinProtocolVersion;",
    "right" : "final int version = vMinProtocolVersion;",
    "info" : "VariableDeclarationStatement[22312-22352]:VariableDeclarationStatement[22312-22352]"
  }, {
    "left" : "if (vPeerVersionMessage.clientVersion < version)",
    "right" : "if (vPeerVersionMessage.clientVersion < version)",
    "info" : "IfStatement[22365-22621]:IfStatement[22365-22621]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22414-22621]:Block[22414-22621]"
  }, {
    "left" : "log.warn(\"Connected to a peer speaking protocol version {} but need {}, closing\",\n                        vPeerVersionMessage.clientVersion, version);",
    "right" : "log.warn(\"Connected to a peer speaking protocol version {} but need {}, closing\",\n                        vPeerVersionMessage.clientVersion, version);",
    "info" : "ExpressionStatement[22432-22582]:ExpressionStatement[22432-22582]"
  }, {
    "left" : "close();",
    "right" : "close();",
    "info" : "ExpressionStatement[22599-22607]:ExpressionStatement[22599-22607]"
  }, {
    "left" : "if (m instanceof UTXOsMessage)",
    "right" : "if (m instanceof UTXOsMessage)",
    "info" : "IfStatement[22637-22950]:IfStatement[22637-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22668-22729]:Block[22668-22729]"
  }, {
    "left" : "processUTXOMessage((UTXOsMessage) m);",
    "right" : "processUTXOMessage((UTXOsMessage) m);",
    "info" : "ExpressionStatement[22682-22719]:ExpressionStatement[22682-22719]"
  }, {
    "left" : "if (m instanceof RejectMessage)",
    "right" : "if (m instanceof RejectMessage)",
    "info" : "IfStatement[22735-22950]:IfStatement[22735-22950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22767-22864]:Block[22767-22864]"
  }, {
    "left" : "log.error(\"{} {}: Received {}\", this, getPeerVersionMessage().subVer, m);",
    "right" : "log.error(\"{} {}: Received {}\", this, getPeerVersionMessage().subVer, m);",
    "info" : "ExpressionStatement[22781-22854]:ExpressionStatement[22781-22854]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22870-22950]:Block[22870-22950]"
  }, {
    "left" : "log.warn(\"{}: Received unhandled message: {}\", this, m);",
    "right" : "log.warn(\"{}: Received unhandled message: {}\", this, m);",
    "info" : "ExpressionStatement[22884-22940]:ExpressionStatement[22884-22940]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[22962-22969]:Modifier[22962-22969]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[22970-22974]:PrimitiveType[22970-22974]"
  }, {
    "left" : "UTXOsMessage m",
    "right" : "UTXOsMessage m",
    "info" : "SingleVariableDeclaration[22994-23008]:SingleVariableDeclaration[22994-23008]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23010-23309]:Block[23010-23309]"
  }, {
    "left" : "SettableFuture<UTXOsMessage> future = null;",
    "right" : "SettableFuture<UTXOsMessage> future = null;",
    "info" : "VariableDeclarationStatement[23020-23063]:VariableDeclarationStatement[23020-23063]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[23072-23084]:ExpressionStatement[23072-23084]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[23093-23248]:TryStatement[23093-23248]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23097-23201]:Block[23097-23201]"
  }, {
    "left" : "if (getutxoFutures != null)",
    "right" : "if (getutxoFutures != null)",
    "info" : "IfStatement[23111-23191]:IfStatement[23111-23191]"
  }, {
    "left" : "future = getutxoFutures.pollFirst();",
    "right" : "future = getutxoFutures.pollFirst();",
    "info" : "ExpressionStatement[23155-23191]:ExpressionStatement[23155-23191]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23210-23248]:Block[23210-23248]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[23224-23238]:ExpressionStatement[23224-23238]"
  }, {
    "left" : "if (future != null)",
    "right" : "if (future != null)",
    "info" : "IfStatement[23257-23303]:IfStatement[23257-23303]"
  }, {
    "left" : "future.set(m);",
    "right" : "future.set(m);",
    "info" : "ExpressionStatement[23289-23303]:ExpressionStatement[23289-23303]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[23315-23322]:Modifier[23315-23322]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[23323-23327]:PrimitiveType[23323-23327]"
  }, {
    "left" : "AddressMessage m",
    "right" : "AddressMessage m",
    "info" : "SingleVariableDeclaration[23350-23366]:SingleVariableDeclaration[23350-23366]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23368-23639]:Block[23368-23639]"
  }, {
    "left" : "SettableFuture<AddressMessage> future;",
    "right" : "SettableFuture<AddressMessage> future;",
    "info" : "VariableDeclarationStatement[23378-23416]:VariableDeclarationStatement[23378-23416]"
  }, {
    "left" : "synchronized (getAddrFutures) {\n            future = getAddrFutures.poll();\n            if (future == null)  // Not an addr message we are waiting for.\n                return;\n        }",
    "right" : "synchronized (getAddrFutures) {\n            future = getAddrFutures.poll();\n            if (future == null)  // Not an addr message we are waiting for.\n                return;\n        }",
    "info" : "SynchronizedStatement[23425-23610]:SynchronizedStatement[23425-23610]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23455-23610]:Block[23455-23610]"
  }, {
    "left" : "future = getAddrFutures.poll();",
    "right" : "future = getAddrFutures.poll();",
    "info" : "ExpressionStatement[23469-23500]:ExpressionStatement[23469-23500]"
  }, {
    "left" : "if (future == null)",
    "right" : "if (future == null)",
    "info" : "IfStatement[23513-23600]:IfStatement[23513-23600]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[23593-23600]:ReturnStatement[23593-23600]"
  }, {
    "left" : "future.set(m);",
    "right" : "future.set(m);",
    "info" : "ExpressionStatement[23619-23633]:ExpressionStatement[23619-23633]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[23645-23652]:Modifier[23645-23652]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[23653-23657]:PrimitiveType[23653-23657]"
  }, {
    "left" : "VersionMessage m",
    "right" : "VersionMessage m",
    "info" : "SingleVariableDeclaration[23680-23696]:SingleVariableDeclaration[23680-23696]"
  }, {
    "left" : "ProtocolException",
    "right" : "ProtocolException",
    "info" : "SimpleType[23705-23722]:SimpleType[23705-23722]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23723-25362]:Block[23723-25362]"
  }, {
    "left" : "if (vPeerVersionMessage != null)",
    "right" : "if (vPeerVersionMessage != null)",
    "info" : "IfStatement[23733-23844]:IfStatement[23733-23844]"
  }, {
    "left" : "throw new ProtocolException(\"Got two version messages from peer\");",
    "right" : "throw new ProtocolException(\"Got two version messages from peer\");",
    "info" : "ThrowStatement[23778-23844]:ThrowStatement[23778-23844]"
  }, {
    "left" : "vPeerVersionMessage = m;",
    "right" : "vPeerVersionMessage = m;",
    "info" : "ExpressionStatement[23853-23877]:ExpressionStatement[23853-23877]"
  }, {
    "left" : "int peerVersion = vPeerVersionMessage.clientVersion;",
    "right" : "int peerVersion = vPeerVersionMessage.clientVersion;",
    "info" : "VariableDeclarationStatement[23933-23985]:VariableDeclarationStatement[23933-23985]"
  }, {
    "left" : "PeerAddress peerAddress = getAddress();",
    "right" : "PeerAddress peerAddress = getAddress();",
    "info" : "VariableDeclarationStatement[23994-24033]:VariableDeclarationStatement[23994-24033]"
  }, {
    "left" : "long peerTime = vPeerVersionMessage.time * 1000;",
    "right" : "long peerTime = vPeerVersionMessage.time * 1000;",
    "info" : "VariableDeclarationStatement[24042-24090]:VariableDeclarationStatement[24042-24090]"
  }, {
    "left" : "log.info(\"Connected to {}: version={}, subVer='{}', services=0x{}, time={}, blocks={}\",\n                peerAddress == null ? \"Peer\" : peerAddress.getAddr().getHostAddress(),\n                peerVersion,\n                vPeerVersionMessage.subVer,\n                vPeerVersionMessage.localServices,\n                String.format(\"%tF %tT\", peerTime, peerTime),\n                vPeerVersionMessage.bestHeight);",
    "right" : "log.info(\"Connected to {}: version={}, subVer='{}', services=0x{}, time={}, blocks={}\",\n                peerAddress == null ? \"Peer\" : peerAddress.getAddr().getHostAddress(),\n                peerVersion,\n                vPeerVersionMessage.subVer,\n                vPeerVersionMessage.localServices,\n                String.format(\"%tF %tT\", peerTime, peerTime),\n                vPeerVersionMessage.bestHeight);",
    "info" : "ExpressionStatement[24099-24508]:ExpressionStatement[24099-24508]"
  }, {
    "left" : "sendMessage(new VersionAck());",
    "right" : "sendMessage(new VersionAck());",
    "info" : "ExpressionStatement[24627-24657]:ExpressionStatement[24627-24657]"
  }, {
    "left" : "if (!vPeerVersionMessage.hasBlockChain() ||\n                (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight <= 0))",
    "right" : "if (!vPeerVersionMessage.hasBlockChain() ||\n                (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight <= 0))",
    "info" : "IfStatement[25044-25314]:IfStatement[25044-25314]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25176-25314]:Block[25176-25314]"
  }, {
    "left" : "throw new ProtocolException(\"Peer does not have a copy of the block chain.\");",
    "right" : "throw new ProtocolException(\"Peer does not have a copy of the block chain.\");",
    "info" : "ThrowStatement[25227-25304]:ThrowStatement[25227-25304]"
  }, {
    "left" : "versionHandshakeFuture.set(this);",
    "right" : "versionHandshakeFuture.set(this);",
    "info" : "ExpressionStatement[25323-25356]:ExpressionStatement[25323-25356]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[25368-25375]:Modifier[25368-25375]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[25376-25380]:PrimitiveType[25376-25380]"
  }, {
    "left" : "FilteredBlock m",
    "right" : "FilteredBlock m",
    "info" : "SingleVariableDeclaration[25400-25415]:SingleVariableDeclaration[25400-25415]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25417-26359]:Block[25417-26359]"
  }, {
    "left" : "currentFilteredBlock = m;",
    "right" : "currentFilteredBlock = m;",
    "info" : "ExpressionStatement[25806-25831]:ExpressionStatement[25806-25831]"
  }, {
    "left" : "filteredBlocksReceived++;",
    "right" : "filteredBlocksReceived++;",
    "info" : "ExpressionStatement[26168-26193]:ExpressionStatement[26168-26193]"
  }, {
    "left" : "if (filteredBlocksReceived % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1)",
    "right" : "if (filteredBlocksReceived % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1)",
    "info" : "IfStatement[26202-26353]:IfStatement[26202-26353]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26303-26353]:Block[26303-26353]"
  }, {
    "left" : "sendMessage(vBloomFilter);",
    "right" : "sendMessage(vBloomFilter);",
    "info" : "ExpressionStatement[26317-26343]:ExpressionStatement[26317-26343]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[26365-26372]:Modifier[26365-26372]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[26373-26377]:PrimitiveType[26373-26377]"
  }, {
    "left" : "NotFoundMessage m",
    "right" : "NotFoundMessage m",
    "info" : "SingleVariableDeclaration[26401-26418]:SingleVariableDeclaration[26401-26418]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26420-27310]:Block[26420-27310]"
  }, {
    "left" : "for (GetDataRequest req : getDataFutures)",
    "right" : "for (GetDataRequest req : getDataFutures)",
    "info" : "EnhancedForStatement[26914-27304]:EnhancedForStatement[26914-27304]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26956-27304]:Block[26956-27304]"
  }, {
    "left" : "for (InventoryItem item : m.getItems())",
    "right" : "for (InventoryItem item : m.getItems())",
    "info" : "EnhancedForStatement[26970-27294]:EnhancedForStatement[26970-27294]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27010-27294]:Block[27010-27294]"
  }, {
    "left" : "if (item.hash.equals(req.hash))",
    "right" : "if (item.hash.equals(req.hash))",
    "info" : "IfStatement[27028-27280]:IfStatement[27028-27280]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27060-27280]:Block[27060-27280]"
  }, {
    "left" : "log.info(\"{}: Bottomed out dep tree at {}\", this, req.hash);",
    "right" : "log.info(\"{}: Bottomed out dep tree at {}\", this, req.hash);",
    "info" : "ExpressionStatement[27082-27142]:ExpressionStatement[27082-27142]"
  }, {
    "left" : "req.future.cancel(true);",
    "right" : "req.future.cancel(true);",
    "info" : "ExpressionStatement[27163-27187]:ExpressionStatement[27163-27187]"
  }, {
    "left" : "getDataFutures.remove(req);",
    "right" : "getDataFutures.remove(req);",
    "info" : "ExpressionStatement[27208-27235]:ExpressionStatement[27208-27235]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[27256-27262]:BreakStatement[27256-27262]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[27316-27323]:Modifier[27316-27323]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[27324-27328]:PrimitiveType[27324-27328]"
  }, {
    "left" : "AlertMessage m",
    "right" : "AlertMessage m",
    "info" : "SingleVariableDeclaration[27342-27356]:SingleVariableDeclaration[27342-27356]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27358-28056]:Block[27358-28056]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[27368-28050]:TryStatement[27368-28050]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27372-27651]:Block[27372-27651]"
  }, {
    "left" : "if (m.isSignatureValid())",
    "right" : "if (m.isSignatureValid())",
    "info" : "IfStatement[27386-27641]:IfStatement[27386-27641]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27412-27512]:Block[27412-27512]"
  }, {
    "left" : "log.info(\"Received alert from peer {}: {}\", this, m.getStatusBar());",
    "right" : "log.info(\"Received alert from peer {}: {}\", this, m.getStatusBar());",
    "info" : "ExpressionStatement[27430-27498]:ExpressionStatement[27430-27498]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27518-27641]:Block[27518-27641]"
  }, {
    "left" : "log.warn(\"Received alert with invalid signature from peer {}: {}\", this, m.getStatusBar());",
    "right" : "log.warn(\"Received alert with invalid signature from peer {}: {}\", this, m.getStatusBar());",
    "info" : "ExpressionStatement[27536-27627]:ExpressionStatement[27536-27627]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27672-28050]:Block[27672-28050]"
  }, {
    "left" : "log.error(\"Failed to check signature: bug in platform libraries?\", t);",
    "right" : "log.error(\"Failed to check signature: bug in platform libraries?\", t);",
    "info" : "ExpressionStatement[27970-28040]:ExpressionStatement[27970-28040]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[28062-28069]:Modifier[28062-28069]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[28070-28074]:PrimitiveType[28070-28074]"
  }, {
    "left" : "HeadersMessage m",
    "right" : "HeadersMessage m",
    "info" : "SingleVariableDeclaration[28090-28106]:SingleVariableDeclaration[28090-28106]"
  }, {
    "left" : "ProtocolException",
    "right" : "ProtocolException",
    "info" : "SimpleType[28115-28132]:SimpleType[28115-28132]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28133-32268]:Block[28133-32268]"
  }, {
    "left" : "boolean downloadBlockBodies;",
    "right" : "boolean downloadBlockBodies;",
    "info" : "VariableDeclarationStatement[28622-28650]:VariableDeclarationStatement[28622-28650]"
  }, {
    "left" : "long fastCatchupTimeSecs;",
    "right" : "long fastCatchupTimeSecs;",
    "info" : "VariableDeclarationStatement[28659-28684]:VariableDeclarationStatement[28659-28684]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[28694-28706]:ExpressionStatement[28694-28706]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[28715-29157]:TryStatement[28715-29157]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28719-29110]:Block[28719-29110]"
  }, {
    "left" : "if (blockChain == null)",
    "right" : "if (blockChain == null)",
    "info" : "IfStatement[28733-28980]:IfStatement[28733-28980]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28757-28980]:Block[28757-28980]"
  }, {
    "left" : "log.warn(\"Received headers when Peer is not configured with a chain.\");",
    "right" : "log.warn(\"Received headers when Peer is not configured with a chain.\");",
    "info" : "ExpressionStatement[28871-28942]:ExpressionStatement[28871-28942]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[28959-28966]:ReturnStatement[28959-28966]"
  }, {
    "left" : "fastCatchupTimeSecs = this.fastCatchupTimeSecs;",
    "right" : "fastCatchupTimeSecs = this.fastCatchupTimeSecs;",
    "info" : "ExpressionStatement[28993-29040]:ExpressionStatement[28993-29040]"
  }, {
    "left" : "downloadBlockBodies = this.downloadBlockBodies;",
    "right" : "downloadBlockBodies = this.downloadBlockBodies;",
    "info" : "ExpressionStatement[29053-29100]:ExpressionStatement[29053-29100]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29119-29157]:Block[29119-29157]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[29133-29147]:ExpressionStatement[29133-29147]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[29167-32262]:TryStatement[29167-32262]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29171-32031]:Block[29171-32031]"
  }, {
    "left" : "checkState(!downloadBlockBodies, toString());",
    "right" : "checkState(!downloadBlockBodies, toString());",
    "info" : "ExpressionStatement[29185-29230]:ExpressionStatement[29185-29230]"
  }, {
    "left" : "for (int i = 0; i < m.getBlockHeaders().size(); i++)",
    "right" : "for (int i = 0; i < m.getBlockHeaders().size(); i++)",
    "info" : "ForStatement[29243-31564]:ForStatement[29243-31564]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29296-31564]:Block[29296-31564]"
  }, {
    "left" : "Block header = m.getBlockHeaders().get(i);",
    "right" : "Block header = m.getBlockHeaders().get(i);",
    "info" : "VariableDeclarationStatement[29314-29356]:VariableDeclarationStatement[29314-29356]"
  }, {
    "left" : "boolean passedTime = header.getTimeSeconds() >= fastCatchupTimeSecs;",
    "right" : "boolean passedTime = header.getTimeSeconds() >= fastCatchupTimeSecs;",
    "info" : "VariableDeclarationStatement[29665-29733]:VariableDeclarationStatement[29665-29733]"
  }, {
    "left" : "boolean reachedTop = blockChain.getBestChainHeight() >= vPeerVersionMessage.bestHeight;",
    "right" : "boolean reachedTop = blockChain.getBestChainHeight() >= vPeerVersionMessage.bestHeight;",
    "info" : "VariableDeclarationStatement[29750-29837]:VariableDeclarationStatement[29750-29837]"
  }, {
    "left" : "if (!passedTime && !reachedTop)",
    "right" : "if (!passedTime && !reachedTop)",
    "info" : "IfStatement[29854-31550]:IfStatement[29854-31550]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29886-30889]:Block[29886-30889]"
  }, {
    "left" : "if (!vDownloadData)",
    "right" : "if (!vDownloadData)",
    "info" : "IfStatement[29908-30175]:IfStatement[29908-30175]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29928-30175]:Block[29928-30175]"
  }, {
    "left" : "log.info(\"Lost download peer status, throwing away downloaded headers.\");",
    "right" : "log.info(\"Lost download peer status, throwing away downloaded headers.\");",
    "info" : "ExpressionStatement[30048-30121]:ExpressionStatement[30048-30121]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[30146-30153]:ReturnStatement[30146-30153]"
  }, {
    "left" : "if (blockChain.add(header))",
    "right" : "if (blockChain.add(header))",
    "info" : "IfStatement[30196-30871]:IfStatement[30196-30871]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30224-30421]:Block[30224-30421]"
  }, {
    "left" : "invokeOnBlocksDownloaded(header, null);",
    "right" : "invokeOnBlocksDownloaded(header, null);",
    "info" : "ExpressionStatement[30360-30399]:ExpressionStatement[30360-30399]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30427-30871]:Block[30427-30871]"
  }, {
    "left" : "throw new ProtocolException(\"Got unconnected header from peer: \" + header.getHashAsString());",
    "right" : "throw new ProtocolException(\"Got unconnected header from peer: \" + header.getHashAsString());",
    "info" : "ThrowStatement[30756-30849]:ThrowStatement[30756-30849]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30895-31550]:Block[30895-31550]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[30917-30929]:ExpressionStatement[30917-30929]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[30950-31504]:TryStatement[30950-31504]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30954-31433]:Block[30954-31433]"
  }, {
    "left" : "log.info(\"Passed the fast catchup time, discarding {} headers and requesting full blocks\",\n                                m.getBlockHeaders().size() - i);",
    "right" : "log.info(\"Passed the fast catchup time, discarding {} headers and requesting full blocks\",\n                                m.getBlockHeaders().size() - i);",
    "info" : "ExpressionStatement[30980-31135]:ExpressionStatement[30980-31135]"
  }, {
    "left" : "this.downloadBlockBodies = true;",
    "right" : "this.downloadBlockBodies = true;",
    "info" : "ExpressionStatement[31160-31192]:ExpressionStatement[31160-31192]"
  }, {
    "left" : "this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH;",
    "right" : "this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH;",
    "info" : "ExpressionStatement[31292-31339]:ExpressionStatement[31292-31339]"
  }, {
    "left" : "blockChainDownloadLocked(Sha256Hash.ZERO_HASH);",
    "right" : "blockChainDownloadLocked(Sha256Hash.ZERO_HASH);",
    "info" : "ExpressionStatement[31364-31411]:ExpressionStatement[31364-31411]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31442-31504]:Block[31442-31504]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[31468-31482]:ExpressionStatement[31468-31482]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[31525-31532]:ReturnStatement[31525-31532]"
  }, {
    "left" : "if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)",
    "right" : "if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)",
    "info" : "IfStatement[31744-32021]:IfStatement[31744-32021]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31806-32021]:Block[31806-32021]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[31824-31836]:ExpressionStatement[31824-31836]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[31853-32007]:TryStatement[31853-32007]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31857-31944]:Block[31857-31944]"
  }, {
    "left" : "blockChainDownloadLocked(Sha256Hash.ZERO_HASH);",
    "right" : "blockChainDownloadLocked(Sha256Hash.ZERO_HASH);",
    "info" : "ExpressionStatement[31879-31926]:ExpressionStatement[31879-31926]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31953-32007]:Block[31953-32007]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[31975-31989]:ExpressionStatement[31975-31989]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32064-32136]:Block[32064-32136]"
  }, {
    "left" : "log.warn(\"Block header verification failed\", e);",
    "right" : "log.warn(\"Block header verification failed\", e);",
    "info" : "ExpressionStatement[32078-32126]:ExpressionStatement[32078-32126]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32163-32262]:Block[32163-32262]"
  }, {
    "left" : "throw new RuntimeException(e);",
    "right" : "throw new RuntimeException(e);",
    "info" : "ThrowStatement[32222-32252]:ThrowStatement[32222-32252]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[32274-32281]:Modifier[32274-32281]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[32282-32286]:PrimitiveType[32282-32286]"
  }, {
    "left" : "GetDataMessage getdata",
    "right" : "GetDataMessage getdata",
    "info" : "SingleVariableDeclaration[32302-32324]:SingleVariableDeclaration[32302-32324]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32326-33073]:Block[32326-33073]"
  }, {
    "left" : "log.info(\"{}: Received getdata message: {}\", getAddress(), getdata.toString());",
    "right" : "log.info(\"{}: Received getdata message: {}\", getAddress(), getdata.toString());",
    "info" : "ExpressionStatement[32336-32415]:ExpressionStatement[32336-32415]"
  }, {
    "left" : "ArrayList<Message> items = new ArrayList<Message>();",
    "right" : "ArrayList<Message> items = new ArrayList<Message>();",
    "info" : "VariableDeclarationStatement[32424-32476]:VariableDeclarationStatement[32424-32476]"
  }, {
    "left" : "for (ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "right" : "for (ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "info" : "EnhancedForStatement[32485-32824]:EnhancedForStatement[32485-32824]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32561-32824]:Block[32561-32824]"
  }, {
    "left" : "if (registration.executor != Threading.SAME_THREAD)",
    "right" : "if (registration.executor != Threading.SAME_THREAD)",
    "info" : "IfStatement[32575-32636]:IfStatement[32575-32636]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[32627-32636]:ContinueStatement[32627-32636]"
  }, {
    "left" : "List<Message> listenerItems = registration.listener.getData(this, getdata);",
    "right" : "List<Message> listenerItems = registration.listener.getData(this, getdata);",
    "info" : "VariableDeclarationStatement[32649-32724]:VariableDeclarationStatement[32649-32724]"
  }, {
    "left" : "if (listenerItems == null)",
    "right" : "if (listenerItems == null)",
    "info" : "IfStatement[32737-32773]:IfStatement[32737-32773]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[32764-32773]:ContinueStatement[32764-32773]"
  }, {
    "left" : "items.addAll(listenerItems);",
    "right" : "items.addAll(listenerItems);",
    "info" : "ExpressionStatement[32786-32814]:ExpressionStatement[32786-32814]"
  }, {
    "left" : "if (items.size() == 0)",
    "right" : "if (items.size() == 0)",
    "info" : "IfStatement[32833-32887]:IfStatement[32833-32887]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32856-32887]:Block[32856-32887]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[32870-32877]:ReturnStatement[32870-32877]"
  }, {
    "left" : "log.info(\"{}: Sending {} items gathered from listeners to peer\", getAddress(), items.size());",
    "right" : "log.info(\"{}: Sending {} items gathered from listeners to peer\", getAddress(), items.size());",
    "info" : "ExpressionStatement[32896-32989]:ExpressionStatement[32896-32989]"
  }, {
    "left" : "for (Message item : items)",
    "right" : "for (Message item : items)",
    "info" : "EnhancedForStatement[32998-33067]:EnhancedForStatement[32998-33067]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33025-33067]:Block[33025-33067]"
  }, {
    "left" : "sendMessage(item);",
    "right" : "sendMessage(item);",
    "info" : "ExpressionStatement[33039-33057]:ExpressionStatement[33039-33057]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[33079-33086]:Modifier[33079-33086]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[33087-33091]:PrimitiveType[33087-33091]"
  }, {
    "left" : "final Transaction tx",
    "right" : "final Transaction tx",
    "info" : "SingleVariableDeclaration[33111-33131]:SingleVariableDeclaration[33111-33131]"
  }, {
    "left" : "VerificationException",
    "right" : "VerificationException",
    "info" : "SimpleType[33140-33161]:SimpleType[33140-33161]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33162-38891]:Block[33162-38891]"
  }, {
    "left" : "tx.verify();",
    "right" : "tx.verify();",
    "info" : "ExpressionStatement[33257-33269]:ExpressionStatement[33257-33269]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[33278-33290]:ExpressionStatement[33278-33290]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[33299-38322]:TryStatement[33299-38322]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33303-38275]:Block[33303-38275]"
  }, {
    "left" : "log.debug(\"{}: Received tx {}\", getAddress(), tx.getHashAsString());",
    "right" : "log.debug(\"{}: Received tx {}\", getAddress(), tx.getHashAsString());",
    "info" : "ExpressionStatement[33317-33385]:ExpressionStatement[33317-33385]"
  }, {
    "left" : "TransactionConfidence confidence = tx.getConfidence();",
    "right" : "TransactionConfidence confidence = tx.getConfidence();",
    "info" : "VariableDeclarationStatement[33997-34051]:VariableDeclarationStatement[33997-34051]"
  }, {
    "left" : "confidence.setSource(TransactionConfidence.Source.NETWORK);",
    "right" : "confidence.setSource(TransactionConfidence.Source.NETWORK);",
    "info" : "ExpressionStatement[34064-34123]:ExpressionStatement[34064-34123]"
  }, {
    "left" : "pendingTxDownloads.remove(confidence);",
    "right" : "pendingTxDownloads.remove(confidence);",
    "info" : "ExpressionStatement[34136-34174]:ExpressionStatement[34136-34174]"
  }, {
    "left" : "if (maybeHandleRequestedData(tx))",
    "right" : "if (maybeHandleRequestedData(tx))",
    "info" : "IfStatement[34187-34260]:IfStatement[34187-34260]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34221-34260]:Block[34221-34260]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[34239-34246]:ReturnStatement[34239-34246]"
  }, {
    "left" : "if (currentFilteredBlock != null)",
    "right" : "if (currentFilteredBlock != null)",
    "info" : "IfStatement[34273-34814]:IfStatement[34273-34814]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34307-34814]:Block[34307-34814]"
  }, {
    "left" : "if (!currentFilteredBlock.provideTransaction(tx))",
    "right" : "if (!currentFilteredBlock.provideTransaction(tx))",
    "info" : "IfStatement[34325-34613]:IfStatement[34325-34613]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34375-34613]:Block[34375-34613]"
  }, {
    "left" : "endFilteredBlock(currentFilteredBlock);",
    "right" : "endFilteredBlock(currentFilteredBlock);",
    "info" : "ExpressionStatement[34507-34546]:ExpressionStatement[34507-34546]"
  }, {
    "left" : "currentFilteredBlock = null;",
    "right" : "currentFilteredBlock = null;",
    "info" : "ExpressionStatement[34567-34595]:ExpressionStatement[34567-34595]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[34793-34800]:ReturnStatement[34793-34800]"
  }, {
    "left" : "for (final Wallet wallet : wallets)",
    "right" : "for (final Wallet wallet : wallets)",
    "info" : "EnhancedForStatement[34946-38265]:EnhancedForStatement[34946-38265]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34982-38265]:Block[34982-38265]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[35000-38251]:TryStatement[35000-38251]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35004-38068]:Block[35004-38068]"
  }, {
    "left" : "if (wallet.isPendingTransactionRelevant(tx))",
    "right" : "if (wallet.isPendingTransactionRelevant(tx))",
    "info" : "IfStatement[35026-38050]:IfStatement[35026-38050]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35071-38050]:Block[35071-38050]"
  }, {
    "left" : "if (vDownloadTxDependencies)",
    "right" : "if (vDownloadTxDependencies)",
    "info" : "IfStatement[35097-38028]:IfStatement[35097-38028]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35126-37934]:Block[35126-37934]"
  }, {
    "left" : "Futures.addCallback(downloadDependencies(tx), new FutureCallback<List<Transaction>>() {\n                                @Override\n                                public void onSuccess(List<Transaction> dependencies) {\n                                    try {\n                                        log.info(\"{}: Dependency download complete!\", getAddress());\n                                        wallet.receivePending(tx, dependencies);\n                                    } catch (VerificationException e) {\n                                        log.error(\"{}: Wallet failed to process pending transaction {}\", getAddress(), tx.getHash());\n                                        log.error(\"Error was: \", e);\n                                        // Not much more we can do at this point.\n                                    }\n                                }\n\n                                @Override\n                                public void onFailure(Throwable throwable) {\n                                    log.error(\"Could not download dependencies of tx {}\", tx.getHashAsString());\n                                    log.error(\"Error was: \", throwable);\n                                    // Not much more we can do at this point.\n                                }\n                            });",
    "right" : "Futures.addCallback(downloadDependencies(tx), new FutureCallback<List<Transaction>>() {\n                                @Override\n                                public void onSuccess(List<Transaction> dependencies) {\n                                    try {\n                                        log.info(\"{}: Dependency download complete!\", getAddress());\n                                        wallet.receivePending(tx, dependencies);\n                                    } catch (VerificationException e) {\n                                        log.error(\"{}: Wallet failed to process pending transaction {}\", getAddress(), tx.getHash());\n                                        log.error(\"Error was: \", e);\n                                        // Not much more we can do at this point.\n                                    }\n                                }\n\n                                @Override\n                                public void onFailure(Throwable throwable) {\n                                    log.error(\"Could not download dependencies of tx {}\", tx.getHashAsString());\n                                    log.error(\"Error was: \", throwable);\n                                    // Not much more we can do at this point.\n                                }\n                            });",
    "info" : "ExpressionStatement[36588-37908]:ExpressionStatement[36588-37908]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[36708-36717]:MarkerAnnotation[36708-36717]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[36750-36756]:Modifier[36750-36756]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[36757-36761]:PrimitiveType[36757-36761]"
  }, {
    "left" : "List<Transaction> dependencies",
    "right" : "List<Transaction> dependencies",
    "info" : "SingleVariableDeclaration[36772-36802]:SingleVariableDeclaration[36772-36802]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36804-37458]:Block[36804-37458]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[36842-37424]:TryStatement[36842-37424]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36846-37067]:Block[36846-37067]"
  }, {
    "left" : "log.info(\"{}: Dependency download complete!\", getAddress());",
    "right" : "log.info(\"{}: Dependency download complete!\", getAddress());",
    "info" : "ExpressionStatement[36888-36948]:ExpressionStatement[36888-36948]"
  }, {
    "left" : "wallet.receivePending(tx, dependencies);",
    "right" : "wallet.receivePending(tx, dependencies);",
    "info" : "ExpressionStatement[36989-37029]:ExpressionStatement[36989-37029]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37100-37424]:Block[37100-37424]"
  }, {
    "left" : "log.error(\"{}: Wallet failed to process pending transaction {}\", getAddress(), tx.getHash());",
    "right" : "log.error(\"{}: Wallet failed to process pending transaction {}\", getAddress(), tx.getHash());",
    "info" : "ExpressionStatement[37142-37235]:ExpressionStatement[37142-37235]"
  }, {
    "left" : "log.error(\"Error was: \", e);",
    "right" : "log.error(\"Error was: \", e);",
    "info" : "ExpressionStatement[37276-37304]:ExpressionStatement[37276-37304]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[37492-37501]:MarkerAnnotation[37492-37501]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[37534-37540]:Modifier[37534-37540]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[37541-37545]:PrimitiveType[37541-37545]"
  }, {
    "left" : "Throwable throwable",
    "right" : "Throwable throwable",
    "info" : "SingleVariableDeclaration[37556-37575]:SingleVariableDeclaration[37556-37575]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37577-37876]:Block[37577-37876]"
  }, {
    "left" : "log.error(\"Could not download dependencies of tx {}\", tx.getHashAsString());",
    "right" : "log.error(\"Could not download dependencies of tx {}\", tx.getHashAsString());",
    "info" : "ExpressionStatement[37615-37691]:ExpressionStatement[37615-37691]"
  }, {
    "left" : "log.error(\"Error was: \", throwable);",
    "right" : "log.error(\"Error was: \", throwable);",
    "info" : "ExpressionStatement[37728-37764]:ExpressionStatement[37728-37764]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37940-38028]:Block[37940-38028]"
  }, {
    "left" : "wallet.receivePending(tx, null);",
    "right" : "wallet.receivePending(tx, null);",
    "info" : "ExpressionStatement[37970-38002]:ExpressionStatement[37970-38002]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38101-38251]:Block[38101-38251]"
  }, {
    "left" : "log.error(\"Wallet failed to verify tx\", e);",
    "right" : "log.error(\"Wallet failed to verify tx\", e);",
    "info" : "ExpressionStatement[38123-38166]:ExpressionStatement[38123-38166]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38284-38322]:Block[38284-38322]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[38298-38312]:ExpressionStatement[38298-38312]"
  }, {
    "left" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "right" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "info" : "EnhancedForStatement[38565-38885]:EnhancedForStatement[38565-38885]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38647-38885]:Block[38647-38885]"
  }, {
    "left" : "registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onTransaction(Peer.this, tx);\n                }\n            });",
    "right" : "registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onTransaction(Peer.this, tx);\n                }\n            });",
    "info" : "ExpressionStatement[38661-38875]:ExpressionStatement[38661-38875]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[38724-38733]:MarkerAnnotation[38724-38733]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[38750-38756]:Modifier[38750-38756]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[38757-38761]:PrimitiveType[38757-38761]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38768-38859]:Block[38768-38859]"
  }, {
    "left" : "registration.listener.onTransaction(Peer.this, tx);",
    "right" : "registration.listener.onTransaction(Peer.this, tx);",
    "info" : "ExpressionStatement[38790-38841]:ExpressionStatement[38790-38841]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[40082-40088]:Modifier[40082-40088]"
  }, {
    "left" : "ListenableFuture<List<Transaction>>",
    "right" : "ListenableFuture<List<Transaction>>",
    "info" : "ParameterizedType[40089-40124]:ParameterizedType[40089-40124]"
  }, {
    "left" : "Transaction tx",
    "right" : "Transaction tx",
    "info" : "SingleVariableDeclaration[40146-40160]:SingleVariableDeclaration[40146-40160]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[40162-41228]:Block[40162-41228]"
  }, {
    "left" : "TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence().getConfidenceType();",
    "right" : "TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence().getConfidenceType();",
    "info" : "VariableDeclarationStatement[40172-40263]:VariableDeclarationStatement[40172-40263]"
  }, {
    "left" : "Preconditions.checkArgument(txConfidence != TransactionConfidence.ConfidenceType.BUILDING);",
    "right" : "Preconditions.checkArgument(txConfidence != TransactionConfidence.ConfidenceType.BUILDING);",
    "info" : "ExpressionStatement[40272-40363]:ExpressionStatement[40272-40363]"
  }, {
    "left" : "log.info(\"{}: Downloading dependencies of {}\", getAddress(), tx.getHashAsString());",
    "right" : "log.info(\"{}: Downloading dependencies of {}\", getAddress(), tx.getHashAsString());",
    "info" : "ExpressionStatement[40372-40455]:ExpressionStatement[40372-40455]"
  }, {
    "left" : "final LinkedList<Transaction> results = new LinkedList<Transaction>();",
    "right" : "final LinkedList<Transaction> results = new LinkedList<Transaction>();",
    "info" : "VariableDeclarationStatement[40464-40534]:VariableDeclarationStatement[40464-40534]"
  }, {
    "left" : "final ListenableFuture<Object> future = downloadDependenciesInternal(tx, new Object(), results);",
    "right" : "final ListenableFuture<Object> future = downloadDependenciesInternal(tx, new Object(), results);",
    "info" : "VariableDeclarationStatement[40651-40747]:VariableDeclarationStatement[40651-40747]"
  }, {
    "left" : "final SettableFuture<List<Transaction>> resultFuture = SettableFuture.create();",
    "right" : "final SettableFuture<List<Transaction>> resultFuture = SettableFuture.create();",
    "info" : "VariableDeclarationStatement[40756-40835]:VariableDeclarationStatement[40756-40835]"
  }, {
    "left" : "Futures.addCallback(future, new FutureCallback<Object>() {\n            @Override\n            public void onSuccess(Object ignored) {\n                resultFuture.set(results);\n            }\n\n            @Override\n            public void onFailure(Throwable throwable) {\n                resultFuture.setException(throwable);\n            }\n        });",
    "right" : "Futures.addCallback(future, new FutureCallback<Object>() {\n            @Override\n            public void onSuccess(Object ignored) {\n                resultFuture.set(results);\n            }\n\n            @Override\n            public void onFailure(Throwable throwable) {\n                resultFuture.setException(throwable);\n            }\n        });",
    "info" : "ExpressionStatement[40844-41193]:ExpressionStatement[40844-41193]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[40915-40924]:MarkerAnnotation[40915-40924]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[40937-40943]:Modifier[40937-40943]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[40944-40948]:PrimitiveType[40944-40948]"
  }, {
    "left" : "Object ignored",
    "right" : "Object ignored",
    "info" : "SingleVariableDeclaration[40959-40973]:SingleVariableDeclaration[40959-40973]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[40975-41033]:Block[40975-41033]"
  }, {
    "left" : "resultFuture.set(results);",
    "right" : "resultFuture.set(results);",
    "info" : "ExpressionStatement[40993-41019]:ExpressionStatement[40993-41019]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[41047-41056]:MarkerAnnotation[41047-41056]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[41069-41075]:Modifier[41069-41075]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[41076-41080]:PrimitiveType[41076-41080]"
  }, {
    "left" : "Throwable throwable",
    "right" : "Throwable throwable",
    "info" : "SingleVariableDeclaration[41091-41110]:SingleVariableDeclaration[41091-41110]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41112-41181]:Block[41112-41181]"
  }, {
    "left" : "resultFuture.setException(throwable);",
    "right" : "resultFuture.setException(throwable);",
    "info" : "ExpressionStatement[41130-41167]:ExpressionStatement[41130-41167]"
  }, {
    "left" : "return resultFuture;",
    "right" : "return resultFuture;",
    "info" : "ReturnStatement[41202-41222]:ReturnStatement[41202-41222]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[41349-41356]:Modifier[41349-41356]"
  }, {
    "left" : "ListenableFuture<Object>",
    "right" : "ListenableFuture<Object>",
    "info" : "ParameterizedType[41357-41381]:ParameterizedType[41357-41381]"
  }, {
    "left" : "final Transaction tx",
    "right" : "final Transaction tx",
    "info" : "SingleVariableDeclaration[41411-41431]:SingleVariableDeclaration[41411-41431]"
  }, {
    "left" : "final Object marker",
    "right" : "final Object marker",
    "info" : "SingleVariableDeclaration[41499-41518]:SingleVariableDeclaration[41499-41518]"
  }, {
    "left" : "final List<Transaction> results",
    "right" : "final List<Transaction> results",
    "info" : "SingleVariableDeclaration[41586-41617]:SingleVariableDeclaration[41586-41617]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41619-45783]:Block[41619-45783]"
  }, {
    "left" : "final SettableFuture<Object> resultFuture = SettableFuture.create();",
    "right" : "final SettableFuture<Object> resultFuture = SettableFuture.create();",
    "info" : "VariableDeclarationStatement[41629-41697]:VariableDeclarationStatement[41629-41697]"
  }, {
    "left" : "final Sha256Hash rootTxHash = tx.getHash();",
    "right" : "final Sha256Hash rootTxHash = tx.getHash();",
    "info" : "VariableDeclarationStatement[41706-41749]:VariableDeclarationStatement[41706-41749]"
  }, {
    "left" : "Set<Sha256Hash> needToRequest = new CopyOnWriteArraySet<Sha256Hash>();",
    "right" : "Set<Sha256Hash> needToRequest = new CopyOnWriteArraySet<Sha256Hash>();",
    "info" : "VariableDeclarationStatement[42140-42210]:VariableDeclarationStatement[42140-42210]"
  }, {
    "left" : "for (TransactionInput input : tx.getInputs())",
    "right" : "for (TransactionInput input : tx.getInputs())",
    "info" : "EnhancedForStatement[42219-42420]:EnhancedForStatement[42219-42420]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42265-42420]:Block[42265-42420]"
  }, {
    "left" : "needToRequest.add(input.getOutpoint().getHash());",
    "right" : "needToRequest.add(input.getOutpoint().getHash());",
    "info" : "ExpressionStatement[42361-42410]:ExpressionStatement[42361-42410]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[42429-42441]:ExpressionStatement[42429-42441]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[42450-45748]:TryStatement[42450-45748]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42454-45494]:Block[42454-45494]"
  }, {
    "left" : "List<ListenableFuture<Transaction>> futures = Lists.newArrayList();",
    "right" : "List<ListenableFuture<Transaction>> futures = Lists.newArrayList();",
    "info" : "VariableDeclarationStatement[42531-42598]:VariableDeclarationStatement[42531-42598]"
  }, {
    "left" : "GetDataMessage getdata = new GetDataMessage(params);",
    "right" : "GetDataMessage getdata = new GetDataMessage(params);",
    "info" : "VariableDeclarationStatement[42611-42663]:VariableDeclarationStatement[42611-42663]"
  }, {
    "left" : "if (needToRequest.size() > 1)",
    "right" : "if (needToRequest.size() > 1)",
    "info" : "IfStatement[42676-42820]:IfStatement[42676-42820]"
  }, {
    "left" : "log.info(\"{}: Requesting {} transactions for dep resolution\", getAddress(), needToRequest.size());",
    "right" : "log.info(\"{}: Requesting {} transactions for dep resolution\", getAddress(), needToRequest.size());",
    "info" : "ExpressionStatement[42722-42820]:ExpressionStatement[42722-42820]"
  }, {
    "left" : "for (Sha256Hash hash : needToRequest)",
    "right" : "for (Sha256Hash hash : needToRequest)",
    "info" : "EnhancedForStatement[42833-43160]:EnhancedForStatement[42833-43160]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42871-43160]:Block[42871-43160]"
  }, {
    "left" : "getdata.addTransaction(hash);",
    "right" : "getdata.addTransaction(hash);",
    "info" : "ExpressionStatement[42889-42918]:ExpressionStatement[42889-42918]"
  }, {
    "left" : "GetDataRequest req = new GetDataRequest();",
    "right" : "GetDataRequest req = new GetDataRequest();",
    "info" : "VariableDeclarationStatement[42935-42977]:VariableDeclarationStatement[42935-42977]"
  }, {
    "left" : "req.hash = hash;",
    "right" : "req.hash = hash;",
    "info" : "ExpressionStatement[42994-43010]:ExpressionStatement[42994-43010]"
  }, {
    "left" : "req.future = SettableFuture.create();",
    "right" : "req.future = SettableFuture.create();",
    "info" : "ExpressionStatement[43027-43064]:ExpressionStatement[43027-43064]"
  }, {
    "left" : "futures.add(req.future);",
    "right" : "futures.add(req.future);",
    "info" : "ExpressionStatement[43081-43105]:ExpressionStatement[43081-43105]"
  }, {
    "left" : "getDataFutures.add(req);",
    "right" : "getDataFutures.add(req);",
    "info" : "ExpressionStatement[43122-43146]:ExpressionStatement[43122-43146]"
  }, {
    "left" : "ListenableFuture<List<Transaction>> successful = Futures.successfulAsList(futures);",
    "right" : "ListenableFuture<List<Transaction>> successful = Futures.successfulAsList(futures);",
    "info" : "VariableDeclarationStatement[43173-43256]:VariableDeclarationStatement[43173-43256]"
  }, {
    "left" : "Futures.addCallback(successful, new FutureCallback<List<Transaction>>() {\n                @Override\n                public void onSuccess(List<Transaction> transactions) {\n                    // Once all transactions either were received, or we know there are no more to come ...\n                    // Note that transactions will contain \"null\" for any positions that weren't successful.\n                    List<ListenableFuture<Object>> childFutures = Lists.newLinkedList();\n                    for (Transaction tx : transactions) {\n                        if (tx == null) continue;\n                        log.info(\"{}: Downloaded dependency of {}: {}\", getAddress(), rootTxHash, tx.getHashAsString());\n                        results.add(tx);\n                        // Now recurse into the dependencies of this transaction too.\n                        childFutures.add(downloadDependenciesInternal(tx, marker, results));\n                    }\n                    if (childFutures.size() == 0) {\n                        // Short-circuit: we're at the bottom of this part of the tree.\n                        resultFuture.set(marker);\n                    } else {\n                        // There are some children to download. Wait until it's done (and their children and their\n                        // children...) to inform the caller that we're finished.\n                        Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>() {\n                            @Override\n                            public void onSuccess(List<Object> objects) {\n                                resultFuture.set(marker);\n                            }\n\n                            @Override\n                            public void onFailure(Throwable throwable) {\n                                resultFuture.setException(throwable);\n                            }\n                        });\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable throwable) {\n                    resultFuture.setException(throwable);\n                }\n            });",
    "right" : "Futures.addCallback(successful, new FutureCallback<List<Transaction>>() {\n                @Override\n                public void onSuccess(List<Transaction> transactions) {\n                    // Once all transactions either were received, or we know there are no more to come ...\n                    // Note that transactions will contain \"null\" for any positions that weren't successful.\n                    List<ListenableFuture<Object>> childFutures = Lists.newLinkedList();\n                    for (Transaction tx : transactions) {\n                        if (tx == null) continue;\n                        log.info(\"{}: Downloaded dependency of {}: {}\", getAddress(), rootTxHash, tx.getHashAsString());\n                        results.add(tx);\n                        // Now recurse into the dependencies of this transaction too.\n                        childFutures.add(downloadDependenciesInternal(tx, marker, results));\n                    }\n                    if (childFutures.size() == 0) {\n                        // Short-circuit: we're at the bottom of this part of the tree.\n                        resultFuture.set(marker);\n                    } else {\n                        // There are some children to download. Wait until it's done (and their children and their\n                        // children...) to inform the caller that we're finished.\n                        Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>() {\n                            @Override\n                            public void onSuccess(List<Object> objects) {\n                                resultFuture.set(marker);\n                            }\n\n                            @Override\n                            public void onFailure(Throwable throwable) {\n                                resultFuture.setException(throwable);\n                            }\n                        });\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable throwable) {\n                    resultFuture.setException(throwable);\n                }\n            });",
    "info" : "ExpressionStatement[43269-45414]:ExpressionStatement[43269-45414]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[43359-43368]:MarkerAnnotation[43359-43368]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[43385-43391]:Modifier[43385-43391]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[43392-43396]:PrimitiveType[43392-43396]"
  }, {
    "left" : "List<Transaction> transactions",
    "right" : "List<Transaction> transactions",
    "info" : "SingleVariableDeclaration[43407-43437]:SingleVariableDeclaration[43407-43437]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43439-45234]:Block[43439-45234]"
  }, {
    "left" : "List<ListenableFuture<Object>> childFutures = Lists.newLinkedList();",
    "right" : "List<ListenableFuture<Object>> childFutures = Lists.newLinkedList();",
    "info" : "VariableDeclarationStatement[43678-43746]:VariableDeclarationStatement[43678-43746]"
  }, {
    "left" : "for (Transaction tx : transactions)",
    "right" : "for (Transaction tx : transactions)",
    "info" : "EnhancedForStatement[43767-44217]:EnhancedForStatement[43767-44217]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43803-44217]:Block[43803-44217]"
  }, {
    "left" : "if (tx == null)",
    "right" : "if (tx == null)",
    "info" : "IfStatement[43829-43854]:IfStatement[43829-43854]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[43845-43854]:ContinueStatement[43845-43854]"
  }, {
    "left" : "log.info(\"{}: Downloaded dependency of {}: {}\", getAddress(), rootTxHash, tx.getHashAsString());",
    "right" : "log.info(\"{}: Downloaded dependency of {}: {}\", getAddress(), rootTxHash, tx.getHashAsString());",
    "info" : "ExpressionStatement[43879-43975]:ExpressionStatement[43879-43975]"
  }, {
    "left" : "results.add(tx);",
    "right" : "results.add(tx);",
    "info" : "ExpressionStatement[44000-44016]:ExpressionStatement[44000-44016]"
  }, {
    "left" : "childFutures.add(downloadDependenciesInternal(tx, marker, results));",
    "right" : "childFutures.add(downloadDependenciesInternal(tx, marker, results));",
    "info" : "ExpressionStatement[44127-44195]:ExpressionStatement[44127-44195]"
  }, {
    "left" : "if (childFutures.size() == 0)",
    "right" : "if (childFutures.size() == 0)",
    "info" : "IfStatement[44238-45216]:IfStatement[44238-45216]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[44268-44429]:Block[44268-44429]"
  }, {
    "left" : "resultFuture.set(marker);",
    "right" : "resultFuture.set(marker);",
    "info" : "ExpressionStatement[44382-44407]:ExpressionStatement[44382-44407]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[44435-45216]:Block[44435-45216]"
  }, {
    "left" : "Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>() {\n                            @Override\n                            public void onSuccess(List<Object> objects) {\n                                resultFuture.set(marker);\n                            }\n\n                            @Override\n                            public void onFailure(Throwable throwable) {\n                                resultFuture.setException(throwable);\n                            }\n                        });",
    "right" : "Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>() {\n                            @Override\n                            public void onSuccess(List<Object> objects) {\n                                resultFuture.set(marker);\n                            }\n\n                            @Override\n                            public void onFailure(Throwable throwable) {\n                                resultFuture.setException(throwable);\n                            }\n                        });",
    "info" : "ExpressionStatement[44658-45194]:ExpressionStatement[44658-45194]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[44783-44792]:MarkerAnnotation[44783-44792]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[44821-44827]:Modifier[44821-44827]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[44828-44832]:PrimitiveType[44828-44832]"
  }, {
    "left" : "List<Object> objects",
    "right" : "List<Object> objects",
    "info" : "SingleVariableDeclaration[44843-44863]:SingleVariableDeclaration[44843-44863]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[44865-44954]:Block[44865-44954]"
  }, {
    "left" : "resultFuture.set(marker);",
    "right" : "resultFuture.set(marker);",
    "info" : "ExpressionStatement[44899-44924]:ExpressionStatement[44899-44924]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[44984-44993]:MarkerAnnotation[44984-44993]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[45022-45028]:Modifier[45022-45028]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[45029-45033]:PrimitiveType[45029-45033]"
  }, {
    "left" : "Throwable throwable",
    "right" : "Throwable throwable",
    "info" : "SingleVariableDeclaration[45044-45063]:SingleVariableDeclaration[45044-45063]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45065-45166]:Block[45065-45166]"
  }, {
    "left" : "resultFuture.setException(throwable);",
    "right" : "resultFuture.setException(throwable);",
    "info" : "ExpressionStatement[45099-45136]:ExpressionStatement[45099-45136]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[45252-45261]:MarkerAnnotation[45252-45261]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[45278-45284]:Modifier[45278-45284]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[45285-45289]:PrimitiveType[45285-45289]"
  }, {
    "left" : "Throwable throwable",
    "right" : "Throwable throwable",
    "info" : "SingleVariableDeclaration[45300-45319]:SingleVariableDeclaration[45300-45319]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45321-45398]:Block[45321-45398]"
  }, {
    "left" : "resultFuture.setException(throwable);",
    "right" : "resultFuture.setException(throwable);",
    "info" : "ExpressionStatement[45343-45380]:ExpressionStatement[45343-45380]"
  }, {
    "left" : "sendMessage(getdata);",
    "right" : "sendMessage(getdata);",
    "info" : "ExpressionStatement[45463-45484]:ExpressionStatement[45463-45484]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45515-45701]:Block[45515-45701]"
  }, {
    "left" : "log.error(\"{}: Couldn't send getdata in downloadDependencies({})\", this, tx.getHash());",
    "right" : "log.error(\"{}: Couldn't send getdata in downloadDependencies({})\", this, tx.getHash());",
    "info" : "ExpressionStatement[45529-45616]:ExpressionStatement[45529-45616]"
  }, {
    "left" : "resultFuture.setException(e);",
    "right" : "resultFuture.setException(e);",
    "info" : "ExpressionStatement[45629-45658]:ExpressionStatement[45629-45658]"
  }, {
    "left" : "return resultFuture;",
    "right" : "return resultFuture;",
    "info" : "ReturnStatement[45671-45691]:ReturnStatement[45671-45691]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45710-45748]:Block[45710-45748]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[45724-45738]:ExpressionStatement[45724-45738]"
  }, {
    "left" : "return resultFuture;",
    "right" : "return resultFuture;",
    "info" : "ReturnStatement[45757-45777]:ReturnStatement[45757-45777]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[45789-45796]:Modifier[45789-45796]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[45797-45801]:PrimitiveType[45797-45801]"
  }, {
    "left" : "Block m",
    "right" : "Block m",
    "info" : "SingleVariableDeclaration[45815-45822]:SingleVariableDeclaration[45815-45822]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45824-49305]:Block[45824-49305]"
  }, {
    "left" : "if (log.isDebugEnabled())",
    "right" : "if (log.isDebugEnabled())",
    "info" : "IfStatement[45834-45964]:IfStatement[45834-45964]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45860-45964]:Block[45860-45964]"
  }, {
    "left" : "log.debug(\"{}: Received broadcast block {}\", getAddress(), m.getHashAsString());",
    "right" : "log.debug(\"{}: Received broadcast block {}\", getAddress(), m.getHashAsString());",
    "info" : "ExpressionStatement[45874-45954]:ExpressionStatement[45874-45954]"
  }, {
    "left" : "if (maybeHandleRequestedData(m))",
    "right" : "if (maybeHandleRequestedData(m))",
    "info" : "IfStatement[46024-46064]:IfStatement[46024-46064]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[46057-46064]:ReturnStatement[46057-46064]"
  }, {
    "left" : "if (blockChain == null)",
    "right" : "if (blockChain == null)",
    "info" : "IfStatement[46073-46218]:IfStatement[46073-46218]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46097-46218]:Block[46097-46218]"
  }, {
    "left" : "log.warn(\"Received block but was not configured with an AbstractBlockChain\");",
    "right" : "log.warn(\"Received block but was not configured with an AbstractBlockChain\");",
    "info" : "ExpressionStatement[46111-46188]:ExpressionStatement[46111-46188]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[46201-46208]:ReturnStatement[46201-46208]"
  }, {
    "left" : "if (!vDownloadData)",
    "right" : "if (!vDownloadData)",
    "info" : "IfStatement[46300-46454]:IfStatement[46300-46454]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46320-46454]:Block[46320-46454]"
  }, {
    "left" : "log.debug(\"{}: Received block we did not ask for: {}\", getAddress(), m.getHashAsString());",
    "right" : "log.debug(\"{}: Received block we did not ask for: {}\", getAddress(), m.getHashAsString());",
    "info" : "ExpressionStatement[46334-46424]:ExpressionStatement[46334-46424]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[46437-46444]:ReturnStatement[46437-46444]"
  }, {
    "left" : "pendingBlockDownloads.remove(m.getHash());",
    "right" : "pendingBlockDownloads.remove(m.getHash());",
    "info" : "ExpressionStatement[46463-46505]:ExpressionStatement[46463-46505]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[46514-49299]:TryStatement[46514-49299]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46518-48986]:Block[46518-48986]"
  }, {
    "left" : "if (blockChain.add(m))",
    "right" : "if (blockChain.add(m))",
    "info" : "IfStatement[46650-48976]:IfStatement[46650-48976]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46673-46841]:Block[46673-46841]"
  }, {
    "left" : "invokeOnBlocksDownloaded(m, null);",
    "right" : "invokeOnBlocksDownloaded(m, null);",
    "info" : "ExpressionStatement[46793-46827]:ExpressionStatement[46793-46827]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46847-48976]:Block[46847-48976]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[48459-48471]:ExpressionStatement[48459-48471]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[48488-48962]:TryStatement[48488-48962]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48492-48899]:Block[48492-48899]"
  }, {
    "left" : "if (downloadBlockBodies)",
    "right" : "if (downloadBlockBodies)",
    "info" : "IfStatement[48514-48881]:IfStatement[48514-48881]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48539-48736]:Block[48539-48736]"
  }, {
    "left" : "final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));",
    "right" : "final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));",
    "info" : "VariableDeclarationStatement[48565-48642]:VariableDeclarationStatement[48565-48642]"
  }, {
    "left" : "blockChainDownloadLocked(orphanRoot.getHash());",
    "right" : "blockChainDownloadLocked(orphanRoot.getHash());",
    "info" : "ExpressionStatement[48667-48714]:ExpressionStatement[48667-48714]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48742-48881]:Block[48742-48881]"
  }, {
    "left" : "log.info(\"Did not start chain download on solved block due to in-flight header download.\");",
    "right" : "log.info(\"Did not start chain download on solved block due to in-flight header download.\");",
    "info" : "ExpressionStatement[48768-48859]:ExpressionStatement[48768-48859]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48908-48962]:Block[48908-48962]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[48930-48944]:ExpressionStatement[48930-48944]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49019-49173]:Block[49019-49173]"
  }, {
    "left" : "log.warn(\"{}: Block verification failed\", getAddress(), e);",
    "right" : "log.warn(\"{}: Block verification failed\", getAddress(), e);",
    "info" : "ExpressionStatement[49104-49163]:ExpressionStatement[49104-49163]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49200-49299]:Block[49200-49299]"
  }, {
    "left" : "throw new RuntimeException(e);",
    "right" : "throw new RuntimeException(e);",
    "info" : "ThrowStatement[49259-49289]:ThrowStatement[49259-49289]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[49346-49353]:Modifier[49346-49353]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[49354-49358]:PrimitiveType[49354-49358]"
  }, {
    "left" : "FilteredBlock m",
    "right" : "FilteredBlock m",
    "info" : "SingleVariableDeclaration[49376-49391]:SingleVariableDeclaration[49376-49391]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49393-56372]:Block[49393-56372]"
  }, {
    "left" : "if (log.isDebugEnabled())",
    "right" : "if (log.isDebugEnabled())",
    "info" : "IfStatement[49403-49533]:IfStatement[49403-49533]"
  }, {
    "left" : "log.debug(\"{}: Received broadcast filtered block {}\", getAddress(), m.getHash().toString());",
    "right" : "log.debug(\"{}: Received broadcast filtered block {}\", getAddress(), m.getHash().toString());",
    "info" : "ExpressionStatement[49441-49533]:ExpressionStatement[49441-49533]"
  }, {
    "left" : "if (!vDownloadData)",
    "right" : "if (!vDownloadData)",
    "info" : "IfStatement[49542-49699]:IfStatement[49542-49699]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49562-49699]:Block[49562-49699]"
  }, {
    "left" : "log.debug(\"{}: Received block we did not ask for: {}\", getAddress(), m.getHash().toString());",
    "right" : "log.debug(\"{}: Received block we did not ask for: {}\", getAddress(), m.getHash().toString());",
    "info" : "ExpressionStatement[49576-49669]:ExpressionStatement[49576-49669]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[49682-49689]:ReturnStatement[49682-49689]"
  }, {
    "left" : "if (blockChain == null)",
    "right" : "if (blockChain == null)",
    "info" : "IfStatement[49708-49862]:IfStatement[49708-49862]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49732-49862]:Block[49732-49862]"
  }, {
    "left" : "log.warn(\"Received filtered block but was not configured with an AbstractBlockChain\");",
    "right" : "log.warn(\"Received filtered block but was not configured with an AbstractBlockChain\");",
    "info" : "ExpressionStatement[49746-49832]:ExpressionStatement[49746-49832]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[49845-49852]:ReturnStatement[49845-49852]"
  }, {
    "left" : "pendingBlockDownloads.remove(m.getBlockHeader().getHash());",
    "right" : "pendingBlockDownloads.remove(m.getBlockHeader().getHash());",
    "info" : "ExpressionStatement[50149-50208]:ExpressionStatement[50149-50208]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[50217-56366]:TryStatement[50217-56366]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50221-55802]:Block[50221-55802]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[52135-52147]:ExpressionStatement[52135-52147]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[52160-53864]:TryStatement[52160-53864]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52164-53809]:Block[52164-53809]"
  }, {
    "left" : "if (awaitingFreshFilter != null)",
    "right" : "if (awaitingFreshFilter != null)",
    "info" : "IfStatement[52182-53795]:IfStatement[52182-53795]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52215-52841]:Block[52215-52841]"
  }, {
    "left" : "log.info(\"Discarding block {} because we're still waiting for a fresh filter\", m.getHash());",
    "right" : "log.info(\"Discarding block {} because we're still waiting for a fresh filter\", m.getHash());",
    "info" : "ExpressionStatement[52237-52329]:ExpressionStatement[52237-52329]"
  }, {
    "left" : "awaitingFreshFilter.add(m.getHash());",
    "right" : "awaitingFreshFilter.add(m.getHash());",
    "info" : "ExpressionStatement[52687-52724]:ExpressionStatement[52687-52724]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[52745-52752]:ReturnStatement[52745-52752]"
  }, {
    "left" : "if (checkForFilterExhaustion(m))",
    "right" : "if (checkForFilterExhaustion(m))",
    "info" : "IfStatement[52847-53795]:IfStatement[52847-53795]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52880-53795]:Block[52880-53795]"
  }, {
    "left" : "log.info(\"Bloom filter exhausted whilst processing block {}, discarding\", m.getHash());",
    "right" : "log.info(\"Bloom filter exhausted whilst processing block {}, discarding\", m.getHash());",
    "info" : "ExpressionStatement[53381-53468]:ExpressionStatement[53381-53468]"
  }, {
    "left" : "awaitingFreshFilter = new LinkedList<Sha256Hash>();",
    "right" : "awaitingFreshFilter = new LinkedList<Sha256Hash>();",
    "info" : "ExpressionStatement[53489-53540]:ExpressionStatement[53489-53540]"
  }, {
    "left" : "awaitingFreshFilter.add(m.getHash());",
    "right" : "awaitingFreshFilter.add(m.getHash());",
    "info" : "ExpressionStatement[53561-53598]:ExpressionStatement[53561-53598]"
  }, {
    "left" : "awaitingFreshFilter.addAll(blockChain.drainOrphanBlocks());",
    "right" : "awaitingFreshFilter.addAll(blockChain.drainOrphanBlocks());",
    "info" : "ExpressionStatement[53619-53678]:ExpressionStatement[53619-53678]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[53699-53706]:ReturnStatement[53699-53706]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53818-53864]:Block[53818-53864]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[53836-53850]:ExpressionStatement[53836-53850]"
  }, {
    "left" : "if (blockChain.add(m))",
    "right" : "if (blockChain.add(m))",
    "info" : "IfStatement[53878-55792]:IfStatement[53878-55792]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53901-54083]:Block[53901-54083]"
  }, {
    "left" : "invokeOnBlocksDownloaded(m.getBlockHeader(), m);",
    "right" : "invokeOnBlocksDownloaded(m.getBlockHeader(), m);",
    "info" : "ExpressionStatement[54021-54069]:ExpressionStatement[54021-54069]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54089-55792]:Block[54089-55792]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[55497-55509]:ExpressionStatement[55497-55509]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[55526-55778]:TryStatement[55526-55778]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55530-55715]:Block[55530-55715]"
  }, {
    "left" : "final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));",
    "right" : "final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));",
    "info" : "VariableDeclarationStatement[55552-55629]:VariableDeclarationStatement[55552-55629]"
  }, {
    "left" : "blockChainDownloadLocked(orphanRoot.getHash());",
    "right" : "blockChainDownloadLocked(orphanRoot.getHash());",
    "info" : "ExpressionStatement[55650-55697]:ExpressionStatement[55650-55697]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55724-55778]:Block[55724-55778]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[55746-55760]:ExpressionStatement[55746-55760]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55835-55997]:Block[55835-55997]"
  }, {
    "left" : "log.warn(\"{}: FilteredBlock verification failed\", getAddress(), e);",
    "right" : "log.warn(\"{}: FilteredBlock verification failed\", getAddress(), e);",
    "info" : "ExpressionStatement[55920-55987]:ExpressionStatement[55920-55987]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56024-56366]:Block[56024-56366]"
  }, {
    "left" : "throw new RuntimeException(e);",
    "right" : "throw new RuntimeException(e);",
    "info" : "ThrowStatement[56326-56356]:ThrowStatement[56326-56356]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[56378-56385]:Modifier[56378-56385]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[56386-56393]:PrimitiveType[56386-56393]"
  }, {
    "left" : "FilteredBlock m",
    "right" : "FilteredBlock m",
    "info" : "SingleVariableDeclaration[56419-56434]:SingleVariableDeclaration[56419-56434]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56436-56615]:Block[56436-56615]"
  }, {
    "left" : "boolean exhausted = false;",
    "right" : "boolean exhausted = false;",
    "info" : "VariableDeclarationStatement[56446-56472]:VariableDeclarationStatement[56446-56472]"
  }, {
    "left" : "for (Wallet wallet : wallets)",
    "right" : "for (Wallet wallet : wallets)",
    "info" : "EnhancedForStatement[56481-56583]:EnhancedForStatement[56481-56583]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56511-56583]:Block[56511-56583]"
  }, {
    "left" : "exhausted |= wallet.checkForFilterExhaustion(m);",
    "right" : "exhausted |= wallet.checkForFilterExhaustion(m);",
    "info" : "ExpressionStatement[56525-56573]:ExpressionStatement[56525-56573]"
  }, {
    "left" : "return exhausted;",
    "right" : "return exhausted;",
    "info" : "ReturnStatement[56592-56609]:ReturnStatement[56592-56609]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[56621-56628]:Modifier[56621-56628]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[56629-56636]:PrimitiveType[56629-56636]"
  }, {
    "left" : "Message m",
    "right" : "Message m",
    "info" : "SingleVariableDeclaration[56662-56671]:SingleVariableDeclaration[56662-56671]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56673-57052]:Block[56673-57052]"
  }, {
    "left" : "boolean found = false;",
    "right" : "boolean found = false;",
    "info" : "VariableDeclarationStatement[56683-56705]:VariableDeclarationStatement[56683-56705]"
  }, {
    "left" : "Sha256Hash hash = m.getHash();",
    "right" : "Sha256Hash hash = m.getHash();",
    "info" : "VariableDeclarationStatement[56714-56744]:VariableDeclarationStatement[56714-56744]"
  }, {
    "left" : "for (GetDataRequest req : getDataFutures)",
    "right" : "for (GetDataRequest req : getDataFutures)",
    "info" : "EnhancedForStatement[56753-57024]:EnhancedForStatement[56753-57024]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56795-57024]:Block[56795-57024]"
  }, {
    "left" : "if (hash.equals(req.hash))",
    "right" : "if (hash.equals(req.hash))",
    "info" : "IfStatement[56809-57014]:IfStatement[56809-57014]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56836-57014]:Block[56836-57014]"
  }, {
    "left" : "req.future.set(m);",
    "right" : "req.future.set(m);",
    "info" : "ExpressionStatement[56854-56872]:ExpressionStatement[56854-56872]"
  }, {
    "left" : "getDataFutures.remove(req);",
    "right" : "getDataFutures.remove(req);",
    "info" : "ExpressionStatement[56889-56916]:ExpressionStatement[56889-56916]"
  }, {
    "left" : "found = true;",
    "right" : "found = true;",
    "info" : "ExpressionStatement[56933-56946]:ExpressionStatement[56933-56946]"
  }, {
    "left" : "return found;",
    "right" : "return found;",
    "info" : "ReturnStatement[57033-57046]:ReturnStatement[57033-57046]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[57058-57065]:Modifier[57058-57065]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[57066-57070]:PrimitiveType[57066-57070]"
  }, {
    "left" : "final Block block",
    "right" : "final Block block",
    "info" : "SingleVariableDeclaration[57096-57113]:SingleVariableDeclaration[57096-57113]"
  }, {
    "left" : "@Nullable final FilteredBlock fb",
    "right" : "@Nullable final FilteredBlock fb",
    "info" : "SingleVariableDeclaration[57115-57147]:SingleVariableDeclaration[57115-57147]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57149-57996]:Block[57149-57996]"
  }, {
    "left" : "final int blocksLeft = Math.max(0, (int) vPeerVersionMessage.bestHeight - checkNotNull(blockChain).getBestChainHeight());",
    "right" : "final int blocksLeft = Math.max(0, (int) vPeerVersionMessage.bestHeight - checkNotNull(blockChain).getBestChainHeight());",
    "info" : "VariableDeclarationStatement[57516-57637]:VariableDeclarationStatement[57516-57637]"
  }, {
    "left" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "right" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "info" : "EnhancedForStatement[57646-57990]:EnhancedForStatement[57646-57990]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57728-57990]:Block[57728-57990]"
  }, {
    "left" : "registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);\n                }\n            });",
    "right" : "registration.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);\n                }\n            });",
    "info" : "ExpressionStatement[57742-57980]:ExpressionStatement[57742-57980]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[57805-57814]:MarkerAnnotation[57805-57814]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[57831-57837]:Modifier[57831-57837]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[57838-57842]:PrimitiveType[57838-57842]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57849-57964]:Block[57849-57964]"
  }, {
    "left" : "registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);",
    "right" : "registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);",
    "info" : "ExpressionStatement[57871-57946]:ExpressionStatement[57871-57946]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[58002-58009]:Modifier[58002-58009]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[58010-58014]:PrimitiveType[58010-58014]"
  }, {
    "left" : "InventoryMessage inv",
    "right" : "InventoryMessage inv",
    "info" : "SingleVariableDeclaration[58026-58046]:SingleVariableDeclaration[58026-58046]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58048-65282]:Block[58048-65282]"
  }, {
    "left" : "List<InventoryItem> items = inv.getItems();",
    "right" : "List<InventoryItem> items = inv.getItems();",
    "info" : "VariableDeclarationStatement[58058-58101]:VariableDeclarationStatement[58058-58101]"
  }, {
    "left" : "List<InventoryItem> transactions = new LinkedList<InventoryItem>();",
    "right" : "List<InventoryItem> transactions = new LinkedList<InventoryItem>();",
    "info" : "VariableDeclarationStatement[58194-58261]:VariableDeclarationStatement[58194-58261]"
  }, {
    "left" : "List<InventoryItem> blocks = new LinkedList<InventoryItem>();",
    "right" : "List<InventoryItem> blocks = new LinkedList<InventoryItem>();",
    "info" : "VariableDeclarationStatement[58270-58331]:VariableDeclarationStatement[58270-58331]"
  }, {
    "left" : "for (InventoryItem item : items)",
    "right" : "for (InventoryItem item : items)",
    "info" : "EnhancedForStatement[58341-58741]:EnhancedForStatement[58341-58741]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58374-58741]:Block[58374-58741]"
  }, {
    "left" : "switch (item.type) {\n                case Transaction:\n                    transactions.add(item);\n                    break;\n                case Block:\n                    blocks.add(item);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Not implemented: \" + item.type);\n            }",
    "right" : "switch (item.type) {\n                case Transaction:\n                    transactions.add(item);\n                    break;\n                case Block:\n                    blocks.add(item);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Not implemented: \" + item.type);\n            }",
    "info" : "SwitchStatement[58388-58731]:SwitchStatement[58388-58731]"
  }, {
    "left" : "case Transaction:",
    "right" : "case Transaction:",
    "info" : "SwitchCase[58425-58442]:SwitchCase[58425-58442]"
  }, {
    "left" : "transactions.add(item);",
    "right" : "transactions.add(item);",
    "info" : "ExpressionStatement[58463-58486]:ExpressionStatement[58463-58486]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[58507-58513]:BreakStatement[58507-58513]"
  }, {
    "left" : "case Block:",
    "right" : "case Block:",
    "info" : "SwitchCase[58530-58541]:SwitchCase[58530-58541]"
  }, {
    "left" : "blocks.add(item);",
    "right" : "blocks.add(item);",
    "info" : "ExpressionStatement[58562-58579]:ExpressionStatement[58562-58579]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[58600-58606]:BreakStatement[58600-58606]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[58623-58631]:SwitchCase[58623-58631]"
  }, {
    "left" : "throw new IllegalStateException(\"Not implemented: \" + item.type);",
    "right" : "throw new IllegalStateException(\"Not implemented: \" + item.type);",
    "info" : "ThrowStatement[58652-58717]:ThrowStatement[58652-58717]"
  }, {
    "left" : "final boolean downloadData = this.vDownloadData;",
    "right" : "final boolean downloadData = this.vDownloadData;",
    "info" : "VariableDeclarationStatement[58751-58799]:VariableDeclarationStatement[58751-58799]"
  }, {
    "left" : "if (transactions.size() == 0 && blocks.size() == 1)",
    "right" : "if (transactions.size() == 0 && blocks.size() == 1)",
    "info" : "IfStatement[58809-59584]:IfStatement[58809-59584]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58861-59584]:Block[58861-59584]"
  }, {
    "left" : "if (downloadData && blockChain != null)",
    "right" : "if (downloadData && blockChain != null)",
    "info" : "IfStatement[59310-59574]:IfStatement[59310-59574]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59350-59502]:Block[59350-59502]"
  }, {
    "left" : "if (!blockChain.isOrphan(blocks.get(0).hash))",
    "right" : "if (!blockChain.isOrphan(blocks.get(0).hash))",
    "info" : "IfStatement[59368-59488]:IfStatement[59368-59488]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59414-59488]:Block[59414-59488]"
  }, {
    "left" : "blocksAnnounced.incrementAndGet();",
    "right" : "blocksAnnounced.incrementAndGet();",
    "info" : "ExpressionStatement[59436-59470]:ExpressionStatement[59436-59470]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59508-59574]:Block[59508-59574]"
  }, {
    "left" : "blocksAnnounced.incrementAndGet();",
    "right" : "blocksAnnounced.incrementAndGet();",
    "info" : "ExpressionStatement[59526-59560]:ExpressionStatement[59526-59560]"
  }, {
    "left" : "GetDataMessage getdata = new GetDataMessage(params);",
    "right" : "GetDataMessage getdata = new GetDataMessage(params);",
    "info" : "VariableDeclarationStatement[59594-59646]:VariableDeclarationStatement[59594-59646]"
  }, {
    "left" : "Iterator<InventoryItem> it = transactions.iterator();",
    "right" : "Iterator<InventoryItem> it = transactions.iterator();",
    "info" : "VariableDeclarationStatement[59656-59709]:VariableDeclarationStatement[59656-59709]"
  }, {
    "left" : "while (it.hasNext())",
    "right" : "while (it.hasNext())",
    "info" : "WhileStatement[59718-61319]:WhileStatement[59718-61319]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59739-61319]:Block[59739-61319]"
  }, {
    "left" : "InventoryItem item = it.next();",
    "right" : "InventoryItem item = it.next();",
    "info" : "VariableDeclarationStatement[59753-59784]:VariableDeclarationStatement[59753-59784]"
  }, {
    "left" : "TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress());",
    "right" : "TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress());",
    "info" : "VariableDeclarationStatement[60568-60661]:VariableDeclarationStatement[60568-60661]"
  }, {
    "left" : "if (conf.numBroadcastPeers() > 1)",
    "right" : "if (conf.numBroadcastPeers() > 1)",
    "info" : "IfStatement[60674-61309]:IfStatement[60674-61309]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60708-60829]:Block[60708-60829]"
  }, {
    "left" : "it.remove();",
    "right" : "it.remove();",
    "info" : "ExpressionStatement[60803-60815]:ExpressionStatement[60803-60815]"
  }, {
    "left" : "if (conf.getSource().equals(TransactionConfidence.Source.SELF))",
    "right" : "if (conf.getSource().equals(TransactionConfidence.Source.SELF))",
    "info" : "IfStatement[60835-61309]:IfStatement[60835-61309]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60899-61020]:Block[60899-61020]"
  }, {
    "left" : "it.remove();",
    "right" : "it.remove();",
    "info" : "ExpressionStatement[60994-61006]:ExpressionStatement[60994-61006]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61026-61309]:Block[61026-61309]"
  }, {
    "left" : "log.debug(\"{}: getdata on tx {}\", getAddress(), item.hash);",
    "right" : "log.debug(\"{}: getdata on tx {}\", getAddress(), item.hash);",
    "info" : "ExpressionStatement[61044-61103]:ExpressionStatement[61044-61103]"
  }, {
    "left" : "getdata.addItem(item);",
    "right" : "getdata.addItem(item);",
    "info" : "ExpressionStatement[61120-61142]:ExpressionStatement[61120-61142]"
  }, {
    "left" : "pendingTxDownloads.add(conf);",
    "right" : "pendingTxDownloads.add(conf);",
    "info" : "ExpressionStatement[61266-61295]:ExpressionStatement[61266-61295]"
  }, {
    "left" : "boolean pingAfterGetData = false;",
    "right" : "boolean pingAfterGetData = false;",
    "info" : "VariableDeclarationStatement[61533-61566]:VariableDeclarationStatement[61533-61566]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[61576-61588]:ExpressionStatement[61576-61588]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[61597-65001]:TryStatement[61597-65001]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61601-64954]:Block[61601-64954]"
  }, {
    "left" : "if (blocks.size() > 0 && downloadData && blockChain != null)",
    "right" : "if (blocks.size() > 0 && downloadData && blockChain != null)",
    "info" : "IfStatement[61615-64944]:IfStatement[61615-64944]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61676-64944]:Block[61676-64944]"
  }, {
    "left" : "for (InventoryItem item : blocks)",
    "right" : "for (InventoryItem item : blocks)",
    "info" : "EnhancedForStatement[62054-64417]:EnhancedForStatement[62054-64417]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62088-64417]:Block[62088-64417]"
  }, {
    "left" : "if (blockChain.isOrphan(item.hash) && downloadBlockBodies)",
    "right" : "if (blockChain.isOrphan(item.hash) && downloadBlockBodies)",
    "info" : "IfStatement[62110-64399]:IfStatement[62110-64399]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62169-62568]:Block[62169-62568]"
  }, {
    "left" : "final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(item.hash));",
    "right" : "final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(item.hash));",
    "info" : "VariableDeclarationStatement[62399-62474]:VariableDeclarationStatement[62399-62474]"
  }, {
    "left" : "blockChainDownloadLocked(orphanRoot.getHash());",
    "right" : "blockChainDownloadLocked(orphanRoot.getHash());",
    "info" : "ExpressionStatement[62499-62546]:ExpressionStatement[62499-62546]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62574-64399]:Block[62574-64399]"
  }, {
    "left" : "if (!pendingBlockDownloads.contains(item.hash))",
    "right" : "if (!pendingBlockDownloads.contains(item.hash))",
    "info" : "IfStatement[63884-64377]:IfStatement[63884-64377]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63932-64377]:Block[63932-64377]"
  }, {
    "left" : "if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks)",
    "right" : "if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks)",
    "info" : "IfStatement[63962-64285]:IfStatement[63962-64285]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64036-64193]:Block[64036-64193]"
  }, {
    "left" : "getdata.addFilteredBlock(item.hash);",
    "right" : "getdata.addFilteredBlock(item.hash);",
    "info" : "ExpressionStatement[64070-64106]:ExpressionStatement[64070-64106]"
  }, {
    "left" : "pingAfterGetData = true;",
    "right" : "pingAfterGetData = true;",
    "info" : "ExpressionStatement[64139-64163]:ExpressionStatement[64139-64163]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64199-64285]:Block[64199-64285]"
  }, {
    "left" : "getdata.addItem(item);",
    "right" : "getdata.addItem(item);",
    "info" : "ExpressionStatement[64233-64255]:ExpressionStatement[64233-64255]"
  }, {
    "left" : "pendingBlockDownloads.add(item.hash);",
    "right" : "pendingBlockDownloads.add(item.hash);",
    "info" : "ExpressionStatement[64314-64351]:ExpressionStatement[64314-64351]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64963-65001]:Block[64963-65001]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[64977-64991]:ExpressionStatement[64977-64991]"
  }, {
    "left" : "if (!getdata.getItems().isEmpty())",
    "right" : "if (!getdata.getItems().isEmpty())",
    "info" : "IfStatement[65011-65169]:IfStatement[65011-65169]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65046-65169]:Block[65046-65169]"
  }, {
    "left" : "sendMessage(getdata);",
    "right" : "sendMessage(getdata);",
    "info" : "ExpressionStatement[65138-65159]:ExpressionStatement[65138-65159]"
  }, {
    "left" : "if (pingAfterGetData)",
    "right" : "if (pingAfterGetData)",
    "info" : "IfStatement[65179-65276]:IfStatement[65179-65276]"
  }, {
    "left" : "sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));",
    "right" : "sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));",
    "info" : "ExpressionStatement[65213-65276]:ExpressionStatement[65213-65276]"
  }, {
    "left" : "@SuppressWarnings(\"unchecked\")",
    "right" : "@SuppressWarnings(\"unchecked\")",
    "info" : "SingleMemberAnnotation[65571-65601]:SingleMemberAnnotation[65571-65601]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[65946-65952]:Modifier[65946-65952]"
  }, {
    "left" : "ListenableFuture<Block>",
    "right" : "ListenableFuture<Block>",
    "info" : "ParameterizedType[65953-65976]:ParameterizedType[65953-65976]"
  }, {
    "left" : "Sha256Hash blockHash",
    "right" : "Sha256Hash blockHash",
    "info" : "SingleVariableDeclaration[65986-66006]:SingleVariableDeclaration[65986-66006]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66008-66258]:Block[66008-66258]"
  }, {
    "left" : "log.info(\"Request to fetch block {}\", blockHash);",
    "right" : "log.info(\"Request to fetch block {}\", blockHash);",
    "info" : "ExpressionStatement[66062-66111]:ExpressionStatement[66062-66111]"
  }, {
    "left" : "GetDataMessage getdata = new GetDataMessage(params);",
    "right" : "GetDataMessage getdata = new GetDataMessage(params);",
    "info" : "VariableDeclarationStatement[66120-66172]:VariableDeclarationStatement[66120-66172]"
  }, {
    "left" : "getdata.addBlock(blockHash);",
    "right" : "getdata.addBlock(blockHash);",
    "info" : "ExpressionStatement[66181-66209]:ExpressionStatement[66181-66209]"
  }, {
    "left" : "return sendSingleGetData(getdata);",
    "right" : "return sendSingleGetData(getdata);",
    "info" : "ReturnStatement[66218-66252]:ReturnStatement[66218-66252]"
  }, {
    "left" : "@SuppressWarnings(\"unchecked\")",
    "right" : "@SuppressWarnings(\"unchecked\")",
    "info" : "SingleMemberAnnotation[66588-66618]:SingleMemberAnnotation[66588-66618]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[66969-66975]:Modifier[66969-66975]"
  }, {
    "left" : "ListenableFuture<Transaction>",
    "right" : "ListenableFuture<Transaction>",
    "info" : "ParameterizedType[66976-67005]:ParameterizedType[66976-67005]"
  }, {
    "left" : "Sha256Hash hash",
    "right" : "Sha256Hash hash",
    "info" : "SingleVariableDeclaration[67032-67047]:SingleVariableDeclaration[67032-67047]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67049-67346]:Block[67049-67346]"
  }, {
    "left" : "log.info(\"Request to fetch peer mempool tx  {}\", hash);",
    "right" : "log.info(\"Request to fetch peer mempool tx  {}\", hash);",
    "info" : "ExpressionStatement[67143-67198]:ExpressionStatement[67143-67198]"
  }, {
    "left" : "GetDataMessage getdata = new GetDataMessage(params);",
    "right" : "GetDataMessage getdata = new GetDataMessage(params);",
    "info" : "VariableDeclarationStatement[67207-67259]:VariableDeclarationStatement[67207-67259]"
  }, {
    "left" : "getdata.addTransaction(hash);",
    "right" : "getdata.addTransaction(hash);",
    "info" : "ExpressionStatement[67268-67297]:ExpressionStatement[67268-67297]"
  }, {
    "left" : "return sendSingleGetData(getdata);",
    "right" : "return sendSingleGetData(getdata);",
    "info" : "ReturnStatement[67306-67340]:ReturnStatement[67306-67340]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[67405-67412]:Modifier[67405-67412]"
  }, {
    "left" : "ListenableFuture",
    "right" : "ListenableFuture",
    "info" : "SimpleType[67413-67429]:SimpleType[67413-67429]"
  }, {
    "left" : "GetDataMessage getdata",
    "right" : "GetDataMessage getdata",
    "info" : "SingleVariableDeclaration[67448-67470]:SingleVariableDeclaration[67448-67470]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67472-67830]:Block[67472-67830]"
  }, {
    "left" : "Preconditions.checkArgument(getdata.getItems().size() == 1);",
    "right" : "Preconditions.checkArgument(getdata.getItems().size() == 1);",
    "info" : "ExpressionStatement[67526-67586]:ExpressionStatement[67526-67586]"
  }, {
    "left" : "GetDataRequest req = new GetDataRequest();",
    "right" : "GetDataRequest req = new GetDataRequest();",
    "info" : "VariableDeclarationStatement[67595-67637]:VariableDeclarationStatement[67595-67637]"
  }, {
    "left" : "req.future = SettableFuture.create();",
    "right" : "req.future = SettableFuture.create();",
    "info" : "ExpressionStatement[67646-67683]:ExpressionStatement[67646-67683]"
  }, {
    "left" : "req.hash = getdata.getItems().get(0).hash;",
    "right" : "req.hash = getdata.getItems().get(0).hash;",
    "info" : "ExpressionStatement[67692-67734]:ExpressionStatement[67692-67734]"
  }, {
    "left" : "getDataFutures.add(req);",
    "right" : "getDataFutures.add(req);",
    "info" : "ExpressionStatement[67743-67767]:ExpressionStatement[67743-67767]"
  }, {
    "left" : "sendMessage(getdata);",
    "right" : "sendMessage(getdata);",
    "info" : "ExpressionStatement[67776-67797]:ExpressionStatement[67776-67797]"
  }, {
    "left" : "return req.future;",
    "right" : "return req.future;",
    "info" : "ReturnStatement[67806-67824]:ReturnStatement[67806-67824]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[67962-67968]:Modifier[67962-67968]"
  }, {
    "left" : "ListenableFuture<AddressMessage>",
    "right" : "ListenableFuture<AddressMessage>",
    "info" : "ParameterizedType[67969-68001]:ParameterizedType[67969-68001]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68012-68254]:Block[68012-68254]"
  }, {
    "left" : "SettableFuture<AddressMessage> future = SettableFuture.create();",
    "right" : "SettableFuture<AddressMessage> future = SettableFuture.create();",
    "info" : "VariableDeclarationStatement[68022-68086]:VariableDeclarationStatement[68022-68086]"
  }, {
    "left" : "synchronized (getAddrFutures) {\n            getAddrFutures.add(future);\n        }",
    "right" : "synchronized (getAddrFutures) {\n            getAddrFutures.add(future);\n        }",
    "info" : "SynchronizedStatement[68095-68176]:SynchronizedStatement[68095-68176]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68125-68176]:Block[68125-68176]"
  }, {
    "left" : "getAddrFutures.add(future);",
    "right" : "getAddrFutures.add(future);",
    "info" : "ExpressionStatement[68139-68166]:ExpressionStatement[68139-68166]"
  }, {
    "left" : "sendMessage(new GetAddrMessage(params));",
    "right" : "sendMessage(new GetAddrMessage(params));",
    "info" : "ExpressionStatement[68185-68225]:ExpressionStatement[68185-68225]"
  }, {
    "left" : "return future;",
    "right" : "return future;",
    "info" : "ReturnStatement[68234-68248]:ReturnStatement[68234-68248]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[68971-68977]:Modifier[68971-68977]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[68978-68982]:PrimitiveType[68978-68982]"
  }, {
    "left" : "long secondsSinceEpoch",
    "right" : "long secondsSinceEpoch",
    "info" : "SingleVariableDeclaration[69005-69027]:SingleVariableDeclaration[69005-69027]"
  }, {
    "left" : "boolean useFilteredBlocks",
    "right" : "boolean useFilteredBlocks",
    "info" : "SingleVariableDeclaration[69029-69054]:SingleVariableDeclaration[69029-69054]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69056-69809]:Block[69056-69809]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[69066-69078]:ExpressionStatement[69066-69078]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[69087-69803]:TryStatement[69087-69803]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69091-69756]:Block[69091-69756]"
  }, {
    "left" : "if (secondsSinceEpoch == 0)",
    "right" : "if (secondsSinceEpoch == 0)",
    "info" : "IfStatement[69105-69690]:IfStatement[69105-69690]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69133-69273]:Block[69133-69273]"
  }, {
    "left" : "fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();",
    "right" : "fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();",
    "info" : "ExpressionStatement[69151-69215]:ExpressionStatement[69151-69215]"
  }, {
    "left" : "downloadBlockBodies = true;",
    "right" : "downloadBlockBodies = true;",
    "info" : "ExpressionStatement[69232-69259]:ExpressionStatement[69232-69259]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69279-69690]:Block[69279-69690]"
  }, {
    "left" : "fastCatchupTimeSecs = secondsSinceEpoch;",
    "right" : "fastCatchupTimeSecs = secondsSinceEpoch;",
    "info" : "ExpressionStatement[69297-69337]:ExpressionStatement[69297-69337]"
  }, {
    "left" : "if (blockChain != null && fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds())",
    "right" : "if (blockChain != null && fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds())",
    "info" : "IfStatement[69524-69676]:IfStatement[69524-69676]"
  }, {
    "left" : "downloadBlockBodies = false;",
    "right" : "downloadBlockBodies = false;",
    "info" : "ExpressionStatement[69648-69676]:ExpressionStatement[69648-69676]"
  }, {
    "left" : "this.useFilteredBlocks = useFilteredBlocks;",
    "right" : "this.useFilteredBlocks = useFilteredBlocks;",
    "info" : "ExpressionStatement[69703-69746]:ExpressionStatement[69703-69746]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69765-69803]:Block[69765-69803]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[69779-69793]:ExpressionStatement[69779-69793]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[70145-70151]:Modifier[70145-70151]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[70152-70156]:PrimitiveType[70152-70156]"
  }, {
    "left" : "Wallet wallet",
    "right" : "Wallet wallet",
    "info" : "SingleVariableDeclaration[70167-70180]:SingleVariableDeclaration[70167-70180]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70182-70218]:Block[70182-70218]"
  }, {
    "left" : "wallets.add(wallet);",
    "right" : "wallets.add(wallet);",
    "info" : "ExpressionStatement[70192-70212]:ExpressionStatement[70192-70212]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[70307-70313]:Modifier[70307-70313]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[70314-70318]:PrimitiveType[70314-70318]"
  }, {
    "left" : "Wallet wallet",
    "right" : "Wallet wallet",
    "info" : "SingleVariableDeclaration[70332-70345]:SingleVariableDeclaration[70332-70345]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70347-70386]:Block[70347-70386]"
  }, {
    "left" : "wallets.remove(wallet);",
    "right" : "wallets.remove(wallet);",
    "info" : "ExpressionStatement[70357-70380]:ExpressionStatement[70357-70380]"
  }, {
    "left" : "@GuardedBy(\"lock\")",
    "right" : "@GuardedBy(\"lock\")",
    "info" : "SingleMemberAnnotation[70628-70646]:SingleMemberAnnotation[70628-70646]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[70651-70658]:Modifier[70651-70658]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[70659-70663]:PrimitiveType[70659-70663]"
  }, {
    "left" : "Sha256Hash toHash",
    "right" : "Sha256Hash toHash",
    "info" : "SingleVariableDeclaration[70689-70706]:SingleVariableDeclaration[70689-70706]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70708-76248]:Block[70708-76248]"
  }, {
    "left" : "checkState(lock.isHeldByCurrentThread());",
    "right" : "checkState(lock.isHeldByCurrentThread());",
    "info" : "ExpressionStatement[70718-70759]:ExpressionStatement[70718-70759]"
  }, {
    "left" : "List<Sha256Hash> blockLocator = new ArrayList<Sha256Hash>(51);",
    "right" : "List<Sha256Hash> blockLocator = new ArrayList<Sha256Hash>(51);",
    "info" : "VariableDeclarationStatement[73546-73608]:VariableDeclarationStatement[73546-73608]"
  }, {
    "left" : "BlockStore store = checkNotNull(blockChain).getBlockStore();",
    "right" : "BlockStore store = checkNotNull(blockChain).getBlockStore();",
    "info" : "VariableDeclarationStatement[74087-74147]:VariableDeclarationStatement[74087-74147]"
  }, {
    "left" : "StoredBlock chainHead = blockChain.getChainHead();",
    "right" : "StoredBlock chainHead = blockChain.getChainHead();",
    "info" : "VariableDeclarationStatement[74156-74206]:VariableDeclarationStatement[74156-74206]"
  }, {
    "left" : "Sha256Hash chainHeadHash = chainHead.getHeader().getHash();",
    "right" : "Sha256Hash chainHeadHash = chainHead.getHeader().getHash();",
    "info" : "VariableDeclarationStatement[74215-74274]:VariableDeclarationStatement[74215-74274]"
  }, {
    "left" : "if (Objects.equal(lastGetBlocksBegin, chainHeadHash) && Objects.equal(lastGetBlocksEnd, toHash))",
    "right" : "if (Objects.equal(lastGetBlocksBegin, chainHeadHash) && Objects.equal(lastGetBlocksEnd, toHash))",
    "info" : "IfStatement[74354-74785]:IfStatement[74354-74785]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74451-74785]:Block[74451-74785]"
  }, {
    "left" : "log.info(\"blockChainDownloadLocked({}): ignoring duplicated request: {}\", toHash, chainHeadHash);",
    "right" : "log.info(\"blockChainDownloadLocked({}): ignoring duplicated request: {}\", toHash, chainHeadHash);",
    "info" : "ExpressionStatement[74465-74562]:ExpressionStatement[74465-74562]"
  }, {
    "left" : "for (Sha256Hash hash : pendingBlockDownloads)\n                log.info(\"Pending block download: {}\", hash);",
    "right" : "for (Sha256Hash hash : pendingBlockDownloads)\n                log.info(\"Pending block download: {}\", hash);",
    "info" : "EnhancedForStatement[74575-74682]:EnhancedForStatement[74575-74682]"
  }, {
    "left" : "log.info(\"Pending block download: {}\", hash);",
    "right" : "log.info(\"Pending block download: {}\", hash);",
    "info" : "ExpressionStatement[74637-74682]:ExpressionStatement[74637-74682]"
  }, {
    "left" : "log.info(Throwables.getStackTraceAsString(new Throwable()));",
    "right" : "log.info(Throwables.getStackTraceAsString(new Throwable()));",
    "info" : "ExpressionStatement[74695-74755]:ExpressionStatement[74695-74755]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[74768-74775]:ReturnStatement[74768-74775]"
  }, {
    "left" : "if (log.isDebugEnabled())",
    "right" : "if (log.isDebugEnabled())",
    "info" : "IfStatement[74794-74971]:IfStatement[74794-74971]"
  }, {
    "left" : "log.debug(\"{}: blockChainDownloadLocked({}) current head = {}\",\n                    this, toHash, chainHead.getHeader().getHashAsString());",
    "right" : "log.debug(\"{}: blockChainDownloadLocked({}) current head = {}\",\n                    this, toHash, chainHead.getHeader().getHashAsString());",
    "info" : "ExpressionStatement[74832-74971]:ExpressionStatement[74832-74971]"
  }, {
    "left" : "StoredBlock cursor = chainHead;",
    "right" : "StoredBlock cursor = chainHead;",
    "info" : "VariableDeclarationStatement[74980-75011]:VariableDeclarationStatement[74980-75011]"
  }, {
    "left" : "for (int i = 100; cursor != null && i > 0; i--)",
    "right" : "for (int i = 100; cursor != null && i > 0; i--)",
    "info" : "ForStatement[75020-75403]:ForStatement[75020-75403]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75068-75403]:Block[75068-75403]"
  }, {
    "left" : "blockLocator.add(cursor.getHeader().getHash());",
    "right" : "blockLocator.add(cursor.getHeader().getHash());",
    "info" : "ExpressionStatement[75082-75129]:ExpressionStatement[75082-75129]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[75142-75393]:TryStatement[75142-75393]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75146-75209]:Block[75146-75209]"
  }, {
    "left" : "cursor = cursor.getPrev(store);",
    "right" : "cursor = cursor.getPrev(store);",
    "info" : "ExpressionStatement[75164-75195]:ExpressionStatement[75164-75195]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75240-75393]:Block[75240-75393]"
  }, {
    "left" : "log.error(\"Failed to walk the block chain whilst constructing a locator\");",
    "right" : "log.error(\"Failed to walk the block chain whilst constructing a locator\");",
    "info" : "ExpressionStatement[75258-75332]:ExpressionStatement[75258-75332]"
  }, {
    "left" : "throw new RuntimeException(e);",
    "right" : "throw new RuntimeException(e);",
    "info" : "ThrowStatement[75349-75379]:ThrowStatement[75349-75379]"
  }, {
    "left" : "if (cursor != null)",
    "right" : "if (cursor != null)",
    "info" : "IfStatement[75523-75608]:IfStatement[75523-75608]"
  }, {
    "left" : "blockLocator.add(params.getGenesisBlock().getHash());",
    "right" : "blockLocator.add(params.getGenesisBlock().getHash());",
    "info" : "ExpressionStatement[75555-75608]:ExpressionStatement[75555-75608]"
  }, {
    "left" : "lastGetBlocksBegin = chainHeadHash;",
    "right" : "lastGetBlocksBegin = chainHeadHash;",
    "info" : "ExpressionStatement[75786-75821]:ExpressionStatement[75786-75821]"
  }, {
    "left" : "lastGetBlocksEnd = toHash;",
    "right" : "lastGetBlocksEnd = toHash;",
    "info" : "ExpressionStatement[75830-75856]:ExpressionStatement[75830-75856]"
  }, {
    "left" : "if (downloadBlockBodies)",
    "right" : "if (downloadBlockBodies)",
    "info" : "IfStatement[75866-76242]:IfStatement[75866-76242]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75891-76027]:Block[75891-76027]"
  }, {
    "left" : "GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash);",
    "right" : "GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash);",
    "info" : "VariableDeclarationStatement[75905-75983]:VariableDeclarationStatement[75905-75983]"
  }, {
    "left" : "sendMessage(message);",
    "right" : "sendMessage(message);",
    "info" : "ExpressionStatement[75996-76017]:ExpressionStatement[75996-76017]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76033-76242]:Block[76033-76242]"
  }, {
    "left" : "GetHeadersMessage message = new GetHeadersMessage(params, blockLocator, toHash);",
    "right" : "GetHeadersMessage message = new GetHeadersMessage(params, blockLocator, toHash);",
    "info" : "VariableDeclarationStatement[76118-76198]:VariableDeclarationStatement[76118-76198]"
  }, {
    "left" : "sendMessage(message);",
    "right" : "sendMessage(message);",
    "info" : "ExpressionStatement[76211-76232]:ExpressionStatement[76211-76232]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[76494-76500]:Modifier[76494-76500]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[76501-76505]:PrimitiveType[76501-76505]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76532-77472]:Block[76532-77472]"
  }, {
    "left" : "setDownloadData(true);",
    "right" : "setDownloadData(true);",
    "info" : "ExpressionStatement[76542-76564]:ExpressionStatement[76542-76564]"
  }, {
    "left" : "final int blocksLeft = getPeerBlockHeightDifference();",
    "right" : "final int blocksLeft = getPeerBlockHeightDifference();",
    "info" : "VariableDeclarationStatement[76720-76774]:VariableDeclarationStatement[76720-76774]"
  }, {
    "left" : "if (blocksLeft >= 0)",
    "right" : "if (blocksLeft >= 0)",
    "info" : "IfStatement[76783-77466]:IfStatement[76783-77466]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76804-77466]:Block[76804-77466]"
  }, {
    "left" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "right" : "for (final ListenerRegistration<PeerEventListener> registration : eventListeners)",
    "info" : "EnhancedForStatement[76818-77183]:EnhancedForStatement[76818-77183]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76900-77183]:Block[76900-77183]"
  }, {
    "left" : "registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onChainDownloadStarted(Peer.this, blocksLeft);\n                    }\n                });",
    "right" : "registration.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        registration.listener.onChainDownloadStarted(Peer.this, blocksLeft);\n                    }\n                });",
    "info" : "ExpressionStatement[76918-77169]:ExpressionStatement[76918-77169]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[76985-76994]:MarkerAnnotation[76985-76994]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[77015-77021]:Modifier[77015-77021]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[77022-77026]:PrimitiveType[77022-77026]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[77033-77149]:Block[77033-77149]"
  }, {
    "left" : "registration.listener.onChainDownloadStarted(Peer.this, blocksLeft);",
    "right" : "registration.listener.onChainDownloadStarted(Peer.this, blocksLeft);",
    "info" : "ExpressionStatement[77059-77127]:ExpressionStatement[77059-77127]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[77293-77305]:ExpressionStatement[77293-77305]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[77318-77456]:TryStatement[77318-77456]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[77322-77401]:Block[77322-77401]"
  }, {
    "left" : "blockChainDownloadLocked(Sha256Hash.ZERO_HASH);",
    "right" : "blockChainDownloadLocked(Sha256Hash.ZERO_HASH);",
    "info" : "ExpressionStatement[77340-77387]:ExpressionStatement[77340-77387]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[77410-77456]:Block[77410-77456]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[77428-77442]:ExpressionStatement[77428-77442]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[77478-77485]:Modifier[77478-77485]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[77826-77832]:Modifier[77826-77832]"
  }, {
    "left" : "long nonce",
    "right" : "long nonce",
    "info" : "SingleVariableDeclaration[77845-77855]:SingleVariableDeclaration[77845-77855]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[77857-78001]:Block[77857-78001]"
  }, {
    "left" : "future = SettableFuture.create();",
    "right" : "future = SettableFuture.create();",
    "info" : "ExpressionStatement[77871-77904]:ExpressionStatement[77871-77904]"
  }, {
    "left" : "this.nonce = nonce;",
    "right" : "this.nonce = nonce;",
    "info" : "ExpressionStatement[77917-77936]:ExpressionStatement[77917-77936]"
  }, {
    "left" : "startTimeMsec = Utils.currentTimeMillis();",
    "right" : "startTimeMsec = Utils.currentTimeMillis();",
    "info" : "ExpressionStatement[77949-77991]:ExpressionStatement[77949-77991]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[78011-78017]:Modifier[78011-78017]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[78018-78022]:PrimitiveType[78018-78022]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78034-78344]:Block[78034-78344]"
  }, {
    "left" : "if (!future.isDone())",
    "right" : "if (!future.isDone())",
    "info" : "IfStatement[78048-78334]:IfStatement[78048-78334]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78070-78334]:Block[78070-78334]"
  }, {
    "left" : "Long elapsed = Utils.currentTimeMillis() - startTimeMsec;",
    "right" : "Long elapsed = Utils.currentTimeMillis() - startTimeMsec;",
    "info" : "VariableDeclarationStatement[78088-78145]:VariableDeclarationStatement[78088-78145]"
  }, {
    "left" : "Peer.this.addPingTimeData(elapsed);",
    "right" : "Peer.this.addPingTimeData(elapsed);",
    "info" : "ExpressionStatement[78162-78197]:ExpressionStatement[78162-78197]"
  }, {
    "left" : "log.debug(\"{}: ping time is {} msec\", Peer.this.toString(), elapsed);",
    "right" : "log.debug(\"{}: ping time is {} msec\", Peer.this.toString(), elapsed);",
    "info" : "ExpressionStatement[78214-78283]:ExpressionStatement[78214-78283]"
  }, {
    "left" : "future.set(elapsed);",
    "right" : "future.set(elapsed);",
    "info" : "ExpressionStatement[78300-78320]:ExpressionStatement[78300-78320]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[78416-78423]:Modifier[78416-78423]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[78424-78428]:PrimitiveType[78424-78428]"
  }, {
    "left" : "long sample",
    "right" : "long sample",
    "info" : "SingleVariableDeclaration[78445-78456]:SingleVariableDeclaration[78445-78456]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78458-79128]:Block[78458-79128]"
  }, {
    "left" : "lastPingTimesLock.lock();",
    "right" : "lastPingTimesLock.lock();",
    "info" : "ExpressionStatement[78468-78493]:ExpressionStatement[78468-78493]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[78502-79122]:TryStatement[78502-79122]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78506-79062]:Block[78506-79062]"
  }, {
    "left" : "if (lastPingTimes == null)",
    "right" : "if (lastPingTimes == null)",
    "info" : "IfStatement[78520-79052]:IfStatement[78520-79052]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78547-78756]:Block[78547-78756]"
  }, {
    "left" : "lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW];",
    "right" : "lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW];",
    "info" : "ExpressionStatement[78565-78618]:ExpressionStatement[78565-78618]"
  }, {
    "left" : "Arrays.fill(lastPingTimes, sample);",
    "right" : "Arrays.fill(lastPingTimes, sample);",
    "info" : "ExpressionStatement[78707-78742]:ExpressionStatement[78707-78742]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78762-79052]:Block[78762-79052]"
  }, {
    "left" : "System.arraycopy(lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1);",
    "right" : "System.arraycopy(lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1);",
    "info" : "ExpressionStatement[78836-78915]:ExpressionStatement[78836-78915]"
  }, {
    "left" : "lastPingTimes[lastPingTimes.length - 1] = sample;",
    "right" : "lastPingTimes[lastPingTimes.length - 1] = sample;",
    "info" : "ExpressionStatement[78989-79038]:ExpressionStatement[78989-79038]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79071-79122]:Block[79071-79122]"
  }, {
    "left" : "lastPingTimesLock.unlock();",
    "right" : "lastPingTimesLock.unlock();",
    "info" : "ExpressionStatement[79085-79112]:ExpressionStatement[79085-79112]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[79588-79594]:Modifier[79588-79594]"
  }, {
    "left" : "ListenableFuture<Long>",
    "right" : "ListenableFuture<Long>",
    "info" : "ParameterizedType[79595-79617]:ParameterizedType[79595-79617]"
  }, {
    "left" : "ProtocolException",
    "right" : "ProtocolException",
    "info" : "SimpleType[79632-79649]:SimpleType[79632-79649]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79650-79719]:Block[79650-79719]"
  }, {
    "left" : "return ping((long) (Math.random() * Long.MAX_VALUE));",
    "right" : "return ping((long) (Math.random() * Long.MAX_VALUE));",
    "info" : "ReturnStatement[79660-79713]:ReturnStatement[79660-79713]"
  }, {
    "left" : "protected",
    "right" : "protected",
    "info" : "Modifier[79725-79734]:Modifier[79725-79734]"
  }, {
    "left" : "ListenableFuture<Long>",
    "right" : "ListenableFuture<Long>",
    "info" : "ParameterizedType[79735-79757]:ParameterizedType[79735-79757]"
  }, {
    "left" : "long nonce",
    "right" : "long nonce",
    "info" : "SingleVariableDeclaration[79763-79773]:SingleVariableDeclaration[79763-79773]"
  }, {
    "left" : "ProtocolException",
    "right" : "ProtocolException",
    "info" : "SimpleType[79782-79799]:SimpleType[79782-79799]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79800-80182]:Block[79800-80182]"
  }, {
    "left" : "final VersionMessage ver = vPeerVersionMessage;",
    "right" : "final VersionMessage ver = vPeerVersionMessage;",
    "info" : "VariableDeclarationStatement[79810-79857]:VariableDeclarationStatement[79810-79857]"
  }, {
    "left" : "if (!ver.isPingPongSupported())",
    "right" : "if (!ver.isPingPongSupported())",
    "info" : "IfStatement[79866-79994]:IfStatement[79866-79994]"
  }, {
    "left" : "throw new ProtocolException(\"Peer version is too low for measurable pings: \" + ver);",
    "right" : "throw new ProtocolException(\"Peer version is too low for measurable pings: \" + ver);",
    "info" : "ThrowStatement[79910-79994]:ThrowStatement[79910-79994]"
  }, {
    "left" : "PendingPing pendingPing = new PendingPing(nonce);",
    "right" : "PendingPing pendingPing = new PendingPing(nonce);",
    "info" : "VariableDeclarationStatement[80003-80052]:VariableDeclarationStatement[80003-80052]"
  }, {
    "left" : "pendingPings.add(pendingPing);",
    "right" : "pendingPings.add(pendingPing);",
    "info" : "ExpressionStatement[80061-80091]:ExpressionStatement[80061-80091]"
  }, {
    "left" : "sendMessage(new Ping(pendingPing.nonce));",
    "right" : "sendMessage(new Ping(pendingPing.nonce));",
    "info" : "ExpressionStatement[80100-80141]:ExpressionStatement[80100-80141]"
  }, {
    "left" : "return pendingPing.future;",
    "right" : "return pendingPing.future;",
    "info" : "ReturnStatement[80150-80176]:ReturnStatement[80150-80176]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[80415-80421]:Modifier[80415-80421]"
  }, {
    "left" : "long",
    "right" : "long",
    "info" : "PrimitiveType[80422-80426]:PrimitiveType[80422-80426]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[80445-80708]:Block[80445-80708]"
  }, {
    "left" : "lastPingTimesLock.lock();",
    "right" : "lastPingTimesLock.lock();",
    "info" : "ExpressionStatement[80455-80480]:ExpressionStatement[80455-80480]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[80489-80702]:TryStatement[80489-80702]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[80493-80642]:Block[80493-80642]"
  }, {
    "left" : "if (lastPingTimes == null)",
    "right" : "if (lastPingTimes == null)",
    "info" : "IfStatement[80507-80572]:IfStatement[80507-80572]"
  }, {
    "left" : "return Long.MAX_VALUE;",
    "right" : "return Long.MAX_VALUE;",
    "info" : "ReturnStatement[80550-80572]:ReturnStatement[80550-80572]"
  }, {
    "left" : "return lastPingTimes[lastPingTimes.length - 1];",
    "right" : "return lastPingTimes[lastPingTimes.length - 1];",
    "info" : "ReturnStatement[80585-80632]:ReturnStatement[80585-80632]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[80651-80702]:Block[80651-80702]"
  }, {
    "left" : "lastPingTimesLock.unlock();",
    "right" : "lastPingTimesLock.unlock();",
    "info" : "ExpressionStatement[80665-80692]:ExpressionStatement[80665-80692]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[80991-80997]:Modifier[80991-80997]"
  }, {
    "left" : "long",
    "right" : "long",
    "info" : "PrimitiveType[80998-81002]:PrimitiveType[80998-81002]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[81017-81361]:Block[81017-81361]"
  }, {
    "left" : "lastPingTimesLock.lock();",
    "right" : "lastPingTimesLock.lock();",
    "info" : "ExpressionStatement[81027-81052]:ExpressionStatement[81027-81052]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[81061-81355]:TryStatement[81061-81355]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[81065-81295]:Block[81065-81295]"
  }, {
    "left" : "if (lastPingTimes == null)",
    "right" : "if (lastPingTimes == null)",
    "info" : "IfStatement[81079-81144]:IfStatement[81079-81144]"
  }, {
    "left" : "return Long.MAX_VALUE;",
    "right" : "return Long.MAX_VALUE;",
    "info" : "ReturnStatement[81122-81144]:ReturnStatement[81122-81144]"
  }, {
    "left" : "long sum = 0;",
    "right" : "long sum = 0;",
    "info" : "VariableDeclarationStatement[81157-81170]:VariableDeclarationStatement[81157-81170]"
  }, {
    "left" : "for (long i : lastPingTimes) sum += i;",
    "right" : "for (long i : lastPingTimes) sum += i;",
    "info" : "EnhancedForStatement[81183-81221]:EnhancedForStatement[81183-81221]"
  }, {
    "left" : "sum += i;",
    "right" : "sum += i;",
    "info" : "ExpressionStatement[81212-81221]:ExpressionStatement[81212-81221]"
  }, {
    "left" : "return (long)((double) sum / lastPingTimes.length);",
    "right" : "return (long)((double) sum / lastPingTimes.length);",
    "info" : "ReturnStatement[81234-81285]:ReturnStatement[81234-81285]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[81304-81355]:Block[81304-81355]"
  }, {
    "left" : "lastPingTimesLock.unlock();",
    "right" : "lastPingTimesLock.unlock();",
    "info" : "ExpressionStatement[81318-81345]:ExpressionStatement[81318-81345]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[81367-81374]:Modifier[81367-81374]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[81375-81379]:PrimitiveType[81375-81379]"
  }, {
    "left" : "Pong m",
    "right" : "Pong m",
    "info" : "SingleVariableDeclaration[81392-81398]:SingleVariableDeclaration[81392-81398]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[81400-81783]:Block[81400-81783]"
  }, {
    "left" : "for (PendingPing ping : pendingPings)",
    "right" : "for (PendingPing ping : pendingPings)",
    "info" : "EnhancedForStatement[81488-81777]:EnhancedForStatement[81488-81777]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[81526-81777]:Block[81526-81777]"
  }, {
    "left" : "if (m.getNonce() == ping.nonce)",
    "right" : "if (m.getNonce() == ping.nonce)",
    "info" : "IfStatement[81540-81767]:IfStatement[81540-81767]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[81572-81767]:Block[81572-81767]"
  }, {
    "left" : "pendingPings.remove(ping);",
    "right" : "pendingPings.remove(ping);",
    "info" : "ExpressionStatement[81590-81616]:ExpressionStatement[81590-81616]"
  }, {
    "left" : "ping.complete();",
    "right" : "ping.complete();",
    "info" : "ExpressionStatement[81713-81729]:ExpressionStatement[81713-81729]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[81746-81753]:ReturnStatement[81746-81753]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[81983-81989]:Modifier[81983-81989]"
  }, {
    "left" : "int",
    "right" : "int",
    "info" : "PrimitiveType[81990-81993]:PrimitiveType[81990-81993]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[82025-82699]:Block[82025-82699]"
  }, {
    "left" : "checkNotNull(blockChain, \"No block chain configured\");",
    "right" : "checkNotNull(blockChain, \"No block chain configured\");",
    "info" : "ExpressionStatement[82035-82089]:ExpressionStatement[82035-82089]"
  }, {
    "left" : "int chainHeight = (int) getBestHeight();",
    "right" : "int chainHeight = (int) getBestHeight();",
    "info" : "VariableDeclarationStatement[82165-82205]:VariableDeclarationStatement[82165-82205]"
  }, {
    "left" : "checkState(params.allowEmptyPeerChain() || chainHeight > 0, \"Connected to peer with zero/negative chain height\", chainHeight);",
    "right" : "checkState(params.allowEmptyPeerChain() || chainHeight > 0, \"Connected to peer with zero/negative chain height\", chainHeight);",
    "info" : "ExpressionStatement[82505-82631]:ExpressionStatement[82505-82631]"
  }, {
    "left" : "return chainHeight - blockChain.getBestChainHeight();",
    "right" : "return chainHeight - blockChain.getBestChainHeight();",
    "info" : "ReturnStatement[82640-82693]:ReturnStatement[82640-82693]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[82705-82712]:Modifier[82705-82712]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[82713-82720]:PrimitiveType[82713-82720]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[82750-82847]:Block[82750-82847]"
  }, {
    "left" : "return vPeerVersionMessage.clientVersion >= NotFoundMessage.MIN_PROTOCOL_VERSION;",
    "right" : "return vPeerVersionMessage.clientVersion >= NotFoundMessage.MIN_PROTOCOL_VERSION;",
    "info" : "ReturnStatement[82760-82841]:ReturnStatement[82760-82841]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[83042-83048]:Modifier[83042-83048]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[83049-83056]:PrimitiveType[83049-83056]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[83075-83112]:Block[83075-83112]"
  }, {
    "left" : "return vDownloadData;",
    "right" : "return vDownloadData;",
    "info" : "ReturnStatement[83085-83106]:ReturnStatement[83085-83106]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[83462-83468]:Modifier[83462-83468]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[83469-83473]:PrimitiveType[83469-83473]"
  }, {
    "left" : "boolean downloadData",
    "right" : "boolean downloadData",
    "info" : "SingleVariableDeclaration[83490-83510]:SingleVariableDeclaration[83490-83510]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[83512-83562]:Block[83512-83562]"
  }, {
    "left" : "this.vDownloadData = downloadData;",
    "right" : "this.vDownloadData = downloadData;",
    "info" : "ExpressionStatement[83522-83556]:ExpressionStatement[83522-83556]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[83630-83636]:Modifier[83630-83636]"
  }, {
    "left" : "VersionMessage",
    "right" : "VersionMessage",
    "info" : "SimpleType[83637-83651]:SimpleType[83637-83651]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[83676-83719]:Block[83676-83719]"
  }, {
    "left" : "return vPeerVersionMessage;",
    "right" : "return vPeerVersionMessage;",
    "info" : "ReturnStatement[83686-83713]:ReturnStatement[83686-83713]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[83790-83796]:Modifier[83790-83796]"
  }, {
    "left" : "VersionMessage",
    "right" : "VersionMessage",
    "info" : "SimpleType[83797-83811]:SimpleType[83797-83811]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[83832-83870]:Block[83832-83870]"
  }, {
    "left" : "return versionMessage;",
    "right" : "return versionMessage;",
    "info" : "ReturnStatement[83842-83864]:ReturnStatement[83842-83864]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[84012-84018]:Modifier[84012-84018]"
  }, {
    "left" : "long",
    "right" : "long",
    "info" : "PrimitiveType[84019-84023]:PrimitiveType[84019-84023]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[84040-84118]:Block[84040-84118]"
  }, {
    "left" : "return vPeerVersionMessage.bestHeight + blocksAnnounced.get();",
    "right" : "return vPeerVersionMessage.bestHeight + blocksAnnounced.get();",
    "info" : "ReturnStatement[84050-84112]:ReturnStatement[84050-84112]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[84346-84352]:Modifier[84346-84352]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[84353-84360]:PrimitiveType[84353-84360]"
  }, {
    "left" : "int minProtocolVersion",
    "right" : "int minProtocolVersion",
    "info" : "SingleVariableDeclaration[84383-84405]:SingleVariableDeclaration[84383-84405]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[84407-84721]:Block[84407-84721]"
  }, {
    "left" : "this.vMinProtocolVersion = minProtocolVersion;",
    "right" : "this.vMinProtocolVersion = minProtocolVersion;",
    "info" : "ExpressionStatement[84417-84463]:ExpressionStatement[84417-84463]"
  }, {
    "left" : "if (getVersionMessage().clientVersion < minProtocolVersion)",
    "right" : "if (getVersionMessage().clientVersion < minProtocolVersion)",
    "info" : "IfStatement[84472-84693]:IfStatement[84472-84693]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[84532-84693]:Block[84532-84693]"
  }, {
    "left" : "log.warn(\"{}: Disconnecting due to new min protocol version {}\", this, minProtocolVersion);",
    "right" : "log.warn(\"{}: Disconnecting due to new min protocol version {}\", this, minProtocolVersion);",
    "info" : "ExpressionStatement[84546-84637]:ExpressionStatement[84546-84637]"
  }, {
    "left" : "close();",
    "right" : "close();",
    "info" : "ExpressionStatement[84650-84658]:ExpressionStatement[84650-84658]"
  }, {
    "left" : "return true;",
    "right" : "return true;",
    "info" : "ReturnStatement[84671-84683]:ReturnStatement[84671-84683]"
  }, {
    "left" : "return false;",
    "right" : "return false;",
    "info" : "ReturnStatement[84702-84715]:ReturnStatement[84702-84715]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[85736-85742]:Modifier[85736-85742]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[85743-85747]:PrimitiveType[85743-85747]"
  }, {
    "left" : "BloomFilter filter",
    "right" : "BloomFilter filter",
    "info" : "SingleVariableDeclaration[85763-85781]:SingleVariableDeclaration[85763-85781]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[85783-85828]:Block[85783-85828]"
  }, {
    "left" : "setBloomFilter(filter, true);",
    "right" : "setBloomFilter(filter, true);",
    "info" : "ExpressionStatement[85793-85822]:ExpressionStatement[85793-85822]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[86752-86758]:Modifier[86752-86758]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[86759-86763]:PrimitiveType[86759-86763]"
  }, {
    "left" : "BloomFilter filter",
    "right" : "BloomFilter filter",
    "info" : "SingleVariableDeclaration[86779-86797]:SingleVariableDeclaration[86779-86797]"
  }, {
    "left" : "boolean andQueryMemPool",
    "right" : "boolean andQueryMemPool",
    "info" : "SingleVariableDeclaration[86799-86822]:SingleVariableDeclaration[86799-86822]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[86824-87324]:Block[86824-87324]"
  }, {
    "left" : "checkNotNull(filter, \"Clearing filters is not currently supported\");",
    "right" : "checkNotNull(filter, \"Clearing filters is not currently supported\");",
    "info" : "ExpressionStatement[86834-86902]:ExpressionStatement[86834-86902]"
  }, {
    "left" : "final VersionMessage ver = vPeerVersionMessage;",
    "right" : "final VersionMessage ver = vPeerVersionMessage;",
    "info" : "VariableDeclarationStatement[86911-86958]:VariableDeclarationStatement[86911-86958]"
  }, {
    "left" : "if (ver == null || !ver.isBloomFilteringSupported())",
    "right" : "if (ver == null || !ver.isBloomFilteringSupported())",
    "info" : "IfStatement[86967-87039]:IfStatement[86967-87039]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[87032-87039]:ReturnStatement[87032-87039]"
  }, {
    "left" : "vBloomFilter = filter;",
    "right" : "vBloomFilter = filter;",
    "info" : "ExpressionStatement[87048-87070]:ExpressionStatement[87048-87070]"
  }, {
    "left" : "log.debug(\"{}: Sending Bloom filter{}\", this, andQueryMemPool ? \" and querying mempool\" : \"\");",
    "right" : "log.debug(\"{}: Sending Bloom filter{}\", this, andQueryMemPool ? \" and querying mempool\" : \"\");",
    "info" : "ExpressionStatement[87079-87173]:ExpressionStatement[87079-87173]"
  }, {
    "left" : "sendMessage(filter);",
    "right" : "sendMessage(filter);",
    "info" : "ExpressionStatement[87182-87202]:ExpressionStatement[87182-87202]"
  }, {
    "left" : "if (andQueryMemPool)",
    "right" : "if (andQueryMemPool)",
    "info" : "IfStatement[87211-87281]:IfStatement[87211-87281]"
  }, {
    "left" : "sendMessage(new MemoryPoolMessage());",
    "right" : "sendMessage(new MemoryPoolMessage());",
    "info" : "ExpressionStatement[87244-87281]:ExpressionStatement[87244-87281]"
  }, {
    "left" : "maybeRestartChainDownload();",
    "right" : "maybeRestartChainDownload();",
    "info" : "ExpressionStatement[87290-87318]:ExpressionStatement[87290-87318]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[87330-87337]:Modifier[87330-87337]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[87338-87342]:PrimitiveType[87338-87342]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[87371-88964]:Block[87371-88964]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[87381-87393]:ExpressionStatement[87381-87393]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[87402-88958]:TryStatement[87402-88958]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[87406-88911]:Block[87406-88911]"
  }, {
    "left" : "if (awaitingFreshFilter == null)",
    "right" : "if (awaitingFreshFilter == null)",
    "info" : "IfStatement[87420-87476]:IfStatement[87420-87476]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[87469-87476]:ReturnStatement[87469-87476]"
  }, {
    "left" : "if (!vDownloadData)",
    "right" : "if (!vDownloadData)",
    "info" : "IfStatement[87489-87735]:IfStatement[87489-87735]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[87509-87735]:Block[87509-87735]"
  }, {
    "left" : "log.warn(\"Lost download peer status whilst awaiting fresh filter.\");",
    "right" : "log.warn(\"Lost download peer status whilst awaiting fresh filter.\");",
    "info" : "ExpressionStatement[87629-87697]:ExpressionStatement[87629-87697]"
  }, {
    "left" : "return;",
    "right" : "return;",
    "info" : "ReturnStatement[87714-87721]:ReturnStatement[87714-87721]"
  }, {
    "left" : "ping().addListener(new Runnable() {\n                @Override\n                public void run() {\n                    lock.lock();\n                    checkNotNull(awaitingFreshFilter);\n                    GetDataMessage getdata = new GetDataMessage(params);\n                    for (Sha256Hash hash : awaitingFreshFilter)\n                        getdata.addFilteredBlock(hash);\n                    awaitingFreshFilter = null;\n                    lock.unlock();\n\n                    log.info(\"Restarting chain download\");\n                    sendMessage(getdata);\n                    // TODO: This bizarre ping-after-getdata hack probably isn't necessary.\n                    // It's to ensure we know when the end of a filtered block stream of txns is, but we should just be\n                    // able to match txns with the merkleblock. Ask Matt why it's written this way.\n                    sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));\n                }\n            }, Threading.SAME_THREAD);",
    "right" : "ping().addListener(new Runnable() {\n                @Override\n                public void run() {\n                    lock.lock();\n                    checkNotNull(awaitingFreshFilter);\n                    GetDataMessage getdata = new GetDataMessage(params);\n                    for (Sha256Hash hash : awaitingFreshFilter)\n                        getdata.addFilteredBlock(hash);\n                    awaitingFreshFilter = null;\n                    lock.unlock();\n\n                    log.info(\"Restarting chain download\");\n                    sendMessage(getdata);\n                    // TODO: This bizarre ping-after-getdata hack probably isn't necessary.\n                    // It's to ensure we know when the end of a filtered block stream of txns is, but we should just be\n                    // able to match txns with the merkleblock. Ask Matt why it's written this way.\n                    sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));\n                }\n            }, Threading.SAME_THREAD);",
    "info" : "ExpressionStatement[87885-88901]:ExpressionStatement[87885-88901]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[87937-87946]:MarkerAnnotation[87937-87946]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[87963-87969]:Modifier[87963-87969]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[87970-87974]:PrimitiveType[87970-87974]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[87981-88862]:Block[87981-88862]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[88003-88015]:ExpressionStatement[88003-88015]"
  }, {
    "left" : "checkNotNull(awaitingFreshFilter);",
    "right" : "checkNotNull(awaitingFreshFilter);",
    "info" : "ExpressionStatement[88036-88070]:ExpressionStatement[88036-88070]"
  }, {
    "left" : "GetDataMessage getdata = new GetDataMessage(params);",
    "right" : "GetDataMessage getdata = new GetDataMessage(params);",
    "info" : "VariableDeclarationStatement[88091-88143]:VariableDeclarationStatement[88091-88143]"
  }, {
    "left" : "for (Sha256Hash hash : awaitingFreshFilter)\n                        getdata.addFilteredBlock(hash);",
    "right" : "for (Sha256Hash hash : awaitingFreshFilter)\n                        getdata.addFilteredBlock(hash);",
    "info" : "EnhancedForStatement[88164-88263]:EnhancedForStatement[88164-88263]"
  }, {
    "left" : "getdata.addFilteredBlock(hash);",
    "right" : "getdata.addFilteredBlock(hash);",
    "info" : "ExpressionStatement[88232-88263]:ExpressionStatement[88232-88263]"
  }, {
    "left" : "awaitingFreshFilter = null;",
    "right" : "awaitingFreshFilter = null;",
    "info" : "ExpressionStatement[88284-88311]:ExpressionStatement[88284-88311]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[88332-88346]:ExpressionStatement[88332-88346]"
  }, {
    "left" : "log.info(\"Restarting chain download\");",
    "right" : "log.info(\"Restarting chain download\");",
    "info" : "ExpressionStatement[88368-88406]:ExpressionStatement[88368-88406]"
  }, {
    "left" : "sendMessage(getdata);",
    "right" : "sendMessage(getdata);",
    "info" : "ExpressionStatement[88427-88448]:ExpressionStatement[88427-88448]"
  }, {
    "left" : "sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));",
    "right" : "sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));",
    "info" : "ExpressionStatement[88781-88844]:ExpressionStatement[88781-88844]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[88920-88958]:Block[88920-88958]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[88934-88948]:ExpressionStatement[88934-88948]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[89172-89178]:Modifier[89172-89178]"
  }, {
    "left" : "BloomFilter",
    "right" : "BloomFilter",
    "info" : "SimpleType[89179-89190]:SimpleType[89179-89190]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89208-89244]:Block[89208-89244]"
  }, {
    "left" : "return vBloomFilter;",
    "right" : "return vBloomFilter;",
    "info" : "ReturnStatement[89218-89238]:ReturnStatement[89218-89238]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[89851-89857]:Modifier[89851-89857]"
  }, {
    "left" : "ListenableFuture<UTXOsMessage>",
    "right" : "ListenableFuture<UTXOsMessage>",
    "info" : "ParameterizedType[89858-89888]:ParameterizedType[89858-89888]"
  }, {
    "left" : "List<TransactionOutPoint>",
    "right" : "List<TransactionOutPoint>",
    "info" : "ParameterizedType[89898-89923]:ParameterizedType[89898-89923]"
  }, {
    "left" : "List<TransactionOutPoint> outPoints",
    "right" : "boolean includeMempool",
    "info" : "SingleVariableDeclaration[89898-89933]:SingleVariableDeclaration[90762-90784]"
  }, {
    "left" : "outPoints",
    "right" : "outPoints",
    "info" : "SimpleName[89924-89933]:SimpleName[89924-89933]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89935-90900]:Block[90786-91760]"
  }, {
    "left" : "lock.lock();",
    "right" : "lock.lock();",
    "info" : "ExpressionStatement[89945-89957]:ExpressionStatement[90796-90808]"
  }, {
    "left" : "try{...}",
    "right" : "try{...}",
    "info" : "TryStatement[89966-90893]:TryStatement[90817-91754]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89970-90846]:Block[90821-91707]"
  }, {
    "left" : "VersionMessage peerVer = getPeerVersionMessage();",
    "right" : "VersionMessage peerVer = getPeerVersionMessage();",
    "info" : "VariableDeclarationStatement[89984-90033]:VariableDeclarationStatement[90835-90884]"
  }, {
    "left" : "if (peerVer.clientVersion < GetUTXOsMessage.MIN_PROTOCOL_VERSION)",
    "right" : "if (peerVer.clientVersion < GetUTXOsMessage.MIN_PROTOCOL_VERSION)",
    "info" : "IfStatement[90046-90207]:IfStatement[90897-91058]"
  }, {
    "left" : "throw new ProtocolException(\"Peer does not support getutxos protocol version\");",
    "right" : "throw new ProtocolException(\"Peer does not support getutxos protocol version\");",
    "info" : "ThrowStatement[90128-90207]:ThrowStatement[90979-91058]"
  }, {
    "left" : "if ((peerVer.localServices & GetUTXOsMessage.SERVICE_FLAGS_REQUIRED) != GetUTXOsMessage.SERVICE_FLAGS_REQUIRED)",
    "right" : "if ((peerVer.localServices & GetUTXOsMessage.SERVICE_FLAGS_REQUIRED) != GetUTXOsMessage.SERVICE_FLAGS_REQUIRED)",
    "info" : "IfStatement[90220-90448]:IfStatement[91071-91299]"
  }, {
    "left" : "throw new ProtocolException(\"Peer does not support getutxos protocol flag: find Bitcoin XT nodes.\");",
    "right" : "throw new ProtocolException(\"Peer does not support getutxos protocol flag: find Bitcoin XT nodes.\");",
    "info" : "ThrowStatement[90348-90448]:ThrowStatement[91199-91299]"
  }, {
    "left" : "SettableFuture<UTXOsMessage> future = SettableFuture.create();",
    "right" : "SettableFuture<UTXOsMessage> future = SettableFuture.create();",
    "info" : "VariableDeclarationStatement[90461-90523]:VariableDeclarationStatement[91312-91374]"
  }, {
    "left" : "if (getutxoFutures == null)",
    "right" : "if (getutxoFutures == null)",
    "info" : "IfStatement[90590-90698]:IfStatement[91441-91549]"
  }, {
    "left" : "getutxoFutures = new LinkedList<SettableFuture<UTXOsMessage>>();",
    "right" : "getutxoFutures = new LinkedList<SettableFuture<UTXOsMessage>>();",
    "info" : "ExpressionStatement[90634-90698]:ExpressionStatement[91485-91549]"
  }, {
    "left" : "getutxoFutures.add(future);",
    "right" : "getutxoFutures.add(future);",
    "info" : "ExpressionStatement[90711-90738]:ExpressionStatement[91562-91589]"
  }, {
    "left" : "sendMessage(new GetUTXOsMessage(params, outPoints, true));",
    "right" : "sendMessage(new GetUTXOsMessage(params, outPoints, includeMempool));",
    "info" : "ExpressionStatement[90751-90809]:ExpressionStatement[91602-91670]"
  }, {
    "left" : "true",
    "right" : "true",
    "info" : "BooleanLiteral[90802-90806]:BooleanLiteral[89972-89976]"
  }, {
    "left" : "return future;",
    "right" : "return future;",
    "info" : "ReturnStatement[90822-90836]:ReturnStatement[91683-91697]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[90855-90893]:Block[91716-91754]"
  }, {
    "left" : "lock.unlock();",
    "right" : "lock.unlock();",
    "info" : "ExpressionStatement[90869-90883]:ExpressionStatement[91730-91744]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[91241-91247]:Modifier[92101-92107]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[91248-91255]:PrimitiveType[92108-92115]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91284-91331]:Block[92144-92191]"
  }, {
    "left" : "return vDownloadTxDependencies;",
    "right" : "return vDownloadTxDependencies;",
    "info" : "ReturnStatement[91294-91325]:ReturnStatement[92154-92185]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[91664-91670]:Modifier[92524-92530]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[91671-91675]:PrimitiveType[92531-92535]"
  }, {
    "left" : "boolean value",
    "right" : "boolean value",
    "info" : "SingleVariableDeclaration[91702-91715]:SingleVariableDeclaration[92562-92575]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91717-91765]:Block[92577-92625]"
  }, {
    "left" : "vDownloadTxDependencies = value;",
    "right" : "vDownloadTxDependencies = value;",
    "info" : "ExpressionStatement[91727-91759]:ExpressionStatement[92587-92619]"
  } ]
}