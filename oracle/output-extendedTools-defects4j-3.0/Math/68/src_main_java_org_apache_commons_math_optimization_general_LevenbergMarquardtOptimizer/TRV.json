{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "private int solvedCols;",
      "right" : "private int solvedCols;",
      "info" : "FieldDeclaration[5236-5294]:FieldDeclaration[5236-5294]"
    }, {
      "left" : "private double[] diagR;",
      "right" : "private double[] diagR;",
      "info" : "FieldDeclaration[5300-5395]:FieldDeclaration[5300-5395]"
    }, {
      "left" : "private double[] jacNorm;",
      "right" : "private double[] jacNorm;",
      "info" : "FieldDeclaration[5401-5482]:FieldDeclaration[5401-5482]"
    }, {
      "left" : "private double[] beta;",
      "right" : "private double[] beta;",
      "info" : "FieldDeclaration[5488-5573]:FieldDeclaration[5488-5573]"
    }, {
      "left" : "private int[] permutation;",
      "right" : "private int[] permutation;",
      "info" : "FieldDeclaration[5579-5643]:FieldDeclaration[5579-5643]"
    }, {
      "left" : "private int rank;",
      "right" : "private int rank;",
      "info" : "FieldDeclaration[5649-5706]:FieldDeclaration[5649-5706]"
    }, {
      "left" : "private double lmPar;",
      "right" : "private double lmPar;",
      "info" : "FieldDeclaration[5712-5775]:FieldDeclaration[5712-5775]"
    }, {
      "left" : "private double[] lmDir;",
      "right" : "private double[] lmDir;",
      "info" : "FieldDeclaration[5781-5869]:FieldDeclaration[5781-5869]"
    }, {
      "left" : "private double initialStepBoundFactor;",
      "right" : "private double initialStepBoundFactor;",
      "info" : "FieldDeclaration[5875-5992]:FieldDeclaration[5875-5992]"
    }, {
      "left" : "private double costRelativeTolerance;",
      "right" : "private double costRelativeTolerance;",
      "info" : "FieldDeclaration[5998-6092]:FieldDeclaration[5998-6092]"
    }, {
      "left" : "private double parRelativeTolerance;",
      "right" : "private double parRelativeTolerance;",
      "info" : "FieldDeclaration[6098-6209]:FieldDeclaration[6098-6209]"
    }, {
      "left" : "private double orthoTolerance;",
      "right" : "private double orthoTolerance;",
      "info" : "FieldDeclaration[6215-6364]:FieldDeclaration[6215-6364]"
    }, {
      "left" : "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
      "right" : "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
      "info" : "MethodDeclaration[7771-8354]:MethodDeclaration[7808-8391]"
    }, {
      "left" : "public void setCostRelativeTolerance(double costRelativeTolerance)",
      "right" : "public void setCostRelativeTolerance(double costRelativeTolerance)",
      "info" : "MethodDeclaration[8360-8783]:MethodDeclaration[8397-8820]"
    }, {
      "left" : "public void setParRelativeTolerance(double parRelativeTolerance)",
      "right" : "public void setParRelativeTolerance(double parRelativeTolerance)",
      "info" : "MethodDeclaration[8789-9248]:MethodDeclaration[8826-9285]"
    }, {
      "left" : "public void setOrthoTolerance(double orthoTolerance)",
      "right" : "public void setOrthoTolerance(double orthoTolerance)",
      "info" : "MethodDeclaration[9254-9721]:MethodDeclaration[9291-9758]"
    }, {
      "left" : "private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3)",
      "right" : "private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3)",
      "info" : "MethodDeclaration[18794-24927]:MethodDeclaration[19222-25355]"
    }, {
      "left" : "private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work)",
      "right" : "private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work)",
      "info" : "MethodDeclaration[24933-29705]:MethodDeclaration[25361-30133]"
    }, {
      "left" : "private void qrDecomposition() throws OptimizationException",
      "right" : "private void qrDecomposition() throws OptimizationException",
      "info" : "MethodDeclaration[29711-33451]:MethodDeclaration[30139-33879]"
    }, {
      "left" : "private void qTy(double[] y)",
      "right" : "private void qTy(double[] y)",
      "info" : "MethodDeclaration[33457-34015]:MethodDeclaration[33885-34443]"
    } ],
    "mappings" : [
 {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[8216-8222]:Modifier[8253-8259]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[8223-8227]:PrimitiveType[8260-8264]"
    }, {
      "left" : "setInitialStepBoundFactor",
      "right" : "setInitialStepBoundFactor",
      "info" : "SimpleName[8228-8253]:SimpleName[8265-8290]"
    }, {
      "left" : "double initialStepBoundFactor",
      "right" : "double initialStepBoundFactor",
      "info" : "SingleVariableDeclaration[8254-8283]:SingleVariableDeclaration[8291-8320]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8285-8354]:Block[8322-8391]"
    }, {
      "left" : "this.initialStepBoundFactor = initialStepBoundFactor;",
      "right" : "this.initialStepBoundFactor = initialStepBoundFactor;",
      "info" : "ExpressionStatement[8295-8348]:ExpressionStatement[8332-8385]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[8649-8655]:Modifier[8686-8692]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[8656-8660]:PrimitiveType[8693-8697]"
    }, {
      "left" : "setCostRelativeTolerance",
      "right" : "setCostRelativeTolerance",
      "info" : "SimpleName[8661-8685]:SimpleName[8698-8722]"
    }, {
      "left" : "double costRelativeTolerance",
      "right" : "double costRelativeTolerance",
      "info" : "SingleVariableDeclaration[8686-8714]:SingleVariableDeclaration[8723-8751]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8716-8783]:Block[8753-8820]"
    }, {
      "left" : "this.costRelativeTolerance = costRelativeTolerance;",
      "right" : "this.costRelativeTolerance = costRelativeTolerance;",
      "info" : "ExpressionStatement[8726-8777]:ExpressionStatement[8763-8814]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[9118-9124]:Modifier[9155-9161]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[9125-9129]:PrimitiveType[9162-9166]"
    }, {
      "left" : "setParRelativeTolerance",
      "right" : "setParRelativeTolerance",
      "info" : "SimpleName[9130-9153]:SimpleName[9167-9190]"
    }, {
      "left" : "double parRelativeTolerance",
      "right" : "double parRelativeTolerance",
      "info" : "SingleVariableDeclaration[9154-9181]:SingleVariableDeclaration[9191-9218]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9183-9248]:Block[9220-9285]"
    }, {
      "left" : "this.parRelativeTolerance = parRelativeTolerance;",
      "right" : "this.parRelativeTolerance = parRelativeTolerance;",
      "info" : "ExpressionStatement[9193-9242]:ExpressionStatement[9230-9279]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[9615-9621]:Modifier[9652-9658]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[9622-9626]:PrimitiveType[9659-9663]"
    }, {
      "left" : "setOrthoTolerance",
      "right" : "setOrthoTolerance",
      "info" : "SimpleName[9627-9644]:SimpleName[9664-9681]"
    }, {
      "left" : "double orthoTolerance",
      "right" : "double orthoTolerance",
      "info" : "SingleVariableDeclaration[9645-9666]:SingleVariableDeclaration[9682-9703]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9668-9721]:Block[9705-9758]"
    }, {
      "left" : "this.orthoTolerance = orthoTolerance;",
      "right" : "this.orthoTolerance = orthoTolerance;",
      "info" : "ExpressionStatement[9678-9715]:ExpressionStatement[9715-9752]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[19651-19658]:Modifier[20079-20086]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[19659-19663]:PrimitiveType[20087-20091]"
    }, {
      "left" : "determineLMParameter",
      "right" : "determineLMParameter",
      "info" : "SimpleName[19664-19684]:SimpleName[20092-20112]"
    }, {
      "left" : "double[] qy",
      "right" : "double[] qy",
      "info" : "SingleVariableDeclaration[19685-19696]:SingleVariableDeclaration[20113-20124]"
    }, {
      "left" : "double delta",
      "right" : "double delta",
      "info" : "SingleVariableDeclaration[19698-19710]:SingleVariableDeclaration[20126-20138]"
    }, {
      "left" : "double[] diag",
      "right" : "double[] diag",
      "info" : "SingleVariableDeclaration[19712-19725]:SingleVariableDeclaration[20140-20153]"
    }, {
      "left" : "double[] work1",
      "right" : "double[] work1",
      "info" : "SingleVariableDeclaration[19739-19753]:SingleVariableDeclaration[20167-20181]"
    }, {
      "left" : "double[] work2",
      "right" : "double[] work2",
      "info" : "SingleVariableDeclaration[19755-19769]:SingleVariableDeclaration[20183-20197]"
    }, {
      "left" : "double[] work3",
      "right" : "double[] work3",
      "info" : "SingleVariableDeclaration[19771-19785]:SingleVariableDeclaration[20199-20213]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19787-24927]:Block[20215-25355]"
    }, {
      "left" : "for (int j = 0; j < rank; ++j)",
      "right" : "for (int j = 0; j < rank; ++j)",
      "info" : "ForStatement[19938-20023]:ForStatement[20366-20451]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19969-20023]:Block[20397-20451]"
    }, {
      "left" : "lmDir[permutation[j]] = qy[j];",
      "right" : "lmDir[permutation[j]] = qy[j];",
      "info" : "ExpressionStatement[19983-20013]:ExpressionStatement[20411-20441]"
    }, {
      "left" : "for (int j = rank; j < cols; ++j)",
      "right" : "for (int j = rank; j < cols; ++j)",
      "info" : "ForStatement[20032-20116]:ForStatement[20460-20544]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20066-20116]:Block[20494-20544]"
    }, {
      "left" : "lmDir[permutation[j]] = 0;",
      "right" : "lmDir[permutation[j]] = 0;",
      "info" : "ExpressionStatement[20080-20106]:ExpressionStatement[20508-20534]"
    }, {
      "left" : "for (int k = rank - 1; k >= 0; --k)",
      "right" : "for (int k = rank - 1; k >= 0; --k)",
      "info" : "ForStatement[20125-20406]:ForStatement[20553-20834]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20161-20406]:Block[20589-20834]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[20175-20199]:VariableDeclarationStatement[20603-20627]"
    }, {
      "left" : "double ypk = lmDir[pk] / diagR[pk];",
      "right" : "double ypk = lmDir[pk] / diagR[pk];",
      "info" : "VariableDeclarationStatement[20212-20247]:VariableDeclarationStatement[20640-20675]"
    }, {
      "left" : "for (int i = 0; i < k; ++i)",
      "right" : "for (int i = 0; i < k; ++i)",
      "info" : "ForStatement[20260-20367]:ForStatement[20688-20795]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20288-20367]:Block[20716-20795]"
    }, {
      "left" : "lmDir[permutation[i]] -= ypk * jacobian[i][pk];",
      "right" : "lmDir[permutation[i]] -= ypk * jacobian[i][pk];",
      "info" : "ExpressionStatement[20306-20353]:ExpressionStatement[20734-20781]"
    }, {
      "left" : "lmDir[pk] = ypk;",
      "right" : "lmDir[pk] = ypk;",
      "info" : "ExpressionStatement[20380-20396]:ExpressionStatement[20808-20824]"
    }, {
      "left" : "double dxNorm = 0;",
      "right" : "double dxNorm = 0;",
      "info" : "VariableDeclarationStatement[20529-20547]:VariableDeclarationStatement[20957-20975]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[20556-20742]:ForStatement[20984-21170]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20593-20742]:Block[21021-21170]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[20607-20631]:VariableDeclarationStatement[21035-21059]"
    }, {
      "left" : "double s = diag[pj] * lmDir[pj];",
      "right" : "double s = diag[pj] * lmDir[pj];",
      "info" : "VariableDeclarationStatement[20644-20676]:VariableDeclarationStatement[21072-21104]"
    }, {
      "left" : "work1[pj] = s;",
      "right" : "work1[pj] = s;",
      "info" : "ExpressionStatement[20689-20703]:ExpressionStatement[21117-21131]"
    }, {
      "left" : "dxNorm += s * s;",
      "right" : "dxNorm += s * s;",
      "info" : "ExpressionStatement[20716-20732]:ExpressionStatement[21144-21160]"
    }, {
      "left" : "dxNorm = Math.sqrt(dxNorm);",
      "right" : "dxNorm = Math.sqrt(dxNorm);",
      "info" : "ExpressionStatement[20751-20778]:ExpressionStatement[21179-21206]"
    }, {
      "left" : "double fp = dxNorm - delta;",
      "right" : "double fp = dxNorm - delta;",
      "info" : "VariableDeclarationStatement[20787-20814]:VariableDeclarationStatement[21215-21242]"
    }, {
      "left" : "if (fp <= 0.1 * delta)",
      "right" : "if (fp <= 0.1 * delta)",
      "info" : "IfStatement[20823-20900]:IfStatement[21251-21328]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20846-20900]:Block[21274-21328]"
    }, {
      "left" : "lmPar = 0;",
      "right" : "lmPar = 0;",
      "info" : "ExpressionStatement[20860-20870]:ExpressionStatement[21288-21298]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[20883-20890]:ReturnStatement[21311-21318]"
    }, {
      "left" : "double sum2;",
      "right" : "double sum2;",
      "info" : "VariableDeclarationStatement[21091-21103]:VariableDeclarationStatement[21519-21531]"
    }, {
      "left" : "double parl = 0;",
      "right" : "double parl = 0;",
      "info" : "VariableDeclarationStatement[21112-21128]:VariableDeclarationStatement[21540-21556]"
    }, {
      "left" : "if (rank == solvedCols)",
      "right" : "if (rank == solvedCols)",
      "info" : "IfStatement[21137-21778]:IfStatement[21565-22206]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21161-21778]:Block[21589-22206]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[21175-21316]:ForStatement[21603-21744]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21212-21316]:Block[21640-21744]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[21230-21254]:VariableDeclarationStatement[21658-21682]"
    }, {
      "left" : "work1[pj] *= diag[pj] / dxNorm;",
      "right" : "work1[pj] *= diag[pj] / dxNorm;",
      "info" : "ExpressionStatement[21271-21302]:ExpressionStatement[21699-21730]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[21329-21338]:ExpressionStatement[21757-21766]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[21351-21728]:ForStatement[21779-22156]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21388-21728]:Block[21816-22156]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[21406-21430]:VariableDeclarationStatement[21834-21858]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[21447-21462]:VariableDeclarationStatement[21875-21890]"
    }, {
      "left" : "for (int i = 0; i < j; ++i)",
      "right" : "for (int i = 0; i < j; ++i)",
      "info" : "ForStatement[21479-21594]:ForStatement[21907-22022]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21507-21594]:Block[21935-22022]"
    }, {
      "left" : "sum += jacobian[i][pj] * work1[permutation[i]];",
      "right" : "sum += jacobian[i][pj] * work1[permutation[i]];",
      "info" : "ExpressionStatement[21529-21576]:ExpressionStatement[21957-22004]"
    }, {
      "left" : "double s = (work1[pj] - sum) / diagR[pj];",
      "right" : "double s = (work1[pj] - sum) / diagR[pj];",
      "info" : "VariableDeclarationStatement[21611-21652]:VariableDeclarationStatement[22039-22080]"
    }, {
      "left" : "work1[pj] = s;",
      "right" : "work1[pj] = s;",
      "info" : "ExpressionStatement[21669-21683]:ExpressionStatement[22097-22111]"
    }, {
      "left" : "sum2 += s * s;",
      "right" : "sum2 += s * s;",
      "info" : "ExpressionStatement[21700-21714]:ExpressionStatement[22128-22142]"
    }, {
      "left" : "parl = fp / (delta * sum2);",
      "right" : "parl = fp / (delta * sum2);",
      "info" : "ExpressionStatement[21741-21768]:ExpressionStatement[22169-22196]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[21860-21869]:ExpressionStatement[22288-22297]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[21878-22156]:ForStatement[22306-22584]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21915-22156]:Block[22343-22584]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[21929-21953]:VariableDeclarationStatement[22357-22381]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[21966-21981]:VariableDeclarationStatement[22394-22409]"
    }, {
      "left" : "for (int i = 0; i <= j; ++i)",
      "right" : "for (int i = 0; i <= j; ++i)",
      "info" : "ForStatement[21994-22086]:ForStatement[22422-22514]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22023-22086]:Block[22451-22514]"
    }, {
      "left" : "sum += jacobian[i][pj] * qy[i];",
      "right" : "sum += jacobian[i][pj] * qy[i];",
      "info" : "ExpressionStatement[22041-22072]:ExpressionStatement[22469-22500]"
    }, {
      "left" : "sum /= diag[pj];",
      "right" : "sum /= diag[pj];",
      "info" : "ExpressionStatement[22099-22115]:ExpressionStatement[22527-22543]"
    }, {
      "left" : "sum2 += sum * sum;",
      "right" : "sum2 += sum * sum;",
      "info" : "ExpressionStatement[22128-22146]:ExpressionStatement[22556-22574]"
    }, {
      "left" : "double gNorm = Math.sqrt(sum2);",
      "right" : "double gNorm = Math.sqrt(sum2);",
      "info" : "VariableDeclarationStatement[22165-22196]:VariableDeclarationStatement[22593-22624]"
    }, {
      "left" : "double paru = gNorm / delta;",
      "right" : "double paru = gNorm / delta;",
      "info" : "VariableDeclarationStatement[22205-22233]:VariableDeclarationStatement[22633-22661]"
    }, {
      "left" : "if (paru == 0)",
      "right" : "if (paru == 0)",
      "info" : "IfStatement[22242-22391]:IfStatement[22670-22819]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22257-22391]:Block[22685-22819]"
    }, {
      "left" : "paru = 2.2251e-308 / Math.min(delta, 0.1);",
      "right" : "paru = 2.2251e-308 / Math.min(delta, 0.1);",
      "info" : "ExpressionStatement[22339-22381]:ExpressionStatement[22767-22809]"
    }, {
      "left" : "lmPar = Math.min(paru, Math.max(lmPar, parl));",
      "right" : "lmPar = Math.min(paru, Math.max(lmPar, parl));",
      "info" : "ExpressionStatement[22513-22559]:ExpressionStatement[22941-22987]"
    }, {
      "left" : "if (lmPar == 0)",
      "right" : "if (lmPar == 0)",
      "info" : "IfStatement[22568-22631]:IfStatement[22996-23059]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22584-22631]:Block[23012-23059]"
    }, {
      "left" : "lmPar = gNorm / dxNorm;",
      "right" : "lmPar = gNorm / dxNorm;",
      "info" : "ExpressionStatement[22598-22621]:ExpressionStatement[23026-23049]"
    }, {
      "left" : "for (int countdown = 10; countdown >= 0; --countdown)",
      "right" : "for (int countdown = 10; countdown >= 0; --countdown)",
      "info" : "ForStatement[22641-24921]:ForStatement[23069-25349]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22695-24921]:Block[23123-25349]"
    }, {
      "left" : "if (lmPar == 0)",
      "right" : "if (lmPar == 0)",
      "info" : "IfStatement[22777-22869]:IfStatement[23205-23297]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22793-22869]:Block[23221-23297]"
    }, {
      "left" : "lmPar = Math.max(2.2251e-308, 0.001 * paru);",
      "right" : "lmPar = Math.max(2.2251e-308, 0.001 * paru);",
      "info" : "ExpressionStatement[22811-22855]:ExpressionStatement[23239-23283]"
    }, {
      "left" : "double sPar = Math.sqrt(lmPar);",
      "right" : "double sPar = Math.sqrt(lmPar);",
      "info" : "VariableDeclarationStatement[22882-22913]:VariableDeclarationStatement[23310-23341]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[22926-23064]:ForStatement[23354-23492]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22963-23064]:Block[23391-23492]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[22981-23005]:VariableDeclarationStatement[23409-23433]"
    }, {
      "left" : "work1[pj] = sPar * diag[pj];",
      "right" : "work1[pj] = sPar * diag[pj];",
      "info" : "ExpressionStatement[23022-23050]:ExpressionStatement[23450-23478]"
    }, {
      "left" : "determineLMDirection(qy, work1, work2, work3);",
      "right" : "determineLMDirection(qy, work1, work2, work3);",
      "info" : "ExpressionStatement[23077-23123]:ExpressionStatement[23505-23551]"
    }, {
      "left" : "dxNorm = 0;",
      "right" : "dxNorm = 0;",
      "info" : "ExpressionStatement[23137-23148]:ExpressionStatement[23565-23576]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[23161-23367]:ForStatement[23589-23795]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23198-23367]:Block[23626-23795]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[23216-23240]:VariableDeclarationStatement[23644-23668]"
    }, {
      "left" : "double s = diag[pj] * lmDir[pj];",
      "right" : "double s = diag[pj] * lmDir[pj];",
      "info" : "VariableDeclarationStatement[23257-23289]:VariableDeclarationStatement[23685-23717]"
    }, {
      "left" : "work3[pj] = s;",
      "right" : "work3[pj] = s;",
      "info" : "ExpressionStatement[23306-23320]:ExpressionStatement[23734-23748]"
    }, {
      "left" : "dxNorm += s * s;",
      "right" : "dxNorm += s * s;",
      "info" : "ExpressionStatement[23337-23353]:ExpressionStatement[23765-23781]"
    }, {
      "left" : "dxNorm = Math.sqrt(dxNorm);",
      "right" : "dxNorm = Math.sqrt(dxNorm);",
      "info" : "ExpressionStatement[23380-23407]:ExpressionStatement[23808-23835]"
    }, {
      "left" : "double previousFP = fp;",
      "right" : "double previousFP = fp;",
      "info" : "VariableDeclarationStatement[23420-23443]:VariableDeclarationStatement[23848-23871]"
    }, {
      "left" : "fp = dxNorm - delta;",
      "right" : "fp = dxNorm - delta;",
      "info" : "ExpressionStatement[23456-23476]:ExpressionStatement[23884-23904]"
    }, {
      "left" : "if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0)))",
      "right" : "if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0)))",
      "info" : "IfStatement[23643-23796]:IfStatement[24071-24224]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23757-23796]:Block[24185-24224]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[23775-23782]:ReturnStatement[24203-24210]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[23855-24007]:ForStatement[24283-24435]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23892-24007]:Block[24320-24435]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[23910-23934]:VariableDeclarationStatement[24338-24362]"
    }, {
      "left" : "work1[pj] = work3[pj] * diag[pj] / dxNorm;",
      "right" : "work1[pj] = work3[pj] * diag[pj] / dxNorm;",
      "info" : "ExpressionStatement[23951-23993]:ExpressionStatement[24379-24421]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[24020-24337]:ForStatement[24448-24765]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24057-24337]:Block[24485-24765]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[24075-24099]:VariableDeclarationStatement[24503-24527]"
    }, {
      "left" : "work1[pj] /= work2[j];",
      "right" : "work1[pj] /= work2[j];",
      "info" : "ExpressionStatement[24116-24138]:ExpressionStatement[24544-24566]"
    }, {
      "left" : "double tmp = work1[pj];",
      "right" : "double tmp = work1[pj];",
      "info" : "VariableDeclarationStatement[24155-24178]:VariableDeclarationStatement[24583-24606]"
    }, {
      "left" : "for (int i = j + 1; i < solvedCols; ++i)",
      "right" : "for (int i = j + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[24195-24323]:ForStatement[24623-24751]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24236-24323]:Block[24664-24751]"
    }, {
      "left" : "work1[permutation[i]] -= jacobian[i][pj] * tmp;",
      "right" : "work1[permutation[i]] -= jacobian[i][pj] * tmp;",
      "info" : "ExpressionStatement[24258-24305]:ExpressionStatement[24686-24733]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[24350-24359]:ExpressionStatement[24778-24787]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[24372-24505]:ForStatement[24800-24933]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24409-24505]:Block[24837-24933]"
    }, {
      "left" : "double s = work1[permutation[j]];",
      "right" : "double s = work1[permutation[j]];",
      "info" : "VariableDeclarationStatement[24427-24460]:VariableDeclarationStatement[24855-24888]"
    }, {
      "left" : "sum2 += s * s;",
      "right" : "sum2 += s * s;",
      "info" : "ExpressionStatement[24477-24491]:ExpressionStatement[24905-24919]"
    }, {
      "left" : "double correction = fp / (delta * sum2);",
      "right" : "double correction = fp / (delta * sum2);",
      "info" : "VariableDeclarationStatement[24518-24558]:VariableDeclarationStatement[24946-24986]"
    }, {
      "left" : "if (fp > 0)",
      "right" : "if (fp > 0)",
      "info" : "IfStatement[24647-24799]:IfStatement[25075-25227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24659-24720]:Block[25087-25148]"
    }, {
      "left" : "parl = Math.max(parl, lmPar);",
      "right" : "parl = Math.max(parl, lmPar);",
      "info" : "ExpressionStatement[24677-24706]:ExpressionStatement[25105-25134]"
    }, {
      "left" : "if (fp < 0)",
      "right" : "if (fp < 0)",
      "info" : "IfStatement[24726-24799]:IfStatement[25154-25227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24738-24799]:Block[25166-25227]"
    }, {
      "left" : "paru = Math.min(paru, lmPar);",
      "right" : "paru = Math.min(paru, lmPar);",
      "info" : "ExpressionStatement[24756-24785]:ExpressionStatement[25184-25213]"
    }, {
      "left" : "lmPar = Math.max(parl, lmPar + correction);",
      "right" : "lmPar = Math.max(parl, lmPar + correction);",
      "info" : "ExpressionStatement[24867-24910]:ExpressionStatement[25295-25338]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[25729-25736]:Modifier[26157-26164]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[25737-25741]:PrimitiveType[26165-26169]"
    }, {
      "left" : "determineLMDirection",
      "right" : "determineLMDirection",
      "info" : "SimpleName[25742-25762]:SimpleName[26170-26190]"
    }, {
      "left" : "double[] qy",
      "right" : "double[] qy",
      "info" : "SingleVariableDeclaration[25763-25774]:SingleVariableDeclaration[26191-26202]"
    }, {
      "left" : "double[] diag",
      "right" : "double[] diag",
      "info" : "SingleVariableDeclaration[25776-25789]:SingleVariableDeclaration[26204-26217]"
    }, {
      "left" : "double[] lmDiag",
      "right" : "double[] lmDiag",
      "info" : "SingleVariableDeclaration[25803-25818]:SingleVariableDeclaration[26231-26246]"
    }, {
      "left" : "double[] work",
      "right" : "double[] work",
      "info" : "SingleVariableDeclaration[25820-25833]:SingleVariableDeclaration[26248-26261]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25835-29705]:Block[26263-30133]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[25975-26256]:ForStatement[26403-26684]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26012-26256]:Block[26440-26684]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[26026-26050]:VariableDeclarationStatement[26454-26478]"
    }, {
      "left" : "for (int i = j + 1; i < solvedCols; ++i)",
      "right" : "for (int i = j + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[26063-26182]:ForStatement[26491-26610]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26104-26182]:Block[26532-26610]"
    }, {
      "left" : "jacobian[i][pj] = jacobian[j][permutation[i]];",
      "right" : "jacobian[i][pj] = jacobian[j][permutation[i]];",
      "info" : "ExpressionStatement[26122-26168]:ExpressionStatement[26550-26596]"
    }, {
      "left" : "lmDir[j] = diagR[pj];",
      "right" : "lmDir[j] = diagR[pj];",
      "info" : "ExpressionStatement[26195-26216]:ExpressionStatement[26623-26644]"
    }, {
      "left" : "work[j]  = qy[j];",
      "right" : "work[j]  = qy[j];",
      "info" : "ExpressionStatement[26229-26246]:ExpressionStatement[26657-26674]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[26333-28778]:ForStatement[26761-29206]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26370-28778]:Block[26798-29206]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[26520-26544]:VariableDeclarationStatement[26948-26972]"
    }, {
      "left" : "double dpj = diag[pj];",
      "right" : "double dpj = diag[pj];",
      "info" : "VariableDeclarationStatement[26557-26579]:VariableDeclarationStatement[26985-27007]"
    }, {
      "left" : "if (dpj != 0)",
      "right" : "if (dpj != 0)",
      "info" : "IfStatement[26592-26683]:IfStatement[27020-27111]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26606-26683]:Block[27034-27111]"
    }, {
      "left" : "Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);",
      "right" : "Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);",
      "info" : "ExpressionStatement[26624-26669]:ExpressionStatement[27052-27097]"
    }, {
      "left" : "lmDiag[j] = dpj;",
      "right" : "lmDiag[j] = dpj;",
      "info" : "ExpressionStatement[26696-26712]:ExpressionStatement[27124-27140]"
    }, {
      "left" : "double qtbpj = 0;",
      "right" : "double qtbpj = 0;",
      "info" : "VariableDeclarationStatement[26899-26916]:VariableDeclarationStatement[27327-27344]"
    }, {
      "left" : "for (int k = j; k < solvedCols; ++k)",
      "right" : "for (int k = j; k < solvedCols; ++k)",
      "info" : "ForStatement[26929-28547]:ForStatement[27357-28975]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26966-28547]:Block[27394-28975]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[26984-27008]:VariableDeclarationStatement[27412-27436]"
    }, {
      "left" : "if (lmDiag[k] != 0)",
      "right" : "if (lmDiag[k] != 0)",
      "info" : "IfStatement[27157-28533]:IfStatement[27585-28961]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27177-28533]:Block[27605-28961]"
    }, {
      "left" : "final double sin;",
      "right" : "final double sin;",
      "info" : "VariableDeclarationStatement[27200-27217]:VariableDeclarationStatement[27628-27645]"
    }, {
      "left" : "final double cos;",
      "right" : "final double cos;",
      "info" : "VariableDeclarationStatement[27238-27255]:VariableDeclarationStatement[27666-27683]"
    }, {
      "left" : "double rkk = jacobian[k][pk];",
      "right" : "double rkk = jacobian[k][pk];",
      "info" : "VariableDeclarationStatement[27276-27305]:VariableDeclarationStatement[27704-27733]"
    }, {
      "left" : "if (Math.abs(rkk) < Math.abs(lmDiag[k]))",
      "right" : "if (Math.abs(rkk) < Math.abs(lmDiag[k]))",
      "info" : "IfStatement[27326-27761]:IfStatement[27754-28189]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27367-27567]:Block[27795-27995]"
    }, {
      "left" : "final double cotan = rkk / lmDiag[k];",
      "right" : "final double cotan = rkk / lmDiag[k];",
      "info" : "VariableDeclarationStatement[27393-27430]:VariableDeclarationStatement[27821-27858]"
    }, {
      "left" : "sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);",
      "right" : "sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);",
      "info" : "ExpressionStatement[27455-27500]:ExpressionStatement[27883-27928]"
    }, {
      "left" : "cos   = sin * cotan;",
      "right" : "cos   = sin * cotan;",
      "info" : "ExpressionStatement[27525-27545]:ExpressionStatement[27953-27973]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27573-27761]:Block[28001-28189]"
    }, {
      "left" : "final double tan = lmDiag[k] / rkk;",
      "right" : "final double tan = lmDiag[k] / rkk;",
      "info" : "VariableDeclarationStatement[27599-27634]:VariableDeclarationStatement[28027-28062]"
    }, {
      "left" : "cos = 1.0 / Math.sqrt(1.0 + tan * tan);",
      "right" : "cos = 1.0 / Math.sqrt(1.0 + tan * tan);",
      "info" : "ExpressionStatement[27659-27698]:ExpressionStatement[28087-28126]"
    }, {
      "left" : "sin = cos * tan;",
      "right" : "sin = cos * tan;",
      "info" : "ExpressionStatement[27723-27739]:ExpressionStatement[28151-28167]"
    }, {
      "left" : "jacobian[k][pk] = cos * rkk + sin * lmDiag[k];",
      "right" : "jacobian[k][pk] = cos * rkk + sin * lmDiag[k];",
      "info" : "ExpressionStatement[27908-27954]:ExpressionStatement[28336-28382]"
    }, {
      "left" : "final double temp = cos * work[k] + sin * qtbpj;",
      "right" : "final double temp = cos * work[k] + sin * qtbpj;",
      "info" : "VariableDeclarationStatement[27975-28023]:VariableDeclarationStatement[28403-28451]"
    }, {
      "left" : "qtbpj = -sin * work[k] + cos * qtbpj;",
      "right" : "qtbpj = -sin * work[k] + cos * qtbpj;",
      "info" : "ExpressionStatement[28044-28081]:ExpressionStatement[28472-28509]"
    }, {
      "left" : "work[k] = temp;",
      "right" : "work[k] = temp;",
      "info" : "ExpressionStatement[28102-28117]:ExpressionStatement[28530-28545]"
    }, {
      "left" : "for (int i = k + 1; i < solvedCols; ++i)",
      "right" : "for (int i = k + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[28207-28514]:ForStatement[28635-28942]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28248-28514]:Block[28676-28942]"
    }, {
      "left" : "double rik = jacobian[i][pk];",
      "right" : "double rik = jacobian[i][pk];",
      "info" : "VariableDeclarationStatement[28274-28303]:VariableDeclarationStatement[28702-28731]"
    }, {
      "left" : "final double temp2 = cos * rik + sin * lmDiag[i];",
      "right" : "final double temp2 = cos * rik + sin * lmDiag[i];",
      "info" : "VariableDeclarationStatement[28328-28377]:VariableDeclarationStatement[28756-28805]"
    }, {
      "left" : "lmDiag[i] = -sin * rik + cos * lmDiag[i];",
      "right" : "lmDiag[i] = -sin * rik + cos * lmDiag[i];",
      "info" : "ExpressionStatement[28402-28443]:ExpressionStatement[28830-28871]"
    }, {
      "left" : "jacobian[i][pk] = temp2;",
      "right" : "jacobian[i][pk] = temp2;",
      "info" : "ExpressionStatement[28468-28492]:ExpressionStatement[28896-28920]"
    }, {
      "left" : "lmDiag[j] = jacobian[j][permutation[j]];",
      "right" : "lmDiag[j] = jacobian[j][permutation[j]];",
      "info" : "ExpressionStatement[28675-28715]:ExpressionStatement[29103-29143]"
    }, {
      "left" : "jacobian[j][permutation[j]] = lmDir[j];",
      "right" : "jacobian[j][permutation[j]] = lmDir[j];",
      "info" : "ExpressionStatement[28728-28767]:ExpressionStatement[29156-29195]"
    }, {
      "left" : "int nSing = solvedCols;",
      "right" : "int nSing = solvedCols;",
      "info" : "VariableDeclarationStatement[28909-28932]:VariableDeclarationStatement[29337-29360]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[28941-29172]:ForStatement[29369-29600]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28978-29172]:Block[29406-29600]"
    }, {
      "left" : "if ((lmDiag[j] == 0) && (nSing == solvedCols))",
      "right" : "if ((lmDiag[j] == 0) && (nSing == solvedCols))",
      "info" : "IfStatement[28992-29081]:IfStatement[29420-29509]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29039-29081]:Block[29467-29509]"
    }, {
      "left" : "nSing = j;",
      "right" : "nSing = j;",
      "info" : "ExpressionStatement[29057-29067]:ExpressionStatement[29485-29495]"
    }, {
      "left" : "if (nSing < solvedCols)",
      "right" : "if (nSing < solvedCols)",
      "info" : "IfStatement[29094-29162]:IfStatement[29522-29590]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29118-29162]:Block[29546-29590]"
    }, {
      "left" : "work[j] = 0;",
      "right" : "work[j] = 0;",
      "info" : "ExpressionStatement[29136-29148]:ExpressionStatement[29564-29576]"
    }, {
      "left" : "if (nSing > 0)",
      "right" : "if (nSing > 0)",
      "info" : "IfStatement[29181-29526]:IfStatement[29609-29954]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29196-29526]:Block[29624-29954]"
    }, {
      "left" : "for (int j = nSing - 1; j >= 0; --j)",
      "right" : "for (int j = nSing - 1; j >= 0; --j)",
      "info" : "ForStatement[29210-29516]:ForStatement[29638-29944]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29247-29516]:Block[29675-29944]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[29265-29289]:VariableDeclarationStatement[29693-29717]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[29306-29321]:VariableDeclarationStatement[29734-29749]"
    }, {
      "left" : "for (int i = j + 1; i < nSing; ++i)",
      "right" : "for (int i = j + 1; i < nSing; ++i)",
      "info" : "ForStatement[29338-29447]:ForStatement[29766-29875]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29374-29447]:Block[29802-29875]"
    }, {
      "left" : "sum += jacobian[i][pj] * work[i];",
      "right" : "sum += jacobian[i][pj] * work[i];",
      "info" : "ExpressionStatement[29396-29429]:ExpressionStatement[29824-29857]"
    }, {
      "left" : "work[j] = (work[j] - sum) / lmDiag[j];",
      "right" : "work[j] = (work[j] - sum) / lmDiag[j];",
      "info" : "ExpressionStatement[29464-29502]:ExpressionStatement[29892-29930]"
    }, {
      "left" : "for (int j = 0; j < lmDir.length; ++j)",
      "right" : "for (int j = 0; j < lmDir.length; ++j)",
      "info" : "ForStatement[29603-29698]:ForStatement[30031-30126]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29642-29698]:Block[30070-30126]"
    }, {
      "left" : "lmDir[permutation[j]] = work[j];",
      "right" : "lmDir[permutation[j]] = work[j];",
      "info" : "ExpressionStatement[29656-29688]:ExpressionStatement[30084-30116]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[30936-30943]:Modifier[31364-31371]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[30944-30948]:PrimitiveType[31372-31376]"
    }, {
      "left" : "qrDecomposition",
      "right" : "qrDecomposition",
      "info" : "SimpleName[30949-30964]:SimpleName[31377-31392]"
    }, {
      "left" : "OptimizationException",
      "right" : "OptimizationException",
      "info" : "SimpleType[30974-30995]:SimpleType[31402-31423]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30996-33451]:Block[31424-33879]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[31034-31332]:ForStatement[31462-31760]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31065-31332]:Block[31493-31760]"
    }, {
      "left" : "permutation[k] = k;",
      "right" : "permutation[k] = k;",
      "info" : "ExpressionStatement[31079-31098]:ExpressionStatement[31507-31526]"
    }, {
      "left" : "double norm2 = 0;",
      "right" : "double norm2 = 0;",
      "info" : "VariableDeclarationStatement[31111-31128]:VariableDeclarationStatement[31539-31556]"
    }, {
      "left" : "for (int i = 0; i < jacobian.length; ++i)",
      "right" : "for (int i = 0; i < jacobian.length; ++i)",
      "info" : "ForStatement[31141-31279]:ForStatement[31569-31707]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31183-31279]:Block[31611-31707]"
    }, {
      "left" : "double akk = jacobian[i][k];",
      "right" : "double akk = jacobian[i][k];",
      "info" : "VariableDeclarationStatement[31201-31229]:VariableDeclarationStatement[31629-31657]"
    }, {
      "left" : "norm2 += akk * akk;",
      "right" : "norm2 += akk * akk;",
      "info" : "ExpressionStatement[31246-31265]:ExpressionStatement[31674-31693]"
    }, {
      "left" : "jacNorm[k] = Math.sqrt(norm2);",
      "right" : "jacNorm[k] = Math.sqrt(norm2);",
      "info" : "ExpressionStatement[31292-31322]:ExpressionStatement[31720-31750]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[31394-33416]:ForStatement[31822-33844]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31425-33416]:Block[31853-33844]"
    }, {
      "left" : "int nextColumn = -1;",
      "right" : "int nextColumn = -1;",
      "info" : "VariableDeclarationStatement[31517-31537]:VariableDeclarationStatement[31945-31965]"
    }, {
      "left" : "double ak2 = Double.NEGATIVE_INFINITY;",
      "right" : "double ak2 = Double.NEGATIVE_INFINITY;",
      "info" : "VariableDeclarationStatement[31550-31588]:VariableDeclarationStatement[31978-32016]"
    }, {
      "left" : "for (int i = k; i < cols; ++i)",
      "right" : "for (int i = k; i < cols; ++i)",
      "info" : "ForStatement[31601-32271]:ForStatement[32029-32699]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31632-32271]:Block[32060-32699]"
    }, {
      "left" : "double norm2 = 0;",
      "right" : "double norm2 = 0;",
      "info" : "VariableDeclarationStatement[31650-31667]:VariableDeclarationStatement[32078-32095]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[31684-31847]:ForStatement[32112-32275]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31726-31847]:Block[32154-32275]"
    }, {
      "left" : "double aki = jacobian[j][permutation[i]];",
      "right" : "double aki = jacobian[j][permutation[i]];",
      "info" : "VariableDeclarationStatement[31748-31789]:VariableDeclarationStatement[32176-32217]"
    }, {
      "left" : "norm2 += aki * aki;",
      "right" : "norm2 += aki * aki;",
      "info" : "ExpressionStatement[31810-31829]:ExpressionStatement[32238-32257]"
    }, {
      "left" : "if (Double.isInfinite(norm2) || Double.isNaN(norm2))",
      "right" : "if (Double.isInfinite(norm2) || Double.isNaN(norm2))",
      "info" : "IfStatement[31864-32128]:IfStatement[32292-32556]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31917-32128]:Block[32345-32556]"
    }, {
      "left" : "throw new OptimizationException(\n                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n                            rows, cols);",
      "right" : "throw new OptimizationException(\n                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n                            rows, cols);",
      "info" : "ThrowStatement[31939-32110]:ThrowStatement[32367-32538]"
    }, {
      "left" : "if (norm2 > ak2)",
      "right" : "if (norm2 > ak2)",
      "info" : "IfStatement[32145-32257]:IfStatement[32573-32685]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32162-32257]:Block[32590-32685]"
    }, {
      "left" : "nextColumn = i;",
      "right" : "nextColumn = i;",
      "info" : "ExpressionStatement[32184-32199]:ExpressionStatement[32612-32627]"
    }, {
      "left" : "ak2        = norm2;",
      "right" : "ak2        = norm2;",
      "info" : "ExpressionStatement[32220-32239]:ExpressionStatement[32648-32667]"
    }, {
      "left" : "if (ak2 == 0)",
      "right" : "if (ak2 == 0)",
      "info" : "IfStatement[32284-32363]:IfStatement[32712-32791]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32298-32363]:Block[32726-32791]"
    }, {
      "left" : "rank = k;",
      "right" : "rank = k;",
      "info" : "ExpressionStatement[32316-32325]:ExpressionStatement[32744-32753]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[32342-32349]:ReturnStatement[32770-32777]"
    }, {
      "left" : "int pk                  = permutation[nextColumn];",
      "right" : "int pk                  = permutation[nextColumn];",
      "info" : "VariableDeclarationStatement[32376-32426]:VariableDeclarationStatement[32804-32854]"
    }, {
      "left" : "permutation[nextColumn] = permutation[k];",
      "right" : "permutation[nextColumn] = permutation[k];",
      "info" : "ExpressionStatement[32439-32480]:ExpressionStatement[32867-32908]"
    }, {
      "left" : "permutation[k]          = pk;",
      "right" : "permutation[k]          = pk;",
      "info" : "ExpressionStatement[32493-32522]:ExpressionStatement[32921-32950]"
    }, {
      "left" : "double akk   = jacobian[k][pk];",
      "right" : "double akk   = jacobian[k][pk];",
      "info" : "VariableDeclarationStatement[32590-32621]:VariableDeclarationStatement[33018-33049]"
    }, {
      "left" : "double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);",
      "right" : "double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);",
      "info" : "VariableDeclarationStatement[32634-32694]:VariableDeclarationStatement[33062-33122]"
    }, {
      "left" : "double betak = 1.0 / (ak2 - akk * alpha);",
      "right" : "double betak = 1.0 / (ak2 - akk * alpha);",
      "info" : "VariableDeclarationStatement[32707-32748]:VariableDeclarationStatement[33135-33176]"
    }, {
      "left" : "beta[pk]     = betak;",
      "right" : "beta[pk]     = betak;",
      "info" : "ExpressionStatement[32761-32782]:ExpressionStatement[33189-33210]"
    }, {
      "left" : "diagR[pk]        = alpha;",
      "right" : "diagR[pk]        = alpha;",
      "info" : "ExpressionStatement[32840-32865]:ExpressionStatement[33268-33293]"
    }, {
      "left" : "jacobian[k][pk] -= alpha;",
      "right" : "jacobian[k][pk] -= alpha;",
      "info" : "ExpressionStatement[32878-32903]:ExpressionStatement[33306-33331]"
    }, {
      "left" : "for (int dk = cols - 1 - k; dk > 0; --dk)",
      "right" : "for (int dk = cols - 1 - k; dk > 0; --dk)",
      "info" : "ForStatement[32964-33405]:ForStatement[33392-33833]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33006-33405]:Block[33434-33833]"
    }, {
      "left" : "double gamma = 0;",
      "right" : "double gamma = 0;",
      "info" : "VariableDeclarationStatement[33024-33041]:VariableDeclarationStatement[33452-33469]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[33058-33200]:ForStatement[33486-33628]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33100-33200]:Block[33528-33628]"
    }, {
      "left" : "gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];",
      "right" : "gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];",
      "info" : "ExpressionStatement[33122-33182]:ExpressionStatement[33550-33610]"
    }, {
      "left" : "gamma *= betak;",
      "right" : "gamma *= betak;",
      "info" : "ExpressionStatement[33217-33232]:ExpressionStatement[33645-33660]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[33249-33391]:ForStatement[33677-33819]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33291-33391]:Block[33719-33819]"
    }, {
      "left" : "jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];",
      "right" : "jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];",
      "info" : "ExpressionStatement[33313-33373]:ExpressionStatement[33741-33801]"
    }, {
      "left" : "rank = solvedCols;",
      "right" : "rank = solvedCols;",
      "info" : "ExpressionStatement[33426-33444]:ExpressionStatement[33854-33872]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[33614-33621]:Modifier[34042-34049]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[33622-33626]:PrimitiveType[34050-34054]"
    }, {
      "left" : "qTy",
      "right" : "qTy",
      "info" : "SimpleName[33627-33630]:SimpleName[34055-34058]"
    }, {
      "left" : "double[] y",
      "right" : "double[] y",
      "info" : "SingleVariableDeclaration[33631-33641]:SingleVariableDeclaration[34059-34069]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33643-34015]:Block[34071-34443]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[33653-34009]:ForStatement[34081-34437]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33684-34009]:Block[34112-34437]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[33698-33722]:VariableDeclarationStatement[34126-34150]"
    }, {
      "left" : "double gamma = 0;",
      "right" : "double gamma = 0;",
      "info" : "VariableDeclarationStatement[33735-33752]:VariableDeclarationStatement[34163-34180]"
    }, {
      "left" : "for (int i = k; i < rows; ++i)",
      "right" : "for (int i = k; i < rows; ++i)",
      "info" : "ForStatement[33765-33860]:ForStatement[34193-34288]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33796-33860]:Block[34224-34288]"
    }, {
      "left" : "gamma += jacobian[i][pk] * y[i];",
      "right" : "gamma += jacobian[i][pk] * y[i];",
      "info" : "ExpressionStatement[33814-33846]:ExpressionStatement[34242-34274]"
    }, {
      "left" : "gamma *= beta[pk];",
      "right" : "gamma *= beta[pk];",
      "info" : "ExpressionStatement[33873-33891]:ExpressionStatement[34301-34319]"
    }, {
      "left" : "for (int i = k; i < rows; ++i)",
      "right" : "for (int i = k; i < rows; ++i)",
      "info" : "ForStatement[33904-33999]:ForStatement[34332-34427]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33935-33999]:Block[34363-34427]"
    }, {
      "left" : "y[i] -= gamma * jacobian[i][pk];",
      "right" : "y[i] -= gamma * jacobian[i][pk];",
      "info" : "ExpressionStatement[33953-33985]:ExpressionStatement[34381-34413]"
    } ]
  },
  "interFileMappings" : { }
}