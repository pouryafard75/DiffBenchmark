{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "JsDocInfoParser",
      "right" : "JsDocInfoParser",
      "info" : "TypeDeclaration[1462-73438]:TypeDeclaration[1462-73498]"
    }, {
      "left" : "private final JsDocTokenStream stream;",
      "right" : "private final JsDocTokenStream stream;",
      "info" : "FieldDeclaration[1667-1705]:FieldDeclaration[1667-1705]"
    }, {
      "left" : "private final JSDocInfoBuilder jsdocBuilder;",
      "right" : "private final JSDocInfoBuilder jsdocBuilder;",
      "info" : "FieldDeclaration[1708-1752]:FieldDeclaration[1708-1752]"
    }, {
      "left" : "private final String sourceName;",
      "right" : "private final String sourceName;",
      "info" : "FieldDeclaration[1755-1787]:FieldDeclaration[1755-1787]"
    }, {
      "left" : "private final ErrorReporter errorReporter;",
      "right" : "private final ErrorReporter errorReporter;",
      "info" : "FieldDeclaration[1790-1832]:FieldDeclaration[1790-1832]"
    }, {
      "left" : "private final ErrorReporterParser parser = new ErrorReporterParser();",
      "right" : "private final ErrorReporterParser parser = new ErrorReporterParser();",
      "info" : "FieldDeclaration[1835-1904]:FieldDeclaration[1835-1904]"
    }, {
      "left" : "private final Node templateNode;",
      "right" : "private final Node templateNode;",
      "info" : "FieldDeclaration[2049-2081]:FieldDeclaration[2049-2081]"
    }, {
      "left" : "ErrorReporterParser",
      "right" : "ErrorReporterParser",
      "info" : "TypeDeclaration[2085-3055]:TypeDeclaration[2085-3055]"
    }, {
      "left" : "void addParserWarning(String messageId, String messageArg, int lineno,\n        int charno)",
      "right" : "void addParserWarning(String messageId, String messageArg, int lineno,\n        int charno)",
      "info" : "MethodDeclaration[2125-2346]:MethodDeclaration[2125-2346]"
    }, {
      "left" : "void addParserWarning(String messageId, int lineno, int charno)",
      "right" : "void addParserWarning(String messageId, int lineno, int charno)",
      "info" : "MethodDeclaration[2352-2534]:MethodDeclaration[2352-2534]"
    }, {
      "left" : "void addTypeWarning(String messageId, String messageArg, int lineno,\n                    int charno)",
      "right" : "void addTypeWarning(String messageId, String messageArg, int lineno,\n                    int charno)",
      "info" : "MethodDeclaration[2540-2818]:MethodDeclaration[2540-2818]"
    }, {
      "left" : "void addTypeWarning(String messageId, int lineno, int charno)",
      "right" : "void addTypeWarning(String messageId, int lineno, int charno)",
      "info" : "MethodDeclaration[2824-3051]:MethodDeclaration[2824-3051]"
    }, {
      "left" : "private JSDocInfo fileOverviewJSDocInfo = null;",
      "right" : "private JSDocInfo fileOverviewJSDocInfo = null;",
      "info" : "FieldDeclaration[3122-3169]:FieldDeclaration[3122-3169]"
    }, {
      "left" : "private State state;",
      "right" : "private State state;",
      "info" : "FieldDeclaration[3172-3192]:FieldDeclaration[3172-3192]"
    }, {
      "left" : "private final Map<String, Annotation> annotationNames;",
      "right" : "private final Map<String, Annotation> annotationNames;",
      "info" : "FieldDeclaration[3196-3250]:FieldDeclaration[3196-3250]"
    }, {
      "left" : "private final Set<String> suppressionNames;",
      "right" : "private final Set<String> suppressionNames;",
      "info" : "FieldDeclaration[3253-3296]:FieldDeclaration[3253-3296]"
    }, {
      "left" : "static private final Set<String> modifiesAnnotationKeywords =\n      ImmutableSet.<String>of(\"this\", \"arguments\");",
      "right" : "static private final Set<String> modifiesAnnotationKeywords =\n      ImmutableSet.<String>of(\"this\", \"arguments\");",
      "info" : "FieldDeclaration[3299-3412]:FieldDeclaration[3299-3412]"
    }, {
      "left" : "private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;",
      "right" : "private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;",
      "info" : "FieldDeclaration[3416-3473]:FieldDeclaration[3416-3473]"
    }, {
      "left" : "void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder)",
      "right" : "void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder)",
      "info" : "MethodDeclaration[3477-3855]:MethodDeclaration[3477-3855]"
    }, {
      "left" : "void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo)",
      "right" : "void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo)",
      "info" : "MethodDeclaration[3859-4112]:MethodDeclaration[3859-4112]"
    }, {
      "left" : "enum : State",
      "right" : "enum : State",
      "info" : "EnumDeclaration[4116-4212]:EnumDeclaration[4116-4212]"
    }, {
      "left" : "JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  String sourceName,\n                  Config config,\n                  ErrorReporter errorReporter)",
      "right" : "JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  String sourceName,\n                  Config config,\n                  ErrorReporter errorReporter)",
      "info" : "MethodDeclaration[4216-4866]:MethodDeclaration[4216-4866]"
    }, {
      "left" : "public static Node parseTypeString(String typeString)",
      "right" : "public static Node parseTypeString(String typeString)",
      "info" : "MethodDeclaration[4870-5495]:MethodDeclaration[4870-5495]"
    }, {
      "left" : "boolean parse()",
      "right" : "boolean parse()",
      "info" : "MethodDeclaration[5499-34873]:MethodDeclaration[5499-34873]"
    }, {
      "left" : "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes)",
      "right" : "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes)",
      "info" : "MethodDeclaration[34877-35515]:MethodDeclaration[34877-35515]"
    }, {
      "left" : "private JsDocToken parseSuppressTag(JsDocToken token)",
      "right" : "private JsDocToken parseSuppressTag(JsDocToken token)",
      "info" : "MethodDeclaration[35519-36879]:MethodDeclaration[35519-36879]"
    }, {
      "left" : "private JsDocToken parseModifiesTag(JsDocToken token)",
      "right" : "private JsDocToken parseModifiesTag(JsDocToken token)",
      "info" : "MethodDeclaration[36883-38294]:MethodDeclaration[36883-38294]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token)",
      "info" : "MethodDeclaration[38298-38656]:MethodDeclaration[38298-38656]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC)",
      "info" : "MethodDeclaration[38660-39151]:MethodDeclaration[38660-39151]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n      int startCharno)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n      int startCharno)",
      "info" : "MethodDeclaration[39155-39716]:MethodDeclaration[39155-39716]"
    }, {
      "left" : "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC)",
      "right" : "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC)",
      "info" : "MethodDeclaration[39720-40390]:MethodDeclaration[39720-40390]"
    }, {
      "left" : "private Node parseAndRecordParamTypeNode(JsDocToken token)",
      "right" : "private Node parseAndRecordParamTypeNode(JsDocToken token)",
      "info" : "MethodDeclaration[40394-41263]:MethodDeclaration[40394-41263]"
    }, {
      "left" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames)",
      "right" : "private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames)",
      "info" : "MethodDeclaration[41267-42587]:MethodDeclaration[41267-42587]"
    }, {
      "left" : "private String toString(JsDocToken token)",
      "right" : "private String toString(JsDocToken token)",
      "info" : "MethodDeclaration[42591-43533]:MethodDeclaration[42591-43533]"
    }, {
      "left" : "private JSTypeExpression createJSTypeExpression(Node n)",
      "right" : "private JSTypeExpression createJSTypeExpression(Node n)",
      "info" : "MethodDeclaration[43537-43768]:MethodDeclaration[43537-43768]"
    }, {
      "left" : "ExtractionInfo",
      "right" : "ExtractionInfo",
      "info" : "TypeDeclaration[43772-44149]:TypeDeclaration[43772-44149]"
    }, {
      "left" : "private final String string;",
      "right" : "private final String string;",
      "info" : "FieldDeclaration[43959-43987]:FieldDeclaration[43959-43987]"
    }, {
      "left" : "private final JsDocToken token;",
      "right" : "private final JsDocToken token;",
      "info" : "FieldDeclaration[43992-44023]:FieldDeclaration[43992-44023]"
    }, {
      "left" : "public ExtractionInfo(String string, JsDocToken token)",
      "right" : "public ExtractionInfo(String string, JsDocToken token)",
      "info" : "MethodDeclaration[44029-44145]:MethodDeclaration[44029-44145]"
    }, {
      "left" : "ExtendedTypeInfo",
      "right" : "ExtendedTypeInfo",
      "info" : "TypeDeclaration[44153-44489]:TypeDeclaration[44153-44489]"
    }, {
      "left" : "final JSTypeExpression type;",
      "right" : "final JSTypeExpression type;",
      "info" : "FieldDeclaration[44249-44277]:FieldDeclaration[44249-44277]"
    }, {
      "left" : "final int lineno;",
      "right" : "final int lineno;",
      "info" : "FieldDeclaration[44282-44299]:FieldDeclaration[44282-44299]"
    }, {
      "left" : "final int charno;",
      "right" : "final int charno;",
      "info" : "FieldDeclaration[44304-44321]:FieldDeclaration[44304-44321]"
    }, {
      "left" : "public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno)",
      "right" : "public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno)",
      "info" : "MethodDeclaration[44327-44485]:MethodDeclaration[44327-44485]"
    }, {
      "left" : "private ExtractionInfo extractSingleLineBlock()",
      "right" : "private ExtractionInfo extractSingleLineBlock()",
      "info" : "MethodDeclaration[44493-45228]:MethodDeclaration[44493-45228]"
    }, {
      "left" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token)",
      "right" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token)",
      "info" : "MethodDeclaration[45232-45385]:MethodDeclaration[45232-45385]"
    }, {
      "left" : "enum : WhitespaceOption",
      "right" : "enum : WhitespaceOption",
      "info" : "EnumDeclaration[45389-45715]:EnumDeclaration[45389-45715]"
    }, {
      "left" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option)",
      "right" : "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option)",
      "info" : "MethodDeclaration[45719-48824]:MethodDeclaration[45719-48824]"
    }, {
      "left" : "private ExtractionInfo extractBlockComment(JsDocToken token)",
      "right" : "private ExtractionInfo extractBlockComment(JsDocToken token)",
      "info" : "MethodDeclaration[48829-50326]:MethodDeclaration[48829-50326]"
    }, {
      "left" : "private static String trimEnd(String s)",
      "right" : "private static String trimEnd(String s)",
      "info" : "MethodDeclaration[50330-51092]:MethodDeclaration[50330-51092]"
    }, {
      "left" : "private Node parseTypeExpressionAnnotation(JsDocToken token)",
      "right" : "private Node parseTypeExpressionAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[51512-52074]:MethodDeclaration[51512-52074]"
    }, {
      "left" : "private Node parseParamTypeExpressionAnnotation(JsDocToken token)",
      "right" : "private Node parseParamTypeExpressionAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[52078-53264]:MethodDeclaration[52078-53264]"
    }, {
      "left" : "private Node parseTypeNameAnnotation(JsDocToken token)",
      "right" : "private Node parseTypeNameAnnotation(JsDocToken token)",
      "info" : "MethodDeclaration[53268-53769]:MethodDeclaration[53268-53769]"
    }, {
      "left" : "private Node parseTopLevelTypeExpression(JsDocToken token)",
      "right" : "private Node parseTopLevelTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[53773-54431]:MethodDeclaration[53773-54431]"
    }, {
      "left" : "private Node parseTypeExpressionList(JsDocToken token)",
      "right" : "private Node parseTypeExpressionList(JsDocToken token)",
      "info" : "MethodDeclaration[54435-55056]:MethodDeclaration[54435-55056]"
    }, {
      "left" : "private Node parseTypeExpression(JsDocToken token)",
      "right" : "private Node parseTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[55060-56714]:MethodDeclaration[55060-56714]"
    }, {
      "left" : "private Node parseBasicTypeExpression(JsDocToken token)",
      "right" : "private Node parseBasicTypeExpression(JsDocToken token)",
      "info" : "MethodDeclaration[56718-57687]:MethodDeclaration[56718-57716]"
    }, {
      "left" : "private Node parseTypeName(JsDocToken token)",
      "right" : "private Node parseTypeName(JsDocToken token)",
      "info" : "MethodDeclaration[57691-58724]:MethodDeclaration[57720-58753]"
    }, {
      "left" : "private Node parseFunctionType(JsDocToken token)",
      "right" : "private Node parseFunctionType(JsDocToken token)",
      "info" : "MethodDeclaration[58728-60775]:MethodDeclaration[58757-60835]"
    }, {
      "left" : "// NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token)",
      "right" : "// NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token)",
      "info" : "MethodDeclaration[60779-63866]:MethodDeclaration[60839-63926]"
    }, {
      "left" : "private Node parseResultType(JsDocToken token)",
      "right" : "private Node parseResultType(JsDocToken token)",
      "info" : "MethodDeclaration[63870-64305]:MethodDeclaration[63930-64365]"
    }, {
      "left" : "private Node parseUnionType(JsDocToken token)",
      "right" : "private Node parseUnionType(JsDocToken token)",
      "info" : "MethodDeclaration[64309-64583]:MethodDeclaration[64369-64643]"
    }, {
      "left" : "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate)",
      "right" : "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate)",
      "info" : "MethodDeclaration[64587-65785]:MethodDeclaration[64647-65845]"
    }, {
      "left" : "private Node parseArrayType(JsDocToken token)",
      "right" : "private Node parseArrayType(JsDocToken token)",
      "info" : "MethodDeclaration[65789-66732]:MethodDeclaration[65849-66792]"
    }, {
      "left" : "private Node parseRecordType(JsDocToken token)",
      "right" : "private Node parseRecordType(JsDocToken token)",
      "info" : "MethodDeclaration[66736-67222]:MethodDeclaration[66796-67282]"
    }, {
      "left" : "private Node parseFieldTypeList(JsDocToken token)",
      "right" : "private Node parseFieldTypeList(JsDocToken token)",
      "info" : "MethodDeclaration[67226-67826]:MethodDeclaration[67286-67886]"
    }, {
      "left" : "private Node parseFieldType(JsDocToken token)",
      "right" : "private Node parseFieldType(JsDocToken token)",
      "info" : "MethodDeclaration[67830-68537]:MethodDeclaration[67890-68597]"
    }, {
      "left" : "private Node parseFieldName(JsDocToken token)",
      "right" : "private Node parseFieldName(JsDocToken token)",
      "info" : "MethodDeclaration[68541-68860]:MethodDeclaration[68601-68920]"
    }, {
      "left" : "private Node wrapNode(int type, Node n)",
      "right" : "private Node wrapNode(int type, Node n)",
      "info" : "MethodDeclaration[68864-69047]:MethodDeclaration[68924-69107]"
    }, {
      "left" : "private Node newNode(int type)",
      "right" : "private Node newNode(int type)",
      "info" : "MethodDeclaration[69051-69191]:MethodDeclaration[69111-69251]"
    }, {
      "left" : "private Node newStringNode(String s)",
      "right" : "private Node newStringNode(String s)",
      "info" : "MethodDeclaration[69195-69344]:MethodDeclaration[69255-69404]"
    }, {
      "left" : "private Node createTemplateNode()",
      "right" : "private Node createTemplateNode()",
      "info" : "MethodDeclaration[69466-69680]:MethodDeclaration[69526-69740]"
    }, {
      "left" : "private Node reportTypeSyntaxWarning(String warning)",
      "right" : "private Node reportTypeSyntaxWarning(String warning)",
      "info" : "MethodDeclaration[69684-69835]:MethodDeclaration[69744-69895]"
    }, {
      "left" : "private Node reportGenericTypeSyntaxWarning()",
      "right" : "private Node reportGenericTypeSyntaxWarning()",
      "info" : "MethodDeclaration[69839-69951]:MethodDeclaration[69899-70011]"
    }, {
      "left" : "private JsDocToken eatTokensUntilEOL()",
      "right" : "private JsDocToken eatTokensUntilEOL()",
      "info" : "MethodDeclaration[69955-70177]:MethodDeclaration[70015-70237]"
    }, {
      "left" : "private JsDocToken eatTokensUntilEOL(JsDocToken token)",
      "right" : "private JsDocToken eatTokensUntilEOL(JsDocToken token)",
      "info" : "MethodDeclaration[70181-70607]:MethodDeclaration[70241-70667]"
    }, {
      "left" : "private static final JsDocToken NO_UNREAD_TOKEN = null;",
      "right" : "private static final JsDocToken NO_UNREAD_TOKEN = null;",
      "info" : "FieldDeclaration[70611-70758]:FieldDeclaration[70671-70818]"
    }, {
      "left" : "private JsDocToken unreadToken = NO_UNREAD_TOKEN;",
      "right" : "private JsDocToken unreadToken = NO_UNREAD_TOKEN;",
      "info" : "FieldDeclaration[70762-70846]:FieldDeclaration[70822-70906]"
    }, {
      "left" : "private void restoreLookAhead(JsDocToken token)",
      "right" : "private void restoreLookAhead(JsDocToken token)",
      "info" : "MethodDeclaration[70850-70986]:MethodDeclaration[70910-71046]"
    }, {
      "left" : "private boolean match(JsDocToken token)",
      "right" : "private boolean match(JsDocToken token)",
      "info" : "MethodDeclaration[70990-71194]:MethodDeclaration[71050-71254]"
    }, {
      "left" : "private boolean match(JsDocToken token1, JsDocToken token2)",
      "right" : "private boolean match(JsDocToken token1, JsDocToken token2)",
      "info" : "MethodDeclaration[71198-71454]:MethodDeclaration[71258-71514]"
    }, {
      "left" : "private JsDocToken next()",
      "right" : "private JsDocToken next()",
      "info" : "MethodDeclaration[71458-71730]:MethodDeclaration[71518-71790]"
    }, {
      "left" : "private JsDocToken current()",
      "right" : "private JsDocToken current()",
      "info" : "MethodDeclaration[71734-71922]:MethodDeclaration[71794-71982]"
    }, {
      "left" : "private void skipEOLs()",
      "right" : "private void skipEOLs()",
      "info" : "MethodDeclaration[71926-72211]:MethodDeclaration[71986-72271]"
    }, {
      "left" : "private boolean hasParsedFileOverviewDocInfo()",
      "right" : "private boolean hasParsedFileOverviewDocInfo()",
      "info" : "MethodDeclaration[72215-72431]:MethodDeclaration[72275-72491]"
    }, {
      "left" : "boolean hasParsedJSDocInfo()",
      "right" : "boolean hasParsedJSDocInfo()",
      "info" : "MethodDeclaration[72435-72508]:MethodDeclaration[72495-72568]"
    }, {
      "left" : "JSDocInfo retrieveAndResetParsedJSDocInfo()",
      "right" : "JSDocInfo retrieveAndResetParsedJSDocInfo()",
      "info" : "MethodDeclaration[72512-72604]:MethodDeclaration[72572-72664]"
    }, {
      "left" : "JSDocInfo getFileOverviewJSDocInfo()",
      "right" : "JSDocInfo getFileOverviewJSDocInfo()",
      "info" : "MethodDeclaration[72608-72742]:MethodDeclaration[72668-72802]"
    }, {
      "left" : "private boolean lookAheadForTypeAnnotation()",
      "right" : "private boolean lookAheadForTypeAnnotation()",
      "info" : "MethodDeclaration[72746-73436]:MethodDeclaration[72806-73496]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2216-2346]:Block[2216-2346]"
    }, {
      "left" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          sourceName, lineno, null, charno);",
      "right" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          sourceName, lineno, null, charno);",
      "info" : "ExpressionStatement[2224-2340]:ExpressionStatement[2224-2340]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2416-2534]:Block[2416-2534]"
    }, {
      "left" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          sourceName, lineno, null, charno);",
      "right" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          sourceName, lineno, null, charno);",
      "info" : "ExpressionStatement[2424-2528]:ExpressionStatement[2424-2528]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2641-2818]:Block[2641-2818]"
    }, {
      "left" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage1(messageId, messageArg),\n          sourceName, lineno, null, charno);",
      "right" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage1(messageId, messageArg),\n          sourceName, lineno, null, charno);",
      "info" : "ExpressionStatement[2649-2812]:ExpressionStatement[2649-2812]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2886-3051]:Block[2886-3051]"
    }, {
      "left" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage0(messageId),\n          sourceName, lineno, null, charno);",
      "right" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage0(messageId),\n          sourceName, lineno, null, charno);",
      "info" : "ExpressionStatement[2894-3045]:ExpressionStatement[2894-3045]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3794-3855]:Block[3794-3855]"
    }, {
      "left" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
      "right" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
      "info" : "ExpressionStatement[3800-3851]:ExpressionStatement[3800-3851]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4051-4112]:Block[4051-4112]"
    }, {
      "left" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
      "right" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
      "info" : "ExpressionStatement[4057-4108]:ExpressionStatement[4057-4108]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4413-4866]:Block[4413-4866]"
    }, {
      "left" : "this.stream = stream;",
      "right" : "this.stream = stream;",
      "info" : "ExpressionStatement[4419-4440]:ExpressionStatement[4419-4440]"
    }, {
      "left" : "this.sourceName = sourceName;",
      "right" : "this.sourceName = sourceName;",
      "info" : "ExpressionStatement[4445-4474]:ExpressionStatement[4445-4474]"
    }, {
      "left" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
      "right" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
      "info" : "ExpressionStatement[4479-4552]:ExpressionStatement[4479-4552]"
    }, {
      "left" : "if (commentNode != null)",
      "right" : "if (commentNode != null)",
      "info" : "IfStatement[4557-4666]:IfStatement[4557-4666]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4582-4666]:Block[4582-4666]"
    }, {
      "left" : "this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());",
      "right" : "this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());",
      "info" : "ExpressionStatement[4590-4660]:ExpressionStatement[4590-4660]"
    }, {
      "left" : "this.annotationNames = config.annotationNames;",
      "right" : "this.annotationNames = config.annotationNames;",
      "info" : "ExpressionStatement[4671-4717]:ExpressionStatement[4671-4717]"
    }, {
      "left" : "this.suppressionNames = config.suppressionNames;",
      "right" : "this.suppressionNames = config.suppressionNames;",
      "info" : "ExpressionStatement[4722-4770]:ExpressionStatement[4722-4770]"
    }, {
      "left" : "this.errorReporter = errorReporter;",
      "right" : "this.errorReporter = errorReporter;",
      "info" : "ExpressionStatement[4776-4811]:ExpressionStatement[4776-4811]"
    }, {
      "left" : "this.templateNode = this.createTemplateNode();",
      "right" : "this.templateNode = this.createTemplateNode();",
      "info" : "ExpressionStatement[4816-4862]:ExpressionStatement[4816-4862]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5073-5495]:Block[5073-5495]"
    }, {
      "left" : "Config config = new Config(\n        Sets.<String>newHashSet(),\n        Sets.<String>newHashSet(),\n        false,\n        LanguageMode.ECMASCRIPT3,\n        false);",
      "right" : "Config config = new Config(\n        Sets.<String>newHashSet(),\n        Sets.<String>newHashSet(),\n        false,\n        LanguageMode.ECMASCRIPT3,\n        false);",
      "info" : "VariableDeclarationStatement[5079-5241]:VariableDeclarationStatement[5079-5241]"
    }, {
      "left" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        null,\n        \"typeparsing\",\n        config,\n        NullErrorReporter.forNewRhino());",
      "right" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        null,\n        \"typeparsing\",\n        config,\n        NullErrorReporter.forNewRhino());",
      "info" : "VariableDeclarationStatement[5246-5428]:VariableDeclarationStatement[5246-5428]"
    }, {
      "left" : "return parser.parseTopLevelTypeExpression(parser.next());",
      "right" : "return parser.parseTopLevelTypeExpression(parser.next());",
      "info" : "ReturnStatement[5434-5491]:ReturnStatement[5434-5491]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5831-34873]:Block[5831-34873]"
    }, {
      "left" : "int lineno;",
      "right" : "int lineno;",
      "info" : "VariableDeclarationStatement[5837-5848]:VariableDeclarationStatement[5837-5848]"
    }, {
      "left" : "int charno;",
      "right" : "int charno;",
      "info" : "VariableDeclarationStatement[5853-5864]:VariableDeclarationStatement[5853-5864]"
    }, {
      "left" : "JSTypeExpression type;",
      "right" : "JSTypeExpression type;",
      "info" : "VariableDeclarationStatement[5946-5968]:VariableDeclarationStatement[5946-5968]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[5974-6009]:ExpressionStatement[5974-6009]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[6014-6025]:ExpressionStatement[6014-6025]"
    }, {
      "left" : "JsDocToken token = next();",
      "right" : "JsDocToken token = next();",
      "info" : "VariableDeclarationStatement[6031-6057]:VariableDeclarationStatement[6031-6057]"
    }, {
      "left" : "List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();",
      "right" : "List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();",
      "info" : "VariableDeclarationStatement[6063-6123]:VariableDeclarationStatement[6063-6123]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[6174-6676]:IfStatement[6174-6676]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6219-6430]:Block[6219-6430]"
    }, {
      "left" : "ExtractionInfo blockInfo = extractBlockComment(token);",
      "right" : "ExtractionInfo blockInfo = extractBlockComment(token);",
      "info" : "VariableDeclarationStatement[6227-6281]:VariableDeclarationStatement[6227-6281]"
    }, {
      "left" : "token = blockInfo.token;",
      "right" : "token = blockInfo.token;",
      "info" : "ExpressionStatement[6288-6312]:ExpressionStatement[6288-6312]"
    }, {
      "left" : "if (!blockInfo.string.isEmpty())",
      "right" : "if (!blockInfo.string.isEmpty())",
      "info" : "IfStatement[6319-6424]:IfStatement[6319-6424]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6352-6424]:Block[6352-6424]"
    }, {
      "left" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
      "right" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
      "info" : "ExpressionStatement[6362-6416]:ExpressionStatement[6362-6416]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6436-6676]:Block[6436-6676]"
    }, {
      "left" : "if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC)",
      "info" : "IfStatement[6444-6670]:IfStatement[6444-6670]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6517-6670]:Block[6517-6670]"
    }, {
      "left" : "jsdocBuilder.recordBlockDescription(\"\");",
      "right" : "jsdocBuilder.recordBlockDescription(\"\");",
      "info" : "ExpressionStatement[6622-6662]:ExpressionStatement[6622-6662]"
    }, {
      "left" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
      "right" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
      "info" : "LabeledStatement[6713-34869]:LabeledStatement[6713-34869]"
    }, {
      "left" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
      "right" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
      "info" : "ForStatement[6720-34869]:ForStatement[6720-34869]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6729-34869]:Block[6729-34869]"
    }, {
      "left" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
      "right" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
      "info" : "SwitchStatement[6737-34820]:SwitchStatement[6737-34820]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[6762-6778]:SwitchCase[6762-6778]"
    }, {
      "left" : "if (state == State.SEARCHING_ANNOTATION)",
      "right" : "if (state == State.SEARCHING_ANNOTATION)",
      "info" : "IfStatement[6789-33812]:IfStatement[6789-33812]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6830-33812]:Block[6830-33812]"
    }, {
      "left" : "state = State.SEARCHING_NEWLINE;",
      "right" : "state = State.SEARCHING_NEWLINE;",
      "info" : "ExpressionStatement[6844-6876]:ExpressionStatement[6844-6876]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[6889-6917]:ExpressionStatement[6889-6917]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[6930-6958]:ExpressionStatement[6930-6958]"
    }, {
      "left" : "String annotationName = stream.getString();",
      "right" : "String annotationName = stream.getString();",
      "info" : "VariableDeclarationStatement[6972-7015]:VariableDeclarationStatement[6972-7015]"
    }, {
      "left" : "Annotation annotation = annotationNames.get(annotationName);",
      "right" : "Annotation annotation = annotationNames.get(annotationName);",
      "info" : "VariableDeclarationStatement[7028-7088]:VariableDeclarationStatement[7028-7088]"
    }, {
      "left" : "if (annotation == null)",
      "right" : "if (annotation == null)",
      "info" : "IfStatement[7101-33800]:IfStatement[7101-33800]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7125-7274]:Block[7125-7274]"
    }, {
      "left" : "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[7141-7260]:ExpressionStatement[7141-7260]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7280-33800]:Block[7280-33800]"
    }, {
      "left" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
      "right" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
      "info" : "ExpressionStatement[7351-7411]:ExpressionStatement[7351-7411]"
    }, {
      "left" : "switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }",
      "right" : "switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }",
      "info" : "SwitchStatement[7427-33786]:SwitchStatement[7427-33786]"
    }, {
      "left" : "case AUTHOR:",
      "right" : "case AUTHOR:",
      "info" : "SwitchCase[7465-7477]:SwitchCase[7465-7477]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[7496-8112]:IfStatement[7496-8112]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7541-8031]:Block[7541-8031]"
    }, {
      "left" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[7563-7616]:VariableDeclarationStatement[7563-7616]"
    }, {
      "left" : "String author = authorInfo.string;",
      "right" : "String author = authorInfo.string;",
      "info" : "VariableDeclarationStatement[7637-7671]:VariableDeclarationStatement[7637-7671]"
    }, {
      "left" : "if (author.length() == 0)",
      "right" : "if (author.length() == 0)",
      "info" : "IfStatement[7693-7965]:IfStatement[7693-7965]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7719-7882]:Block[7719-7882]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[7743-7860]:ExpressionStatement[7743-7860]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7888-7965]:Block[7888-7965]"
    }, {
      "left" : "jsdocBuilder.addAuthor(author);",
      "right" : "jsdocBuilder.addAuthor(author);",
      "info" : "ExpressionStatement[7912-7943]:ExpressionStatement[7912-7943]"
    }, {
      "left" : "token = authorInfo.token;",
      "right" : "token = authorInfo.token;",
      "info" : "ExpressionStatement[7986-8011]:ExpressionStatement[7986-8011]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8037-8112]:Block[8037-8112]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[8059-8092]:ExpressionStatement[8059-8092]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[8131-8146]:ContinueStatement[8131-8146]"
    }, {
      "left" : "case CONSTANT:",
      "right" : "case CONSTANT:",
      "info" : "SwitchCase[8164-8178]:SwitchCase[8164-8178]"
    }, {
      "left" : "if (!jsdocBuilder.recordConstancy())",
      "right" : "if (!jsdocBuilder.recordConstancy())",
      "info" : "IfStatement[8197-8383]:IfStatement[8197-8383]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8234-8383]:Block[8234-8383]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8256-8363]:ExpressionStatement[8256-8363]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[8402-8430]:ExpressionStatement[8402-8430]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[8449-8464]:ContinueStatement[8449-8464]"
    }, {
      "left" : "case CONSTRUCTOR:",
      "right" : "case CONSTRUCTOR:",
      "info" : "SwitchCase[8482-8499]:SwitchCase[8482-8499]"
    }, {
      "left" : "if (!jsdocBuilder.recordConstructor())",
      "right" : "if (!jsdocBuilder.recordConstructor())",
      "info" : "IfStatement[8518-8975]:IfStatement[8518-8975]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8557-8975]:Block[8557-8975]"
    }, {
      "left" : "if (jsdocBuilder.isInterfaceRecorded())",
      "right" : "if (jsdocBuilder.isInterfaceRecorded())",
      "info" : "IfStatement[8579-8955]:IfStatement[8579-8955]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8619-8788]:Block[8619-8788]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8643-8766]:ExpressionStatement[8643-8766]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8794-8955]:Block[8794-8955]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[8818-8933]:ExpressionStatement[8818-8933]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[8994-9022]:ExpressionStatement[8994-9022]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[9041-9056]:ContinueStatement[9041-9056]"
    }, {
      "left" : "case DEPRECATED:",
      "right" : "case DEPRECATED:",
      "info" : "SwitchCase[9074-9090]:SwitchCase[9074-9090]"
    }, {
      "left" : "if (!jsdocBuilder.recordDeprecated())",
      "right" : "if (!jsdocBuilder.recordDeprecated())",
      "info" : "IfStatement[9109-9301]:IfStatement[9109-9301]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9147-9301]:Block[9147-9301]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[9169-9281]:ExpressionStatement[9169-9281]"
    }, {
      "left" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[9379-9465]:VariableDeclarationStatement[9379-9465]"
    }, {
      "left" : "String reason = reasonInfo.string;",
      "right" : "String reason = reasonInfo.string;",
      "info" : "VariableDeclarationStatement[9485-9519]:VariableDeclarationStatement[9485-9519]"
    }, {
      "left" : "if (reason.length() > 0)",
      "right" : "if (reason.length() > 0)",
      "info" : "IfStatement[9539-9651]:IfStatement[9539-9651]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9564-9651]:Block[9564-9651]"
    }, {
      "left" : "jsdocBuilder.recordDeprecationReason(reason);",
      "right" : "jsdocBuilder.recordDeprecationReason(reason);",
      "info" : "ExpressionStatement[9586-9631]:ExpressionStatement[9586-9631]"
    }, {
      "left" : "token = reasonInfo.token;",
      "right" : "token = reasonInfo.token;",
      "info" : "ExpressionStatement[9671-9696]:ExpressionStatement[9671-9696]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[9715-9730]:ContinueStatement[9715-9730]"
    }, {
      "left" : "case INTERFACE:",
      "right" : "case INTERFACE:",
      "info" : "SwitchCase[9748-9763]:SwitchCase[9748-9763]"
    }, {
      "left" : "if (!jsdocBuilder.recordInterface())",
      "right" : "if (!jsdocBuilder.recordInterface())",
      "info" : "IfStatement[9782-10239]:IfStatement[9782-10239]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9819-10239]:Block[9819-10239]"
    }, {
      "left" : "if (jsdocBuilder.isConstructorRecorded())",
      "right" : "if (jsdocBuilder.isConstructorRecorded())",
      "info" : "IfStatement[9841-10219]:IfStatement[9841-10219]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9883-10052]:Block[9883-10052]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[9907-10030]:ExpressionStatement[9907-10030]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10058-10219]:Block[10058-10219]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[10082-10197]:ExpressionStatement[10082-10197]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[10258-10286]:ExpressionStatement[10258-10286]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[10305-10320]:ContinueStatement[10305-10320]"
    }, {
      "left" : "case DESC:",
      "right" : "case DESC:",
      "info" : "SwitchCase[10338-10348]:SwitchCase[10338-10348]"
    }, {
      "left" : "if (jsdocBuilder.isDescriptionRecorded())",
      "right" : "if (jsdocBuilder.isDescriptionRecorded())",
      "info" : "IfStatement[10367-11008]:IfStatement[10367-11008]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10409-10648]:Block[10409-10648]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[10431-10543]:ExpressionStatement[10431-10543]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[10564-10592]:ExpressionStatement[10564-10592]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[10613-10628]:ContinueStatement[10613-10628]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10654-11008]:Block[10654-11008]"
    }, {
      "left" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[10676-10769]:VariableDeclarationStatement[10676-10769]"
    }, {
      "left" : "String description = descriptionInfo.string;",
      "right" : "String description = descriptionInfo.string;",
      "info" : "VariableDeclarationStatement[10791-10835]:VariableDeclarationStatement[10791-10835]"
    }, {
      "left" : "jsdocBuilder.recordDescription(description);",
      "right" : "jsdocBuilder.recordDescription(description);",
      "info" : "ExpressionStatement[10857-10901]:ExpressionStatement[10857-10901]"
    }, {
      "left" : "token = descriptionInfo.token;",
      "right" : "token = descriptionInfo.token;",
      "info" : "ExpressionStatement[10922-10952]:ExpressionStatement[10922-10952]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[10973-10988]:ContinueStatement[10973-10988]"
    }, {
      "left" : "case FILE_OVERVIEW:",
      "right" : "case FILE_OVERVIEW:",
      "info" : "SwitchCase[11026-11045]:SwitchCase[11026-11045]"
    }, {
      "left" : "String fileOverview = \"\";",
      "right" : "String fileOverview = \"\";",
      "info" : "VariableDeclarationStatement[11064-11089]:VariableDeclarationStatement[11064-11089]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[11108-11535]:IfStatement[11108-11535]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11153-11454]:Block[11153-11454]"
    }, {
      "left" : "ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);",
      "right" : "ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);",
      "info" : "VariableDeclarationStatement[11175-11320]:VariableDeclarationStatement[11175-11320]"
    }, {
      "left" : "fileOverview = fileOverviewInfo.string;",
      "right" : "fileOverview = fileOverviewInfo.string;",
      "info" : "ExpressionStatement[11342-11381]:ExpressionStatement[11342-11381]"
    }, {
      "left" : "token = fileOverviewInfo.token;",
      "right" : "token = fileOverviewInfo.token;",
      "info" : "ExpressionStatement[11403-11434]:ExpressionStatement[11403-11434]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11460-11535]:Block[11460-11535]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[11482-11515]:ExpressionStatement[11482-11515]"
    }, {
      "left" : "if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null)",
      "right" : "if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null)",
      "info" : "IfStatement[11555-11824]:IfStatement[11555-11824]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11662-11824]:Block[11662-11824]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[11684-11804]:ExpressionStatement[11684-11804]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[11843-11858]:ContinueStatement[11843-11858]"
    }, {
      "left" : "case LICENSE:",
      "right" : "case LICENSE:",
      "info" : "SwitchCase[11876-11889]:SwitchCase[11876-11889]"
    }, {
      "left" : "case PRESERVE:",
      "right" : "case PRESERVE:",
      "info" : "SwitchCase[11906-11920]:SwitchCase[11906-11920]"
    }, {
      "left" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
      "right" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
      "info" : "VariableDeclarationStatement[11939-12105]:VariableDeclarationStatement[11939-12105]"
    }, {
      "left" : "String preserve = preserveInfo.string;",
      "right" : "String preserve = preserveInfo.string;",
      "info" : "VariableDeclarationStatement[12125-12163]:VariableDeclarationStatement[12125-12163]"
    }, {
      "left" : "if (preserve.length() > 0)",
      "right" : "if (preserve.length() > 0)",
      "info" : "IfStatement[12183-12372]:IfStatement[12183-12372]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12210-12372]:Block[12210-12372]"
    }, {
      "left" : "if (fileLevelJsDocBuilder != null)",
      "right" : "if (fileLevelJsDocBuilder != null)",
      "info" : "IfStatement[12232-12352]:IfStatement[12232-12352]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12267-12352]:Block[12267-12352]"
    }, {
      "left" : "fileLevelJsDocBuilder.append(preserve);",
      "right" : "fileLevelJsDocBuilder.append(preserve);",
      "info" : "ExpressionStatement[12291-12330]:ExpressionStatement[12291-12330]"
    }, {
      "left" : "token = preserveInfo.token;",
      "right" : "token = preserveInfo.token;",
      "info" : "ExpressionStatement[12392-12419]:ExpressionStatement[12392-12419]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[12438-12453]:ContinueStatement[12438-12453]"
    }, {
      "left" : "case ENUM:",
      "right" : "case ENUM:",
      "info" : "SwitchCase[12471-12481]:SwitchCase[12471-12481]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[12500-12515]:ExpressionStatement[12500-12515]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[12534-12562]:ExpressionStatement[12534-12562]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[12581-12609]:ExpressionStatement[12581-12609]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[12629-12641]:ExpressionStatement[12629-12641]"
    }, {
      "left" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
      "info" : "IfStatement[12660-12844]:IfStatement[12660-12844]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12716-12844]:Block[12716-12844]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "info" : "ExpressionStatement[12738-12824]:ExpressionStatement[12738-12824]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[12864-12979]:IfStatement[12864-12979]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12882-12979]:Block[12882-12979]"
    }, {
      "left" : "type = createJSTypeExpression(newStringNode(\"number\"));",
      "right" : "type = createJSTypeExpression(newStringNode(\"number\"));",
      "info" : "ExpressionStatement[12904-12959]:ExpressionStatement[12904-12959]"
    }, {
      "left" : "if (!jsdocBuilder.recordEnumParameterType(type))",
      "right" : "if (!jsdocBuilder.recordEnumParameterType(type))",
      "info" : "IfStatement[12998-13179]:IfStatement[12998-13179]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13047-13179]:Block[13047-13179]"
    }, {
      "left" : "parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[13069-13159]:ExpressionStatement[13069-13159]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[13198-13231]:ExpressionStatement[13198-13231]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[13250-13265]:ContinueStatement[13250-13265]"
    }, {
      "left" : "case EXPORT:",
      "right" : "case EXPORT:",
      "info" : "SwitchCase[13283-13295]:SwitchCase[13283-13295]"
    }, {
      "left" : "if (!jsdocBuilder.recordExport())",
      "right" : "if (!jsdocBuilder.recordExport())",
      "info" : "IfStatement[13314-13498]:IfStatement[13314-13498]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13348-13498]:Block[13348-13498]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[13370-13478]:ExpressionStatement[13370-13478]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[13517-13545]:ExpressionStatement[13517-13545]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[13564-13579]:ContinueStatement[13564-13579]"
    }, {
      "left" : "case EXTERNS:",
      "right" : "case EXTERNS:",
      "info" : "SwitchCase[13597-13610]:SwitchCase[13597-13610]"
    }, {
      "left" : "if (!jsdocBuilder.recordExterns())",
      "right" : "if (!jsdocBuilder.recordExterns())",
      "info" : "IfStatement[13629-13815]:IfStatement[13629-13815]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13664-13815]:Block[13664-13815]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[13686-13795]:ExpressionStatement[13686-13795]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[13834-13862]:ExpressionStatement[13834-13862]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[13881-13896]:ContinueStatement[13881-13896]"
    }, {
      "left" : "case JAVA_DISPATCH:",
      "right" : "case JAVA_DISPATCH:",
      "info" : "SwitchCase[13914-13933]:SwitchCase[13914-13933]"
    }, {
      "left" : "if (!jsdocBuilder.recordJavaDispatch())",
      "right" : "if (!jsdocBuilder.recordJavaDispatch())",
      "info" : "IfStatement[13952-14148]:IfStatement[13952-14148]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13992-14148]:Block[13992-14148]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[14014-14128]:ExpressionStatement[14014-14128]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[14167-14195]:ExpressionStatement[14167-14195]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[14214-14229]:ContinueStatement[14214-14229]"
    }, {
      "left" : "case EXTENDS:",
      "right" : "case EXTENDS:",
      "info" : "SwitchCase[14247-14260]:SwitchCase[14247-14260]"
    }, {
      "left" : "case IMPLEMENTS:",
      "right" : "case IMPLEMENTS:",
      "info" : "SwitchCase[14277-14293]:SwitchCase[14277-14293]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[14312-14323]:ExpressionStatement[14312-14323]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[14342-14357]:ExpressionStatement[14342-14357]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[14376-14404]:ExpressionStatement[14376-14404]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[14423-14451]:ExpressionStatement[14423-14451]"
    }, {
      "left" : "boolean matchingRc = false;",
      "right" : "boolean matchingRc = false;",
      "info" : "VariableDeclarationStatement[14470-14497]:VariableDeclarationStatement[14470-14497]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[14517-14641]:IfStatement[14517-14641]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14545-14641]:Block[14545-14641]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[14567-14582]:ExpressionStatement[14567-14582]"
    }, {
      "left" : "matchingRc = true;",
      "right" : "matchingRc = true;",
      "info" : "ExpressionStatement[14603-14621]:ExpressionStatement[14603-14621]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[14661-16560]:IfStatement[14661-16560]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14693-16454]:Block[14693-16454]"
    }, {
      "left" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
      "right" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
      "info" : "VariableDeclarationStatement[14715-14818]:VariableDeclarationStatement[14715-14818]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[14840-14868]:ExpressionStatement[14840-14868]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[14889-14917]:ExpressionStatement[14889-14917]"
    }, {
      "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "info" : "ExpressionStatement[14939-14981]:ExpressionStatement[14939-14981]"
    }, {
      "left" : "if (typeNode != null && !matchingRc)",
      "right" : "if (typeNode != null && !matchingRc)",
      "info" : "IfStatement[15002-15136]:IfStatement[15002-15136]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15039-15136]:Block[15039-15136]"
    }, {
      "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "info" : "ExpressionStatement[15063-15114]:ExpressionStatement[15063-15114]"
    }, {
      "left" : "type = createJSTypeExpression(typeNode);",
      "right" : "type = createJSTypeExpression(typeNode);",
      "info" : "ExpressionStatement[15157-15197]:ExpressionStatement[15157-15197]"
    }, {
      "left" : "if (annotation == Annotation.EXTENDS)",
      "right" : "if (annotation == Annotation.EXTENDS)",
      "info" : "IfStatement[15219-15845]:IfStatement[15219-15845]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15257-15479]:Block[15257-15479]"
    }, {
      "left" : "extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));",
      "right" : "extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));",
      "info" : "ExpressionStatement[15344-15457]:ExpressionStatement[15344-15457]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15485-15845]:Block[15485-15845]"
    }, {
      "left" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
      "right" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
      "info" : "ExpressionStatement[15509-15598]:ExpressionStatement[15509-15598]"
    }, {
      "left" : "if (!jsdocBuilder.recordImplementedInterface(type))",
      "right" : "if (!jsdocBuilder.recordImplementedInterface(type))",
      "info" : "IfStatement[15621-15823]:IfStatement[15621-15823]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15673-15823]:Block[15673-15823]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
      "info" : "ExpressionStatement[15699-15799]:ExpressionStatement[15699-15799]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[15866-15881]:ExpressionStatement[15866-15881]"
    }, {
      "left" : "if (matchingRc)",
      "right" : "if (matchingRc)",
      "info" : "IfStatement[15902-16434]:IfStatement[15902-16434]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15918-16156]:Block[15918-16156]"
    }, {
      "left" : "if (token != JsDocToken.RC)",
      "right" : "if (token != JsDocToken.RC)",
      "info" : "IfStatement[15942-16134]:IfStatement[15942-16134]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15970-16134]:Block[15970-16134]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[15996-16110]:ExpressionStatement[15996-16110]"
    }, {
      "left" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
      "right" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
      "info" : "IfStatement[16162-16434]:IfStatement[16162-16434]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16269-16434]:Block[16269-16434]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[16293-16412]:ExpressionStatement[16293-16412]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16460-16560]:Block[16460-16560]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);",
      "info" : "ExpressionStatement[16482-16540]:ExpressionStatement[16482-16540]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[16579-16612]:ExpressionStatement[16579-16612]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[16631-16646]:ContinueStatement[16631-16646]"
    }, {
      "left" : "case HIDDEN:",
      "right" : "case HIDDEN:",
      "info" : "SwitchCase[16664-16676]:SwitchCase[16664-16676]"
    }, {
      "left" : "if (!jsdocBuilder.recordHiddenness())",
      "right" : "if (!jsdocBuilder.recordHiddenness())",
      "info" : "IfStatement[16695-16883]:IfStatement[16695-16883]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16733-16883]:Block[16733-16883]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[16755-16863]:ExpressionStatement[16755-16863]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[16902-16930]:ExpressionStatement[16902-16930]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[16949-16964]:ContinueStatement[16949-16964]"
    }, {
      "left" : "case LENDS:",
      "right" : "case LENDS:",
      "info" : "SwitchCase[16982-16993]:SwitchCase[16982-16993]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[17012-17023]:ExpressionStatement[17012-17023]"
    }, {
      "left" : "matchingRc = false;",
      "right" : "matchingRc = false;",
      "info" : "ExpressionStatement[17043-17062]:ExpressionStatement[17043-17062]"
    }, {
      "left" : "if (match(JsDocToken.LC))",
      "right" : "if (match(JsDocToken.LC))",
      "info" : "IfStatement[17081-17203]:IfStatement[17081-17203]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17107-17203]:Block[17107-17203]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[17129-17144]:ExpressionStatement[17129-17144]"
    }, {
      "left" : "matchingRc = true;",
      "right" : "matchingRc = true;",
      "info" : "ExpressionStatement[17165-17183]:ExpressionStatement[17165-17183]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[17223-17709]:IfStatement[17223-17709]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17253-17548]:Block[17253-17548]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[17275-17290]:ExpressionStatement[17275-17290]"
    }, {
      "left" : "if (!jsdocBuilder.recordLends(stream.getString()))",
      "right" : "if (!jsdocBuilder.recordLends(stream.getString()))",
      "info" : "IfStatement[17311-17528]:IfStatement[17311-17528]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17362-17528]:Block[17362-17528]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[17386-17506]:ExpressionStatement[17386-17506]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17554-17709]:Block[17554-17709]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[17576-17689]:ExpressionStatement[17576-17689]"
    }, {
      "left" : "if (matchingRc && !match(JsDocToken.RC))",
      "right" : "if (matchingRc && !match(JsDocToken.RC))",
      "info" : "IfStatement[17729-17922]:IfStatement[17729-17922]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17770-17922]:Block[17770-17922]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[17792-17902]:ExpressionStatement[17792-17902]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[17941-17969]:ExpressionStatement[17941-17969]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[17988-18003]:ContinueStatement[17988-18003]"
    }, {
      "left" : "case MEANING:",
      "right" : "case MEANING:",
      "info" : "SwitchCase[18021-18034]:SwitchCase[18021-18034]"
    }, {
      "left" : "ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[18053-18140]:VariableDeclarationStatement[18053-18140]"
    }, {
      "left" : "String meaning = meaningInfo.string;",
      "right" : "String meaning = meaningInfo.string;",
      "info" : "VariableDeclarationStatement[18159-18195]:VariableDeclarationStatement[18159-18195]"
    }, {
      "left" : "token = meaningInfo.token;",
      "right" : "token = meaningInfo.token;",
      "info" : "ExpressionStatement[18214-18240]:ExpressionStatement[18214-18240]"
    }, {
      "left" : "if (!jsdocBuilder.recordMeaning(meaning))",
      "right" : "if (!jsdocBuilder.recordMeaning(meaning))",
      "info" : "IfStatement[18259-18458]:IfStatement[18259-18458]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18301-18458]:Block[18301-18458]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[18323-18438]:ExpressionStatement[18323-18438]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[18477-18492]:ContinueStatement[18477-18492]"
    }, {
      "left" : "case NO_ALIAS:",
      "right" : "case NO_ALIAS:",
      "info" : "SwitchCase[18510-18524]:SwitchCase[18510-18524]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoAlias())",
      "right" : "if (!jsdocBuilder.recordNoAlias())",
      "info" : "IfStatement[18543-18729]:IfStatement[18543-18729]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18578-18729]:Block[18578-18729]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[18600-18709]:ExpressionStatement[18600-18709]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[18748-18776]:ExpressionStatement[18748-18776]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[18795-18810]:ContinueStatement[18795-18810]"
    }, {
      "left" : "case NO_COMPILE:",
      "right" : "case NO_COMPILE:",
      "info" : "SwitchCase[18828-18844]:SwitchCase[18828-18844]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoCompile())",
      "right" : "if (!jsdocBuilder.recordNoCompile())",
      "info" : "IfStatement[18863-19053]:IfStatement[18863-19053]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18900-19053]:Block[18900-19053]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[18922-19033]:ExpressionStatement[18922-19033]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[19072-19100]:ExpressionStatement[19072-19100]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[19119-19134]:ContinueStatement[19119-19134]"
    }, {
      "left" : "case NO_TYPE_CHECK:",
      "right" : "case NO_TYPE_CHECK:",
      "info" : "SwitchCase[19152-19171]:SwitchCase[19152-19171]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoTypeCheck())",
      "right" : "if (!jsdocBuilder.recordNoTypeCheck())",
      "info" : "IfStatement[19190-19380]:IfStatement[19190-19380]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19229-19380]:Block[19229-19380]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[19251-19360]:ExpressionStatement[19251-19360]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[19399-19427]:ExpressionStatement[19399-19427]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[19446-19461]:ContinueStatement[19446-19461]"
    }, {
      "left" : "case NOT_IMPLEMENTED:",
      "right" : "case NOT_IMPLEMENTED:",
      "info" : "SwitchCase[19479-19500]:SwitchCase[19479-19500]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[19519-19547]:ExpressionStatement[19519-19547]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[19566-19581]:ContinueStatement[19566-19581]"
    }, {
      "left" : "case INHERIT_DOC:",
      "right" : "case INHERIT_DOC:",
      "info" : "SwitchCase[19599-19616]:SwitchCase[19599-19616]"
    }, {
      "left" : "case OVERRIDE:",
      "right" : "case OVERRIDE:",
      "info" : "SwitchCase[19633-19647]:SwitchCase[19633-19647]"
    }, {
      "left" : "if (!jsdocBuilder.recordOverride())",
      "right" : "if (!jsdocBuilder.recordOverride())",
      "info" : "IfStatement[19666-19852]:IfStatement[19666-19852]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19702-19852]:Block[19702-19852]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[19724-19832]:ExpressionStatement[19724-19832]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[19871-19899]:ExpressionStatement[19871-19899]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[19918-19933]:ContinueStatement[19918-19933]"
    }, {
      "left" : "case THROWS:",
      "right" : "case THROWS:",
      "info" : "SwitchCase[19951-19963]:SwitchCase[19951-19963]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[19982-19993]:ExpressionStatement[19982-19993]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[20012-20027]:ExpressionStatement[20012-20027]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[20046-20074]:ExpressionStatement[20046-20074]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[20093-20121]:ExpressionStatement[20093-20121]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[20140-20152]:ExpressionStatement[20140-20152]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[20172-20597]:IfStatement[20172-20597]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20200-20597]:Block[20200-20597]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
      "info" : "ExpressionStatement[20222-20308]:ExpressionStatement[20222-20308]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[20330-20577]:IfStatement[20330-20577]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20348-20577]:Block[20348-20577]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[20489-20517]:ExpressionStatement[20489-20517]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[20540-20555]:ContinueStatement[20540-20555]"
    }, {
      "left" : "token = current();",
      "right" : "token = current();",
      "info" : "ExpressionStatement[20692-20710]:ExpressionStatement[20692-20710]"
    }, {
      "left" : "jsdocBuilder.recordThrowType(type);",
      "right" : "jsdocBuilder.recordThrowType(type);",
      "info" : "ExpressionStatement[20772-20807]:ExpressionStatement[20772-20807]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[20894-21426]:IfStatement[20894-21426]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20939-21345]:Block[20939-21345]"
    }, {
      "left" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[20961-21054]:VariableDeclarationStatement[20961-21054]"
    }, {
      "left" : "String description = descriptionInfo.string;",
      "right" : "String description = descriptionInfo.string;",
      "info" : "VariableDeclarationStatement[21076-21120]:VariableDeclarationStatement[21076-21120]"
    }, {
      "left" : "if (description.length() > 0)",
      "right" : "if (description.length() > 0)",
      "info" : "IfStatement[21142-21273]:IfStatement[21142-21273]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21172-21273]:Block[21172-21273]"
    }, {
      "left" : "jsdocBuilder.recordThrowDescription(type, description);",
      "right" : "jsdocBuilder.recordThrowDescription(type, description);",
      "info" : "ExpressionStatement[21196-21251]:ExpressionStatement[21196-21251]"
    }, {
      "left" : "token = descriptionInfo.token;",
      "right" : "token = descriptionInfo.token;",
      "info" : "ExpressionStatement[21295-21325]:ExpressionStatement[21295-21325]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21351-21426]:Block[21351-21426]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[21373-21406]:ExpressionStatement[21373-21406]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[21445-21460]:ContinueStatement[21445-21460]"
    }, {
      "left" : "case PARAM:",
      "right" : "case PARAM:",
      "info" : "SwitchCase[21478-21489]:SwitchCase[21478-21489]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[21508-21519]:ExpressionStatement[21508-21519]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[21538-21553]:ExpressionStatement[21538-21553]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[21572-21600]:ExpressionStatement[21572-21600]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[21619-21647]:ExpressionStatement[21619-21647]"
    }, {
      "left" : "type = null;",
      "right" : "type = null;",
      "info" : "ExpressionStatement[21666-21678]:ExpressionStatement[21666-21678]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[21698-22294]:IfStatement[21698-22294]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21726-22294]:Block[21726-22294]"
    }, {
      "left" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
      "right" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
      "info" : "ExpressionStatement[21748-21839]:ExpressionStatement[21748-21839]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[21861-22108]:IfStatement[21861-22108]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21879-22108]:Block[21879-22108]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[22020-22048]:ExpressionStatement[22020-22048]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[22071-22086]:ContinueStatement[22071-22086]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[22129-22140]:ExpressionStatement[22129-22140]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[22161-22176]:ExpressionStatement[22161-22176]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[22197-22225]:ExpressionStatement[22197-22225]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[22246-22274]:ExpressionStatement[22246-22274]"
    }, {
      "left" : "String name = null;",
      "right" : "String name = null;",
      "info" : "VariableDeclarationStatement[22314-22333]:VariableDeclarationStatement[22314-22333]"
    }, {
      "left" : "boolean isBracketedParam = JsDocToken.LB == token;",
      "right" : "boolean isBracketedParam = JsDocToken.LB == token;",
      "info" : "VariableDeclarationStatement[22352-22402]:VariableDeclarationStatement[22352-22402]"
    }, {
      "left" : "if (isBracketedParam)",
      "right" : "if (isBracketedParam)",
      "info" : "IfStatement[22421-22500]:IfStatement[22421-22500]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22443-22500]:Block[22443-22500]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[22465-22480]:ExpressionStatement[22465-22480]"
    }, {
      "left" : "if (JsDocToken.STRING != token)",
      "right" : "if (JsDocToken.STRING != token)",
      "info" : "IfStatement[22520-24418]:IfStatement[22520-24418]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22552-22685]:Block[22552-22685]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
      "info" : "ExpressionStatement[22574-22665]:ExpressionStatement[22574-22665]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22691-24418]:Block[22691-24418]"
    }, {
      "left" : "name = stream.getString();",
      "right" : "name = stream.getString();",
      "info" : "ExpressionStatement[22713-22739]:ExpressionStatement[22713-22739]"
    }, {
      "left" : "if (isBracketedParam)",
      "right" : "if (isBracketedParam)",
      "info" : "IfStatement[22761-23645]:IfStatement[22761-23645]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22783-23645]:Block[22783-23645]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[22807-22822]:ExpressionStatement[22807-22822]"
    }, {
      "left" : "if (JsDocToken.EQUALS == token)",
      "right" : "if (JsDocToken.EQUALS == token)",
      "info" : "IfStatement[23020-23243]:IfStatement[23020-23243]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23052-23243]:Block[23052-23243]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[23078-23093]:ExpressionStatement[23078-23093]"
    }, {
      "left" : "if (JsDocToken.STRING == token)",
      "right" : "if (JsDocToken.STRING == token)",
      "info" : "IfStatement[23118-23219]:IfStatement[23118-23219]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23150-23219]:Block[23150-23219]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[23178-23193]:ExpressionStatement[23178-23193]"
    }, {
      "left" : "if (JsDocToken.RB != token)",
      "right" : "if (JsDocToken.RB != token)",
      "info" : "IfStatement[23267-23623]:IfStatement[23267-23623]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23295-23393]:Block[23295-23393]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ExpressionStatement[23321-23369]:ExpressionStatement[23321-23369]"
    }, {
      "left" : "if (type != null)",
      "right" : "if (type != null)",
      "info" : "IfStatement[23399-23623]:IfStatement[23399-23623]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23417-23623]:Block[23417-23623]"
    }, {
      "left" : "type = JSTypeExpression.makeOptionalArg(type);",
      "right" : "type = JSTypeExpression.makeOptionalArg(type);",
      "info" : "ExpressionStatement[23553-23599]:ExpressionStatement[23553-23599]"
    }, {
      "left" : "if (name.indexOf('.') > -1)",
      "right" : "if (name.indexOf('.') > -1)",
      "info" : "IfStatement[23874-24398]:IfStatement[23874-24398]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23902-23960]:Block[23902-23960]"
    }, {
      "left" : "name = null;",
      "right" : "name = null;",
      "info" : "ExpressionStatement[23926-23938]:ExpressionStatement[23926-23938]"
    }, {
      "left" : "if (!jsdocBuilder.recordParameter(name, type))",
      "right" : "if (!jsdocBuilder.recordParameter(name, type))",
      "info" : "IfStatement[23966-24398]:IfStatement[23966-24398]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24013-24398]:Block[24013-24398]"
    }, {
      "left" : "if (jsdocBuilder.hasParameter(name))",
      "right" : "if (jsdocBuilder.hasParameter(name))",
      "info" : "IfStatement[24037-24376]:IfStatement[24037-24376]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24074-24221]:Block[24074-24221]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
      "info" : "ExpressionStatement[24100-24197]:ExpressionStatement[24100-24197]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24227-24376]:Block[24227-24376]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
      "info" : "ExpressionStatement[24253-24352]:ExpressionStatement[24253-24352]"
    }, {
      "left" : "if (name == null)",
      "right" : "if (name == null)",
      "info" : "IfStatement[24438-24567]:IfStatement[24438-24567]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24456-24567]:Block[24456-24567]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[24478-24511]:ExpressionStatement[24478-24511]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[24532-24547]:ContinueStatement[24532-24547]"
    }, {
      "left" : "jsdocBuilder.markName(name, lineno, charno);",
      "right" : "jsdocBuilder.markName(name, lineno, charno);",
      "info" : "ExpressionStatement[24587-24631]:ExpressionStatement[24587-24631]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[24722-25314]:IfStatement[24722-25314]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24767-25233]:Block[24767-25233]"
    }, {
      "left" : "ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[24789-24887]:VariableDeclarationStatement[24789-24887]"
    }, {
      "left" : "String paramDescription = paramDescriptionInfo.string;",
      "right" : "String paramDescription = paramDescriptionInfo.string;",
      "info" : "VariableDeclarationStatement[24909-24963]:VariableDeclarationStatement[24909-24963]"
    }, {
      "left" : "if (paramDescription.length() > 0)",
      "right" : "if (paramDescription.length() > 0)",
      "info" : "IfStatement[24985-25156]:IfStatement[24985-25156]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25020-25156]:Block[25020-25156]"
    }, {
      "left" : "jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);",
      "right" : "jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);",
      "info" : "ExpressionStatement[25044-25134]:ExpressionStatement[25044-25134]"
    }, {
      "left" : "token = paramDescriptionInfo.token;",
      "right" : "token = paramDescriptionInfo.token;",
      "info" : "ExpressionStatement[25178-25213]:ExpressionStatement[25178-25213]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25239-25314]:Block[25239-25314]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[25261-25294]:ExpressionStatement[25261-25294]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[25333-25348]:ContinueStatement[25333-25348]"
    }, {
      "left" : "case PRESERVE_TRY:",
      "right" : "case PRESERVE_TRY:",
      "info" : "SwitchCase[25366-25384]:SwitchCase[25366-25384]"
    }, {
      "left" : "if (!jsdocBuilder.recordPreserveTry())",
      "right" : "if (!jsdocBuilder.recordPreserveTry())",
      "info" : "IfStatement[25403-25598]:IfStatement[25403-25598]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25442-25598]:Block[25442-25598]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[25464-25578]:ExpressionStatement[25464-25578]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[25617-25645]:ExpressionStatement[25617-25645]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[25664-25679]:ContinueStatement[25664-25679]"
    }, {
      "left" : "case PRIVATE:",
      "right" : "case PRIVATE:",
      "info" : "SwitchCase[25697-25710]:SwitchCase[25697-25710]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
      "info" : "IfStatement[25729-25947]:IfStatement[25729-25947]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25785-25947]:Block[25785-25947]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[25807-25927]:ExpressionStatement[25807-25927]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[25966-25994]:ExpressionStatement[25966-25994]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[26013-26028]:ContinueStatement[26013-26028]"
    }, {
      "left" : "case PROTECTED:",
      "right" : "case PROTECTED:",
      "info" : "SwitchCase[26046-26061]:SwitchCase[26046-26061]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
      "info" : "IfStatement[26080-26302]:IfStatement[26080-26302]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26138-26302]:Block[26138-26302]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[26160-26282]:ExpressionStatement[26160-26282]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[26321-26349]:ExpressionStatement[26321-26349]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[26368-26383]:ContinueStatement[26368-26383]"
    }, {
      "left" : "case PUBLIC:",
      "right" : "case PUBLIC:",
      "info" : "SwitchCase[26401-26413]:SwitchCase[26401-26413]"
    }, {
      "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
      "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
      "info" : "IfStatement[26432-26648]:IfStatement[26432-26648]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26487-26648]:Block[26487-26648]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[26509-26628]:ExpressionStatement[26509-26628]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[26667-26695]:ExpressionStatement[26667-26695]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[26714-26729]:ContinueStatement[26714-26729]"
    }, {
      "left" : "case NO_SHADOW:",
      "right" : "case NO_SHADOW:",
      "info" : "SwitchCase[26747-26762]:SwitchCase[26747-26762]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoShadow())",
      "right" : "if (!jsdocBuilder.recordNoShadow())",
      "info" : "IfStatement[26781-26969]:IfStatement[26781-26969]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26817-26969]:Block[26817-26969]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[26839-26949]:ExpressionStatement[26839-26949]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[26988-27016]:ExpressionStatement[26988-27016]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[27035-27050]:ContinueStatement[27035-27050]"
    }, {
      "left" : "case NO_SIDE_EFFECTS:",
      "right" : "case NO_SIDE_EFFECTS:",
      "info" : "SwitchCase[27068-27089]:SwitchCase[27068-27089]"
    }, {
      "left" : "if (!jsdocBuilder.recordNoSideEffects())",
      "right" : "if (!jsdocBuilder.recordNoSideEffects())",
      "info" : "IfStatement[27108-27306]:IfStatement[27108-27306]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27149-27306]:Block[27149-27306]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[27171-27286]:ExpressionStatement[27171-27286]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[27325-27353]:ExpressionStatement[27325-27353]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[27372-27387]:ContinueStatement[27372-27387]"
    }, {
      "left" : "case MODIFIES:",
      "right" : "case MODIFIES:",
      "info" : "SwitchCase[27405-27419]:SwitchCase[27405-27419]"
    }, {
      "left" : "token = parseModifiesTag(next());",
      "right" : "token = parseModifiesTag(next());",
      "info" : "ExpressionStatement[27438-27471]:ExpressionStatement[27438-27471]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[27490-27505]:ContinueStatement[27490-27505]"
    }, {
      "left" : "case IMPLICIT_CAST:",
      "right" : "case IMPLICIT_CAST:",
      "info" : "SwitchCase[27523-27542]:SwitchCase[27523-27542]"
    }, {
      "left" : "if (!jsdocBuilder.recordImplicitCast())",
      "right" : "if (!jsdocBuilder.recordImplicitCast())",
      "info" : "IfStatement[27561-27755]:IfStatement[27561-27755]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27601-27755]:Block[27601-27755]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[27623-27735]:ExpressionStatement[27623-27735]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[27774-27802]:ExpressionStatement[27774-27802]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[27821-27836]:ContinueStatement[27821-27836]"
    }, {
      "left" : "case SEE:",
      "right" : "case SEE:",
      "info" : "SwitchCase[27854-27863]:SwitchCase[27854-27863]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[27882-28517]:IfStatement[27882-28517]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27927-28436]:Block[27927-28436]"
    }, {
      "left" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[27949-28005]:VariableDeclarationStatement[27949-28005]"
    }, {
      "left" : "String reference = referenceInfo.string;",
      "right" : "String reference = referenceInfo.string;",
      "info" : "VariableDeclarationStatement[28026-28066]:VariableDeclarationStatement[28026-28066]"
    }, {
      "left" : "if (reference.length() == 0)",
      "right" : "if (reference.length() == 0)",
      "info" : "IfStatement[28088-28366]:IfStatement[28088-28366]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28117-28277]:Block[28117-28277]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[28141-28255]:ExpressionStatement[28141-28255]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28283-28366]:Block[28283-28366]"
    }, {
      "left" : "jsdocBuilder.addReference(reference);",
      "right" : "jsdocBuilder.addReference(reference);",
      "info" : "ExpressionStatement[28307-28344]:ExpressionStatement[28307-28344]"
    }, {
      "left" : "token = referenceInfo.token;",
      "right" : "token = referenceInfo.token;",
      "info" : "ExpressionStatement[28388-28416]:ExpressionStatement[28388-28416]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28442-28517]:Block[28442-28517]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[28464-28497]:ExpressionStatement[28464-28497]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[28536-28551]:ContinueStatement[28536-28551]"
    }, {
      "left" : "case SUPPRESS:",
      "right" : "case SUPPRESS:",
      "info" : "SwitchCase[28569-28583]:SwitchCase[28569-28583]"
    }, {
      "left" : "token = parseSuppressTag(next());",
      "right" : "token = parseSuppressTag(next());",
      "info" : "ExpressionStatement[28602-28635]:ExpressionStatement[28602-28635]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[28654-28669]:ContinueStatement[28654-28669]"
    }, {
      "left" : "case TEMPLATE:",
      "right" : "case TEMPLATE:",
      "info" : "SwitchCase[28687-28701]:SwitchCase[28687-28701]"
    }, {
      "left" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[28720-28775]:VariableDeclarationStatement[28720-28775]"
    }, {
      "left" : "String templateTypeName = templateInfo.string;",
      "right" : "String templateTypeName = templateInfo.string;",
      "info" : "VariableDeclarationStatement[28794-28840]:VariableDeclarationStatement[28794-28840]"
    }, {
      "left" : "if (templateTypeName.length() == 0)",
      "right" : "if (templateTypeName.length() == 0)",
      "info" : "IfStatement[28860-29307]:IfStatement[28860-29307]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28896-29055]:Block[28896-29055]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[28918-29035]:ExpressionStatement[28918-29035]"
    }, {
      "left" : "if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName))",
      "right" : "if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName))",
      "info" : "IfStatement[29061-29307]:IfStatement[29061-29307]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29144-29307]:Block[29144-29307]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[29166-29287]:ExpressionStatement[29166-29287]"
    }, {
      "left" : "token = templateInfo.token;",
      "right" : "token = templateInfo.token;",
      "info" : "ExpressionStatement[29327-29354]:ExpressionStatement[29327-29354]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[29373-29388]:ContinueStatement[29373-29388]"
    }, {
      "left" : "case VERSION:",
      "right" : "case VERSION:",
      "info" : "SwitchCase[29406-29419]:SwitchCase[29406-29419]"
    }, {
      "left" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
      "right" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
      "info" : "VariableDeclarationStatement[29438-29492]:VariableDeclarationStatement[29438-29492]"
    }, {
      "left" : "String version = versionInfo.string;",
      "right" : "String version = versionInfo.string;",
      "info" : "VariableDeclarationStatement[29511-29547]:VariableDeclarationStatement[29511-29547]"
    }, {
      "left" : "if (version.length() == 0)",
      "right" : "if (version.length() == 0)",
      "info" : "IfStatement[29567-30007]:IfStatement[29567-30007]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29594-29754]:Block[29594-29754]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[29616-29734]:ExpressionStatement[29616-29734]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29760-30007]:Block[29760-30007]"
    }, {
      "left" : "if (!jsdocBuilder.recordVersion(version))",
      "right" : "if (!jsdocBuilder.recordVersion(version))",
      "info" : "IfStatement[29782-29987]:IfStatement[29782-29987]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29824-29987]:Block[29824-29987]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[29849-29965]:ExpressionStatement[29849-29965]"
    }, {
      "left" : "token = versionInfo.token;",
      "right" : "token = versionInfo.token;",
      "info" : "ExpressionStatement[30027-30053]:ExpressionStatement[30027-30053]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[30072-30087]:ContinueStatement[30072-30087]"
    }, {
      "left" : "case DEFINE:",
      "right" : "case DEFINE:",
      "info" : "SwitchCase[30105-30117]:SwitchCase[30105-30117]"
    }, {
      "left" : "case RETURN:",
      "right" : "case RETURN:",
      "info" : "SwitchCase[30134-30146]:SwitchCase[30134-30146]"
    }, {
      "left" : "case THIS:",
      "right" : "case THIS:",
      "info" : "SwitchCase[30163-30173]:SwitchCase[30163-30173]"
    }, {
      "left" : "case TYPE:",
      "right" : "case TYPE:",
      "info" : "SwitchCase[30190-30200]:SwitchCase[30190-30200]"
    }, {
      "left" : "case TYPEDEF:",
      "right" : "case TYPEDEF:",
      "info" : "SwitchCase[30217-30230]:SwitchCase[30217-30230]"
    }, {
      "left" : "lineno = stream.getLineno();",
      "right" : "lineno = stream.getLineno();",
      "info" : "ExpressionStatement[30249-30277]:ExpressionStatement[30249-30277]"
    }, {
      "left" : "charno = stream.getCharno();",
      "right" : "charno = stream.getCharno();",
      "info" : "ExpressionStatement[30296-30324]:ExpressionStatement[30296-30324]"
    }, {
      "left" : "Node typeNode = null;",
      "right" : "Node typeNode = null;",
      "info" : "VariableDeclarationStatement[30344-30365]:VariableDeclarationStatement[30344-30365]"
    }, {
      "left" : "if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN)",
      "right" : "if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN)",
      "info" : "IfStatement[30384-30842]:IfStatement[30384-30842]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30476-30669]:Block[30476-30669]"
    }, {
      "left" : "typeNode = newNode(Token.QMARK);",
      "right" : "typeNode = newNode(Token.QMARK);",
      "info" : "ExpressionStatement[30617-30649]:ExpressionStatement[30617-30649]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30675-30842]:Block[30675-30842]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[30697-30708]:ExpressionStatement[30697-30708]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[30729-30744]:ExpressionStatement[30729-30744]"
    }, {
      "left" : "typeNode = parseAndRecordTypeNode(token, lineno, charno);",
      "right" : "typeNode = parseAndRecordTypeNode(token, lineno, charno);",
      "info" : "ExpressionStatement[30765-30822]:ExpressionStatement[30765-30822]"
    }, {
      "left" : "if (annotation == Annotation.THIS)",
      "right" : "if (annotation == Annotation.THIS)",
      "info" : "IfStatement[30862-31147]:IfStatement[30862-31147]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30897-31147]:Block[30897-31147]"
    }, {
      "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
      "info" : "ExpressionStatement[30919-30961]:ExpressionStatement[30919-30961]"
    }, {
      "left" : "if (typeNode != null && token != JsDocToken.LC)",
      "right" : "if (typeNode != null && token != JsDocToken.LC)",
      "info" : "IfStatement[30982-31127]:IfStatement[30982-31127]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31030-31127]:Block[31030-31127]"
    }, {
      "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "info" : "ExpressionStatement[31054-31105]:ExpressionStatement[31054-31105]"
    }, {
      "left" : "type = createJSTypeExpression(typeNode);",
      "right" : "type = createJSTypeExpression(typeNode);",
      "info" : "ExpressionStatement[31166-31206]:ExpressionStatement[31166-31206]"
    }, {
      "left" : "if (type == null)",
      "right" : "if (type == null)",
      "info" : "IfStatement[31226-33736]:IfStatement[31226-33688]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31244-31370]:Block[31244-31370]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31376-33736]:Block[31376-33688]"
    }, {
      "left" : "switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
      "right" : "switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
      "info" : "SwitchStatement[31398-33668]:SwitchStatement[31398-33668]"
    }, {
      "left" : "case DEFINE:",
      "right" : "case DEFINE:",
      "info" : "SwitchCase[31442-31454]:SwitchCase[31442-31454]"
    }, {
      "left" : "if (!jsdocBuilder.recordDefineType(type))",
      "right" : "if (!jsdocBuilder.recordDefineType(type))",
      "info" : "IfStatement[31479-31665]:IfStatement[31479-31665]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31521-31665]:Block[31521-31665]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
      "right" : "parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
      "info" : "ExpressionStatement[31549-31639]:ExpressionStatement[31549-31639]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[31690-31696]:BreakStatement[31690-31696]"
    }, {
      "left" : "case RETURN:",
      "right" : "case RETURN:",
      "info" : "SwitchCase[31720-31732]:SwitchCase[31720-31732]"
    }, {
      "left" : "if (!jsdocBuilder.recordReturnType(type))",
      "right" : "if (!jsdocBuilder.recordReturnType(type))",
      "info" : "IfStatement[31757-31982]:IfStatement[31757-31982]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31799-31982]:Block[31799-31982]"
    }, {
      "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[31827-31923]:ExpressionStatement[31827-31923]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[31950-31956]:BreakStatement[31950-31956]"
    }, {
      "left" : "if (jsdocBuilder.shouldParseDocumentation())",
      "right" : "if (jsdocBuilder.shouldParseDocumentation())",
      "info" : "IfStatement[32082-32768]:IfStatement[32082-32768]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32127-32675]:Block[32127-32675]"
    }, {
      "left" : "ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);",
      "right" : "ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);",
      "info" : "VariableDeclarationStatement[32155-32260]:VariableDeclarationStatement[32155-32260]"
    }, {
      "left" : "String returnDescription =\n                              returnDescriptionInfo.string;",
      "right" : "String returnDescription =\n                              returnDescriptionInfo.string;",
      "info" : "VariableDeclarationStatement[32288-32374]:VariableDeclarationStatement[32288-32374]"
    }, {
      "left" : "if (returnDescription.length() > 0)",
      "right" : "if (returnDescription.length() > 0)",
      "info" : "IfStatement[32402-32585]:IfStatement[32402-32585]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32438-32585]:Block[32438-32585]"
    }, {
      "left" : "jsdocBuilder.recordReturnDescription(\n                                returnDescription);",
      "right" : "jsdocBuilder.recordReturnDescription(\n                                returnDescription);",
      "info" : "ExpressionStatement[32468-32557]:ExpressionStatement[32468-32557]"
    }, {
      "left" : "token = returnDescriptionInfo.token;",
      "right" : "token = returnDescriptionInfo.token;",
      "info" : "ExpressionStatement[32613-32649]:ExpressionStatement[32613-32649]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32681-32768]:Block[32681-32768]"
    }, {
      "left" : "token = eatTokensUntilEOL(token);",
      "right" : "token = eatTokensUntilEOL(token);",
      "info" : "ExpressionStatement[32709-32742]:ExpressionStatement[32709-32742]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[32793-32808]:ContinueStatement[32793-32808]"
    }, {
      "left" : "case THIS:",
      "right" : "case THIS:",
      "info" : "SwitchCase[32832-32842]:SwitchCase[32832-32842]"
    }, {
      "left" : "if (!jsdocBuilder.recordThisType(type))",
      "right" : "if (!jsdocBuilder.recordThisType(type))",
      "info" : "IfStatement[32867-33057]:IfStatement[32867-33057]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32907-33057]:Block[32907-33057]"
    }, {
      "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[32935-33031]:ExpressionStatement[32935-33031]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[33082-33088]:BreakStatement[33082-33088]"
    }, {
      "left" : "case TYPE:",
      "right" : "case TYPE:",
      "info" : "SwitchCase[33112-33122]:SwitchCase[33112-33122]"
    }, {
      "left" : "if (!jsdocBuilder.recordType(type))",
      "right" : "if (!jsdocBuilder.recordType(type))",
      "info" : "IfStatement[33147-33333]:IfStatement[33147-33333]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33183-33333]:Block[33183-33333]"
    }, {
      "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[33211-33307]:ExpressionStatement[33211-33307]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[33358-33364]:BreakStatement[33358-33364]"
    }, {
      "left" : "case TYPEDEF:",
      "right" : "case TYPEDEF:",
      "info" : "SwitchCase[33388-33401]:SwitchCase[33388-33401]"
    }, {
      "left" : "if (!jsdocBuilder.recordTypedef(type))",
      "right" : "if (!jsdocBuilder.recordTypedef(type))",
      "info" : "IfStatement[33426-33615]:IfStatement[33426-33615]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33465-33615]:Block[33465-33615]"
    }, {
      "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
      "info" : "ExpressionStatement[33493-33589]:ExpressionStatement[33493-33589]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[33640-33646]:BreakStatement[33640-33646]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[33688-33716]:ExpressionStatement[33708-33736]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[33755-33770]:ContinueStatement[33755-33770]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[33823-33829]:BreakStatement[33823-33829]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[33839-33848]:SwitchCase[33839-33848]"
    }, {
      "left" : "if (hasParsedFileOverviewDocInfo())",
      "right" : "if (hasParsedFileOverviewDocInfo())",
      "info" : "IfStatement[33859-33979]:IfStatement[33859-33979]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33895-33979]:Block[33895-33979]"
    }, {
      "left" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
      "right" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
      "info" : "ExpressionStatement[33909-33967]:ExpressionStatement[33909-33967]"
    }, {
      "left" : "checkExtendedTypes(extendedTypes);",
      "right" : "checkExtendedTypes(extendedTypes);",
      "info" : "ExpressionStatement[33990-34024]:ExpressionStatement[33990-34024]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[34035-34047]:ReturnStatement[34035-34047]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[34057-34066]:SwitchCase[34057-34066]"
    }, {
      "left" : "jsdocBuilder.build(null);",
      "right" : "jsdocBuilder.build(null);",
      "info" : "ExpressionStatement[34126-34151]:ExpressionStatement[34126-34151]"
    }, {
      "left" : "parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[34162-34262]:ExpressionStatement[34162-34262]"
    }, {
      "left" : "checkExtendedTypes(extendedTypes);",
      "right" : "checkExtendedTypes(extendedTypes);",
      "info" : "ExpressionStatement[34273-34307]:ExpressionStatement[34273-34307]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[34318-34331]:ReturnStatement[34318-34331]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[34341-34350]:SwitchCase[34341-34350]"
    }, {
      "left" : "if (state == State.SEARCHING_NEWLINE)",
      "right" : "if (state == State.SEARCHING_NEWLINE)",
      "info" : "IfStatement[34361-34460]:IfStatement[34361-34460]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34399-34460]:Block[34399-34460]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[34413-34448]:ExpressionStatement[34413-34448]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[34471-34486]:ExpressionStatement[34471-34486]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[34497-34512]:ContinueStatement[34497-34512]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[34522-34530]:SwitchCase[34522-34530]"
    }, {
      "left" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
      "right" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
      "info" : "IfStatement[34541-34812]:IfStatement[34541-34812]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34610-34679]:Block[34610-34679]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[34624-34639]:ExpressionStatement[34624-34639]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[34652-34667]:ContinueStatement[34652-34667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34685-34812]:Block[34685-34812]"
    }, {
      "left" : "state = State.SEARCHING_NEWLINE;",
      "right" : "state = State.SEARCHING_NEWLINE;",
      "info" : "ExpressionStatement[34699-34731]:ExpressionStatement[34699-34731]"
    }, {
      "left" : "token = eatTokensUntilEOL();",
      "right" : "token = eatTokensUntilEOL();",
      "info" : "ExpressionStatement[34744-34772]:ExpressionStatement[34744-34772]"
    }, {
      "left" : "continue retry;",
      "right" : "continue retry;",
      "info" : "ContinueStatement[34785-34800]:ContinueStatement[34785-34800]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[34848-34863]:ExpressionStatement[34848-34863]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[34947-35515]:Block[34947-35515]"
    }, {
      "left" : "for (ExtendedTypeInfo typeInfo : extendedTypes)",
      "right" : "for (ExtendedTypeInfo typeInfo : extendedTypes)",
      "info" : "EnhancedForStatement[34953-35511]:EnhancedForStatement[34953-35511]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35001-35511]:Block[35001-35511]"
    }, {
      "left" : "if (jsdocBuilder.isInterfaceRecorded())",
      "right" : "if (jsdocBuilder.isInterfaceRecorded())",
      "info" : "IfStatement[35072-35505]:IfStatement[35072-35505]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35112-35313]:Block[35112-35313]"
    }, {
      "left" : "if (!jsdocBuilder.recordExtendedInterface(typeInfo.type))",
      "right" : "if (!jsdocBuilder.recordExtendedInterface(typeInfo.type))",
      "info" : "IfStatement[35122-35305]:IfStatement[35122-35305]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35180-35305]:Block[35180-35305]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);",
      "right" : "parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);",
      "info" : "ExpressionStatement[35192-35295]:ExpressionStatement[35192-35295]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35319-35505]:Block[35319-35505]"
    }, {
      "left" : "if (!jsdocBuilder.recordBaseType(typeInfo.type))",
      "right" : "if (!jsdocBuilder.recordBaseType(typeInfo.type))",
      "info" : "IfStatement[35329-35497]:IfStatement[35329-35497]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35378-35497]:Block[35378-35497]"
    }, {
      "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);",
      "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);",
      "info" : "ExpressionStatement[35390-35487]:ExpressionStatement[35390-35487]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35727-36879]:Block[35727-36879]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[35733-36857]:IfStatement[35733-36857]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35761-36857]:Block[35761-36857]"
    }, {
      "left" : "Set<String> suppressions = new HashSet<String>();",
      "right" : "Set<String> suppressions = new HashSet<String>();",
      "info" : "VariableDeclarationStatement[35769-35818]:VariableDeclarationStatement[35769-35818]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[35825-36468]:WhileStatement[35825-36468]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35838-36468]:Block[35838-36468]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[35848-36351]:IfStatement[35848-36351]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35878-36199]:Block[35878-36199]"
    }, {
      "left" : "String name = stream.getString();",
      "right" : "String name = stream.getString();",
      "info" : "VariableDeclarationStatement[35890-35923]:VariableDeclarationStatement[35890-35923]"
    }, {
      "left" : "if (!suppressionNames.contains(name))",
      "right" : "if (!suppressionNames.contains(name))",
      "info" : "IfStatement[35934-36114]:IfStatement[35934-36114]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[35972-36114]:Block[35972-36114]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[35986-36102]:ExpressionStatement[35986-36102]"
    }, {
      "left" : "suppressions.add(stream.getString());",
      "right" : "suppressions.add(stream.getString());",
      "info" : "ExpressionStatement[36126-36163]:ExpressionStatement[36126-36163]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[36174-36189]:ExpressionStatement[36174-36189]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36205-36351]:Block[36205-36351]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[36217-36317]:ExpressionStatement[36217-36317]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[36328-36341]:ReturnStatement[36328-36341]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[36361-36460]:IfStatement[36361-36460]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36389-36426]:Block[36389-36426]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[36401-36416]:ExpressionStatement[36401-36416]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36432-36460]:Block[36432-36460]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[36444-36450]:BreakStatement[36444-36450]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[36476-36851]:IfStatement[36476-36851]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36503-36619]:Block[36503-36619]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[36513-36611]:ExpressionStatement[36513-36611]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36625-36851]:Block[36625-36851]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[36635-36650]:ExpressionStatement[36635-36650]"
    }, {
      "left" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
      "right" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
      "info" : "IfStatement[36659-36843]:IfStatement[36659-36843]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[36711-36843]:Block[36711-36843]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[36723-36833]:ExpressionStatement[36723-36833]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[36862-36875]:ReturnStatement[36862-36875]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37094-38294]:Block[37094-38294]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[37100-38272]:IfStatement[37100-38272]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37128-38272]:Block[37128-38272]"
    }, {
      "left" : "Set<String> modifies = new HashSet<String>();",
      "right" : "Set<String> modifies = new HashSet<String>();",
      "info" : "VariableDeclarationStatement[37136-37181]:VariableDeclarationStatement[37136-37181]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[37188-37891]:WhileStatement[37188-37891]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37201-37891]:Block[37201-37891]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[37211-37774]:IfStatement[37211-37774]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37241-37622]:Block[37241-37622]"
    }, {
      "left" : "String name = stream.getString();",
      "right" : "String name = stream.getString();",
      "info" : "VariableDeclarationStatement[37253-37286]:VariableDeclarationStatement[37253-37286]"
    }, {
      "left" : "if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name))",
      "right" : "if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name))",
      "info" : "IfStatement[37297-37541]:IfStatement[37297-37541]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37395-37541]:Block[37395-37541]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[37411-37529]:ExpressionStatement[37411-37529]"
    }, {
      "left" : "modifies.add(stream.getString());",
      "right" : "modifies.add(stream.getString());",
      "info" : "ExpressionStatement[37553-37586]:ExpressionStatement[37553-37586]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[37597-37612]:ExpressionStatement[37597-37612]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37628-37774]:Block[37628-37774]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[37640-37740]:ExpressionStatement[37640-37740]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[37751-37764]:ReturnStatement[37751-37764]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[37784-37883]:IfStatement[37784-37883]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37812-37849]:Block[37812-37849]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[37824-37839]:ExpressionStatement[37824-37839]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37855-37883]:Block[37855-37883]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[37867-37873]:BreakStatement[37867-37873]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[37899-38266]:IfStatement[37899-38266]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[37926-38042]:Block[37926-38042]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[37936-38034]:ExpressionStatement[37936-38034]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38048-38266]:Block[38048-38266]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[38058-38073]:ExpressionStatement[38058-38073]"
    }, {
      "left" : "if (!jsdocBuilder.recordModifies(modifies))",
      "right" : "if (!jsdocBuilder.recordModifies(modifies))",
      "info" : "IfStatement[38082-38258]:IfStatement[38082-38258]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38126-38258]:Block[38126-38258]"
    }, {
      "left" : "parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "right" : "parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[38138-38248]:ExpressionStatement[38138-38248]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[38277-38290]:ReturnStatement[38277-38290]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[38585-38656]:Block[38585-38656]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
      "right" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
      "info" : "ReturnStatement[38591-38652]:ReturnStatement[38591-38652]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39037-39151]:Block[39037-39151]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
      "right" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
      "info" : "ReturnStatement[39043-39147]:ReturnStatement[39043-39147]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[39609-39716]:Block[39609-39716]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, lineno, startCharno,\n        token == JsDocToken.LC, false);",
      "right" : "return parseAndRecordTypeNode(token, lineno, startCharno,\n        token == JsDocToken.LC, false);",
      "info" : "ReturnStatement[39615-39712]:ReturnStatement[39615-39712]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40304-40390]:Block[40304-40390]"
    }, {
      "left" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
      "right" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
      "info" : "ReturnStatement[40310-40386]:ReturnStatement[40310-40386]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[40909-41263]:Block[40909-41263]"
    }, {
      "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "info" : "ExpressionStatement[40915-40967]:ExpressionStatement[40915-40967]"
    }, {
      "left" : "int lineno = stream.getLineno();",
      "right" : "int lineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[40972-41004]:VariableDeclarationStatement[40972-41004]"
    }, {
      "left" : "int startCharno = stream.getCharno();",
      "right" : "int startCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[41009-41046]:VariableDeclarationStatement[41009-41046]"
    }, {
      "left" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
      "right" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
      "info" : "VariableDeclarationStatement[41052-41110]:VariableDeclarationStatement[41052-41110]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[41115-41150]:VariableDeclarationStatement[41115-41150]"
    }, {
      "left" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        true);",
      "right" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        true);",
      "info" : "ExpressionStatement[41156-41238]:ExpressionStatement[41156-41238]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[41243-41259]:ReturnStatement[41243-41259]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42135-42587]:Block[42135-42587]"
    }, {
      "left" : "Node typeNode = null;",
      "right" : "Node typeNode = null;",
      "info" : "VariableDeclarationStatement[42141-42162]:VariableDeclarationStatement[42141-42162]"
    }, {
      "left" : "if (onlyParseSimpleNames)",
      "right" : "if (onlyParseSimpleNames)",
      "info" : "IfStatement[42168-42318]:IfStatement[42168-42318]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42194-42250]:Block[42194-42250]"
    }, {
      "left" : "typeNode = parseTypeNameAnnotation(token);",
      "right" : "typeNode = parseTypeNameAnnotation(token);",
      "info" : "ExpressionStatement[42202-42244]:ExpressionStatement[42202-42244]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42256-42318]:Block[42256-42318]"
    }, {
      "left" : "typeNode = parseTypeExpressionAnnotation(token);",
      "right" : "typeNode = parseTypeExpressionAnnotation(token);",
      "info" : "ExpressionStatement[42264-42312]:ExpressionStatement[42264-42312]"
    }, {
      "left" : "if (typeNode != null && !matchingLC)",
      "right" : "if (typeNode != null && !matchingLC)",
      "info" : "IfStatement[42324-42426]:IfStatement[42324-42426]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42361-42426]:Block[42361-42426]"
    }, {
      "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
      "info" : "ExpressionStatement[42369-42420]:ExpressionStatement[42369-42420]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[42432-42467]:VariableDeclarationStatement[42432-42467]"
    }, {
      "left" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        matchingLC);",
      "right" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        matchingLC);",
      "info" : "ExpressionStatement[42473-42561]:ExpressionStatement[42473-42561]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[42567-42583]:ReturnStatement[42567-42583]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[42703-43533]:Block[42703-43533]"
    }, {
      "left" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
      "right" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
      "info" : "SwitchStatement[42709-43529]:SwitchStatement[42709-43529]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[42732-42748]:SwitchCase[42732-42748]"
    }, {
      "left" : "return \"@\" + stream.getString();",
      "right" : "return \"@\" + stream.getString();",
      "info" : "ReturnStatement[42757-42789]:ReturnStatement[42757-42789]"
    }, {
      "left" : "case BANG:",
      "right" : "case BANG:",
      "info" : "SwitchCase[42797-42807]:SwitchCase[42797-42807]"
    }, {
      "left" : "return \"!\";",
      "right" : "return \"!\";",
      "info" : "ReturnStatement[42816-42827]:ReturnStatement[42816-42827]"
    }, {
      "left" : "case COMMA:",
      "right" : "case COMMA:",
      "info" : "SwitchCase[42835-42846]:SwitchCase[42835-42846]"
    }, {
      "left" : "return \",\";",
      "right" : "return \",\";",
      "info" : "ReturnStatement[42855-42866]:ReturnStatement[42855-42866]"
    }, {
      "left" : "case COLON:",
      "right" : "case COLON:",
      "info" : "SwitchCase[42874-42885]:SwitchCase[42874-42885]"
    }, {
      "left" : "return \":\";",
      "right" : "return \":\";",
      "info" : "ReturnStatement[42894-42905]:ReturnStatement[42894-42905]"
    }, {
      "left" : "case GT:",
      "right" : "case GT:",
      "info" : "SwitchCase[42913-42921]:SwitchCase[42913-42921]"
    }, {
      "left" : "return \">\";",
      "right" : "return \">\";",
      "info" : "ReturnStatement[42930-42941]:ReturnStatement[42930-42941]"
    }, {
      "left" : "case LB:",
      "right" : "case LB:",
      "info" : "SwitchCase[42949-42957]:SwitchCase[42949-42957]"
    }, {
      "left" : "return \"[\";",
      "right" : "return \"[\";",
      "info" : "ReturnStatement[42966-42977]:ReturnStatement[42966-42977]"
    }, {
      "left" : "case LC:",
      "right" : "case LC:",
      "info" : "SwitchCase[42985-42993]:SwitchCase[42985-42993]"
    }, {
      "left" : "return \"{\";",
      "right" : "return \"{\";",
      "info" : "ReturnStatement[43002-43013]:ReturnStatement[43002-43013]"
    }, {
      "left" : "case LP:",
      "right" : "case LP:",
      "info" : "SwitchCase[43021-43029]:SwitchCase[43021-43029]"
    }, {
      "left" : "return \"(\";",
      "right" : "return \"(\";",
      "info" : "ReturnStatement[43038-43049]:ReturnStatement[43038-43049]"
    }, {
      "left" : "case LT:",
      "right" : "case LT:",
      "info" : "SwitchCase[43057-43065]:SwitchCase[43057-43065]"
    }, {
      "left" : "return \".<\";",
      "right" : "return \".<\";",
      "info" : "ReturnStatement[43074-43086]:ReturnStatement[43074-43086]"
    }, {
      "left" : "case QMARK:",
      "right" : "case QMARK:",
      "info" : "SwitchCase[43094-43105]:SwitchCase[43094-43105]"
    }, {
      "left" : "return \"?\";",
      "right" : "return \"?\";",
      "info" : "ReturnStatement[43114-43125]:ReturnStatement[43114-43125]"
    }, {
      "left" : "case PIPE:",
      "right" : "case PIPE:",
      "info" : "SwitchCase[43133-43143]:SwitchCase[43133-43143]"
    }, {
      "left" : "return \"|\";",
      "right" : "return \"|\";",
      "info" : "ReturnStatement[43152-43163]:ReturnStatement[43152-43163]"
    }, {
      "left" : "case RB:",
      "right" : "case RB:",
      "info" : "SwitchCase[43171-43179]:SwitchCase[43171-43179]"
    }, {
      "left" : "return \"]\";",
      "right" : "return \"]\";",
      "info" : "ReturnStatement[43188-43199]:ReturnStatement[43188-43199]"
    }, {
      "left" : "case RC:",
      "right" : "case RC:",
      "info" : "SwitchCase[43207-43215]:SwitchCase[43207-43215]"
    }, {
      "left" : "return \"}\";",
      "right" : "return \"}\";",
      "info" : "ReturnStatement[43224-43235]:ReturnStatement[43224-43235]"
    }, {
      "left" : "case RP:",
      "right" : "case RP:",
      "info" : "SwitchCase[43243-43251]:SwitchCase[43243-43251]"
    }, {
      "left" : "return \")\";",
      "right" : "return \")\";",
      "info" : "ReturnStatement[43260-43271]:ReturnStatement[43260-43271]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[43279-43289]:SwitchCase[43279-43289]"
    }, {
      "left" : "return \"*\";",
      "right" : "return \"*\";",
      "info" : "ReturnStatement[43298-43309]:ReturnStatement[43298-43309]"
    }, {
      "left" : "case ELLIPSIS:",
      "right" : "case ELLIPSIS:",
      "info" : "SwitchCase[43317-43331]:SwitchCase[43317-43331]"
    }, {
      "left" : "return \"...\";",
      "right" : "return \"...\";",
      "info" : "ReturnStatement[43340-43353]:ReturnStatement[43340-43353]"
    }, {
      "left" : "case EQUALS:",
      "right" : "case EQUALS:",
      "info" : "SwitchCase[43361-43373]:SwitchCase[43361-43373]"
    }, {
      "left" : "return \"=\";",
      "right" : "return \"=\";",
      "info" : "ReturnStatement[43382-43393]:ReturnStatement[43382-43393]"
    }, {
      "left" : "case STRING:",
      "right" : "case STRING:",
      "info" : "SwitchCase[43401-43413]:SwitchCase[43401-43413]"
    }, {
      "left" : "return stream.getString();",
      "right" : "return stream.getString();",
      "info" : "ReturnStatement[43422-43448]:ReturnStatement[43422-43448]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[43456-43464]:SwitchCase[43456-43464]"
    }, {
      "left" : "throw new IllegalStateException(token.toString());",
      "right" : "throw new IllegalStateException(token.toString());",
      "info" : "ThrowStatement[43473-43523]:ThrowStatement[43473-43523]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[43688-43768]:Block[43688-43768]"
    }, {
      "left" : "return n == null ? null :\n        new JSTypeExpression(n, sourceName);",
      "right" : "return n == null ? null :\n        new JSTypeExpression(n, sourceName);",
      "info" : "ReturnStatement[43694-43764]:ReturnStatement[43694-43764]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44084-44145]:Block[44084-44145]"
    }, {
      "left" : "this.string = string;",
      "right" : "this.string = string;",
      "info" : "ExpressionStatement[44092-44113]:ExpressionStatement[44092-44113]"
    }, {
      "left" : "this.token = token;",
      "right" : "this.token = token;",
      "info" : "ExpressionStatement[44120-44139]:ExpressionStatement[44120-44139]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44398-44485]:Block[44398-44485]"
    }, {
      "left" : "this.type = type;",
      "right" : "this.type = type;",
      "info" : "ExpressionStatement[44406-44423]:ExpressionStatement[44406-44423]"
    }, {
      "left" : "this.lineno = lineno;",
      "right" : "this.lineno = lineno;",
      "info" : "ExpressionStatement[44430-44451]:ExpressionStatement[44430-44451]"
    }, {
      "left" : "this.charno = charno;",
      "right" : "this.charno = charno;",
      "info" : "ExpressionStatement[44458-44479]:ExpressionStatement[44458-44479]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[44794-45228]:Block[44794-45228]"
    }, {
      "left" : "stream.update();",
      "right" : "stream.update();",
      "info" : "ExpressionStatement[44840-44856]:ExpressionStatement[44840-44856]"
    }, {
      "left" : "int lineno = stream.getLineno();",
      "right" : "int lineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[44861-44893]:VariableDeclarationStatement[44861-44893]"
    }, {
      "left" : "int charno = stream.getCharno() + 1;",
      "right" : "int charno = stream.getCharno() + 1;",
      "info" : "VariableDeclarationStatement[44898-44934]:VariableDeclarationStatement[44898-44934]"
    }, {
      "left" : "String line = stream.getRemainingJSDocLine().trim();",
      "right" : "String line = stream.getRemainingJSDocLine().trim();",
      "info" : "VariableDeclarationStatement[44940-44992]:VariableDeclarationStatement[44940-44992]"
    }, {
      "left" : "if (line.length() > 0)",
      "right" : "if (line.length() > 0)",
      "info" : "IfStatement[45037-45178]:IfStatement[45037-45178]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45060-45178]:Block[45060-45178]"
    }, {
      "left" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
      "right" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
      "info" : "ExpressionStatement[45068-45172]:ExpressionStatement[45068-45172]"
    }, {
      "left" : "return new ExtractionInfo(line, next());",
      "right" : "return new ExtractionInfo(line, next());",
      "info" : "ReturnStatement[45184-45224]:ReturnStatement[45184-45224]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[45302-45385]:Block[45302-45385]"
    }, {
      "left" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
      "right" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
      "info" : "ReturnStatement[45308-45381]:ReturnStatement[45308-45381]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46478-48824]:Block[46478-48824]"
    }, {
      "left" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
      "right" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
      "info" : "IfStatement[46485-46627]:IfStatement[46485-46627]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46576-46627]:Block[46576-46627]"
    }, {
      "left" : "return new ExtractionInfo(\"\", token);",
      "right" : "return new ExtractionInfo(\"\", token);",
      "info" : "ReturnStatement[46584-46621]:ReturnStatement[46584-46621]"
    }, {
      "left" : "stream.update();",
      "right" : "stream.update();",
      "info" : "ExpressionStatement[46633-46649]:ExpressionStatement[46633-46649]"
    }, {
      "left" : "int startLineno = stream.getLineno();",
      "right" : "int startLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[46654-46691]:VariableDeclarationStatement[46654-46691]"
    }, {
      "left" : "int startCharno = stream.getCharno() + 1;",
      "right" : "int startCharno = stream.getCharno() + 1;",
      "info" : "VariableDeclarationStatement[46696-46737]:VariableDeclarationStatement[46696-46737]"
    }, {
      "left" : "String line = stream.getRemainingJSDocLine();",
      "right" : "String line = stream.getRemainingJSDocLine();",
      "info" : "VariableDeclarationStatement[46788-46833]:VariableDeclarationStatement[46788-46833]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[46838-46912]:IfStatement[46838-46912]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[46879-46912]:Block[46879-46912]"
    }, {
      "left" : "line = line.trim();",
      "right" : "line = line.trim();",
      "info" : "ExpressionStatement[46887-46906]:ExpressionStatement[46887-46906]"
    }, {
      "left" : "StringBuilder builder = new StringBuilder();",
      "right" : "StringBuilder builder = new StringBuilder();",
      "info" : "VariableDeclarationStatement[46918-46962]:VariableDeclarationStatement[46918-46962]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[46967-46988]:ExpressionStatement[46967-46988]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[46994-47029]:ExpressionStatement[46994-47029]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[47034-47049]:ExpressionStatement[47034-47049]"
    }, {
      "left" : "boolean ignoreStar = false;",
      "right" : "boolean ignoreStar = false;",
      "info" : "VariableDeclarationStatement[47055-47082]:VariableDeclarationStatement[47055-47082]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[47088-48820]:DoStatement[47088-48820]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47091-48806]:Block[47091-48806]"
    }, {
      "left" : "switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n          if (!(option == WhitespaceOption.PRESERVE &&\n                token == JsDocToken.ANNOTATION)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
      "right" : "switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n          if (!(option == WhitespaceOption.PRESERVE &&\n                token == JsDocToken.ANNOTATION)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
      "info" : "SwitchStatement[47099-48800]:SwitchStatement[47099-48800]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[47124-47134]:SwitchCase[47124-47134]"
    }, {
      "left" : "if (!ignoreStar)",
      "right" : "if (!ignoreStar)",
      "info" : "IfStatement[47145-47298]:IfStatement[47145-47298]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47162-47298]:Block[47162-47298]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[47176-47252]:IfStatement[47176-47252]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47202-47252]:Block[47202-47252]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[47218-47238]:ExpressionStatement[47218-47238]"
    }, {
      "left" : "builder.append('*');",
      "right" : "builder.append('*');",
      "info" : "ExpressionStatement[47266-47286]:ExpressionStatement[47266-47286]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[47310-47325]:ExpressionStatement[47310-47325]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[47336-47345]:ContinueStatement[47336-47345]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[47355-47364]:SwitchCase[47355-47364]"
    }, {
      "left" : "if (option != WhitespaceOption.SINGLE_LINE)",
      "right" : "if (option != WhitespaceOption.SINGLE_LINE)",
      "info" : "IfStatement[47375-47466]:IfStatement[47375-47466]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47419-47466]:Block[47419-47466]"
    }, {
      "left" : "builder.append(\"\\n\");",
      "right" : "builder.append(\"\\n\");",
      "info" : "ExpressionStatement[47433-47454]:ExpressionStatement[47433-47454]"
    }, {
      "left" : "ignoreStar = true;",
      "right" : "ignoreStar = true;",
      "info" : "ExpressionStatement[47478-47496]:ExpressionStatement[47478-47496]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[47507-47522]:ExpressionStatement[47507-47522]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[47533-47542]:ContinueStatement[47533-47542]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[47552-47568]:SwitchCase[47552-47568]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[47577-47586]:SwitchCase[47577-47586]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[47595-47604]:SwitchCase[47595-47604]"
    }, {
      "left" : "if (!(option == WhitespaceOption.PRESERVE &&\n                token == JsDocToken.ANNOTATION))",
      "right" : "if (!(option == WhitespaceOption.PRESERVE &&\n                token == JsDocToken.ANNOTATION))",
      "info" : "IfStatement[47712-48334]:IfStatement[47712-48334]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47806-48334]:Block[47806-48334]"
    }, {
      "left" : "String multilineText = builder.toString();",
      "right" : "String multilineText = builder.toString();",
      "info" : "VariableDeclarationStatement[47820-47862]:VariableDeclarationStatement[47820-47862]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[47876-47984]:IfStatement[47876-47984]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[47917-47984]:Block[47917-47984]"
    }, {
      "left" : "multilineText = multilineText.trim();",
      "right" : "multilineText = multilineText.trim();",
      "info" : "ExpressionStatement[47933-47970]:ExpressionStatement[47933-47970]"
    }, {
      "left" : "int endLineno = stream.getLineno();",
      "right" : "int endLineno = stream.getLineno();",
      "info" : "VariableDeclarationStatement[47998-48033]:VariableDeclarationStatement[47998-48033]"
    }, {
      "left" : "int endCharno = stream.getCharno();",
      "right" : "int endCharno = stream.getCharno();",
      "info" : "VariableDeclarationStatement[48046-48081]:VariableDeclarationStatement[48046-48081]"
    }, {
      "left" : "if (multilineText.length() > 0)",
      "right" : "if (multilineText.length() > 0)",
      "info" : "IfStatement[48095-48260]:IfStatement[48095-48260]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48127-48260]:Block[48127-48260]"
    }, {
      "left" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
      "right" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
      "info" : "ExpressionStatement[48143-48246]:ExpressionStatement[48143-48246]"
    }, {
      "left" : "return new ExtractionInfo(multilineText, token);",
      "right" : "return new ExtractionInfo(multilineText, token);",
      "info" : "ReturnStatement[48274-48322]:ReturnStatement[48274-48322]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[48371-48379]:SwitchCase[48371-48379]"
    }, {
      "left" : "ignoreStar = false;",
      "right" : "ignoreStar = false;",
      "info" : "ExpressionStatement[48390-48409]:ExpressionStatement[48390-48409]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[48420-48455]:ExpressionStatement[48420-48455]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[48467-48539]:IfStatement[48467-48539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48493-48539]:Block[48493-48539]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[48507-48527]:ExpressionStatement[48507-48527]"
    }, {
      "left" : "builder.append(toString(token));",
      "right" : "builder.append(toString(token));",
      "info" : "ExpressionStatement[48551-48583]:ExpressionStatement[48551-48583]"
    }, {
      "left" : "line = stream.getRemainingJSDocLine();",
      "right" : "line = stream.getRemainingJSDocLine();",
      "info" : "ExpressionStatement[48595-48633]:ExpressionStatement[48595-48633]"
    }, {
      "left" : "if (option != WhitespaceOption.PRESERVE)",
      "right" : "if (option != WhitespaceOption.PRESERVE)",
      "info" : "IfStatement[48645-48733]:IfStatement[48645-48733]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[48686-48733]:Block[48686-48733]"
    }, {
      "left" : "line = trimEnd(line);",
      "right" : "line = trimEnd(line);",
      "info" : "ExpressionStatement[48700-48721]:ExpressionStatement[48700-48721]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[48745-48766]:ExpressionStatement[48745-48766]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[48777-48792]:ExpressionStatement[48777-48792]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49352-50326]:Block[49352-50326]"
    }, {
      "left" : "StringBuilder builder = new StringBuilder();",
      "right" : "StringBuilder builder = new StringBuilder();",
      "info" : "VariableDeclarationStatement[49358-49402]:VariableDeclarationStatement[49358-49402]"
    }, {
      "left" : "boolean ignoreStar = true;",
      "right" : "boolean ignoreStar = true;",
      "info" : "VariableDeclarationStatement[49408-49434]:VariableDeclarationStatement[49408-49434]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[49440-50322]:DoStatement[49440-50322]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49443-50308]:Block[49443-50308]"
    }, {
      "left" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
      "right" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
      "info" : "SwitchStatement[49451-50302]:SwitchStatement[49451-50302]"
    }, {
      "left" : "case ANNOTATION:",
      "right" : "case ANNOTATION:",
      "info" : "SwitchCase[49476-49492]:SwitchCase[49476-49492]"
    }, {
      "left" : "case EOC:",
      "right" : "case EOC:",
      "info" : "SwitchCase[49501-49510]:SwitchCase[49501-49510]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[49519-49528]:SwitchCase[49519-49528]"
    }, {
      "left" : "return new ExtractionInfo(builder.toString().trim(), token);",
      "right" : "return new ExtractionInfo(builder.toString().trim(), token);",
      "info" : "ReturnStatement[49539-49599]:ReturnStatement[49539-49599]"
    }, {
      "left" : "case STAR:",
      "right" : "case STAR:",
      "info" : "SwitchCase[49609-49619]:SwitchCase[49609-49619]"
    }, {
      "left" : "if (!ignoreStar)",
      "right" : "if (!ignoreStar)",
      "info" : "IfStatement[49630-49783]:IfStatement[49630-49783]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49647-49783]:Block[49647-49783]"
    }, {
      "left" : "if (builder.length() > 0)",
      "right" : "if (builder.length() > 0)",
      "info" : "IfStatement[49661-49737]:IfStatement[49661-49737]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[49687-49737]:Block[49687-49737]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[49703-49723]:ExpressionStatement[49703-49723]"
    }, {
      "left" : "builder.append('*');",
      "right" : "builder.append('*');",
      "info" : "ExpressionStatement[49751-49771]:ExpressionStatement[49751-49771]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[49795-49810]:ExpressionStatement[49795-49810]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[49821-49830]:ContinueStatement[49821-49830]"
    }, {
      "left" : "case EOL:",
      "right" : "case EOL:",
      "info" : "SwitchCase[49840-49849]:SwitchCase[49840-49849]"
    }, {
      "left" : "ignoreStar = true;",
      "right" : "ignoreStar = true;",
      "info" : "ExpressionStatement[49860-49878]:ExpressionStatement[49860-49878]"
    }, {
      "left" : "builder.append('\\n');",
      "right" : "builder.append('\\n');",
      "info" : "ExpressionStatement[49889-49910]:ExpressionStatement[49889-49910]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[49921-49936]:ExpressionStatement[49921-49936]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[49947-49956]:ContinueStatement[49947-49956]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[49966-49974]:SwitchCase[49966-49974]"
    }, {
      "left" : "if (!ignoreStar && builder.length() > 0)",
      "right" : "if (!ignoreStar && builder.length() > 0)",
      "info" : "IfStatement[49985-50072]:IfStatement[49985-50072]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50026-50072]:Block[50026-50072]"
    }, {
      "left" : "builder.append(' ');",
      "right" : "builder.append(' ');",
      "info" : "ExpressionStatement[50040-50060]:ExpressionStatement[50040-50060]"
    }, {
      "left" : "ignoreStar = false;",
      "right" : "ignoreStar = false;",
      "info" : "ExpressionStatement[50084-50103]:ExpressionStatement[50084-50103]"
    }, {
      "left" : "builder.append(toString(token));",
      "right" : "builder.append(toString(token));",
      "info" : "ExpressionStatement[50115-50147]:ExpressionStatement[50115-50147]"
    }, {
      "left" : "String line = stream.getRemainingJSDocLine();",
      "right" : "String line = stream.getRemainingJSDocLine();",
      "info" : "VariableDeclarationStatement[50159-50204]:VariableDeclarationStatement[50159-50204]"
    }, {
      "left" : "line = trimEnd(line);",
      "right" : "line = trimEnd(line);",
      "info" : "ExpressionStatement[50215-50236]:ExpressionStatement[50215-50236]"
    }, {
      "left" : "builder.append(line);",
      "right" : "builder.append(line);",
      "info" : "ExpressionStatement[50247-50268]:ExpressionStatement[50247-50268]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[50279-50294]:ExpressionStatement[50279-50294]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50768-51092]:Block[50768-51092]"
    }, {
      "left" : "int trimCount = 0;",
      "right" : "int trimCount = 0;",
      "info" : "VariableDeclarationStatement[50774-50792]:VariableDeclarationStatement[50774-50792]"
    }, {
      "left" : "while (trimCount < s.length())",
      "right" : "while (trimCount < s.length())",
      "info" : "WhileStatement[50797-50988]:WhileStatement[50797-50988]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50828-50988]:Block[50828-50988]"
    }, {
      "left" : "char ch = s.charAt(s.length() - trimCount - 1);",
      "right" : "char ch = s.charAt(s.length() - trimCount - 1);",
      "info" : "VariableDeclarationStatement[50836-50883]:VariableDeclarationStatement[50836-50883]"
    }, {
      "left" : "if (Character.isWhitespace(ch))",
      "right" : "if (Character.isWhitespace(ch))",
      "info" : "IfStatement[50890-50982]:IfStatement[50890-50982]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50922-50952]:Block[50922-50952]"
    }, {
      "left" : "trimCount++;",
      "right" : "trimCount++;",
      "info" : "ExpressionStatement[50932-50944]:ExpressionStatement[50932-50944]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[50958-50982]:Block[50958-50982]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[50968-50974]:BreakStatement[50968-50974]"
    }, {
      "left" : "if (trimCount == 0)",
      "right" : "if (trimCount == 0)",
      "info" : "IfStatement[50994-51037]:IfStatement[50994-51037]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51014-51037]:Block[51014-51037]"
    }, {
      "left" : "return s;",
      "right" : "return s;",
      "info" : "ReturnStatement[51022-51031]:ReturnStatement[51022-51031]"
    }, {
      "left" : "return s.substring(0, s.length() - trimCount);",
      "right" : "return s.substring(0, s.length() - trimCount);",
      "info" : "ReturnStatement[51042-51088]:ReturnStatement[51042-51088]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51675-52074]:Block[51675-52074]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[51681-52070]:IfStatement[51681-52070]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51709-52016]:Block[51709-52016]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[51717-51728]:ExpressionStatement[51717-51728]"
    }, {
      "left" : "Node typeNode = parseTopLevelTypeExpression(next());",
      "right" : "Node typeNode = parseTopLevelTypeExpression(next());",
      "info" : "VariableDeclarationStatement[51735-51787]:VariableDeclarationStatement[51735-51787]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[51794-51986]:IfStatement[51794-51986]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51816-51986]:Block[51816-51986]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[51826-51837]:ExpressionStatement[51826-51837]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[51846-51978]:IfStatement[51846-51978]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51873-51943]:Block[51873-51943]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[51885-51933]:ExpressionStatement[51885-51933]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[51949-51978]:Block[51949-51978]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[51961-51968]:ExpressionStatement[51961-51968]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[51994-52010]:ReturnStatement[51994-52010]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52022-52070]:Block[52022-52070]"
    }, {
      "left" : "return parseTypeExpression(token);",
      "right" : "return parseTypeExpression(token);",
      "info" : "ReturnStatement[52030-52064]:ReturnStatement[52030-52064]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52394-53264]:Block[52394-53264]"
    }, {
      "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
      "info" : "ExpressionStatement[52400-52452]:ExpressionStatement[52400-52452]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[52458-52469]:ExpressionStatement[52458-52469]"
    }, {
      "left" : "boolean restArg = false;",
      "right" : "boolean restArg = false;",
      "info" : "VariableDeclarationStatement[52475-52499]:VariableDeclarationStatement[52475-52499]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[52504-52519]:ExpressionStatement[52504-52519]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[52524-52779]:IfStatement[52524-52779]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52558-52779]:Block[52558-52779]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[52566-52581]:ExpressionStatement[52566-52581]"
    }, {
      "left" : "if (token == JsDocToken.RC)",
      "right" : "if (token == JsDocToken.RC)",
      "info" : "IfStatement[52588-52751]:IfStatement[52588-52751]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52616-52751]:Block[52616-52751]"
    }, {
      "left" : "return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));",
      "right" : "return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));",
      "info" : "ReturnStatement[52688-52743]:ReturnStatement[52688-52743]"
    }, {
      "left" : "restArg = true;",
      "right" : "restArg = true;",
      "info" : "ExpressionStatement[52758-52773]:ExpressionStatement[52758-52773]"
    }, {
      "left" : "Node typeNode = parseTopLevelTypeExpression(token);",
      "right" : "Node typeNode = parseTopLevelTypeExpression(token);",
      "info" : "VariableDeclarationStatement[52785-52836]:VariableDeclarationStatement[52785-52836]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[52841-53238]:IfStatement[52841-53238]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52863-53238]:Block[52863-53238]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[52871-52882]:ExpressionStatement[52871-52882]"
    }, {
      "left" : "if (restArg)",
      "right" : "if (restArg)",
      "info" : "IfStatement[52889-53100]:IfStatement[52889-53100]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[52902-52966]:Block[52902-52966]"
    }, {
      "left" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
      "right" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
      "info" : "ExpressionStatement[52912-52958]:ExpressionStatement[52912-52958]"
    }, {
      "left" : "if (match(JsDocToken.EQUALS))",
      "right" : "if (match(JsDocToken.EQUALS))",
      "info" : "IfStatement[52972-53100]:IfStatement[52972-53100]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53002-53100]:Block[53002-53100]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[53012-53019]:ExpressionStatement[53012-53019]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[53028-53039]:ExpressionStatement[53028-53039]"
    }, {
      "left" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
      "right" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
      "info" : "ExpressionStatement[53048-53092]:ExpressionStatement[53048-53092]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[53108-53232]:IfStatement[53108-53232]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53135-53201]:Block[53135-53201]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[53145-53193]:ExpressionStatement[53145-53193]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53207-53232]:Block[53207-53232]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[53217-53224]:ExpressionStatement[53217-53224]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[53244-53260]:ReturnStatement[53244-53260]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53390-53769]:Block[53390-53769]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[53396-53765]:IfStatement[53396-53765]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53424-53717]:Block[53424-53717]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[53432-53443]:ExpressionStatement[53432-53443]"
    }, {
      "left" : "Node typeNode = parseTypeName(next());",
      "right" : "Node typeNode = parseTypeName(next());",
      "info" : "VariableDeclarationStatement[53450-53488]:VariableDeclarationStatement[53450-53488]"
    }, {
      "left" : "if (typeNode != null)",
      "right" : "if (typeNode != null)",
      "info" : "IfStatement[53495-53687]:IfStatement[53495-53687]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53517-53687]:Block[53517-53687]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[53527-53538]:ExpressionStatement[53527-53538]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[53547-53679]:IfStatement[53547-53679]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53574-53644]:Block[53574-53644]"
    }, {
      "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ExpressionStatement[53586-53634]:ExpressionStatement[53586-53634]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53650-53679]:Block[53650-53679]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[53662-53669]:ExpressionStatement[53662-53669]"
    }, {
      "left" : "return typeNode;",
      "right" : "return typeNode;",
      "info" : "ReturnStatement[53695-53711]:ReturnStatement[53695-53711]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53723-53765]:Block[53723-53765]"
    }, {
      "left" : "return parseTypeName(token);",
      "right" : "return parseTypeName(token);",
      "info" : "ReturnStatement[53731-53759]:ReturnStatement[53731-53759]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[53988-54431]:Block[53988-54431]"
    }, {
      "left" : "Node typeExpr = parseTypeExpression(token);",
      "right" : "Node typeExpr = parseTypeExpression(token);",
      "info" : "VariableDeclarationStatement[53994-54037]:VariableDeclarationStatement[53994-54037]"
    }, {
      "left" : "if (typeExpr != null)",
      "right" : "if (typeExpr != null)",
      "info" : "IfStatement[54042-54406]:IfStatement[54042-54406]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54064-54406]:Block[54064-54406]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[54110-54400]:IfStatement[54110-54400]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54138-54400]:Block[54138-54400]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[54148-54155]:ExpressionStatement[54148-54155]"
    }, {
      "left" : "if (match(JsDocToken.PIPE))",
      "right" : "if (match(JsDocToken.PIPE))",
      "info" : "IfStatement[54164-54287]:IfStatement[54164-54287]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54192-54287]:Block[54192-54287]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[54270-54277]:ExpressionStatement[54270-54277]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54296-54307]:ExpressionStatement[54296-54307]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[54316-54331]:ExpressionStatement[54316-54331]"
    }, {
      "left" : "return parseUnionTypeWithAlternate(token, typeExpr);",
      "right" : "return parseUnionTypeWithAlternate(token, typeExpr);",
      "info" : "ReturnStatement[54340-54392]:ReturnStatement[54340-54392]"
    }, {
      "left" : "return typeExpr;",
      "right" : "return typeExpr;",
      "info" : "ReturnStatement[54411-54427]:ReturnStatement[54411-54427]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54609-55056]:Block[54609-55056]"
    }, {
      "left" : "Node typeExpr = parseTopLevelTypeExpression(token);",
      "right" : "Node typeExpr = parseTopLevelTypeExpression(token);",
      "info" : "VariableDeclarationStatement[54615-54666]:VariableDeclarationStatement[54615-54666]"
    }, {
      "left" : "if (typeExpr == null)",
      "right" : "if (typeExpr == null)",
      "info" : "IfStatement[54671-54719]:IfStatement[54671-54719]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54693-54719]:Block[54693-54719]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[54701-54713]:ReturnStatement[54701-54713]"
    }, {
      "left" : "Node typeList = new Node(Token.BLOCK);",
      "right" : "Node typeList = new Node(Token.BLOCK);",
      "info" : "VariableDeclarationStatement[54724-54762]:VariableDeclarationStatement[54724-54762]"
    }, {
      "left" : "typeList.addChildToBack(typeExpr);",
      "right" : "typeList.addChildToBack(typeExpr);",
      "info" : "ExpressionStatement[54767-54801]:ExpressionStatement[54767-54801]"
    }, {
      "left" : "while (match(JsDocToken.COMMA))",
      "right" : "while (match(JsDocToken.COMMA))",
      "info" : "WhileStatement[54806-55031]:WhileStatement[54806-55031]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54838-55031]:Block[54838-55031]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[54846-54853]:ExpressionStatement[54846-54853]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[54860-54871]:ExpressionStatement[54860-54871]"
    }, {
      "left" : "typeExpr = parseTopLevelTypeExpression(next());",
      "right" : "typeExpr = parseTopLevelTypeExpression(next());",
      "info" : "ExpressionStatement[54878-54925]:ExpressionStatement[54878-54925]"
    }, {
      "left" : "if (typeExpr == null)",
      "right" : "if (typeExpr == null)",
      "info" : "IfStatement[54932-54984]:IfStatement[54932-54984]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[54954-54984]:Block[54954-54984]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[54964-54976]:ReturnStatement[54964-54976]"
    }, {
      "left" : "typeList.addChildToBack(typeExpr);",
      "right" : "typeList.addChildToBack(typeExpr);",
      "info" : "ExpressionStatement[54991-55025]:ExpressionStatement[54991-55025]"
    }, {
      "left" : "return typeList;",
      "right" : "return typeList;",
      "info" : "ReturnStatement[55036-55052]:ReturnStatement[55036-55052]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55321-56714]:Block[55321-56714]"
    }, {
      "left" : "if (token == JsDocToken.QMARK)",
      "right" : "if (token == JsDocToken.QMARK)",
      "info" : "IfStatement[55327-56710]:IfStatement[55327-56710]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[55358-56214]:Block[55358-56214]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[55856-55871]:ExpressionStatement[55856-55871]"
    }, {
      "left" : "if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE)",
      "right" : "if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE)",
      "info" : "IfStatement[55878-56138]:IfStatement[55878-56138]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56059-56138]:Block[56059-56138]"
    }, {
      "left" : "restoreLookAhead(token);",
      "right" : "restoreLookAhead(token);",
      "info" : "ExpressionStatement[56069-56093]:ExpressionStatement[56069-56093]"
    }, {
      "left" : "return newNode(Token.QMARK);",
      "right" : "return newNode(Token.QMARK);",
      "info" : "ReturnStatement[56102-56130]:ReturnStatement[56102-56130]"
    }, {
      "left" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(token));",
      "right" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(token));",
      "info" : "ReturnStatement[56146-56208]:ReturnStatement[56146-56208]"
    }, {
      "left" : "if (token == JsDocToken.BANG)",
      "right" : "if (token == JsDocToken.BANG)",
      "info" : "IfStatement[56220-56710]:IfStatement[56220-56710]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56250-56326]:Block[56250-56326]"
    }, {
      "left" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
      "right" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
      "info" : "ReturnStatement[56258-56320]:ReturnStatement[56258-56320]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56332-56710]:Block[56332-56710]"
    }, {
      "left" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
      "right" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
      "info" : "VariableDeclarationStatement[56340-56393]:VariableDeclarationStatement[56340-56393]"
    }, {
      "left" : "if (basicTypeExpr != null)",
      "right" : "if (basicTypeExpr != null)",
      "info" : "IfStatement[56400-56675]:IfStatement[56400-56675]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56427-56675]:Block[56427-56675]"
    }, {
      "left" : "if (match(JsDocToken.QMARK))",
      "right" : "if (match(JsDocToken.QMARK))",
      "info" : "IfStatement[56437-56667]:IfStatement[56437-56667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56466-56550]:Block[56466-56550]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[56478-56485]:ExpressionStatement[56478-56485]"
    }, {
      "left" : "return wrapNode(Token.QMARK, basicTypeExpr);",
      "right" : "return wrapNode(Token.QMARK, basicTypeExpr);",
      "info" : "ReturnStatement[56496-56540]:ReturnStatement[56496-56540]"
    }, {
      "left" : "if (match(JsDocToken.BANG))",
      "right" : "if (match(JsDocToken.BANG))",
      "info" : "IfStatement[56556-56667]:IfStatement[56556-56667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56584-56667]:Block[56584-56667]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[56596-56603]:ExpressionStatement[56596-56603]"
    }, {
      "left" : "return wrapNode(Token.BANG, basicTypeExpr);",
      "right" : "return wrapNode(Token.BANG, basicTypeExpr);",
      "info" : "ReturnStatement[56614-56657]:ReturnStatement[56614-56657]"
    }, {
      "left" : "return basicTypeExpr;",
      "right" : "return basicTypeExpr;",
      "info" : "ReturnStatement[56683-56704]:ReturnStatement[56683-56704]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56913-57687]:Block[56913-57716]"
    }, {
      "left" : "if (token == JsDocToken.STAR)",
      "right" : "if (token == JsDocToken.STAR)",
      "info" : "IfStatement[56919-57637]:IfStatement[56919-57637]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[56949-56990]:Block[56949-56990]"
    }, {
      "left" : "return newNode(Token.STAR);",
      "right" : "return newNode(Token.STAR);",
      "info" : "ReturnStatement[56957-56984]:ReturnStatement[56957-56984]"
    }, {
      "left" : "if (token == JsDocToken.LB)",
      "right" : "if (token == JsDocToken.LB)",
      "info" : "IfStatement[56996-57637]:IfStatement[56996-57637]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57024-57086]:Block[57024-57086]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57032-57043]:ExpressionStatement[57032-57043]"
    }, {
      "left" : "return parseArrayType(next());",
      "right" : "return parseArrayType(next());",
      "info" : "ReturnStatement[57050-57080]:ReturnStatement[57050-57080]"
    }, {
      "left" : "if (token == JsDocToken.LC)",
      "right" : "if (token == JsDocToken.LC)",
      "info" : "IfStatement[57092-57637]:IfStatement[57092-57637]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57120-57183]:Block[57120-57183]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57128-57139]:ExpressionStatement[57128-57139]"
    }, {
      "left" : "return parseRecordType(next());",
      "right" : "return parseRecordType(next());",
      "info" : "ReturnStatement[57146-57177]:ReturnStatement[57146-57177]"
    }, {
      "left" : "if (token == JsDocToken.LP)",
      "right" : "if (token == JsDocToken.LP)",
      "info" : "IfStatement[57189-57637]:IfStatement[57189-57637]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57217-57279]:Block[57217-57279]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57225-57236]:ExpressionStatement[57225-57236]"
    }, {
      "left" : "return parseUnionType(next());",
      "right" : "return parseUnionType(next());",
      "info" : "ReturnStatement[57243-57273]:ReturnStatement[57243-57273]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[57285-57637]:IfStatement[57285-57637]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57317-57637]:Block[57317-57637]"
    }, {
      "left" : "String string = stream.getString();",
      "right" : "String string = stream.getString();",
      "info" : "VariableDeclarationStatement[57325-57360]:VariableDeclarationStatement[57325-57360]"
    }, {
      "left" : "if (\"function\".equals(string))",
      "right" : "if (\"function\".equals(string))",
      "info" : "IfStatement[57367-57631]:IfStatement[57367-57631]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57398-57469]:Block[57398-57469]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[57408-57419]:ExpressionStatement[57408-57419]"
    }, {
      "left" : "return parseFunctionType(next());",
      "right" : "return parseFunctionType(next());",
      "info" : "ReturnStatement[57428-57461]:ReturnStatement[57428-57461]"
    }, {
      "left" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
      "right" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
      "info" : "IfStatement[57475-57631]:IfStatement[57475-57631]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57532-57579]:Block[57532-57579]"
    }, {
      "left" : "return newStringNode(string);",
      "right" : "return newStringNode(string);",
      "info" : "ReturnStatement[57542-57571]:ReturnStatement[57542-57571]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57585-57631]:Block[57585-57631]"
    }, {
      "left" : "return parseTypeName(token);",
      "right" : "return parseTypeName(token);",
      "info" : "ReturnStatement[57595-57623]:ReturnStatement[57595-57623]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[57643-57683]:ReturnStatement[57672-57712]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57922-58724]:Block[57951-58753]"
    }, {
      "left" : "if (token != JsDocToken.STRING)",
      "right" : "if (token != JsDocToken.STRING)",
      "info" : "IfStatement[57928-58014]:IfStatement[57957-58043]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[57960-58014]:Block[57989-58043]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[57968-58008]:ReturnStatement[57997-58037]"
    }, {
      "left" : "String typeName = stream.getString();",
      "right" : "String typeName = stream.getString();",
      "info" : "VariableDeclarationStatement[58020-58057]:VariableDeclarationStatement[58049-58086]"
    }, {
      "left" : "while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.')",
      "right" : "while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.')",
      "info" : "WhileStatement[58062-58276]:WhileStatement[58091-58305]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58149-58276]:Block[58178-58305]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58157-58168]:ExpressionStatement[58186-58197]"
    }, {
      "left" : "if (match(JsDocToken.STRING))",
      "right" : "if (match(JsDocToken.STRING))",
      "info" : "IfStatement[58175-58270]:IfStatement[58204-58299]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58205-58270]:Block[58234-58299]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[58215-58222]:ExpressionStatement[58244-58251]"
    }, {
      "left" : "typeName += stream.getString();",
      "right" : "typeName += stream.getString();",
      "info" : "ExpressionStatement[58231-58262]:ExpressionStatement[58260-58291]"
    }, {
      "left" : "Node typeNameNode = newStringNode(typeName);",
      "right" : "Node typeNameNode = newStringNode(typeName);",
      "info" : "VariableDeclarationStatement[58282-58326]:VariableDeclarationStatement[58311-58355]"
    }, {
      "left" : "if (match(JsDocToken.LT))",
      "right" : "if (match(JsDocToken.LT))",
      "info" : "IfStatement[58332-58695]:IfStatement[58361-58724]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58358-58695]:Block[58387-58724]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[58366-58373]:ExpressionStatement[58395-58402]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58380-58391]:ExpressionStatement[58409-58420]"
    }, {
      "left" : "Node memberType = parseTypeExpressionList(next());",
      "right" : "Node memberType = parseTypeExpressionList(next());",
      "info" : "VariableDeclarationStatement[58398-58448]:VariableDeclarationStatement[58427-58477]"
    }, {
      "left" : "if (memberType != null)",
      "right" : "if (memberType != null)",
      "info" : "IfStatement[58455-58689]:IfStatement[58484-58718]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58479-58689]:Block[58508-58718]"
    }, {
      "left" : "typeNameNode.addChildToFront(memberType);",
      "right" : "typeNameNode.addChildToFront(memberType);",
      "info" : "ExpressionStatement[58489-58530]:ExpressionStatement[58518-58559]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[58540-58551]:ExpressionStatement[58569-58580]"
    }, {
      "left" : "if (!match(JsDocToken.GT))",
      "right" : "if (!match(JsDocToken.GT))",
      "info" : "IfStatement[58560-58664]:IfStatement[58589-58693]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58587-58664]:Block[58616-58693]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
      "info" : "ReturnStatement[58599-58654]:ReturnStatement[58628-58683]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[58674-58681]:ExpressionStatement[58703-58710]"
    }, {
      "left" : "return typeNameNode;",
      "right" : "return typeNameNode;",
      "info" : "ReturnStatement[58700-58720]:ReturnStatement[58729-58749]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[58951-60775]:Block[58980-60835]"
    }, {
      "left" : "if (token != JsDocToken.LP)",
      "right" : "if (token != JsDocToken.LP)",
      "info" : "IfStatement[59070-59167]:IfStatement[59099-59227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59098-59167]:Block[59127-59227]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
      "info" : "ReturnStatement[59106-59161]:ReturnStatement[59166-59221]"
    }, {
      "left" : "Node functionType = newNode(Token.FUNCTION);",
      "right" : "Node functionType = newNode(Token.FUNCTION);",
      "info" : "VariableDeclarationStatement[59173-59217]:VariableDeclarationStatement[59233-59277]"
    }, {
      "left" : "Node parameters = null;",
      "right" : "Node parameters = null;",
      "info" : "VariableDeclarationStatement[59222-59245]:VariableDeclarationStatement[59282-59305]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[59250-59261]:ExpressionStatement[59310-59321]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[59266-60365]:IfStatement[59326-60425]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59293-60365]:Block[59353-60425]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[59301-59316]:ExpressionStatement[59361-59376]"
    }, {
      "left" : "boolean hasParams = true;",
      "right" : "boolean hasParams = true;",
      "info" : "VariableDeclarationStatement[59324-59349]:VariableDeclarationStatement[59384-59409]"
    }, {
      "left" : "if (token == JsDocToken.STRING)",
      "right" : "if (token == JsDocToken.STRING)",
      "info" : "IfStatement[59356-60211]:IfStatement[59416-60271]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59388-60211]:Block[59448-60271]"
    }, {
      "left" : "String tokenStr = stream.getString();",
      "right" : "String tokenStr = stream.getString();",
      "info" : "VariableDeclarationStatement[59398-59435]:VariableDeclarationStatement[59458-59495]"
    }, {
      "left" : "boolean isThis = \"this\".equals(tokenStr);",
      "right" : "boolean isThis = \"this\".equals(tokenStr);",
      "info" : "VariableDeclarationStatement[59444-59485]:VariableDeclarationStatement[59504-59545]"
    }, {
      "left" : "boolean isNew = \"new\".equals(tokenStr);",
      "right" : "boolean isNew = \"new\".equals(tokenStr);",
      "info" : "VariableDeclarationStatement[59494-59533]:VariableDeclarationStatement[59554-59593]"
    }, {
      "left" : "if (isThis || isNew)",
      "right" : "if (isThis || isNew)",
      "info" : "IfStatement[59542-60203]:IfStatement[59602-60263]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59563-60203]:Block[59623-60263]"
    }, {
      "left" : "if (match(JsDocToken.COLON))",
      "right" : "if (match(JsDocToken.COLON))",
      "info" : "IfStatement[59575-60017]:IfStatement[59635-60077]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59604-59927]:Block[59664-59987]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[59618-59625]:ExpressionStatement[59678-59685]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[59638-59649]:ExpressionStatement[59698-59709]"
    }, {
      "left" : "Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));",
      "right" : "Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));",
      "info" : "VariableDeclarationStatement[59662-59779]:VariableDeclarationStatement[59722-59839]"
    }, {
      "left" : "if (contextType == null)",
      "right" : "if (contextType == null)",
      "info" : "IfStatement[59792-59859]:IfStatement[59852-59919]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59817-59859]:Block[59877-59919]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[59833-59845]:ReturnStatement[59893-59905]"
    }, {
      "left" : "functionType.addChildToFront(contextType);",
      "right" : "functionType.addChildToFront(contextType);",
      "info" : "ExpressionStatement[59873-59915]:ExpressionStatement[59933-59975]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[59933-60017]:Block[59993-60077]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
      "info" : "ReturnStatement[59947-60005]:ReturnStatement[60007-60065]"
    }, {
      "left" : "if (match(JsDocToken.COMMA))",
      "right" : "if (match(JsDocToken.COMMA))",
      "info" : "IfStatement[60029-60193]:IfStatement[60089-60253]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60058-60143]:Block[60118-60203]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[60072-60079]:ExpressionStatement[60132-60139]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[60092-60103]:ExpressionStatement[60152-60163]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[60116-60131]:ExpressionStatement[60176-60191]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60149-60193]:Block[60209-60253]"
    }, {
      "left" : "hasParams = false;",
      "right" : "hasParams = false;",
      "info" : "ExpressionStatement[60163-60181]:ExpressionStatement[60223-60241]"
    }, {
      "left" : "if (hasParams)",
      "right" : "if (hasParams)",
      "info" : "IfStatement[60219-60359]:IfStatement[60279-60419]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60234-60359]:Block[60294-60419]"
    }, {
      "left" : "parameters = parseParametersType(token);",
      "right" : "parameters = parseParametersType(token);",
      "info" : "ExpressionStatement[60244-60284]:ExpressionStatement[60304-60344]"
    }, {
      "left" : "if (parameters == null)",
      "right" : "if (parameters == null)",
      "info" : "IfStatement[60293-60351]:IfStatement[60353-60411]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60317-60351]:Block[60377-60411]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[60329-60341]:ReturnStatement[60389-60401]"
    }, {
      "left" : "if (parameters != null)",
      "right" : "if (parameters != null)",
      "info" : "IfStatement[60371-60449]:IfStatement[60431-60509]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60395-60449]:Block[60455-60509]"
    }, {
      "left" : "functionType.addChildToBack(parameters);",
      "right" : "functionType.addChildToBack(parameters);",
      "info" : "ExpressionStatement[60403-60443]:ExpressionStatement[60463-60503]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[60455-60466]:ExpressionStatement[60515-60526]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[60471-60567]:IfStatement[60531-60627]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60498-60567]:Block[60558-60627]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "info" : "ReturnStatement[60506-60561]:ReturnStatement[60566-60621]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[60573-60584]:ExpressionStatement[60633-60644]"
    }, {
      "left" : "Node resultType = parseResultType(next());",
      "right" : "Node resultType = parseResultType(next());",
      "info" : "VariableDeclarationStatement[60589-60631]:VariableDeclarationStatement[60649-60691]"
    }, {
      "left" : "if (resultType == null)",
      "right" : "if (resultType == null)",
      "info" : "IfStatement[60636-60746]:IfStatement[60696-60806]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60660-60686]:Block[60720-60746]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[60668-60680]:ReturnStatement[60728-60740]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[60692-60746]:Block[60752-60806]"
    }, {
      "left" : "functionType.addChildToBack(resultType);",
      "right" : "functionType.addChildToBack(resultType);",
      "info" : "ExpressionStatement[60700-60740]:ExpressionStatement[60760-60800]"
    }, {
      "left" : "return functionType;",
      "right" : "return functionType;",
      "info" : "ReturnStatement[60751-60771]:ReturnStatement[60811-60831]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62021-63866]:Block[62081-63926]"
    }, {
      "left" : "Node paramsType = newNode(Token.LP);",
      "right" : "Node paramsType = newNode(Token.LP);",
      "info" : "VariableDeclarationStatement[62027-62063]:VariableDeclarationStatement[62087-62123]"
    }, {
      "left" : "boolean isVarArgs = false;",
      "right" : "boolean isVarArgs = false;",
      "info" : "VariableDeclarationStatement[62068-62094]:VariableDeclarationStatement[62128-62154]"
    }, {
      "left" : "Node paramType = null;",
      "right" : "Node paramType = null;",
      "info" : "VariableDeclarationStatement[62099-62121]:VariableDeclarationStatement[62159-62181]"
    }, {
      "left" : "if (token != JsDocToken.RP)",
      "right" : "if (token != JsDocToken.RP)",
      "info" : "IfStatement[62126-63654]:IfStatement[62186-63714]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62154-63654]:Block[62214-63714]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[62162-63648]:DoStatement[62222-63708]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62165-63615]:Block[62225-63675]"
    }, {
      "left" : "if (paramType != null)",
      "right" : "if (paramType != null)",
      "info" : "IfStatement[62175-62308]:IfStatement[62235-62368]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62198-62308]:Block[62258-62368]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[62243-62250]:ExpressionStatement[62303-62310]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62261-62272]:ExpressionStatement[62321-62332]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[62283-62298]:ExpressionStatement[62343-62358]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[62318-63442]:IfStatement[62378-63502]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62352-63218]:Block[62412-63278]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62584-62595]:ExpressionStatement[62644-62655]"
    }, {
      "left" : "if (match(JsDocToken.RP))",
      "right" : "if (match(JsDocToken.RP))",
      "info" : "IfStatement[62606-63179]:IfStatement[62666-63239]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62632-62694]:Block[62692-62754]"
    }, {
      "left" : "paramType = newNode(Token.ELLIPSIS);",
      "right" : "paramType = newNode(Token.ELLIPSIS);",
      "info" : "ExpressionStatement[62646-62682]:ExpressionStatement[62706-62742]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62700-63179]:Block[62760-63239]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62714-62725]:ExpressionStatement[62774-62785]"
    }, {
      "left" : "if (!match(JsDocToken.LB))",
      "right" : "if (!match(JsDocToken.LB))",
      "info" : "IfStatement[62738-62850]:IfStatement[62798-62910]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[62765-62850]:Block[62825-62910]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
      "info" : "ReturnStatement[62781-62836]:ReturnStatement[62841-62896]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[62864-62871]:ExpressionStatement[62924-62931]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62884-62895]:ExpressionStatement[62944-62955]"
    }, {
      "left" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "right" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "info" : "ExpressionStatement[62908-62974]:ExpressionStatement[62968-63034]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[62987-62998]:ExpressionStatement[63047-63058]"
    }, {
      "left" : "if (!match(JsDocToken.RB))",
      "right" : "if (!match(JsDocToken.RB))",
      "info" : "IfStatement[63011-63123]:IfStatement[63071-63183]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63038-63123]:Block[63098-63183]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ReturnStatement[63054-63109]:ReturnStatement[63114-63169]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[63136-63147]:ExpressionStatement[63196-63207]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[63160-63167]:ExpressionStatement[63220-63227]"
    }, {
      "left" : "isVarArgs = true;",
      "right" : "isVarArgs = true;",
      "info" : "ExpressionStatement[63191-63208]:ExpressionStatement[63251-63268]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63224-63442]:Block[63284-63502]"
    }, {
      "left" : "paramType = parseTypeExpression(token);",
      "right" : "paramType = parseTypeExpression(token);",
      "info" : "ExpressionStatement[63236-63275]:ExpressionStatement[63296-63335]"
    }, {
      "left" : "if (match(JsDocToken.EQUALS))",
      "right" : "if (match(JsDocToken.EQUALS))",
      "info" : "IfStatement[63286-63432]:IfStatement[63346-63492]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63316-63432]:Block[63376-63492]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[63330-63341]:ExpressionStatement[63390-63401]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[63354-63361]:ExpressionStatement[63414-63421]"
    }, {
      "left" : "paramType = wrapNode(Token.EQUALS, paramType);",
      "right" : "paramType = wrapNode(Token.EQUALS, paramType);",
      "info" : "ExpressionStatement[63374-63420]:ExpressionStatement[63434-63480]"
    }, {
      "left" : "if (paramType == null)",
      "right" : "if (paramType == null)",
      "info" : "IfStatement[63452-63509]:IfStatement[63512-63569]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63475-63509]:Block[63535-63569]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[63487-63499]:ReturnStatement[63547-63559]"
    }, {
      "left" : "paramsType.addChildToBack(paramType);",
      "right" : "paramsType.addChildToBack(paramType);",
      "info" : "ExpressionStatement[63518-63555]:ExpressionStatement[63578-63615]"
    }, {
      "left" : "if (isVarArgs)",
      "right" : "if (isVarArgs)",
      "info" : "IfStatement[63564-63607]:IfStatement[63624-63667]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63579-63607]:Block[63639-63667]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[63591-63597]:BreakStatement[63651-63657]"
    }, {
      "left" : "if (isVarArgs && match(JsDocToken.COMMA))",
      "right" : "if (isVarArgs && match(JsDocToken.COMMA))",
      "info" : "IfStatement[63660-63777]:IfStatement[63720-63837]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63702-63777]:Block[63762-63837]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
      "info" : "ReturnStatement[63710-63771]:ReturnStatement[63770-63831]"
    }, {
      "left" : "return paramsType;",
      "right" : "return paramsType;",
      "info" : "ReturnStatement[63844-63862]:ReturnStatement[63904-63922]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[63988-64305]:Block[64048-64365]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[63994-64005]:ExpressionStatement[64054-64065]"
    }, {
      "left" : "if (!match(JsDocToken.COLON))",
      "right" : "if (!match(JsDocToken.COLON))",
      "info" : "IfStatement[64010-64082]:IfStatement[64070-64142]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64040-64082]:Block[64100-64142]"
    }, {
      "left" : "return newNode(Token.EMPTY);",
      "right" : "return newNode(Token.EMPTY);",
      "info" : "ReturnStatement[64048-64076]:ReturnStatement[64108-64136]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[64088-64103]:ExpressionStatement[64148-64163]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[64108-64119]:ExpressionStatement[64168-64179]"
    }, {
      "left" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
      "right" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
      "info" : "IfStatement[64124-64301]:IfStatement[64184-64361]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64191-64246]:Block[64251-64306]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[64199-64206]:ExpressionStatement[64259-64266]"
    }, {
      "left" : "return newNode(Token.VOID);",
      "right" : "return newNode(Token.VOID);",
      "info" : "ReturnStatement[64213-64240]:ReturnStatement[64273-64300]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64252-64301]:Block[64312-64361]"
    }, {
      "left" : "return parseTypeExpression(next());",
      "right" : "return parseTypeExpression(next());",
      "info" : "ReturnStatement[64260-64295]:ReturnStatement[64320-64355]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64525-64583]:Block[64585-64643]"
    }, {
      "left" : "return parseUnionTypeWithAlternate(token, null);",
      "right" : "return parseUnionTypeWithAlternate(token, null);",
      "info" : "ReturnStatement[64531-64579]:ReturnStatement[64591-64639]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64784-65785]:Block[64844-65845]"
    }, {
      "left" : "Node union = newNode(Token.PIPE);",
      "right" : "Node union = newNode(Token.PIPE);",
      "info" : "VariableDeclarationStatement[64790-64823]:VariableDeclarationStatement[64850-64883]"
    }, {
      "left" : "if (alternate != null)",
      "right" : "if (alternate != null)",
      "info" : "IfStatement[64828-64897]:IfStatement[64888-64957]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64851-64897]:Block[64911-64957]"
    }, {
      "left" : "union.addChildToBack(alternate);",
      "right" : "union.addChildToBack(alternate);",
      "info" : "ExpressionStatement[64859-64891]:ExpressionStatement[64919-64951]"
    }, {
      "left" : "Node expr = null;",
      "right" : "Node expr = null;",
      "info" : "VariableDeclarationStatement[64903-64920]:VariableDeclarationStatement[64963-64980]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[64925-65588]:DoStatement[64985-65648]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64928-65538]:Block[64988-65598]"
    }, {
      "left" : "if (expr != null)",
      "right" : "if (expr != null)",
      "info" : "IfStatement[64936-65346]:IfStatement[64996-65406]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[64954-65346]:Block[65014-65406]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[64964-64975]:ExpressionStatement[65024-65035]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[64984-64999]:ExpressionStatement[65044-65059]"
    }, {
      "left" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
      "right" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
      "info" : "ExpressionStatement[65008-65101]:ExpressionStatement[65068-65161]"
    }, {
      "left" : "boolean isPipe = token == JsDocToken.PIPE;",
      "right" : "boolean isPipe = token == JsDocToken.PIPE;",
      "info" : "VariableDeclarationStatement[65111-65153]:VariableDeclarationStatement[65171-65213]"
    }, {
      "left" : "if (isPipe && match(JsDocToken.PIPE))",
      "right" : "if (isPipe && match(JsDocToken.PIPE))",
      "info" : "IfStatement[65162-65294]:IfStatement[65222-65354]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65200-65294]:Block[65260-65354]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[65277-65284]:ExpressionStatement[65337-65344]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[65303-65314]:ExpressionStatement[65363-65374]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[65323-65338]:ExpressionStatement[65383-65398]"
    }, {
      "left" : "expr = parseTypeExpression(token);",
      "right" : "expr = parseTypeExpression(token);",
      "info" : "ExpressionStatement[65353-65387]:ExpressionStatement[65413-65447]"
    }, {
      "left" : "if (expr == null)",
      "right" : "if (expr == null)",
      "info" : "IfStatement[65394-65442]:IfStatement[65454-65502]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65412-65442]:Block[65472-65502]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[65422-65434]:ReturnStatement[65482-65494]"
    }, {
      "left" : "union.addChildToBack(expr);",
      "right" : "union.addChildToBack(expr);",
      "info" : "ExpressionStatement[65450-65477]:ExpressionStatement[65510-65537]"
    }, {
      "left" : "if (alternate == null)",
      "right" : "if (alternate == null)",
      "info" : "IfStatement[65594-65763]:IfStatement[65654-65823]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65617-65763]:Block[65677-65823]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[65625-65636]:ExpressionStatement[65685-65696]"
    }, {
      "left" : "if (!match(JsDocToken.RP))",
      "right" : "if (!match(JsDocToken.RP))",
      "info" : "IfStatement[65643-65743]:IfStatement[65703-65803]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[65670-65743]:Block[65730-65803]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
      "info" : "ReturnStatement[65680-65735]:ReturnStatement[65740-65795]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[65750-65757]:ExpressionStatement[65810-65817]"
    }, {
      "left" : "return union;",
      "right" : "return union;",
      "info" : "ReturnStatement[65768-65781]:ReturnStatement[65828-65841]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66007-66732]:Block[66067-66792]"
    }, {
      "left" : "Node array = newNode(Token.LB);",
      "right" : "Node array = newNode(Token.LB);",
      "info" : "VariableDeclarationStatement[66013-66044]:VariableDeclarationStatement[66073-66104]"
    }, {
      "left" : "Node arg = null;",
      "right" : "Node arg = null;",
      "info" : "VariableDeclarationStatement[66049-66065]:VariableDeclarationStatement[66109-66125]"
    }, {
      "left" : "boolean hasVarArgs = false;",
      "right" : "boolean hasVarArgs = false;",
      "info" : "VariableDeclarationStatement[66070-66097]:VariableDeclarationStatement[66130-66157]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[66103-66596]:DoStatement[66163-66656]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66106-66563]:Block[66166-66623]"
    }, {
      "left" : "if (arg != null)",
      "right" : "if (arg != null)",
      "info" : "IfStatement[66114-66200]:IfStatement[66174-66260]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66131-66200]:Block[66191-66260]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[66141-66148]:ExpressionStatement[66201-66208]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[66157-66168]:ExpressionStatement[66217-66228]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[66177-66192]:ExpressionStatement[66237-66252]"
    }, {
      "left" : "if (token == JsDocToken.ELLIPSIS)",
      "right" : "if (token == JsDocToken.ELLIPSIS)",
      "info" : "IfStatement[66207-66403]:IfStatement[66267-66463]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66241-66346]:Block[66301-66406]"
    }, {
      "left" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "right" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
      "info" : "ExpressionStatement[66251-66311]:ExpressionStatement[66311-66371]"
    }, {
      "left" : "hasVarArgs = true;",
      "right" : "hasVarArgs = true;",
      "info" : "ExpressionStatement[66320-66338]:ExpressionStatement[66380-66398]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66352-66403]:Block[66412-66463]"
    }, {
      "left" : "arg = parseTypeExpression(token);",
      "right" : "arg = parseTypeExpression(token);",
      "info" : "ExpressionStatement[66362-66395]:ExpressionStatement[66422-66455]"
    }, {
      "left" : "if (arg == null)",
      "right" : "if (arg == null)",
      "info" : "IfStatement[66411-66458]:IfStatement[66471-66518]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66428-66458]:Block[66488-66518]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[66438-66450]:ReturnStatement[66498-66510]"
    }, {
      "left" : "array.addChildToBack(arg);",
      "right" : "array.addChildToBack(arg);",
      "info" : "ExpressionStatement[66466-66492]:ExpressionStatement[66526-66552]"
    }, {
      "left" : "if (hasVarArgs)",
      "right" : "if (hasVarArgs)",
      "info" : "IfStatement[66499-66539]:IfStatement[66559-66599]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66515-66539]:Block[66575-66599]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[66525-66531]:BreakStatement[66585-66591]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[66546-66557]:ExpressionStatement[66606-66617]"
    }, {
      "left" : "if (!match(JsDocToken.RB))",
      "right" : "if (!match(JsDocToken.RB))",
      "info" : "IfStatement[66602-66698]:IfStatement[66662-66758]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66629-66698]:Block[66689-66758]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
      "info" : "ReturnStatement[66637-66692]:ReturnStatement[66697-66752]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[66703-66710]:ExpressionStatement[66763-66770]"
    }, {
      "left" : "return array;",
      "right" : "return array;",
      "info" : "ReturnStatement[66715-66728]:ReturnStatement[66775-66788]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66836-67222]:Block[66896-67282]"
    }, {
      "left" : "Node recordType = newNode(Token.LC);",
      "right" : "Node recordType = newNode(Token.LC);",
      "info" : "VariableDeclarationStatement[66842-66878]:VariableDeclarationStatement[66902-66938]"
    }, {
      "left" : "Node fieldTypeList = parseFieldTypeList(token);",
      "right" : "Node fieldTypeList = parseFieldTypeList(token);",
      "info" : "VariableDeclarationStatement[66883-66930]:VariableDeclarationStatement[66943-66990]"
    }, {
      "left" : "if (fieldTypeList == null)",
      "right" : "if (fieldTypeList == null)",
      "info" : "IfStatement[66936-67017]:IfStatement[66996-67077]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[66963-67017]:Block[67023-67077]"
    }, {
      "left" : "return reportGenericTypeSyntaxWarning();",
      "right" : "return reportGenericTypeSyntaxWarning();",
      "info" : "ReturnStatement[66971-67011]:ReturnStatement[67031-67071]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[67023-67034]:ExpressionStatement[67083-67094]"
    }, {
      "left" : "if (!match(JsDocToken.RC))",
      "right" : "if (!match(JsDocToken.RC))",
      "info" : "IfStatement[67039-67135]:IfStatement[67099-67195]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67066-67135]:Block[67126-67195]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
      "info" : "ReturnStatement[67074-67129]:ReturnStatement[67134-67189]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[67141-67148]:ExpressionStatement[67201-67208]"
    }, {
      "left" : "recordType.addChildToBack(fieldTypeList);",
      "right" : "recordType.addChildToBack(fieldTypeList);",
      "info" : "ExpressionStatement[67154-67195]:ExpressionStatement[67214-67255]"
    }, {
      "left" : "return recordType;",
      "right" : "return recordType;",
      "info" : "ReturnStatement[67200-67218]:ReturnStatement[67260-67278]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67350-67826]:Block[67410-67886]"
    }, {
      "left" : "Node fieldTypeList = newNode(Token.LB);",
      "right" : "Node fieldTypeList = newNode(Token.LB);",
      "info" : "VariableDeclarationStatement[67356-67395]:VariableDeclarationStatement[67416-67455]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[67401-67795]:DoStatement[67461-67855]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67404-67781]:Block[67464-67841]"
    }, {
      "left" : "Node fieldType = parseFieldType(token);",
      "right" : "Node fieldType = parseFieldType(token);",
      "info" : "VariableDeclarationStatement[67412-67451]:VariableDeclarationStatement[67472-67511]"
    }, {
      "left" : "if (fieldType == null)",
      "right" : "if (fieldType == null)",
      "info" : "IfStatement[67459-67512]:IfStatement[67519-67572]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67482-67512]:Block[67542-67572]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[67492-67504]:ReturnStatement[67552-67564]"
    }, {
      "left" : "fieldTypeList.addChildToBack(fieldType);",
      "right" : "fieldTypeList.addChildToBack(fieldType);",
      "info" : "ExpressionStatement[67520-67560]:ExpressionStatement[67580-67620]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[67568-67579]:ExpressionStatement[67628-67639]"
    }, {
      "left" : "if (!match(JsDocToken.COMMA))",
      "right" : "if (!match(JsDocToken.COMMA))",
      "info" : "IfStatement[67586-67640]:IfStatement[67646-67700]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67616-67640]:Block[67676-67700]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[67626-67632]:BreakStatement[67686-67692]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[67682-67689]:ExpressionStatement[67742-67749]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[67742-67753]:ExpressionStatement[67802-67813]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[67760-67775]:ExpressionStatement[67820-67835]"
    }, {
      "left" : "return fieldTypeList;",
      "right" : "return fieldTypeList;",
      "info" : "ReturnStatement[67801-67822]:ReturnStatement[67861-67882]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[67947-68537]:Block[68007-68597]"
    }, {
      "left" : "Node fieldName = parseFieldName(token);",
      "right" : "Node fieldName = parseFieldName(token);",
      "info" : "VariableDeclarationStatement[67953-67992]:VariableDeclarationStatement[68013-68052]"
    }, {
      "left" : "if (fieldName == null)",
      "right" : "if (fieldName == null)",
      "info" : "IfStatement[67998-68047]:IfStatement[68058-68107]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68021-68047]:Block[68081-68107]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[68029-68041]:ReturnStatement[68089-68101]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68053-68064]:ExpressionStatement[68113-68124]"
    }, {
      "left" : "if (!match(JsDocToken.COLON))",
      "right" : "if (!match(JsDocToken.COLON))",
      "info" : "IfStatement[68069-68130]:IfStatement[68129-68190]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68099-68130]:Block[68159-68190]"
    }, {
      "left" : "return fieldName;",
      "right" : "return fieldName;",
      "info" : "ReturnStatement[68107-68124]:ReturnStatement[68167-68184]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[68162-68169]:ExpressionStatement[68222-68229]"
    }, {
      "left" : "skipEOLs();",
      "right" : "skipEOLs();",
      "info" : "ExpressionStatement[68254-68265]:ExpressionStatement[68314-68325]"
    }, {
      "left" : "Node typeExpression = parseTypeExpression(next());",
      "right" : "Node typeExpression = parseTypeExpression(next());",
      "info" : "VariableDeclarationStatement[68270-68320]:VariableDeclarationStatement[68330-68380]"
    }, {
      "left" : "if (typeExpression == null)",
      "right" : "if (typeExpression == null)",
      "info" : "IfStatement[68326-68380]:IfStatement[68386-68440]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68354-68380]:Block[68414-68440]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[68362-68374]:ReturnStatement[68422-68434]"
    }, {
      "left" : "Node fieldType = newNode(Token.COLON);",
      "right" : "Node fieldType = newNode(Token.COLON);",
      "info" : "VariableDeclarationStatement[68386-68424]:VariableDeclarationStatement[68446-68484]"
    }, {
      "left" : "fieldType.addChildToBack(fieldName);",
      "right" : "fieldType.addChildToBack(fieldName);",
      "info" : "ExpressionStatement[68429-68465]:ExpressionStatement[68489-68525]"
    }, {
      "left" : "fieldType.addChildToBack(typeExpression);",
      "right" : "fieldType.addChildToBack(typeExpression);",
      "info" : "ExpressionStatement[68470-68511]:ExpressionStatement[68530-68571]"
    }, {
      "left" : "return fieldType;",
      "right" : "return fieldType;",
      "info" : "ReturnStatement[68516-68533]:ReturnStatement[68576-68593]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68690-68860]:Block[68750-68920]"
    }, {
      "left" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
      "right" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
      "info" : "SwitchStatement[68696-68856]:SwitchStatement[68756-68916]"
    }, {
      "left" : "case STRING:",
      "right" : "case STRING:",
      "info" : "SwitchCase[68719-68731]:SwitchCase[68779-68791]"
    }, {
      "left" : "String string = stream.getString();",
      "right" : "String string = stream.getString();",
      "info" : "VariableDeclarationStatement[68740-68775]:VariableDeclarationStatement[68800-68835]"
    }, {
      "left" : "return newStringNode(string);",
      "right" : "return newStringNode(string);",
      "info" : "ReturnStatement[68784-68813]:ReturnStatement[68844-68873]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[68821-68829]:SwitchCase[68881-68889]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[68838-68850]:ReturnStatement[68898-68910]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[68904-69047]:Block[68964-69107]"
    }, {
      "left" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);",
      "right" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);",
      "info" : "ReturnStatement[68910-69043]:ReturnStatement[68970-69103]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69082-69191]:Block[69142-69251]"
    }, {
      "left" : "return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
      "right" : "return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
      "info" : "ReturnStatement[69088-69187]:ReturnStatement[69148-69247]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69232-69344]:Block[69292-69404]"
    }, {
      "left" : "return Node.newString(s, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
      "right" : "return Node.newString(s, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
      "info" : "ReturnStatement[69238-69340]:ReturnStatement[69298-69400]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69500-69680]:Block[69560-69740]"
    }, {
      "left" : "Node templateNode = new Node(Token.SCRIPT);",
      "right" : "Node templateNode = new Node(Token.SCRIPT);",
      "info" : "VariableDeclarationStatement[69548-69591]:VariableDeclarationStatement[69608-69651]"
    }, {
      "left" : "templateNode.putProp(Node.SOURCENAME_PROP, sourceName);",
      "right" : "templateNode.putProp(Node.SOURCENAME_PROP, sourceName);",
      "info" : "ExpressionStatement[69596-69651]:ExpressionStatement[69656-69711]"
    }, {
      "left" : "return templateNode;",
      "right" : "return templateNode;",
      "info" : "ReturnStatement[69656-69676]:ReturnStatement[69716-69736]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69737-69835]:Block[69797-69895]"
    }, {
      "left" : "parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());",
      "right" : "parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());",
      "info" : "ExpressionStatement[69743-69814]:ExpressionStatement[69803-69874]"
    }, {
      "left" : "return null;",
      "right" : "return null;",
      "info" : "ReturnStatement[69819-69831]:ReturnStatement[69879-69891]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[69885-69951]:Block[69945-70011]"
    }, {
      "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
      "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
      "info" : "ReturnStatement[69891-69947]:ReturnStatement[69951-70007]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70134-70177]:Block[70194-70237]"
    }, {
      "left" : "return eatTokensUntilEOL(next());",
      "right" : "return eatTokensUntilEOL(next());",
      "info" : "ReturnStatement[70140-70173]:ReturnStatement[70200-70233]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70376-70607]:Block[70436-70667]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[70382-70603]:DoStatement[70442-70663]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70385-70589]:Block[70445-70649]"
    }, {
      "left" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
      "right" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
      "info" : "IfStatement[70393-70561]:IfStatement[70453-70621]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70486-70561]:Block[70546-70621]"
    }, {
      "left" : "state = State.SEARCHING_ANNOTATION;",
      "right" : "state = State.SEARCHING_ANNOTATION;",
      "info" : "ExpressionStatement[70496-70531]:ExpressionStatement[70556-70591]"
    }, {
      "left" : "return token;",
      "right" : "return token;",
      "info" : "ReturnStatement[70540-70553]:ReturnStatement[70600-70613]"
    }, {
      "left" : "token = next();",
      "right" : "token = next();",
      "info" : "ExpressionStatement[70568-70583]:ExpressionStatement[70628-70643]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[70956-70986]:Block[71016-71046]"
    }, {
      "left" : "unreadToken = token;",
      "right" : "unreadToken = token;",
      "info" : "ExpressionStatement[70962-70982]:ExpressionStatement[71022-71042]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71130-71194]:Block[71190-71254]"
    }, {
      "left" : "unreadToken = next();",
      "right" : "unreadToken = next();",
      "info" : "ExpressionStatement[71136-71157]:ExpressionStatement[71196-71217]"
    }, {
      "left" : "return unreadToken == token;",
      "right" : "return unreadToken == token;",
      "info" : "ReturnStatement[71162-71190]:ReturnStatement[71222-71250]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71364-71454]:Block[71424-71514]"
    }, {
      "left" : "unreadToken = next();",
      "right" : "unreadToken = next();",
      "info" : "ExpressionStatement[71370-71391]:ExpressionStatement[71430-71451]"
    }, {
      "left" : "return unreadToken == token1 || unreadToken == token2;",
      "right" : "return unreadToken == token1 || unreadToken == token2;",
      "info" : "ReturnStatement[71396-71450]:ReturnStatement[71456-71510]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71603-71730]:Block[71663-71790]"
    }, {
      "left" : "if (unreadToken == NO_UNREAD_TOKEN)",
      "right" : "if (unreadToken == NO_UNREAD_TOKEN)",
      "info" : "IfStatement[71609-71726]:IfStatement[71669-71786]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71645-71689]:Block[71705-71749]"
    }, {
      "left" : "return stream.getJsDocToken();",
      "right" : "return stream.getJsDocToken();",
      "info" : "ReturnStatement[71653-71683]:ReturnStatement[71713-71743]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71695-71726]:Block[71755-71786]"
    }, {
      "left" : "return current();",
      "right" : "return current();",
      "info" : "ReturnStatement[71703-71720]:ReturnStatement[71763-71780]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[71836-71922]:Block[71896-71982]"
    }, {
      "left" : "JsDocToken t = unreadToken;",
      "right" : "JsDocToken t = unreadToken;",
      "info" : "VariableDeclarationStatement[71842-71869]:VariableDeclarationStatement[71902-71929]"
    }, {
      "left" : "unreadToken = NO_UNREAD_TOKEN;",
      "right" : "unreadToken = NO_UNREAD_TOKEN;",
      "info" : "ExpressionStatement[71874-71904]:ExpressionStatement[71934-71964]"
    }, {
      "left" : "return t;",
      "right" : "return t;",
      "info" : "ReturnStatement[71909-71918]:ReturnStatement[71969-71978]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72090-72211]:Block[72150-72271]"
    }, {
      "left" : "while (match(JsDocToken.EOL))",
      "right" : "while (match(JsDocToken.EOL))",
      "info" : "WhileStatement[72096-72207]:WhileStatement[72156-72267]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72126-72207]:Block[72186-72267]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[72134-72141]:ExpressionStatement[72194-72201]"
    }, {
      "left" : "if (match(JsDocToken.STAR))",
      "right" : "if (match(JsDocToken.STAR))",
      "info" : "IfStatement[72148-72201]:IfStatement[72208-72261]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72176-72201]:Block[72236-72261]"
    }, {
      "left" : "next();",
      "right" : "next();",
      "info" : "ExpressionStatement[72186-72193]:ExpressionStatement[72246-72253]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72371-72431]:Block[72431-72491]"
    }, {
      "left" : "return jsdocBuilder.isPopulatedWithFileOverview();",
      "right" : "return jsdocBuilder.isPopulatedWithFileOverview();",
      "info" : "ReturnStatement[72377-72427]:ReturnStatement[72437-72487]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72464-72508]:Block[72524-72568]"
    }, {
      "left" : "return jsdocBuilder.isPopulated();",
      "right" : "return jsdocBuilder.isPopulated();",
      "info" : "ReturnStatement[72470-72504]:ReturnStatement[72530-72564]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72556-72604]:Block[72616-72664]"
    }, {
      "left" : "return jsdocBuilder.build(sourceName);",
      "right" : "return jsdocBuilder.build(sourceName);",
      "info" : "ReturnStatement[72562-72600]:ReturnStatement[72622-72660]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[72703-72742]:Block[72763-72802]"
    }, {
      "left" : "return fileOverviewJSDocInfo;",
      "right" : "return fileOverviewJSDocInfo;",
      "info" : "ReturnStatement[72709-72738]:ReturnStatement[72769-72798]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73141-73436]:Block[73201-73496]"
    }, {
      "left" : "boolean matchedLc = false;",
      "right" : "boolean matchedLc = false;",
      "info" : "VariableDeclarationStatement[73147-73173]:VariableDeclarationStatement[73207-73233]"
    }, {
      "left" : "int c;",
      "right" : "int c;",
      "info" : "VariableDeclarationStatement[73178-73184]:VariableDeclarationStatement[73238-73244]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[73189-73385]:WhileStatement[73249-73445]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73202-73385]:Block[73262-73445]"
    }, {
      "left" : "c = stream.getChar();",
      "right" : "c = stream.getChar();",
      "info" : "ExpressionStatement[73210-73231]:ExpressionStatement[73270-73291]"
    }, {
      "left" : "if (c == ' ')",
      "right" : "if (c == ' ')",
      "info" : "IfStatement[73238-73379]:IfStatement[73298-73439]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73252-73279]:Block[73312-73339]"
    }, {
      "left" : "continue;",
      "right" : "continue;",
      "info" : "ContinueStatement[73262-73271]:ContinueStatement[73322-73331]"
    }, {
      "left" : "if (c == '{')",
      "right" : "if (c == '{')",
      "info" : "IfStatement[73285-73379]:IfStatement[73345-73439]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73299-73349]:Block[73359-73409]"
    }, {
      "left" : "matchedLc = true;",
      "right" : "matchedLc = true;",
      "info" : "ExpressionStatement[73309-73326]:ExpressionStatement[73369-73386]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[73335-73341]:BreakStatement[73395-73401]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[73355-73379]:Block[73415-73439]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[73365-73371]:BreakStatement[73425-73431]"
    }, {
      "left" : "stream.ungetChar(c);",
      "right" : "stream.ungetChar(c);",
      "info" : "ExpressionStatement[73390-73410]:ExpressionStatement[73450-73470]"
    }, {
      "left" : "return matchedLc;",
      "right" : "return matchedLc;",
      "info" : "ReturnStatement[73415-73432]:ReturnStatement[73475-73492]"
    } ]
  },
  "interFileMappings" : { }
}