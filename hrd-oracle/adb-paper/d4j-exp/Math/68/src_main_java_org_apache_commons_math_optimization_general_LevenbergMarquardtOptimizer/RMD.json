{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "LevenbergMarquardtOptimizer",
      "right" : "LevenbergMarquardtOptimizer",
      "info" : "TypeDeclaration[1082-34018]:TypeDeclaration[1082-34446]"
    }, {
      "left" : "private int solvedCols;",
      "right" : "private int solvedCols;",
      "info" : "FieldDeclaration[5236-5294]:FieldDeclaration[5236-5294]"
    }, {
      "left" : "private double[] diagR;",
      "right" : "private double[] diagR;",
      "info" : "FieldDeclaration[5300-5395]:FieldDeclaration[5300-5395]"
    }, {
      "left" : "private double[] jacNorm;",
      "right" : "private double[] jacNorm;",
      "info" : "FieldDeclaration[5401-5482]:FieldDeclaration[5401-5482]"
    }, {
      "left" : "private double[] beta;",
      "right" : "private double[] beta;",
      "info" : "FieldDeclaration[5488-5573]:FieldDeclaration[5488-5573]"
    }, {
      "left" : "private int[] permutation;",
      "right" : "private int[] permutation;",
      "info" : "FieldDeclaration[5579-5643]:FieldDeclaration[5579-5643]"
    }, {
      "left" : "private int rank;",
      "right" : "private int rank;",
      "info" : "FieldDeclaration[5649-5706]:FieldDeclaration[5649-5706]"
    }, {
      "left" : "private double lmPar;",
      "right" : "private double lmPar;",
      "info" : "FieldDeclaration[5712-5775]:FieldDeclaration[5712-5775]"
    }, {
      "left" : "private double[] lmDir;",
      "right" : "private double[] lmDir;",
      "info" : "FieldDeclaration[5781-5869]:FieldDeclaration[5781-5869]"
    }, {
      "left" : "private double initialStepBoundFactor;",
      "right" : "private double initialStepBoundFactor;",
      "info" : "FieldDeclaration[5875-5992]:FieldDeclaration[5875-5992]"
    }, {
      "left" : "private double costRelativeTolerance;",
      "right" : "private double costRelativeTolerance;",
      "info" : "FieldDeclaration[5998-6092]:FieldDeclaration[5998-6092]"
    }, {
      "left" : "private double parRelativeTolerance;",
      "right" : "private double parRelativeTolerance;",
      "info" : "FieldDeclaration[6098-6209]:FieldDeclaration[6098-6209]"
    }, {
      "left" : "private double orthoTolerance;",
      "right" : "private double orthoTolerance;",
      "info" : "FieldDeclaration[6215-6364]:FieldDeclaration[6215-6364]"
    }, {
      "left" : "public LevenbergMarquardtOptimizer()",
      "right" : "public LevenbergMarquardtOptimizer()",
      "info" : "MethodDeclaration[6370-7765]:MethodDeclaration[6370-7802]"
    }, {
      "left" : "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
      "right" : "public void setInitialStepBoundFactor(double initialStepBoundFactor)",
      "info" : "MethodDeclaration[7771-8354]:MethodDeclaration[7808-8391]"
    }, {
      "left" : "public void setCostRelativeTolerance(double costRelativeTolerance)",
      "right" : "public void setCostRelativeTolerance(double costRelativeTolerance)",
      "info" : "MethodDeclaration[8360-8783]:MethodDeclaration[8397-8820]"
    }, {
      "left" : "public void setParRelativeTolerance(double parRelativeTolerance)",
      "right" : "public void setParRelativeTolerance(double parRelativeTolerance)",
      "info" : "MethodDeclaration[8789-9248]:MethodDeclaration[8826-9285]"
    }, {
      "left" : "public void setOrthoTolerance(double orthoTolerance)",
      "right" : "public void setOrthoTolerance(double orthoTolerance)",
      "info" : "MethodDeclaration[9254-9721]:MethodDeclaration[9291-9758]"
    }, {
      "left" : "protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException",
      "right" : "protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException",
      "info" : "MethodDeclaration[9727-18788]:MethodDeclaration[9764-19216]"
    }, {
      "left" : "private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3)",
      "right" : "private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3)",
      "info" : "MethodDeclaration[18794-24927]:MethodDeclaration[19222-25355]"
    }, {
      "left" : "private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work)",
      "right" : "private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work)",
      "info" : "MethodDeclaration[24933-29705]:MethodDeclaration[25361-30133]"
    }, {
      "left" : "private void qrDecomposition() throws OptimizationException",
      "right" : "private void qrDecomposition() throws OptimizationException",
      "info" : "MethodDeclaration[29711-33451]:MethodDeclaration[30139-33879]"
    }, {
      "left" : "private void qTy(double[] y)",
      "right" : "private void qTy(double[] y)",
      "info" : "MethodDeclaration[33457-34015]:MethodDeclaration[33885-34443]"
    } ],
    "mappings" : [
 {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[5150-5156]:Modifier[5150-5156]"
    }, {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[5157-5162]:TYPE_DECLARATION_KIND[5157-5162]"
    }, {
      "left" : "LevenbergMarquardtOptimizer",
      "right" : "LevenbergMarquardtOptimizer",
      "info" : "SimpleName[5163-5190]:SimpleName[5163-5190]"
    }, {
      "left" : "AbstractLeastSquaresOptimizer",
      "right" : "AbstractLeastSquaresOptimizer",
      "info" : "SimpleType[5199-5228]:SimpleType[5199-5228]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[7393-7399]:Modifier[7393-7399]"
    }, {
      "left" : "LevenbergMarquardtOptimizer",
      "right" : "LevenbergMarquardtOptimizer",
      "info" : "SimpleName[7400-7427]:SimpleName[7400-7427]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7430-7765]:Block[7430-7802]"
    }, {
      "left" : "setMaxIterations(1000);",
      "right" : "setMaxIterations(1000);",
      "info" : "ExpressionStatement[7519-7542]:ExpressionStatement[7519-7542]"
    }, {
      "left" : "setInitialStepBoundFactor(100.0);",
      "right" : "setInitialStepBoundFactor(100.0);",
      "info" : "ExpressionStatement[7604-7637]:ExpressionStatement[7641-7674]"
    }, {
      "left" : "setCostRelativeTolerance(1.0e-10);",
      "right" : "setCostRelativeTolerance(1.0e-10);",
      "info" : "ExpressionStatement[7646-7680]:ExpressionStatement[7683-7717]"
    }, {
      "left" : "setParRelativeTolerance(1.0e-10);",
      "right" : "setParRelativeTolerance(1.0e-10);",
      "info" : "ExpressionStatement[7689-7722]:ExpressionStatement[7726-7759]"
    }, {
      "left" : "setOrthoTolerance(1.0e-10);",
      "right" : "setOrthoTolerance(1.0e-10);",
      "info" : "ExpressionStatement[7731-7758]:ExpressionStatement[7768-7795]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[8216-8222]:Modifier[8253-8259]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[8223-8227]:PrimitiveType[8260-8264]"
    }, {
      "left" : "setInitialStepBoundFactor",
      "right" : "setInitialStepBoundFactor",
      "info" : "SimpleName[8228-8253]:SimpleName[8265-8290]"
    }, {
      "left" : "double initialStepBoundFactor",
      "right" : "double initialStepBoundFactor",
      "info" : "SingleVariableDeclaration[8254-8283]:SingleVariableDeclaration[8291-8320]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8285-8354]:Block[8322-8391]"
    }, {
      "left" : "this.initialStepBoundFactor = initialStepBoundFactor;",
      "right" : "this.initialStepBoundFactor = initialStepBoundFactor;",
      "info" : "ExpressionStatement[8295-8348]:ExpressionStatement[8332-8385]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[8649-8655]:Modifier[8686-8692]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[8656-8660]:PrimitiveType[8693-8697]"
    }, {
      "left" : "setCostRelativeTolerance",
      "right" : "setCostRelativeTolerance",
      "info" : "SimpleName[8661-8685]:SimpleName[8698-8722]"
    }, {
      "left" : "double costRelativeTolerance",
      "right" : "double costRelativeTolerance",
      "info" : "SingleVariableDeclaration[8686-8714]:SingleVariableDeclaration[8723-8751]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8716-8783]:Block[8753-8820]"
    }, {
      "left" : "this.costRelativeTolerance = costRelativeTolerance;",
      "right" : "this.costRelativeTolerance = costRelativeTolerance;",
      "info" : "ExpressionStatement[8726-8777]:ExpressionStatement[8763-8814]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[9118-9124]:Modifier[9155-9161]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[9125-9129]:PrimitiveType[9162-9166]"
    }, {
      "left" : "setParRelativeTolerance",
      "right" : "setParRelativeTolerance",
      "info" : "SimpleName[9130-9153]:SimpleName[9167-9190]"
    }, {
      "left" : "double parRelativeTolerance",
      "right" : "double parRelativeTolerance",
      "info" : "SingleVariableDeclaration[9154-9181]:SingleVariableDeclaration[9191-9218]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9183-9248]:Block[9220-9285]"
    }, {
      "left" : "this.parRelativeTolerance = parRelativeTolerance;",
      "right" : "this.parRelativeTolerance = parRelativeTolerance;",
      "info" : "ExpressionStatement[9193-9242]:ExpressionStatement[9230-9279]"
    }, {
      "left" : "public",
      "right" : "public",
      "info" : "Modifier[9615-9621]:Modifier[9652-9658]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[9622-9626]:PrimitiveType[9659-9663]"
    }, {
      "left" : "setOrthoTolerance",
      "right" : "setOrthoTolerance",
      "info" : "SimpleName[9627-9644]:SimpleName[9664-9681]"
    }, {
      "left" : "double orthoTolerance",
      "right" : "double orthoTolerance",
      "info" : "SingleVariableDeclaration[9645-9666]:SingleVariableDeclaration[9682-9703]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9668-9721]:Block[9705-9758]"
    }, {
      "left" : "this.orthoTolerance = orthoTolerance;",
      "right" : "this.orthoTolerance = orthoTolerance;",
      "info" : "ExpressionStatement[9678-9715]:ExpressionStatement[9715-9752]"
    }, {
      "left" : "@Override",
      "right" : "@Override",
      "info" : "MarkerAnnotation[9752-9761]:MarkerAnnotation[9789-9798]"
    }, {
      "left" : "protected",
      "right" : "protected",
      "info" : "Modifier[9766-9775]:Modifier[9803-9812]"
    }, {
      "left" : "VectorialPointValuePair",
      "right" : "VectorialPointValuePair",
      "info" : "SimpleType[9776-9799]:SimpleType[9813-9836]"
    }, {
      "left" : "doOptimize",
      "right" : "doOptimize",
      "info" : "SimpleName[9800-9810]:SimpleName[9837-9847]"
    }, {
      "left" : "FunctionEvaluationException",
      "right" : "FunctionEvaluationException",
      "info" : "SimpleType[9828-9855]:SimpleType[9865-9892]"
    }, {
      "left" : "OptimizationException",
      "right" : "OptimizationException",
      "info" : "SimpleType[9857-9878]:SimpleType[9894-9915]"
    }, {
      "left" : "IllegalArgumentException",
      "right" : "IllegalArgumentException",
      "info" : "SimpleType[9880-9904]:SimpleType[9917-9941]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9905-18788]:Block[9942-19216]"
    }, {
      "left" : "solvedCols  = Math.min(rows, cols);",
      "right" : "solvedCols  = Math.min(rows, cols);",
      "info" : "ExpressionStatement[9972-10007]:ExpressionStatement[10009-10044]"
    }, {
      "left" : "diagR       = new double[cols];",
      "right" : "diagR       = new double[cols];",
      "info" : "ExpressionStatement[10016-10047]:ExpressionStatement[10053-10084]"
    }, {
      "left" : "jacNorm     = new double[cols];",
      "right" : "jacNorm     = new double[cols];",
      "info" : "ExpressionStatement[10056-10087]:ExpressionStatement[10093-10124]"
    }, {
      "left" : "beta        = new double[cols];",
      "right" : "beta        = new double[cols];",
      "info" : "ExpressionStatement[10096-10127]:ExpressionStatement[10133-10164]"
    }, {
      "left" : "permutation = new int[cols];",
      "right" : "permutation = new int[cols];",
      "info" : "ExpressionStatement[10136-10164]:ExpressionStatement[10173-10201]"
    }, {
      "left" : "lmDir       = new double[cols];",
      "right" : "lmDir       = new double[cols];",
      "info" : "ExpressionStatement[10173-10204]:ExpressionStatement[10210-10241]"
    }, {
      "left" : "double   delta   = 0;",
      "right" : "double   delta   = 0;",
      "info" : "VariableDeclarationStatement[10237-10258]:VariableDeclarationStatement[10274-10295]"
    }, {
      "left" : "double   xNorm   = 0;",
      "right" : "double   xNorm   = 0;",
      "info" : "VariableDeclarationStatement[10267-10288]:VariableDeclarationStatement[10304-10325]"
    }, {
      "left" : "double[] diag    = new double[cols];",
      "right" : "double[] diag    = new double[cols];",
      "info" : "VariableDeclarationStatement[10297-10333]:VariableDeclarationStatement[10334-10370]"
    }, {
      "left" : "double[] oldX    = new double[cols];",
      "right" : "double[] oldX    = new double[cols];",
      "info" : "VariableDeclarationStatement[10342-10378]:VariableDeclarationStatement[10379-10415]"
    }, {
      "left" : "double[] oldRes  = new double[rows];",
      "right" : "double[] oldRes  = new double[rows];",
      "info" : "VariableDeclarationStatement[10387-10423]:VariableDeclarationStatement[10424-10460]"
    }, {
      "left" : "double[] work1   = new double[cols];",
      "right" : "double[] work1   = new double[cols];",
      "info" : "VariableDeclarationStatement[10432-10468]:VariableDeclarationStatement[10469-10505]"
    }, {
      "left" : "double[] work2   = new double[cols];",
      "right" : "double[] work2   = new double[cols];",
      "info" : "VariableDeclarationStatement[10477-10513]:VariableDeclarationStatement[10514-10550]"
    }, {
      "left" : "double[] work3   = new double[cols];",
      "right" : "double[] work3   = new double[cols];",
      "info" : "VariableDeclarationStatement[10522-10558]:VariableDeclarationStatement[10559-10595]"
    }, {
      "left" : "updateResidualsAndCost();",
      "right" : "updateResidualsAndCost();",
      "info" : "ExpressionStatement[10646-10671]:ExpressionStatement[10683-10708]"
    }, {
      "left" : "lmPar = 0;",
      "right" : "lmPar = 0;",
      "info" : "ExpressionStatement[10703-10713]:ExpressionStatement[10740-10750]"
    }, {
      "left" : "boolean firstIteration = true;",
      "right" : "boolean firstIteration = true;",
      "info" : "VariableDeclarationStatement[10722-10752]:VariableDeclarationStatement[10759-10789]"
    }, {
      "left" : "while (true)",
      "right" : "while (true)",
      "info" : "WhileStatement[10761-18781]:WhileStatement[10887-19209]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10774-18781]:Block[10900-19209]"
    }, {
      "left" : "incrementIterationsCounter();",
      "right" : "incrementIterationsCounter();",
      "info" : "ExpressionStatement[10789-10818]:ExpressionStatement[10915-10944]"
    }, {
      "left" : "updateJacobian();",
      "right" : "updateJacobian();",
      "info" : "ExpressionStatement[10901-10918]:ExpressionStatement[11083-11100]"
    }, {
      "left" : "qrDecomposition();",
      "right" : "qrDecomposition();",
      "info" : "ExpressionStatement[10931-10949]:ExpressionStatement[11113-11131]"
    }, {
      "left" : "qTy(residuals);",
      "right" : "qTy(residuals);",
      "info" : "ExpressionStatement[10993-11008]:ExpressionStatement[11175-11190]"
    }, {
      "left" : "for (int k = 0; k < solvedCols; ++k)",
      "right" : "for (int k = 0; k < solvedCols; ++k)",
      "info" : "ForStatement[11145-11283]:ForStatement[11327-11465]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11182-11283]:Block[11364-11465]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[11200-11224]:VariableDeclarationStatement[11382-11406]"
    }, {
      "left" : "jacobian[k][pk] = diagR[pk];",
      "right" : "jacobian[k][pk] = diagR[pk];",
      "info" : "ExpressionStatement[11241-11269]:ExpressionStatement[11423-11451]"
    }, {
      "left" : "if (firstIteration)",
      "right" : "if (firstIteration)",
      "info" : "IfStatement[11297-11991]:IfStatement[11479-12173]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11317-11991]:Block[11499-12173]"
    }, {
      "left" : "xNorm = 0;",
      "right" : "xNorm = 0;",
      "info" : "ExpressionStatement[11452-11462]:ExpressionStatement[11634-11644]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[11479-11784]:ForStatement[11661-11966]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11510-11784]:Block[11692-11966]"
    }, {
      "left" : "double dk = jacNorm[k];",
      "right" : "double dk = jacNorm[k];",
      "info" : "VariableDeclarationStatement[11532-11555]:VariableDeclarationStatement[11714-11737]"
    }, {
      "left" : "if (dk == 0)",
      "right" : "if (dk == 0)",
      "info" : "IfStatement[11576-11646]:IfStatement[11758-11828]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11589-11646]:Block[11771-11828]"
    }, {
      "left" : "dk = 1.0;",
      "right" : "dk = 1.0;",
      "info" : "ExpressionStatement[11615-11624]:ExpressionStatement[11797-11806]"
    }, {
      "left" : "double xk = dk * point[k];",
      "right" : "double xk = dk * point[k];",
      "info" : "VariableDeclarationStatement[11667-11693]:VariableDeclarationStatement[11849-11875]"
    }, {
      "left" : "xNorm  += xk * xk;",
      "right" : "xNorm  += xk * xk;",
      "info" : "ExpressionStatement[11714-11732]:ExpressionStatement[11896-11914]"
    }, {
      "left" : "diag[k] = dk;",
      "right" : "diag[k] = dk;",
      "info" : "ExpressionStatement[11753-11766]:ExpressionStatement[11935-11948]"
    }, {
      "left" : "xNorm = Math.sqrt(xNorm);",
      "right" : "xNorm = Math.sqrt(xNorm);",
      "info" : "ExpressionStatement[11801-11826]:ExpressionStatement[11983-12008]"
    }, {
      "left" : "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);",
      "right" : "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);",
      "info" : "ExpressionStatement[11895-11976]:ExpressionStatement[12077-12158]"
    }, {
      "left" : "double maxCosine = 0;",
      "right" : "double maxCosine = 0;",
      "info" : "VariableDeclarationStatement[12085-12106]:VariableDeclarationStatement[12267-12288]"
    }, {
      "left" : "if (cost != 0)",
      "right" : "if (cost != 0)",
      "info" : "IfStatement[12119-12644]:IfStatement[12301-12826]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12134-12644]:Block[12316-12826]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[12152-12630]:ForStatement[12334-12812]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12189-12630]:Block[12371-12812]"
    }, {
      "left" : "int    pj = permutation[j];",
      "right" : "int    pj = permutation[j];",
      "info" : "VariableDeclarationStatement[12211-12238]:VariableDeclarationStatement[12393-12420]"
    }, {
      "left" : "double s  = jacNorm[pj];",
      "right" : "double s  = jacNorm[pj];",
      "info" : "VariableDeclarationStatement[12259-12283]:VariableDeclarationStatement[12441-12465]"
    }, {
      "left" : "if (s != 0)",
      "right" : "if (s != 0)",
      "info" : "IfStatement[12304-12612]:IfStatement[12486-12794]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12316-12612]:Block[12498-12794]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[12342-12357]:VariableDeclarationStatement[12524-12539]"
    }, {
      "left" : "for (int i = 0; i <= j; ++i)",
      "right" : "for (int i = 0; i <= j; ++i)",
      "info" : "ForStatement[12382-12505]:ForStatement[12564-12687]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12411-12505]:Block[12593-12687]"
    }, {
      "left" : "sum += jacobian[i][pj] * residuals[i];",
      "right" : "sum += jacobian[i][pj] * residuals[i];",
      "info" : "ExpressionStatement[12441-12479]:ExpressionStatement[12623-12661]"
    }, {
      "left" : "maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));",
      "right" : "maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));",
      "info" : "ExpressionStatement[12530-12590]:ExpressionStatement[12712-12772]"
    }, {
      "left" : "if (maxCosine <= orthoTolerance)",
      "right" : "if (maxCosine <= orthoTolerance)",
      "info" : "IfStatement[12657-12823]:IfStatement[12839-12967]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12690-12823]:Block[12872-12967]"
    }, {
      "left" : "return new VectorialPointValuePair(point, objective);",
      "right" : "return current;",
      "info" : "ReturnStatement[12756-12809]:ReturnStatement[12938-12953]"
    }, {
      "left" : "new VectorialPointValuePair(point, objective)",
      "right" : "new VectorialPointValuePair(point, objective)",
      "info" : "ClassInstanceCreation[12763-12808]:ClassInstanceCreation[10832-10877]"
    }, {
      "left" : "for (int j = 0; j < cols; ++j)",
      "right" : "for (int j = 0; j < cols; ++j)",
      "info" : "ForStatement[12873-12976]:ForStatement[13017-13120]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12904-12976]:Block[13048-13120]"
    }, {
      "left" : "diag[j] = Math.max(diag[j], jacNorm[j]);",
      "right" : "diag[j] = Math.max(diag[j], jacNorm[j]);",
      "info" : "ExpressionStatement[12922-12962]:ExpressionStatement[13066-13106]"
    }, {
      "left" : "for (double ratio = 0; ratio < 1.0e-4)",
      "right" : "for (double ratio = 0; ratio < 1.0e-4)",
      "info" : "ForStatement[13016-18770]:ForStatement[13160-19198]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13056-18770]:Block[13200-19198]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[13109-13252]:ForStatement[13253-13396]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13146-13252]:Block[13290-13396]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[13168-13192]:VariableDeclarationStatement[13312-13336]"
    }, {
      "left" : "oldX[pj] = point[pj];",
      "right" : "oldX[pj] = point[pj];",
      "info" : "ExpressionStatement[13213-13234]:ExpressionStatement[13357-13378]"
    }, {
      "left" : "double previousCost = cost;",
      "right" : "double previousCost = cost;",
      "info" : "VariableDeclarationStatement[13269-13296]:VariableDeclarationStatement[13413-13440]"
    }, {
      "left" : "double[] tmpVec = residuals;",
      "right" : "double[] tmpVec = residuals;",
      "info" : "VariableDeclarationStatement[13313-13341]:VariableDeclarationStatement[13457-13485]"
    }, {
      "left" : "residuals = oldRes;",
      "right" : "residuals = oldRes;",
      "info" : "ExpressionStatement[13358-13377]:ExpressionStatement[13502-13521]"
    }, {
      "left" : "oldRes    = tmpVec;",
      "right" : "oldRes    = tmpVec;",
      "info" : "ExpressionStatement[13394-13413]:ExpressionStatement[13538-13557]"
    }, {
      "left" : "determineLMParameter(oldRes, delta, diag, work1, work2, work3);",
      "right" : "determineLMParameter(oldRes, delta, diag, work1, work2, work3);",
      "info" : "ExpressionStatement[13494-13557]:ExpressionStatement[13638-13701]"
    }, {
      "left" : "double lmNorm = 0;",
      "right" : "double lmNorm = 0;",
      "info" : "VariableDeclarationStatement[13656-13674]:VariableDeclarationStatement[13800-13818]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[13691-13981]:ForStatement[13835-14125]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[13728-13981]:Block[13872-14125]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[13750-13774]:VariableDeclarationStatement[13894-13918]"
    }, {
      "left" : "lmDir[pj] = -lmDir[pj];",
      "right" : "lmDir[pj] = -lmDir[pj];",
      "info" : "ExpressionStatement[13795-13818]:ExpressionStatement[13939-13962]"
    }, {
      "left" : "point[pj] = oldX[pj] + lmDir[pj];",
      "right" : "point[pj] = oldX[pj] + lmDir[pj];",
      "info" : "ExpressionStatement[13839-13872]:ExpressionStatement[13983-14016]"
    }, {
      "left" : "double s = diag[pj] * lmDir[pj];",
      "right" : "double s = diag[pj] * lmDir[pj];",
      "info" : "VariableDeclarationStatement[13893-13925]:VariableDeclarationStatement[14037-14069]"
    }, {
      "left" : "lmNorm  += s * s;",
      "right" : "lmNorm  += s * s;",
      "info" : "ExpressionStatement[13946-13963]:ExpressionStatement[14090-14107]"
    }, {
      "left" : "lmNorm = Math.sqrt(lmNorm);",
      "right" : "lmNorm = Math.sqrt(lmNorm);",
      "info" : "ExpressionStatement[13998-14025]:ExpressionStatement[14142-14169]"
    }, {
      "left" : "if (firstIteration)",
      "right" : "if (firstIteration)",
      "info" : "IfStatement[14117-14209]:IfStatement[14261-14353]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14137-14209]:Block[14281-14353]"
    }, {
      "left" : "delta = Math.min(delta, lmNorm);",
      "right" : "delta = Math.min(delta, lmNorm);",
      "info" : "ExpressionStatement[14159-14191]:ExpressionStatement[14303-14335]"
    }, {
      "left" : "updateResidualsAndCost();",
      "right" : "updateResidualsAndCost();",
      "info" : "ExpressionStatement[14300-14325]:ExpressionStatement[14444-14469]"
    }, {
      "left" : "double actRed = -1.0;",
      "right" : "double actRed = -1.0;",
      "info" : "VariableDeclarationStatement[14398-14419]:VariableDeclarationStatement[14615-14636]"
    }, {
      "left" : "if (0.1 * cost < previousCost)",
      "right" : "if (0.1 * cost < previousCost)",
      "info" : "IfStatement[14436-14580]:IfStatement[14653-14797]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14467-14580]:Block[14684-14797]"
    }, {
      "left" : "double r = cost / previousCost;",
      "right" : "double r = cost / previousCost;",
      "info" : "VariableDeclarationStatement[14489-14520]:VariableDeclarationStatement[14706-14737]"
    }, {
      "left" : "actRed = 1.0 - r * r;",
      "right" : "actRed = 1.0 - r * r;",
      "info" : "ExpressionStatement[14541-14562]:ExpressionStatement[14758-14779]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[14713-15026]:ForStatement[14930-15243]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14750-15026]:Block[14967-15243]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[14772-14796]:VariableDeclarationStatement[14989-15013]"
    }, {
      "left" : "double dirJ = lmDir[pj];",
      "right" : "double dirJ = lmDir[pj];",
      "info" : "VariableDeclarationStatement[14817-14841]:VariableDeclarationStatement[15034-15058]"
    }, {
      "left" : "work1[j] = 0;",
      "right" : "work1[j] = 0;",
      "info" : "ExpressionStatement[14862-14875]:ExpressionStatement[15079-15092]"
    }, {
      "left" : "for (int i = 0; i <= j; ++i)",
      "right" : "for (int i = 0; i <= j; ++i)",
      "info" : "ForStatement[14896-15008]:ForStatement[15113-15225]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14925-15008]:Block[15142-15225]"
    }, {
      "left" : "work1[i] += jacobian[i][pj] * dirJ;",
      "right" : "work1[i] += jacobian[i][pj] * dirJ;",
      "info" : "ExpressionStatement[14951-14986]:ExpressionStatement[15168-15203]"
    }, {
      "left" : "double coeff1 = 0;",
      "right" : "double coeff1 = 0;",
      "info" : "VariableDeclarationStatement[15043-15061]:VariableDeclarationStatement[15260-15278]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[15078-15185]:ForStatement[15295-15402]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15115-15185]:Block[15332-15402]"
    }, {
      "left" : "coeff1 += work1[j] * work1[j];",
      "right" : "coeff1 += work1[j] * work1[j];",
      "info" : "ExpressionStatement[15137-15167]:ExpressionStatement[15354-15384]"
    }, {
      "left" : "double pc2 = previousCost * previousCost;",
      "right" : "double pc2 = previousCost * previousCost;",
      "info" : "VariableDeclarationStatement[15202-15243]:VariableDeclarationStatement[15419-15460]"
    }, {
      "left" : "coeff1 = coeff1 / pc2;",
      "right" : "coeff1 = coeff1 / pc2;",
      "info" : "ExpressionStatement[15260-15282]:ExpressionStatement[15477-15499]"
    }, {
      "left" : "double coeff2 = lmPar * lmNorm * lmNorm / pc2;",
      "right" : "double coeff2 = lmPar * lmNorm * lmNorm / pc2;",
      "info" : "VariableDeclarationStatement[15299-15345]:VariableDeclarationStatement[15516-15562]"
    }, {
      "left" : "double preRed = coeff1 + 2 * coeff2;",
      "right" : "double preRed = coeff1 + 2 * coeff2;",
      "info" : "VariableDeclarationStatement[15362-15398]:VariableDeclarationStatement[15579-15615]"
    }, {
      "left" : "double dirDer = -(coeff1 + coeff2);",
      "right" : "double dirDer = -(coeff1 + coeff2);",
      "info" : "VariableDeclarationStatement[15415-15450]:VariableDeclarationStatement[15632-15667]"
    }, {
      "left" : "ratio = (preRed == 0) ? 0 : (actRed / preRed);",
      "right" : "ratio = (preRed == 0) ? 0 : (actRed / preRed);",
      "info" : "ExpressionStatement[15534-15580]:ExpressionStatement[15751-15797]"
    }, {
      "left" : "if (ratio <= 0.25)",
      "right" : "if (ratio <= 0.25)",
      "info" : "IfStatement[15639-16181]:IfStatement[15856-16398]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15658-16045]:Block[15875-16262]"
    }, {
      "left" : "double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;",
      "right" : "double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;",
      "info" : "VariableDeclarationStatement[15680-15779]:VariableDeclarationStatement[15897-15996]"
    }, {
      "left" : "if ((0.1 * cost >= previousCost) || (tmp < 0.1))",
      "right" : "if ((0.1 * cost >= previousCost) || (tmp < 0.1))",
      "info" : "IfStatement[15804-15919]:IfStatement[16021-16136]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15853-15919]:Block[16070-16136]"
    }, {
      "left" : "tmp = 0.1;",
      "right" : "tmp = 0.1;",
      "info" : "ExpressionStatement[15883-15893]:ExpressionStatement[16100-16110]"
    }, {
      "left" : "delta = tmp * Math.min(delta, 10.0 * lmNorm);",
      "right" : "delta = tmp * Math.min(delta, 10.0 * lmNorm);",
      "info" : "ExpressionStatement[15944-15989]:ExpressionStatement[16161-16206]"
    }, {
      "left" : "lmPar /= tmp;",
      "right" : "lmPar /= tmp;",
      "info" : "ExpressionStatement[16014-16027]:ExpressionStatement[16231-16244]"
    }, {
      "left" : "if ((lmPar == 0) || (ratio >= 0.75))",
      "right" : "if ((lmPar == 0) || (ratio >= 0.75))",
      "info" : "IfStatement[16051-16181]:IfStatement[16268-16398]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16088-16181]:Block[16305-16398]"
    }, {
      "left" : "delta = 2 * lmNorm;",
      "right" : "delta = 2 * lmNorm;",
      "info" : "ExpressionStatement[16110-16129]:ExpressionStatement[16327-16346]"
    }, {
      "left" : "lmPar *= 0.5;",
      "right" : "lmPar *= 0.5;",
      "info" : "ExpressionStatement[16150-16163]:ExpressionStatement[16367-16380]"
    }, {
      "left" : "if (ratio >= 1.0e-4)",
      "right" : "if (ratio >= 1.0e-4)",
      "info" : "IfStatement[16249-17079]:IfStatement[16466-17296]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16270-16647]:Block[16487-16864]"
    }, {
      "left" : "firstIteration = false;",
      "right" : "firstIteration = false;",
      "info" : "ExpressionStatement[16353-16376]:ExpressionStatement[16570-16593]"
    }, {
      "left" : "xNorm = 0;",
      "right" : "xNorm = 0;",
      "info" : "ExpressionStatement[16397-16407]:ExpressionStatement[16614-16624]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[16428-16583]:ForStatement[16645-16800]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16459-16583]:Block[16676-16800]"
    }, {
      "left" : "double xK = diag[k] * point[k];",
      "right" : "double xK = diag[k] * point[k];",
      "info" : "VariableDeclarationStatement[16485-16516]:VariableDeclarationStatement[16702-16733]"
    }, {
      "left" : "xNorm    += xK * xK;",
      "right" : "xNorm    += xK * xK;",
      "info" : "ExpressionStatement[16541-16561]:ExpressionStatement[16758-16778]"
    }, {
      "left" : "xNorm = Math.sqrt(xNorm);",
      "right" : "xNorm = Math.sqrt(xNorm);",
      "info" : "ExpressionStatement[16604-16629]:ExpressionStatement[16821-16846]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16653-17079]:Block[16870-17296]"
    }, {
      "left" : "cost = previousCost;",
      "right" : "cost = previousCost;",
      "info" : "ExpressionStatement[16742-16762]:ExpressionStatement[16959-16979]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[16783-16938]:ForStatement[17000-17155]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16820-16938]:Block[17037-17155]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[16846-16870]:VariableDeclarationStatement[17063-17087]"
    }, {
      "left" : "point[pj] = oldX[pj];",
      "right" : "point[pj] = oldX[pj];",
      "info" : "ExpressionStatement[16895-16916]:ExpressionStatement[17112-17133]"
    }, {
      "left" : "tmpVec    = residuals;",
      "right" : "tmpVec    = residuals;",
      "info" : "ExpressionStatement[16959-16981]:ExpressionStatement[17176-17198]"
    }, {
      "left" : "residuals = oldRes;",
      "right" : "residuals = oldRes;",
      "info" : "ExpressionStatement[17002-17021]:ExpressionStatement[17219-17238]"
    }, {
      "left" : "oldRes    = tmpVec;",
      "right" : "oldRes    = tmpVec;",
      "info" : "ExpressionStatement[17042-17061]:ExpressionStatement[17259-17278]"
    }, {
      "left" : "if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm))",
      "right" : "if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm))",
      "info" : "IfStatement[17293-17617]:IfStatement[17741-18027]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17516-17617]:Block[17964-18027]"
    }, {
      "left" : "return new VectorialPointValuePair(point, objective);",
      "right" : "return current;",
      "info" : "ReturnStatement[17542-17595]:ReturnStatement[17990-18005]"
    }, {
      "left" : "new VectorialPointValuePair(point, objective)",
      "right" : "new VectorialPointValuePair(point, objective)",
      "info" : "ClassInstanceCreation[17549-17594]:ClassInstanceCreation[10832-10877]"
    }, {
      "left" : "if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0))",
      "right" : "if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0))",
      "info" : "IfStatement[17768-18755]:IfStatement[18196-19183]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17850-18141]:Block[18278-18569]"
    }, {
      "left" : "throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n                            \" no further reduction in the\" +\n                            \" sum of squares is possible\",\n                            costRelativeTolerance);",
      "right" : "throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n                            \" no further reduction in the\" +\n                            \" sum of squares is possible\",\n                            costRelativeTolerance);",
      "info" : "ThrowStatement[17872-18123]:ThrowStatement[18300-18551]"
    }, {
      "left" : "if (delta <= 2.2204e-16 * xNorm)",
      "right" : "if (delta <= 2.2204e-16 * xNorm)",
      "info" : "IfStatement[18147-18755]:IfStatement[18575-19183]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18180-18484]:Block[18608-18912]"
    }, {
      "left" : "throw new OptimizationException(\"parameters relative tolerance is too small\" +\n                            \" ({0}), no further improvement in\" +\n                            \" the approximate solution is possible\",\n                            parRelativeTolerance);",
      "right" : "throw new OptimizationException(\"parameters relative tolerance is too small\" +\n                            \" ({0}), no further improvement in\" +\n                            \" the approximate solution is possible\",\n                            parRelativeTolerance);",
      "info" : "ThrowStatement[18202-18466]:ThrowStatement[18630-18894]"
    }, {
      "left" : "if (maxCosine <= 2.2204e-16)",
      "right" : "if (maxCosine <= 2.2204e-16)",
      "info" : "IfStatement[18490-18755]:IfStatement[18918-19183]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[18520-18755]:Block[18948-19183]"
    }, {
      "left" : "throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n                            \" solution is orthogonal to the jacobian\",\n                            orthoTolerance);",
      "right" : "throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n                            \" solution is orthogonal to the jacobian\",\n                            orthoTolerance);",
      "info" : "ThrowStatement[18542-18737]:ThrowStatement[18970-19165]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[19651-19658]:Modifier[20079-20086]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[19659-19663]:PrimitiveType[20087-20091]"
    }, {
      "left" : "determineLMParameter",
      "right" : "determineLMParameter",
      "info" : "SimpleName[19664-19684]:SimpleName[20092-20112]"
    }, {
      "left" : "double[] qy",
      "right" : "double[] qy",
      "info" : "SingleVariableDeclaration[19685-19696]:SingleVariableDeclaration[20113-20124]"
    }, {
      "left" : "double delta",
      "right" : "double delta",
      "info" : "SingleVariableDeclaration[19698-19710]:SingleVariableDeclaration[20126-20138]"
    }, {
      "left" : "double[] diag",
      "right" : "double[] diag",
      "info" : "SingleVariableDeclaration[19712-19725]:SingleVariableDeclaration[20140-20153]"
    }, {
      "left" : "double[] work1",
      "right" : "double[] work1",
      "info" : "SingleVariableDeclaration[19739-19753]:SingleVariableDeclaration[20167-20181]"
    }, {
      "left" : "double[] work2",
      "right" : "double[] work2",
      "info" : "SingleVariableDeclaration[19755-19769]:SingleVariableDeclaration[20183-20197]"
    }, {
      "left" : "double[] work3",
      "right" : "double[] work3",
      "info" : "SingleVariableDeclaration[19771-19785]:SingleVariableDeclaration[20199-20213]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19787-24927]:Block[20215-25355]"
    }, {
      "left" : "for (int j = 0; j < rank; ++j)",
      "right" : "for (int j = 0; j < rank; ++j)",
      "info" : "ForStatement[19938-20023]:ForStatement[20366-20451]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[19969-20023]:Block[20397-20451]"
    }, {
      "left" : "lmDir[permutation[j]] = qy[j];",
      "right" : "lmDir[permutation[j]] = qy[j];",
      "info" : "ExpressionStatement[19983-20013]:ExpressionStatement[20411-20441]"
    }, {
      "left" : "for (int j = rank; j < cols; ++j)",
      "right" : "for (int j = rank; j < cols; ++j)",
      "info" : "ForStatement[20032-20116]:ForStatement[20460-20544]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20066-20116]:Block[20494-20544]"
    }, {
      "left" : "lmDir[permutation[j]] = 0;",
      "right" : "lmDir[permutation[j]] = 0;",
      "info" : "ExpressionStatement[20080-20106]:ExpressionStatement[20508-20534]"
    }, {
      "left" : "for (int k = rank - 1; k >= 0; --k)",
      "right" : "for (int k = rank - 1; k >= 0; --k)",
      "info" : "ForStatement[20125-20406]:ForStatement[20553-20834]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20161-20406]:Block[20589-20834]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[20175-20199]:VariableDeclarationStatement[20603-20627]"
    }, {
      "left" : "double ypk = lmDir[pk] / diagR[pk];",
      "right" : "double ypk = lmDir[pk] / diagR[pk];",
      "info" : "VariableDeclarationStatement[20212-20247]:VariableDeclarationStatement[20640-20675]"
    }, {
      "left" : "for (int i = 0; i < k; ++i)",
      "right" : "for (int i = 0; i < k; ++i)",
      "info" : "ForStatement[20260-20367]:ForStatement[20688-20795]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20288-20367]:Block[20716-20795]"
    }, {
      "left" : "lmDir[permutation[i]] -= ypk * jacobian[i][pk];",
      "right" : "lmDir[permutation[i]] -= ypk * jacobian[i][pk];",
      "info" : "ExpressionStatement[20306-20353]:ExpressionStatement[20734-20781]"
    }, {
      "left" : "lmDir[pk] = ypk;",
      "right" : "lmDir[pk] = ypk;",
      "info" : "ExpressionStatement[20380-20396]:ExpressionStatement[20808-20824]"
    }, {
      "left" : "double dxNorm = 0;",
      "right" : "double dxNorm = 0;",
      "info" : "VariableDeclarationStatement[20529-20547]:VariableDeclarationStatement[20957-20975]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[20556-20742]:ForStatement[20984-21170]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20593-20742]:Block[21021-21170]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[20607-20631]:VariableDeclarationStatement[21035-21059]"
    }, {
      "left" : "double s = diag[pj] * lmDir[pj];",
      "right" : "double s = diag[pj] * lmDir[pj];",
      "info" : "VariableDeclarationStatement[20644-20676]:VariableDeclarationStatement[21072-21104]"
    }, {
      "left" : "work1[pj] = s;",
      "right" : "work1[pj] = s;",
      "info" : "ExpressionStatement[20689-20703]:ExpressionStatement[21117-21131]"
    }, {
      "left" : "dxNorm += s * s;",
      "right" : "dxNorm += s * s;",
      "info" : "ExpressionStatement[20716-20732]:ExpressionStatement[21144-21160]"
    }, {
      "left" : "dxNorm = Math.sqrt(dxNorm);",
      "right" : "dxNorm = Math.sqrt(dxNorm);",
      "info" : "ExpressionStatement[20751-20778]:ExpressionStatement[21179-21206]"
    }, {
      "left" : "double fp = dxNorm - delta;",
      "right" : "double fp = dxNorm - delta;",
      "info" : "VariableDeclarationStatement[20787-20814]:VariableDeclarationStatement[21215-21242]"
    }, {
      "left" : "if (fp <= 0.1 * delta)",
      "right" : "if (fp <= 0.1 * delta)",
      "info" : "IfStatement[20823-20900]:IfStatement[21251-21328]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[20846-20900]:Block[21274-21328]"
    }, {
      "left" : "lmPar = 0;",
      "right" : "lmPar = 0;",
      "info" : "ExpressionStatement[20860-20870]:ExpressionStatement[21288-21298]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[20883-20890]:ReturnStatement[21311-21318]"
    }, {
      "left" : "double sum2;",
      "right" : "double sum2;",
      "info" : "VariableDeclarationStatement[21091-21103]:VariableDeclarationStatement[21519-21531]"
    }, {
      "left" : "double parl = 0;",
      "right" : "double parl = 0;",
      "info" : "VariableDeclarationStatement[21112-21128]:VariableDeclarationStatement[21540-21556]"
    }, {
      "left" : "if (rank == solvedCols)",
      "right" : "if (rank == solvedCols)",
      "info" : "IfStatement[21137-21778]:IfStatement[21565-22206]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21161-21778]:Block[21589-22206]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[21175-21316]:ForStatement[21603-21744]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21212-21316]:Block[21640-21744]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[21230-21254]:VariableDeclarationStatement[21658-21682]"
    }, {
      "left" : "work1[pj] *= diag[pj] / dxNorm;",
      "right" : "work1[pj] *= diag[pj] / dxNorm;",
      "info" : "ExpressionStatement[21271-21302]:ExpressionStatement[21699-21730]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[21329-21338]:ExpressionStatement[21757-21766]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[21351-21728]:ForStatement[21779-22156]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21388-21728]:Block[21816-22156]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[21406-21430]:VariableDeclarationStatement[21834-21858]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[21447-21462]:VariableDeclarationStatement[21875-21890]"
    }, {
      "left" : "for (int i = 0; i < j; ++i)",
      "right" : "for (int i = 0; i < j; ++i)",
      "info" : "ForStatement[21479-21594]:ForStatement[21907-22022]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21507-21594]:Block[21935-22022]"
    }, {
      "left" : "sum += jacobian[i][pj] * work1[permutation[i]];",
      "right" : "sum += jacobian[i][pj] * work1[permutation[i]];",
      "info" : "ExpressionStatement[21529-21576]:ExpressionStatement[21957-22004]"
    }, {
      "left" : "double s = (work1[pj] - sum) / diagR[pj];",
      "right" : "double s = (work1[pj] - sum) / diagR[pj];",
      "info" : "VariableDeclarationStatement[21611-21652]:VariableDeclarationStatement[22039-22080]"
    }, {
      "left" : "work1[pj] = s;",
      "right" : "work1[pj] = s;",
      "info" : "ExpressionStatement[21669-21683]:ExpressionStatement[22097-22111]"
    }, {
      "left" : "sum2 += s * s;",
      "right" : "sum2 += s * s;",
      "info" : "ExpressionStatement[21700-21714]:ExpressionStatement[22128-22142]"
    }, {
      "left" : "parl = fp / (delta * sum2);",
      "right" : "parl = fp / (delta * sum2);",
      "info" : "ExpressionStatement[21741-21768]:ExpressionStatement[22169-22196]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[21860-21869]:ExpressionStatement[22288-22297]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[21878-22156]:ForStatement[22306-22584]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[21915-22156]:Block[22343-22584]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[21929-21953]:VariableDeclarationStatement[22357-22381]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[21966-21981]:VariableDeclarationStatement[22394-22409]"
    }, {
      "left" : "for (int i = 0; i <= j; ++i)",
      "right" : "for (int i = 0; i <= j; ++i)",
      "info" : "ForStatement[21994-22086]:ForStatement[22422-22514]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22023-22086]:Block[22451-22514]"
    }, {
      "left" : "sum += jacobian[i][pj] * qy[i];",
      "right" : "sum += jacobian[i][pj] * qy[i];",
      "info" : "ExpressionStatement[22041-22072]:ExpressionStatement[22469-22500]"
    }, {
      "left" : "sum /= diag[pj];",
      "right" : "sum /= diag[pj];",
      "info" : "ExpressionStatement[22099-22115]:ExpressionStatement[22527-22543]"
    }, {
      "left" : "sum2 += sum * sum;",
      "right" : "sum2 += sum * sum;",
      "info" : "ExpressionStatement[22128-22146]:ExpressionStatement[22556-22574]"
    }, {
      "left" : "double gNorm = Math.sqrt(sum2);",
      "right" : "double gNorm = Math.sqrt(sum2);",
      "info" : "VariableDeclarationStatement[22165-22196]:VariableDeclarationStatement[22593-22624]"
    }, {
      "left" : "double paru = gNorm / delta;",
      "right" : "double paru = gNorm / delta;",
      "info" : "VariableDeclarationStatement[22205-22233]:VariableDeclarationStatement[22633-22661]"
    }, {
      "left" : "if (paru == 0)",
      "right" : "if (paru == 0)",
      "info" : "IfStatement[22242-22391]:IfStatement[22670-22819]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22257-22391]:Block[22685-22819]"
    }, {
      "left" : "paru = 2.2251e-308 / Math.min(delta, 0.1);",
      "right" : "paru = 2.2251e-308 / Math.min(delta, 0.1);",
      "info" : "ExpressionStatement[22339-22381]:ExpressionStatement[22767-22809]"
    }, {
      "left" : "lmPar = Math.min(paru, Math.max(lmPar, parl));",
      "right" : "lmPar = Math.min(paru, Math.max(lmPar, parl));",
      "info" : "ExpressionStatement[22513-22559]:ExpressionStatement[22941-22987]"
    }, {
      "left" : "if (lmPar == 0)",
      "right" : "if (lmPar == 0)",
      "info" : "IfStatement[22568-22631]:IfStatement[22996-23059]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22584-22631]:Block[23012-23059]"
    }, {
      "left" : "lmPar = gNorm / dxNorm;",
      "right" : "lmPar = gNorm / dxNorm;",
      "info" : "ExpressionStatement[22598-22621]:ExpressionStatement[23026-23049]"
    }, {
      "left" : "for (int countdown = 10; countdown >= 0; --countdown)",
      "right" : "for (int countdown = 10; countdown >= 0; --countdown)",
      "info" : "ForStatement[22641-24921]:ForStatement[23069-25349]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22695-24921]:Block[23123-25349]"
    }, {
      "left" : "if (lmPar == 0)",
      "right" : "if (lmPar == 0)",
      "info" : "IfStatement[22777-22869]:IfStatement[23205-23297]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22793-22869]:Block[23221-23297]"
    }, {
      "left" : "lmPar = Math.max(2.2251e-308, 0.001 * paru);",
      "right" : "lmPar = Math.max(2.2251e-308, 0.001 * paru);",
      "info" : "ExpressionStatement[22811-22855]:ExpressionStatement[23239-23283]"
    }, {
      "left" : "double sPar = Math.sqrt(lmPar);",
      "right" : "double sPar = Math.sqrt(lmPar);",
      "info" : "VariableDeclarationStatement[22882-22913]:VariableDeclarationStatement[23310-23341]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[22926-23064]:ForStatement[23354-23492]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[22963-23064]:Block[23391-23492]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[22981-23005]:VariableDeclarationStatement[23409-23433]"
    }, {
      "left" : "work1[pj] = sPar * diag[pj];",
      "right" : "work1[pj] = sPar * diag[pj];",
      "info" : "ExpressionStatement[23022-23050]:ExpressionStatement[23450-23478]"
    }, {
      "left" : "determineLMDirection(qy, work1, work2, work3);",
      "right" : "determineLMDirection(qy, work1, work2, work3);",
      "info" : "ExpressionStatement[23077-23123]:ExpressionStatement[23505-23551]"
    }, {
      "left" : "dxNorm = 0;",
      "right" : "dxNorm = 0;",
      "info" : "ExpressionStatement[23137-23148]:ExpressionStatement[23565-23576]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[23161-23367]:ForStatement[23589-23795]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23198-23367]:Block[23626-23795]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[23216-23240]:VariableDeclarationStatement[23644-23668]"
    }, {
      "left" : "double s = diag[pj] * lmDir[pj];",
      "right" : "double s = diag[pj] * lmDir[pj];",
      "info" : "VariableDeclarationStatement[23257-23289]:VariableDeclarationStatement[23685-23717]"
    }, {
      "left" : "work3[pj] = s;",
      "right" : "work3[pj] = s;",
      "info" : "ExpressionStatement[23306-23320]:ExpressionStatement[23734-23748]"
    }, {
      "left" : "dxNorm += s * s;",
      "right" : "dxNorm += s * s;",
      "info" : "ExpressionStatement[23337-23353]:ExpressionStatement[23765-23781]"
    }, {
      "left" : "dxNorm = Math.sqrt(dxNorm);",
      "right" : "dxNorm = Math.sqrt(dxNorm);",
      "info" : "ExpressionStatement[23380-23407]:ExpressionStatement[23808-23835]"
    }, {
      "left" : "double previousFP = fp;",
      "right" : "double previousFP = fp;",
      "info" : "VariableDeclarationStatement[23420-23443]:VariableDeclarationStatement[23848-23871]"
    }, {
      "left" : "fp = dxNorm - delta;",
      "right" : "fp = dxNorm - delta;",
      "info" : "ExpressionStatement[23456-23476]:ExpressionStatement[23884-23904]"
    }, {
      "left" : "if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0)))",
      "right" : "if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0)))",
      "info" : "IfStatement[23643-23796]:IfStatement[24071-24224]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23757-23796]:Block[24185-24224]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[23775-23782]:ReturnStatement[24203-24210]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[23855-24007]:ForStatement[24283-24435]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[23892-24007]:Block[24320-24435]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[23910-23934]:VariableDeclarationStatement[24338-24362]"
    }, {
      "left" : "work1[pj] = work3[pj] * diag[pj] / dxNorm;",
      "right" : "work1[pj] = work3[pj] * diag[pj] / dxNorm;",
      "info" : "ExpressionStatement[23951-23993]:ExpressionStatement[24379-24421]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[24020-24337]:ForStatement[24448-24765]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24057-24337]:Block[24485-24765]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[24075-24099]:VariableDeclarationStatement[24503-24527]"
    }, {
      "left" : "work1[pj] /= work2[j];",
      "right" : "work1[pj] /= work2[j];",
      "info" : "ExpressionStatement[24116-24138]:ExpressionStatement[24544-24566]"
    }, {
      "left" : "double tmp = work1[pj];",
      "right" : "double tmp = work1[pj];",
      "info" : "VariableDeclarationStatement[24155-24178]:VariableDeclarationStatement[24583-24606]"
    }, {
      "left" : "for (int i = j + 1; i < solvedCols; ++i)",
      "right" : "for (int i = j + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[24195-24323]:ForStatement[24623-24751]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24236-24323]:Block[24664-24751]"
    }, {
      "left" : "work1[permutation[i]] -= jacobian[i][pj] * tmp;",
      "right" : "work1[permutation[i]] -= jacobian[i][pj] * tmp;",
      "info" : "ExpressionStatement[24258-24305]:ExpressionStatement[24686-24733]"
    }, {
      "left" : "sum2 = 0;",
      "right" : "sum2 = 0;",
      "info" : "ExpressionStatement[24350-24359]:ExpressionStatement[24778-24787]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[24372-24505]:ForStatement[24800-24933]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24409-24505]:Block[24837-24933]"
    }, {
      "left" : "double s = work1[permutation[j]];",
      "right" : "double s = work1[permutation[j]];",
      "info" : "VariableDeclarationStatement[24427-24460]:VariableDeclarationStatement[24855-24888]"
    }, {
      "left" : "sum2 += s * s;",
      "right" : "sum2 += s * s;",
      "info" : "ExpressionStatement[24477-24491]:ExpressionStatement[24905-24919]"
    }, {
      "left" : "double correction = fp / (delta * sum2);",
      "right" : "double correction = fp / (delta * sum2);",
      "info" : "VariableDeclarationStatement[24518-24558]:VariableDeclarationStatement[24946-24986]"
    }, {
      "left" : "if (fp > 0)",
      "right" : "if (fp > 0)",
      "info" : "IfStatement[24647-24799]:IfStatement[25075-25227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24659-24720]:Block[25087-25148]"
    }, {
      "left" : "parl = Math.max(parl, lmPar);",
      "right" : "parl = Math.max(parl, lmPar);",
      "info" : "ExpressionStatement[24677-24706]:ExpressionStatement[25105-25134]"
    }, {
      "left" : "if (fp < 0)",
      "right" : "if (fp < 0)",
      "info" : "IfStatement[24726-24799]:IfStatement[25154-25227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[24738-24799]:Block[25166-25227]"
    }, {
      "left" : "paru = Math.min(paru, lmPar);",
      "right" : "paru = Math.min(paru, lmPar);",
      "info" : "ExpressionStatement[24756-24785]:ExpressionStatement[25184-25213]"
    }, {
      "left" : "lmPar = Math.max(parl, lmPar + correction);",
      "right" : "lmPar = Math.max(parl, lmPar + correction);",
      "info" : "ExpressionStatement[24867-24910]:ExpressionStatement[25295-25338]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[25729-25736]:Modifier[26157-26164]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[25737-25741]:PrimitiveType[26165-26169]"
    }, {
      "left" : "determineLMDirection",
      "right" : "determineLMDirection",
      "info" : "SimpleName[25742-25762]:SimpleName[26170-26190]"
    }, {
      "left" : "double[] qy",
      "right" : "double[] qy",
      "info" : "SingleVariableDeclaration[25763-25774]:SingleVariableDeclaration[26191-26202]"
    }, {
      "left" : "double[] diag",
      "right" : "double[] diag",
      "info" : "SingleVariableDeclaration[25776-25789]:SingleVariableDeclaration[26204-26217]"
    }, {
      "left" : "double[] lmDiag",
      "right" : "double[] lmDiag",
      "info" : "SingleVariableDeclaration[25803-25818]:SingleVariableDeclaration[26231-26246]"
    }, {
      "left" : "double[] work",
      "right" : "double[] work",
      "info" : "SingleVariableDeclaration[25820-25833]:SingleVariableDeclaration[26248-26261]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[25835-29705]:Block[26263-30133]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[25975-26256]:ForStatement[26403-26684]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26012-26256]:Block[26440-26684]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[26026-26050]:VariableDeclarationStatement[26454-26478]"
    }, {
      "left" : "for (int i = j + 1; i < solvedCols; ++i)",
      "right" : "for (int i = j + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[26063-26182]:ForStatement[26491-26610]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26104-26182]:Block[26532-26610]"
    }, {
      "left" : "jacobian[i][pj] = jacobian[j][permutation[i]];",
      "right" : "jacobian[i][pj] = jacobian[j][permutation[i]];",
      "info" : "ExpressionStatement[26122-26168]:ExpressionStatement[26550-26596]"
    }, {
      "left" : "lmDir[j] = diagR[pj];",
      "right" : "lmDir[j] = diagR[pj];",
      "info" : "ExpressionStatement[26195-26216]:ExpressionStatement[26623-26644]"
    }, {
      "left" : "work[j]  = qy[j];",
      "right" : "work[j]  = qy[j];",
      "info" : "ExpressionStatement[26229-26246]:ExpressionStatement[26657-26674]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[26333-28778]:ForStatement[26761-29206]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26370-28778]:Block[26798-29206]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[26520-26544]:VariableDeclarationStatement[26948-26972]"
    }, {
      "left" : "double dpj = diag[pj];",
      "right" : "double dpj = diag[pj];",
      "info" : "VariableDeclarationStatement[26557-26579]:VariableDeclarationStatement[26985-27007]"
    }, {
      "left" : "if (dpj != 0)",
      "right" : "if (dpj != 0)",
      "info" : "IfStatement[26592-26683]:IfStatement[27020-27111]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26606-26683]:Block[27034-27111]"
    }, {
      "left" : "Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);",
      "right" : "Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);",
      "info" : "ExpressionStatement[26624-26669]:ExpressionStatement[27052-27097]"
    }, {
      "left" : "lmDiag[j] = dpj;",
      "right" : "lmDiag[j] = dpj;",
      "info" : "ExpressionStatement[26696-26712]:ExpressionStatement[27124-27140]"
    }, {
      "left" : "double qtbpj = 0;",
      "right" : "double qtbpj = 0;",
      "info" : "VariableDeclarationStatement[26899-26916]:VariableDeclarationStatement[27327-27344]"
    }, {
      "left" : "for (int k = j; k < solvedCols; ++k)",
      "right" : "for (int k = j; k < solvedCols; ++k)",
      "info" : "ForStatement[26929-28547]:ForStatement[27357-28975]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[26966-28547]:Block[27394-28975]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[26984-27008]:VariableDeclarationStatement[27412-27436]"
    }, {
      "left" : "if (lmDiag[k] != 0)",
      "right" : "if (lmDiag[k] != 0)",
      "info" : "IfStatement[27157-28533]:IfStatement[27585-28961]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27177-28533]:Block[27605-28961]"
    }, {
      "left" : "final double sin;",
      "right" : "final double sin;",
      "info" : "VariableDeclarationStatement[27200-27217]:VariableDeclarationStatement[27628-27645]"
    }, {
      "left" : "final double cos;",
      "right" : "final double cos;",
      "info" : "VariableDeclarationStatement[27238-27255]:VariableDeclarationStatement[27666-27683]"
    }, {
      "left" : "double rkk = jacobian[k][pk];",
      "right" : "double rkk = jacobian[k][pk];",
      "info" : "VariableDeclarationStatement[27276-27305]:VariableDeclarationStatement[27704-27733]"
    }, {
      "left" : "if (Math.abs(rkk) < Math.abs(lmDiag[k]))",
      "right" : "if (Math.abs(rkk) < Math.abs(lmDiag[k]))",
      "info" : "IfStatement[27326-27761]:IfStatement[27754-28189]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27367-27567]:Block[27795-27995]"
    }, {
      "left" : "final double cotan = rkk / lmDiag[k];",
      "right" : "final double cotan = rkk / lmDiag[k];",
      "info" : "VariableDeclarationStatement[27393-27430]:VariableDeclarationStatement[27821-27858]"
    }, {
      "left" : "sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);",
      "right" : "sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);",
      "info" : "ExpressionStatement[27455-27500]:ExpressionStatement[27883-27928]"
    }, {
      "left" : "cos   = sin * cotan;",
      "right" : "cos   = sin * cotan;",
      "info" : "ExpressionStatement[27525-27545]:ExpressionStatement[27953-27973]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[27573-27761]:Block[28001-28189]"
    }, {
      "left" : "final double tan = lmDiag[k] / rkk;",
      "right" : "final double tan = lmDiag[k] / rkk;",
      "info" : "VariableDeclarationStatement[27599-27634]:VariableDeclarationStatement[28027-28062]"
    }, {
      "left" : "cos = 1.0 / Math.sqrt(1.0 + tan * tan);",
      "right" : "cos = 1.0 / Math.sqrt(1.0 + tan * tan);",
      "info" : "ExpressionStatement[27659-27698]:ExpressionStatement[28087-28126]"
    }, {
      "left" : "sin = cos * tan;",
      "right" : "sin = cos * tan;",
      "info" : "ExpressionStatement[27723-27739]:ExpressionStatement[28151-28167]"
    }, {
      "left" : "jacobian[k][pk] = cos * rkk + sin * lmDiag[k];",
      "right" : "jacobian[k][pk] = cos * rkk + sin * lmDiag[k];",
      "info" : "ExpressionStatement[27908-27954]:ExpressionStatement[28336-28382]"
    }, {
      "left" : "final double temp = cos * work[k] + sin * qtbpj;",
      "right" : "final double temp = cos * work[k] + sin * qtbpj;",
      "info" : "VariableDeclarationStatement[27975-28023]:VariableDeclarationStatement[28403-28451]"
    }, {
      "left" : "qtbpj = -sin * work[k] + cos * qtbpj;",
      "right" : "qtbpj = -sin * work[k] + cos * qtbpj;",
      "info" : "ExpressionStatement[28044-28081]:ExpressionStatement[28472-28509]"
    }, {
      "left" : "work[k] = temp;",
      "right" : "work[k] = temp;",
      "info" : "ExpressionStatement[28102-28117]:ExpressionStatement[28530-28545]"
    }, {
      "left" : "for (int i = k + 1; i < solvedCols; ++i)",
      "right" : "for (int i = k + 1; i < solvedCols; ++i)",
      "info" : "ForStatement[28207-28514]:ForStatement[28635-28942]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28248-28514]:Block[28676-28942]"
    }, {
      "left" : "double rik = jacobian[i][pk];",
      "right" : "double rik = jacobian[i][pk];",
      "info" : "VariableDeclarationStatement[28274-28303]:VariableDeclarationStatement[28702-28731]"
    }, {
      "left" : "final double temp2 = cos * rik + sin * lmDiag[i];",
      "right" : "final double temp2 = cos * rik + sin * lmDiag[i];",
      "info" : "VariableDeclarationStatement[28328-28377]:VariableDeclarationStatement[28756-28805]"
    }, {
      "left" : "lmDiag[i] = -sin * rik + cos * lmDiag[i];",
      "right" : "lmDiag[i] = -sin * rik + cos * lmDiag[i];",
      "info" : "ExpressionStatement[28402-28443]:ExpressionStatement[28830-28871]"
    }, {
      "left" : "jacobian[i][pk] = temp2;",
      "right" : "jacobian[i][pk] = temp2;",
      "info" : "ExpressionStatement[28468-28492]:ExpressionStatement[28896-28920]"
    }, {
      "left" : "lmDiag[j] = jacobian[j][permutation[j]];",
      "right" : "lmDiag[j] = jacobian[j][permutation[j]];",
      "info" : "ExpressionStatement[28675-28715]:ExpressionStatement[29103-29143]"
    }, {
      "left" : "jacobian[j][permutation[j]] = lmDir[j];",
      "right" : "jacobian[j][permutation[j]] = lmDir[j];",
      "info" : "ExpressionStatement[28728-28767]:ExpressionStatement[29156-29195]"
    }, {
      "left" : "int nSing = solvedCols;",
      "right" : "int nSing = solvedCols;",
      "info" : "VariableDeclarationStatement[28909-28932]:VariableDeclarationStatement[29337-29360]"
    }, {
      "left" : "for (int j = 0; j < solvedCols; ++j)",
      "right" : "for (int j = 0; j < solvedCols; ++j)",
      "info" : "ForStatement[28941-29172]:ForStatement[29369-29600]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[28978-29172]:Block[29406-29600]"
    }, {
      "left" : "if ((lmDiag[j] == 0) && (nSing == solvedCols))",
      "right" : "if ((lmDiag[j] == 0) && (nSing == solvedCols))",
      "info" : "IfStatement[28992-29081]:IfStatement[29420-29509]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29039-29081]:Block[29467-29509]"
    }, {
      "left" : "nSing = j;",
      "right" : "nSing = j;",
      "info" : "ExpressionStatement[29057-29067]:ExpressionStatement[29485-29495]"
    }, {
      "left" : "if (nSing < solvedCols)",
      "right" : "if (nSing < solvedCols)",
      "info" : "IfStatement[29094-29162]:IfStatement[29522-29590]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29118-29162]:Block[29546-29590]"
    }, {
      "left" : "work[j] = 0;",
      "right" : "work[j] = 0;",
      "info" : "ExpressionStatement[29136-29148]:ExpressionStatement[29564-29576]"
    }, {
      "left" : "if (nSing > 0)",
      "right" : "if (nSing > 0)",
      "info" : "IfStatement[29181-29526]:IfStatement[29609-29954]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29196-29526]:Block[29624-29954]"
    }, {
      "left" : "for (int j = nSing - 1; j >= 0; --j)",
      "right" : "for (int j = nSing - 1; j >= 0; --j)",
      "info" : "ForStatement[29210-29516]:ForStatement[29638-29944]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29247-29516]:Block[29675-29944]"
    }, {
      "left" : "int pj = permutation[j];",
      "right" : "int pj = permutation[j];",
      "info" : "VariableDeclarationStatement[29265-29289]:VariableDeclarationStatement[29693-29717]"
    }, {
      "left" : "double sum = 0;",
      "right" : "double sum = 0;",
      "info" : "VariableDeclarationStatement[29306-29321]:VariableDeclarationStatement[29734-29749]"
    }, {
      "left" : "for (int i = j + 1; i < nSing; ++i)",
      "right" : "for (int i = j + 1; i < nSing; ++i)",
      "info" : "ForStatement[29338-29447]:ForStatement[29766-29875]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29374-29447]:Block[29802-29875]"
    }, {
      "left" : "sum += jacobian[i][pj] * work[i];",
      "right" : "sum += jacobian[i][pj] * work[i];",
      "info" : "ExpressionStatement[29396-29429]:ExpressionStatement[29824-29857]"
    }, {
      "left" : "work[j] = (work[j] - sum) / lmDiag[j];",
      "right" : "work[j] = (work[j] - sum) / lmDiag[j];",
      "info" : "ExpressionStatement[29464-29502]:ExpressionStatement[29892-29930]"
    }, {
      "left" : "for (int j = 0; j < lmDir.length; ++j)",
      "right" : "for (int j = 0; j < lmDir.length; ++j)",
      "info" : "ForStatement[29603-29698]:ForStatement[30031-30126]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[29642-29698]:Block[30070-30126]"
    }, {
      "left" : "lmDir[permutation[j]] = work[j];",
      "right" : "lmDir[permutation[j]] = work[j];",
      "info" : "ExpressionStatement[29656-29688]:ExpressionStatement[30084-30116]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[30936-30943]:Modifier[31364-31371]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[30944-30948]:PrimitiveType[31372-31376]"
    }, {
      "left" : "qrDecomposition",
      "right" : "qrDecomposition",
      "info" : "SimpleName[30949-30964]:SimpleName[31377-31392]"
    }, {
      "left" : "OptimizationException",
      "right" : "OptimizationException",
      "info" : "SimpleType[30974-30995]:SimpleType[31402-31423]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[30996-33451]:Block[31424-33879]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[31034-31332]:ForStatement[31462-31760]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31065-31332]:Block[31493-31760]"
    }, {
      "left" : "permutation[k] = k;",
      "right" : "permutation[k] = k;",
      "info" : "ExpressionStatement[31079-31098]:ExpressionStatement[31507-31526]"
    }, {
      "left" : "double norm2 = 0;",
      "right" : "double norm2 = 0;",
      "info" : "VariableDeclarationStatement[31111-31128]:VariableDeclarationStatement[31539-31556]"
    }, {
      "left" : "for (int i = 0; i < jacobian.length; ++i)",
      "right" : "for (int i = 0; i < jacobian.length; ++i)",
      "info" : "ForStatement[31141-31279]:ForStatement[31569-31707]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31183-31279]:Block[31611-31707]"
    }, {
      "left" : "double akk = jacobian[i][k];",
      "right" : "double akk = jacobian[i][k];",
      "info" : "VariableDeclarationStatement[31201-31229]:VariableDeclarationStatement[31629-31657]"
    }, {
      "left" : "norm2 += akk * akk;",
      "right" : "norm2 += akk * akk;",
      "info" : "ExpressionStatement[31246-31265]:ExpressionStatement[31674-31693]"
    }, {
      "left" : "jacNorm[k] = Math.sqrt(norm2);",
      "right" : "jacNorm[k] = Math.sqrt(norm2);",
      "info" : "ExpressionStatement[31292-31322]:ExpressionStatement[31720-31750]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[31394-33416]:ForStatement[31822-33844]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31425-33416]:Block[31853-33844]"
    }, {
      "left" : "int nextColumn = -1;",
      "right" : "int nextColumn = -1;",
      "info" : "VariableDeclarationStatement[31517-31537]:VariableDeclarationStatement[31945-31965]"
    }, {
      "left" : "double ak2 = Double.NEGATIVE_INFINITY;",
      "right" : "double ak2 = Double.NEGATIVE_INFINITY;",
      "info" : "VariableDeclarationStatement[31550-31588]:VariableDeclarationStatement[31978-32016]"
    }, {
      "left" : "for (int i = k; i < cols; ++i)",
      "right" : "for (int i = k; i < cols; ++i)",
      "info" : "ForStatement[31601-32271]:ForStatement[32029-32699]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31632-32271]:Block[32060-32699]"
    }, {
      "left" : "double norm2 = 0;",
      "right" : "double norm2 = 0;",
      "info" : "VariableDeclarationStatement[31650-31667]:VariableDeclarationStatement[32078-32095]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[31684-31847]:ForStatement[32112-32275]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31726-31847]:Block[32154-32275]"
    }, {
      "left" : "double aki = jacobian[j][permutation[i]];",
      "right" : "double aki = jacobian[j][permutation[i]];",
      "info" : "VariableDeclarationStatement[31748-31789]:VariableDeclarationStatement[32176-32217]"
    }, {
      "left" : "norm2 += aki * aki;",
      "right" : "norm2 += aki * aki;",
      "info" : "ExpressionStatement[31810-31829]:ExpressionStatement[32238-32257]"
    }, {
      "left" : "if (Double.isInfinite(norm2) || Double.isNaN(norm2))",
      "right" : "if (Double.isInfinite(norm2) || Double.isNaN(norm2))",
      "info" : "IfStatement[31864-32128]:IfStatement[32292-32556]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[31917-32128]:Block[32345-32556]"
    }, {
      "left" : "throw new OptimizationException(\n                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n                            rows, cols);",
      "right" : "throw new OptimizationException(\n                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n                            rows, cols);",
      "info" : "ThrowStatement[31939-32110]:ThrowStatement[32367-32538]"
    }, {
      "left" : "if (norm2 > ak2)",
      "right" : "if (norm2 > ak2)",
      "info" : "IfStatement[32145-32257]:IfStatement[32573-32685]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32162-32257]:Block[32590-32685]"
    }, {
      "left" : "nextColumn = i;",
      "right" : "nextColumn = i;",
      "info" : "ExpressionStatement[32184-32199]:ExpressionStatement[32612-32627]"
    }, {
      "left" : "ak2        = norm2;",
      "right" : "ak2        = norm2;",
      "info" : "ExpressionStatement[32220-32239]:ExpressionStatement[32648-32667]"
    }, {
      "left" : "if (ak2 == 0)",
      "right" : "if (ak2 == 0)",
      "info" : "IfStatement[32284-32363]:IfStatement[32712-32791]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[32298-32363]:Block[32726-32791]"
    }, {
      "left" : "rank = k;",
      "right" : "rank = k;",
      "info" : "ExpressionStatement[32316-32325]:ExpressionStatement[32744-32753]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[32342-32349]:ReturnStatement[32770-32777]"
    }, {
      "left" : "int pk                  = permutation[nextColumn];",
      "right" : "int pk                  = permutation[nextColumn];",
      "info" : "VariableDeclarationStatement[32376-32426]:VariableDeclarationStatement[32804-32854]"
    }, {
      "left" : "permutation[nextColumn] = permutation[k];",
      "right" : "permutation[nextColumn] = permutation[k];",
      "info" : "ExpressionStatement[32439-32480]:ExpressionStatement[32867-32908]"
    }, {
      "left" : "permutation[k]          = pk;",
      "right" : "permutation[k]          = pk;",
      "info" : "ExpressionStatement[32493-32522]:ExpressionStatement[32921-32950]"
    }, {
      "left" : "double akk   = jacobian[k][pk];",
      "right" : "double akk   = jacobian[k][pk];",
      "info" : "VariableDeclarationStatement[32590-32621]:VariableDeclarationStatement[33018-33049]"
    }, {
      "left" : "double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);",
      "right" : "double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);",
      "info" : "VariableDeclarationStatement[32634-32694]:VariableDeclarationStatement[33062-33122]"
    }, {
      "left" : "double betak = 1.0 / (ak2 - akk * alpha);",
      "right" : "double betak = 1.0 / (ak2 - akk * alpha);",
      "info" : "VariableDeclarationStatement[32707-32748]:VariableDeclarationStatement[33135-33176]"
    }, {
      "left" : "beta[pk]     = betak;",
      "right" : "beta[pk]     = betak;",
      "info" : "ExpressionStatement[32761-32782]:ExpressionStatement[33189-33210]"
    }, {
      "left" : "diagR[pk]        = alpha;",
      "right" : "diagR[pk]        = alpha;",
      "info" : "ExpressionStatement[32840-32865]:ExpressionStatement[33268-33293]"
    }, {
      "left" : "jacobian[k][pk] -= alpha;",
      "right" : "jacobian[k][pk] -= alpha;",
      "info" : "ExpressionStatement[32878-32903]:ExpressionStatement[33306-33331]"
    }, {
      "left" : "for (int dk = cols - 1 - k; dk > 0; --dk)",
      "right" : "for (int dk = cols - 1 - k; dk > 0; --dk)",
      "info" : "ForStatement[32964-33405]:ForStatement[33392-33833]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33006-33405]:Block[33434-33833]"
    }, {
      "left" : "double gamma = 0;",
      "right" : "double gamma = 0;",
      "info" : "VariableDeclarationStatement[33024-33041]:VariableDeclarationStatement[33452-33469]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[33058-33200]:ForStatement[33486-33628]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33100-33200]:Block[33528-33628]"
    }, {
      "left" : "gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];",
      "right" : "gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];",
      "info" : "ExpressionStatement[33122-33182]:ExpressionStatement[33550-33610]"
    }, {
      "left" : "gamma *= betak;",
      "right" : "gamma *= betak;",
      "info" : "ExpressionStatement[33217-33232]:ExpressionStatement[33645-33660]"
    }, {
      "left" : "for (int j = k; j < jacobian.length; ++j)",
      "right" : "for (int j = k; j < jacobian.length; ++j)",
      "info" : "ForStatement[33249-33391]:ForStatement[33677-33819]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33291-33391]:Block[33719-33819]"
    }, {
      "left" : "jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];",
      "right" : "jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];",
      "info" : "ExpressionStatement[33313-33373]:ExpressionStatement[33741-33801]"
    }, {
      "left" : "rank = solvedCols;",
      "right" : "rank = solvedCols;",
      "info" : "ExpressionStatement[33426-33444]:ExpressionStatement[33854-33872]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[33614-33621]:Modifier[34042-34049]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[33622-33626]:PrimitiveType[34050-34054]"
    }, {
      "left" : "qTy",
      "right" : "qTy",
      "info" : "SimpleName[33627-33630]:SimpleName[34055-34058]"
    }, {
      "left" : "double[] y",
      "right" : "double[] y",
      "info" : "SingleVariableDeclaration[33631-33641]:SingleVariableDeclaration[34059-34069]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33643-34015]:Block[34071-34443]"
    }, {
      "left" : "for (int k = 0; k < cols; ++k)",
      "right" : "for (int k = 0; k < cols; ++k)",
      "info" : "ForStatement[33653-34009]:ForStatement[34081-34437]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33684-34009]:Block[34112-34437]"
    }, {
      "left" : "int pk = permutation[k];",
      "right" : "int pk = permutation[k];",
      "info" : "VariableDeclarationStatement[33698-33722]:VariableDeclarationStatement[34126-34150]"
    }, {
      "left" : "double gamma = 0;",
      "right" : "double gamma = 0;",
      "info" : "VariableDeclarationStatement[33735-33752]:VariableDeclarationStatement[34163-34180]"
    }, {
      "left" : "for (int i = k; i < rows; ++i)",
      "right" : "for (int i = k; i < rows; ++i)",
      "info" : "ForStatement[33765-33860]:ForStatement[34193-34288]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33796-33860]:Block[34224-34288]"
    }, {
      "left" : "gamma += jacobian[i][pk] * y[i];",
      "right" : "gamma += jacobian[i][pk] * y[i];",
      "info" : "ExpressionStatement[33814-33846]:ExpressionStatement[34242-34274]"
    }, {
      "left" : "gamma *= beta[pk];",
      "right" : "gamma *= beta[pk];",
      "info" : "ExpressionStatement[33873-33891]:ExpressionStatement[34301-34319]"
    }, {
      "left" : "for (int i = k; i < rows; ++i)",
      "right" : "for (int i = k; i < rows; ++i)",
      "info" : "ForStatement[33904-33999]:ForStatement[34332-34427]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[33935-33999]:Block[34363-34427]"
    }, {
      "left" : "y[i] -= gamma * jacobian[i][pk];",
      "right" : "y[i] -= gamma * jacobian[i][pk];",
      "info" : "ExpressionStatement[33953-33985]:ExpressionStatement[34381-34413]"
    } ]
  },
  "interFileMappings" : { }
}