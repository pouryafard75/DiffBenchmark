{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "Coders",
      "right" : "Coders",
      "info" : "TypeDeclaration[1678-11835]:TypeDeclaration[1678-11843]"
    }, {
      "left" : "static InputStream addDecoder(final InputStream is,\n            final Coder coder, final byte[] password) throws IOException",
      "right" : "static InputStream addDecoder(final InputStream is,\n            final Coder coder, final byte[] password) throws IOException",
      "info" : "MethodDeclaration[1697-2185]:MethodDeclaration[1697-2185]"
    }, {
      "left" : "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\n                                   final byte[] password) throws IOException",
      "right" : "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\n                                   final byte[] password) throws IOException",
      "info" : "MethodDeclaration[2195-2620]:MethodDeclaration[2195-2620]"
    }, {
      "left" : "static CoderId[] coderTable = new CoderId[] {\n        new CoderId(SevenZMethod.COPY, new CopyDecoder()),\n        new CoderId(SevenZMethod.LZMA, new LZMADecoder()),\n        new CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\n        new CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\n        new CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\n        new CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n    };",
      "right" : "static CoderId[] coderTable = new CoderId[] {\n        new CoderId(SevenZMethod.COPY, new CopyDecoder()),\n        new CoderId(SevenZMethod.LZMA, new LZMADecoder()),\n        new CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\n        new CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\n        new CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\n        new CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n    };",
      "info" : "FieldDeclaration[2626-3057]:FieldDeclaration[2626-3057]"
    }, {
      "left" : "CoderId",
      "right" : "CoderId",
      "info" : "TypeDeclaration[3067-3300]:TypeDeclaration[3067-3300]"
    }, {
      "left" : "CoderId(SevenZMethod method, final CoderBase coder)",
      "right" : "CoderId(SevenZMethod method, final CoderBase coder)",
      "info" : "MethodDeclaration[3098-3227]:MethodDeclaration[3098-3227]"
    }, {
      "left" : "final SevenZMethod method;",
      "right" : "final SevenZMethod method;",
      "info" : "FieldDeclaration[3237-3263]:FieldDeclaration[3237-3263]"
    }, {
      "left" : "final CoderBase coder;",
      "right" : "final CoderBase coder;",
      "info" : "FieldDeclaration[3272-3294]:FieldDeclaration[3272-3294]"
    }, {
      "left" : "CoderBase",
      "right" : "CoderBase",
      "info" : "TypeDeclaration[3310-3684]:TypeDeclaration[3310-3684]"
    }, {
      "left" : "abstract InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException;",
      "right" : "abstract InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException;",
      "info" : "MethodDeclaration[3352-3473]:MethodDeclaration[3352-3473]"
    }, {
      "left" : "OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException",
      "right" : "OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException",
      "info" : "MethodDeclaration[3482-3678]:MethodDeclaration[3482-3678]"
    }, {
      "left" : "CopyDecoder",
      "right" : "CopyDecoder",
      "info" : "TypeDeclaration[3694-4047]:TypeDeclaration[3694-4047]"
    }, {
      "left" : "InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException",
      "right" : "InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException",
      "info" : "MethodDeclaration[3747-3912]:MethodDeclaration[3747-3912]"
    }, {
      "left" : "OutputStream encode(final OutputStream out, final byte[] password)",
      "right" : "OutputStream encode(final OutputStream out, final byte[] password)",
      "info" : "MethodDeclaration[3921-4041]:MethodDeclaration[3921-4041]"
    }, {
      "left" : "LZMADecoder",
      "right" : "LZMADecoder",
      "info" : "TypeDeclaration[4053-4706]:TypeDeclaration[4053-4714]"
    }, {
      "left" : "InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException",
      "right" : "InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException",
      "info" : "MethodDeclaration[4106-4700]:MethodDeclaration[4106-4708]"
    }, {
      "left" : "DeflateDecoder",
      "right" : "DeflateDecoder",
      "info" : "TypeDeclaration[4716-5242]:TypeDeclaration[4724-5250]"
    }, {
      "left" : "InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException",
      "right" : "InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException",
      "info" : "MethodDeclaration[4772-5058]:MethodDeclaration[4780-5066]"
    }, {
      "left" : "OutputStream encode(final OutputStream out, final byte[] password)",
      "right" : "OutputStream encode(final OutputStream out, final byte[] password)",
      "info" : "MethodDeclaration[5067-5236]:MethodDeclaration[5075-5244]"
    }, {
      "left" : "BZIP2Decoder",
      "right" : "BZIP2Decoder",
      "info" : "TypeDeclaration[5248-5707]:TypeDeclaration[5256-5715]"
    }, {
      "left" : "InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException",
      "right" : "InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException",
      "info" : "MethodDeclaration[5302-5504]:MethodDeclaration[5310-5512]"
    }, {
      "left" : "OutputStream encode(final OutputStream out, final byte[] password)\n                throws IOException",
      "right" : "OutputStream encode(final OutputStream out, final byte[] password)\n                throws IOException",
      "info" : "MethodDeclaration[5513-5701]:MethodDeclaration[5521-5709]"
    }, {
      "left" : "AES256SHA256Decoder",
      "right" : "AES256SHA256Decoder",
      "info" : "TypeDeclaration[5713-10804]:TypeDeclaration[5721-10812]"
    }, {
      "left" : "InputStream decode(final InputStream in, final Coder coder,\n                final byte[] passwordBytes) throws IOException",
      "right" : "InputStream decode(final InputStream in, final Coder coder,\n                final byte[] passwordBytes) throws IOException",
      "info" : "MethodDeclaration[5774-10798]:MethodDeclaration[5782-10806]"
    }, {
      "left" : "private boolean isInitialized = false;",
      "right" : "private boolean isInitialized = false;",
      "info" : "FieldDeclaration[5972-6010]:FieldDeclaration[5980-6018]"
    }, {
      "left" : "private CipherInputStream cipherInputStream = null;",
      "right" : "private CipherInputStream cipherInputStream = null;",
      "info" : "FieldDeclaration[6027-6078]:FieldDeclaration[6035-6086]"
    }, {
      "left" : "private CipherInputStream init() throws IOException",
      "right" : "private CipherInputStream init() throws IOException",
      "info" : "MethodDeclaration[6112-10321]:MethodDeclaration[6120-10329]"
    }, {
      "left" : "public int read() throws IOException",
      "right" : "public int read() throws IOException",
      "info" : "MethodDeclaration[10355-10479]:MethodDeclaration[10363-10487]"
    }, {
      "left" : "public int read(byte[] b, int off, int len) throws IOException",
      "right" : "public int read(byte[] b, int off, int len) throws IOException",
      "info" : "MethodDeclaration[10513-10674]:MethodDeclaration[10521-10682]"
    }, {
      "left" : "public void close()",
      "right" : "public void close()",
      "info" : "MethodDeclaration[10708-10773]:MethodDeclaration[10716-10781]"
    }, {
      "left" : "DummyByteAddingInputStream",
      "right" : "DummyByteAddingInputStream",
      "info" : "TypeDeclaration[10810-11833]:TypeDeclaration[10818-11841]"
    }, {
      "left" : "private boolean addDummyByte = true;",
      "right" : "private boolean addDummyByte = true;",
      "info" : "FieldDeclaration[11093-11129]:FieldDeclaration[11101-11137]"
    }, {
      "left" : "private DummyByteAddingInputStream(InputStream in)",
      "right" : "private DummyByteAddingInputStream(InputStream in)",
      "info" : "MethodDeclaration[11139-11224]:MethodDeclaration[11147-11232]"
    }, {
      "left" : "public int read() throws IOException",
      "right" : "public int read() throws IOException",
      "info" : "MethodDeclaration[11234-11494]:MethodDeclaration[11242-11502]"
    }, {
      "left" : "public int read(byte[] b, int off, int len) throws IOException",
      "right" : "public int read(byte[] b, int off, int len) throws IOException",
      "info" : "MethodDeclaration[11504-11827]:MethodDeclaration[11512-11835]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1822-2185]:Block[1822-2185]"
    }, {
      "left" : "for (final CoderId coderId : coderTable)",
      "right" : "for (final CoderId coderId : coderTable)",
      "info" : "EnhancedForStatement[1832-2050]:EnhancedForStatement[1832-2050]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1873-2050]:Block[1873-2050]"
    }, {
      "left" : "if (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId))",
      "right" : "if (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId))",
      "info" : "IfStatement[1887-2040]:IfStatement[1887-2040]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1959-2040]:Block[1959-2040]"
    }, {
      "left" : "return coderId.coder.decode(is, coder, password);",
      "right" : "return coderId.coder.decode(is, coder, password);",
      "info" : "ReturnStatement[1977-2026]:ReturnStatement[1977-2026]"
    }, {
      "left" : "throw new IOException(\"Unsupported compression method \" +\n                Arrays.toString(coder.decompressionMethodId));",
      "right" : "throw new IOException(\"Unsupported compression method \" +\n                Arrays.toString(coder.decompressionMethodId));",
      "info" : "ThrowStatement[2059-2179]:ThrowStatement[2059-2179]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2354-2620]:Block[2354-2620]"
    }, {
      "left" : "for (final CoderId coderId : coderTable)",
      "right" : "for (final CoderId coderId : coderTable)",
      "info" : "EnhancedForStatement[2364-2539]:EnhancedForStatement[2364-2539]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2405-2539]:Block[2405-2539]"
    }, {
      "left" : "if (coderId.method.equals(method))",
      "right" : "if (coderId.method.equals(method))",
      "info" : "IfStatement[2419-2529]:IfStatement[2419-2529]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2454-2529]:Block[2454-2529]"
    }, {
      "left" : "return coderId.coder.encode(out, password);",
      "right" : "return coderId.coder.encode(out, password);",
      "info" : "ReturnStatement[2472-2515]:ReturnStatement[2472-2515]"
    }, {
      "left" : "throw new IOException(\"Unsupported compression method \" + method);",
      "right" : "throw new IOException(\"Unsupported compression method \" + method);",
      "info" : "ThrowStatement[2548-2614]:ThrowStatement[2548-2614]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3150-3227]:Block[3150-3227]"
    }, {
      "left" : "this.method = method;",
      "right" : "this.method = method;",
      "info" : "ExpressionStatement[3164-3185]:ExpressionStatement[3164-3185]"
    }, {
      "left" : "this.coder = coder;",
      "right" : "this.coder = coder;",
      "info" : "ExpressionStatement[3198-3217]:ExpressionStatement[3198-3217]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3580-3678]:Block[3580-3678]"
    }, {
      "left" : "throw new UnsupportedOperationException(\"method doesn't support writing\");",
      "right" : "throw new UnsupportedOperationException(\"method doesn't support writing\");",
      "info" : "ThrowStatement[3594-3668]:ThrowStatement[3594-3668]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3877-3912]:Block[3877-3912]"
    }, {
      "left" : "return in;",
      "right" : "return in;",
      "info" : "ReturnStatement[3891-3901]:ReturnStatement[3891-3901]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4006-4041]:Block[4006-4041]"
    }, {
      "left" : "return out;",
      "right" : "return out;",
      "info" : "ReturnStatement[4020-4031]:ReturnStatement[4020-4031]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4236-4700]:Block[4236-4708]"
    }, {
      "left" : "byte propsByte = coder.properties[0];",
      "right" : "byte propsByte = coder.properties[0];",
      "info" : "VariableDeclarationStatement[4250-4287]:VariableDeclarationStatement[4250-4287]"
    }, {
      "left" : "long dictSize = coder.properties[1];",
      "right" : "long dictSize = coder.properties[1];",
      "info" : "VariableDeclarationStatement[4300-4336]:VariableDeclarationStatement[4300-4336]"
    }, {
      "left" : "for (int i = 1; i < 4; i++)",
      "right" : "for (int i = 1; i < 4; i++)",
      "info" : "ForStatement[4349-4458]:ForStatement[4349-4466]"
    }, {
      "left" : "if (dictSize > LZMAInputStream.DICT_SIZE_MAX)",
      "right" : "if (dictSize > LZMAInputStream.DICT_SIZE_MAX)",
      "info" : "IfStatement[4471-4615]:IfStatement[4479-4623]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4517-4615]:Block[4525-4623]"
    }, {
      "left" : "throw new IOException(\"Dictionary larger than 4GiB maximum size\");",
      "right" : "throw new IOException(\"Dictionary larger than 4GiB maximum size\");",
      "info" : "ThrowStatement[4535-4601]:ThrowStatement[4543-4609]"
    }, {
      "left" : "return new LZMAInputStream(in, -1, propsByte, (int) dictSize);",
      "right" : "return new LZMAInputStream(in, -1, propsByte, (int) dictSize);",
      "info" : "ReturnStatement[4628-4690]:ReturnStatement[4636-4698]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4904-5058]:Block[4912-5066]"
    }, {
      "left" : "return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));",
      "right" : "return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));",
      "info" : "ReturnStatement[4918-5048]:ReturnStatement[4926-5056]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5152-5236]:Block[5160-5244]"
    }, {
      "left" : "return new DeflaterOutputStream(out, new Deflater(9, true));",
      "right" : "return new DeflaterOutputStream(out, new Deflater(9, true));",
      "info" : "ReturnStatement[5166-5226]:ReturnStatement[5174-5234]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5438-5504]:Block[5446-5512]"
    }, {
      "left" : "return new BZip2CompressorInputStream(in);",
      "right" : "return new BZip2CompressorInputStream(in);",
      "info" : "ReturnStatement[5452-5494]:ReturnStatement[5460-5502]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5633-5701]:Block[5641-5709]"
    }, {
      "left" : "return new BZip2CompressorOutputStream(out);",
      "right" : "return new BZip2CompressorOutputStream(out);",
      "info" : "ReturnStatement[5647-5691]:ReturnStatement[5655-5699]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5915-10798]:Block[5923-10806]"
    }, {
      "left" : "return new InputStream() {\n                private boolean isInitialized = false;\n                private CipherInputStream cipherInputStream = null;\n                \n                private CipherInputStream init() throws IOException {\n                    if (isInitialized) {\n                        return cipherInputStream;\n                    }\n                    final int byte0 = 0xff & coder.properties[0];\n                    final int numCyclesPower = byte0 & 0x3f;\n                    final int byte1 = 0xff & coder.properties[1];\n                    final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n                    final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n                    if (2 + saltSize + ivSize > coder.properties.length) {\n                        throw new IOException(\"Salt size + IV size too long\");\n                    }\n                    final byte[] salt = new byte[saltSize];\n                    System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n                    final byte[] iv = new byte[16];\n                    System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n                    \n                    if (passwordBytes == null) {\n                        throw new IOException(\"Cannot read encrypted files without a password\");\n                    }\n                    final byte[] aesKeyBytes;\n                    if (numCyclesPower == 0x3f) {\n                        aesKeyBytes = new byte[32];\n                        System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n                        System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n                    } else {\n                        final MessageDigest digest;\n                        try {\n                            digest = MessageDigest.getInstance(\"SHA-256\");\n                        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n                            IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n                            ioe.initCause(noSuchAlgorithmException);\n                            throw ioe;\n        // TODO: simplify when Compress requires Java 1.6                \n//                            throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n//                                    noSuchAlgorithmException);\n                        }\n                        final byte[] extra = new byte[8];\n                        for (long j = 0; j < (1L << numCyclesPower); j++) {\n                            digest.update(salt);\n                            digest.update(passwordBytes);\n                            digest.update(extra);\n                            for (int k = 0; k < extra.length; k++) {\n                                ++extra[k];\n                                if (extra[k] != 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        aesKeyBytes = digest.digest();\n                    }\n                    \n                    final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n                    try {\n                        final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n                        cipherInputStream = new CipherInputStream(in, cipher);\n                        isInitialized = true;\n                        return cipherInputStream;\n                    } catch (GeneralSecurityException generalSecurityException) {\n                        IOException ioe = new IOException(\"Decryption error \" +\n                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n                        ioe.initCause(generalSecurityException);\n                        throw ioe;\n        // TODO: simplify when Compress requires Java 1.6                \n//                        throw new IOException(\"Decryption error \" +\n//                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n//                                generalSecurityException);\n                    }\n                }\n                \n                @Override\n                public int read() throws IOException {\n                    return init().read();\n                }\n                \n                @Override\n                public int read(byte[] b, int off, int len) throws IOException {\n                    return init().read(b, off, len);\n                }\n                \n                @Override\n                public void close() {\n                }\n            };",
      "right" : "return new InputStream() {\n                private boolean isInitialized = false;\n                private CipherInputStream cipherInputStream = null;\n                \n                private CipherInputStream init() throws IOException {\n                    if (isInitialized) {\n                        return cipherInputStream;\n                    }\n                    final int byte0 = 0xff & coder.properties[0];\n                    final int numCyclesPower = byte0 & 0x3f;\n                    final int byte1 = 0xff & coder.properties[1];\n                    final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n                    final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n                    if (2 + saltSize + ivSize > coder.properties.length) {\n                        throw new IOException(\"Salt size + IV size too long\");\n                    }\n                    final byte[] salt = new byte[saltSize];\n                    System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n                    final byte[] iv = new byte[16];\n                    System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n                    \n                    if (passwordBytes == null) {\n                        throw new IOException(\"Cannot read encrypted files without a password\");\n                    }\n                    final byte[] aesKeyBytes;\n                    if (numCyclesPower == 0x3f) {\n                        aesKeyBytes = new byte[32];\n                        System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n                        System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n                    } else {\n                        final MessageDigest digest;\n                        try {\n                            digest = MessageDigest.getInstance(\"SHA-256\");\n                        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n                            IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n                            ioe.initCause(noSuchAlgorithmException);\n                            throw ioe;\n        // TODO: simplify when Compress requires Java 1.6                \n//                            throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n//                                    noSuchAlgorithmException);\n                        }\n                        final byte[] extra = new byte[8];\n                        for (long j = 0; j < (1L << numCyclesPower); j++) {\n                            digest.update(salt);\n                            digest.update(passwordBytes);\n                            digest.update(extra);\n                            for (int k = 0; k < extra.length; k++) {\n                                ++extra[k];\n                                if (extra[k] != 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        aesKeyBytes = digest.digest();\n                    }\n                    \n                    final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n                    try {\n                        final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n                        cipherInputStream = new CipherInputStream(in, cipher);\n                        isInitialized = true;\n                        return cipherInputStream;\n                    } catch (GeneralSecurityException generalSecurityException) {\n                        IOException ioe = new IOException(\"Decryption error \" +\n                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n                        ioe.initCause(generalSecurityException);\n                        throw ioe;\n        // TODO: simplify when Compress requires Java 1.6                \n//                        throw new IOException(\"Decryption error \" +\n//                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n//                                generalSecurityException);\n                    }\n                }\n                \n                @Override\n                public int read() throws IOException {\n                    return init().read();\n                }\n                \n                @Override\n                public int read(byte[] b, int off, int len) throws IOException {\n                    return init().read(b, off, len);\n                }\n                \n                @Override\n                public void close() {\n                }\n            };",
      "info" : "ReturnStatement[5929-10788]:ReturnStatement[5937-10796]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6164-10321]:Block[6172-10329]"
    }, {
      "left" : "if (isInitialized)",
      "right" : "if (isInitialized)",
      "info" : "IfStatement[6186-6278]:IfStatement[6194-6286]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6205-6278]:Block[6213-6286]"
    }, {
      "left" : "return cipherInputStream;",
      "right" : "return cipherInputStream;",
      "info" : "ReturnStatement[6231-6256]:ReturnStatement[6239-6264]"
    }, {
      "left" : "final int byte0 = 0xff & coder.properties[0];",
      "right" : "final int byte0 = 0xff & coder.properties[0];",
      "info" : "VariableDeclarationStatement[6299-6344]:VariableDeclarationStatement[6307-6352]"
    }, {
      "left" : "final int numCyclesPower = byte0 & 0x3f;",
      "right" : "final int numCyclesPower = byte0 & 0x3f;",
      "info" : "VariableDeclarationStatement[6365-6405]:VariableDeclarationStatement[6373-6413]"
    }, {
      "left" : "final int byte1 = 0xff & coder.properties[1];",
      "right" : "final int byte1 = 0xff & coder.properties[1];",
      "info" : "VariableDeclarationStatement[6426-6471]:VariableDeclarationStatement[6434-6479]"
    }, {
      "left" : "final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);",
      "right" : "final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);",
      "info" : "VariableDeclarationStatement[6492-6547]:VariableDeclarationStatement[6500-6555]"
    }, {
      "left" : "final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);",
      "right" : "final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);",
      "info" : "VariableDeclarationStatement[6568-6623]:VariableDeclarationStatement[6576-6631]"
    }, {
      "left" : "if (2 + saltSize + ivSize > coder.properties.length)",
      "right" : "if (2 + saltSize + ivSize > coder.properties.length)",
      "info" : "IfStatement[6644-6799]:IfStatement[6652-6807]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6697-6799]:Block[6705-6807]"
    }, {
      "left" : "throw new IOException(\"Salt size + IV size too long\");",
      "right" : "throw new IOException(\"Salt size + IV size too long\");",
      "info" : "ThrowStatement[6723-6777]:ThrowStatement[6731-6785]"
    }, {
      "left" : "final byte[] salt = new byte[saltSize];",
      "right" : "final byte[] salt = new byte[saltSize];",
      "info" : "VariableDeclarationStatement[6820-6859]:VariableDeclarationStatement[6828-6867]"
    }, {
      "left" : "System.arraycopy(coder.properties, 2, salt, 0, saltSize);",
      "right" : "System.arraycopy(coder.properties, 2, salt, 0, saltSize);",
      "info" : "ExpressionStatement[6880-6937]:ExpressionStatement[6888-6945]"
    }, {
      "left" : "final byte[] iv = new byte[16];",
      "right" : "final byte[] iv = new byte[16];",
      "info" : "VariableDeclarationStatement[6958-6989]:VariableDeclarationStatement[6966-6997]"
    }, {
      "left" : "System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);",
      "right" : "System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);",
      "info" : "ExpressionStatement[7010-7074]:ExpressionStatement[7018-7082]"
    }, {
      "left" : "if (passwordBytes == null)",
      "right" : "if (passwordBytes == null)",
      "info" : "IfStatement[7116-7263]:IfStatement[7124-7271]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7143-7263]:Block[7151-7271]"
    }, {
      "left" : "throw new IOException(\"Cannot read encrypted files without a password\");",
      "right" : "throw new IOException(\"Cannot read encrypted files without a password\");",
      "info" : "ThrowStatement[7169-7241]:ThrowStatement[7177-7249]"
    }, {
      "left" : "final byte[] aesKeyBytes;",
      "right" : "final byte[] aesKeyBytes;",
      "info" : "VariableDeclarationStatement[7284-7309]:VariableDeclarationStatement[7292-7317]"
    }, {
      "left" : "if (numCyclesPower == 0x3f)",
      "right" : "if (numCyclesPower == 0x3f)",
      "info" : "IfStatement[7330-9101]:IfStatement[7338-9109]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7358-7688]:Block[7366-7696]"
    }, {
      "left" : "aesKeyBytes = new byte[32];",
      "right" : "aesKeyBytes = new byte[32];",
      "info" : "ExpressionStatement[7384-7411]:ExpressionStatement[7392-7419]"
    }, {
      "left" : "System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);",
      "right" : "System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);",
      "info" : "ExpressionStatement[7436-7488]:ExpressionStatement[7444-7496]"
    }, {
      "left" : "System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));",
      "right" : "System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));",
      "info" : "ExpressionStatement[7513-7666]:ExpressionStatement[7521-7674]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7694-9101]:Block[7702-9109]"
    }, {
      "left" : "final MessageDigest digest;",
      "right" : "final MessageDigest digest;",
      "info" : "VariableDeclarationStatement[7720-7747]:VariableDeclarationStatement[7728-7755]"
    }, {
      "left" : "try{...}",
      "right" : "try{...}",
      "info" : "TryStatement[7772-8434]:TryStatement[7780-8442]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7776-7878]:Block[7784-7886]"
    }, {
      "left" : "digest = MessageDigest.getInstance(\"SHA-256\");",
      "right" : "digest = MessageDigest.getInstance(\"SHA-256\");",
      "info" : "ExpressionStatement[7806-7852]:ExpressionStatement[7814-7860]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7937-8434]:Block[7945-8442]"
    }, {
      "left" : "IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");",
      "right" : "IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");",
      "info" : "VariableDeclarationStatement[7967-8055]:VariableDeclarationStatement[7975-8063]"
    }, {
      "left" : "ioe.initCause(noSuchAlgorithmException);",
      "right" : "ioe.initCause(noSuchAlgorithmException);",
      "info" : "ExpressionStatement[8084-8124]:ExpressionStatement[8092-8132]"
    }, {
      "left" : "throw ioe;",
      "right" : "throw ioe;",
      "info" : "ThrowStatement[8153-8163]:ThrowStatement[8161-8171]"
    }, {
      "left" : "final byte[] extra = new byte[8];",
      "right" : "final byte[] extra = new byte[8];",
      "info" : "VariableDeclarationStatement[8459-8492]:VariableDeclarationStatement[8467-8500]"
    }, {
      "left" : "for (long j = 0; j < (1L << numCyclesPower); j++)",
      "right" : "for (long j = 0; j < (1L << numCyclesPower); j++)",
      "info" : "ForStatement[8517-9024]:ForStatement[8525-9032]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8567-9024]:Block[8575-9032]"
    }, {
      "left" : "digest.update(salt);",
      "right" : "digest.update(salt);",
      "info" : "ExpressionStatement[8597-8617]:ExpressionStatement[8605-8625]"
    }, {
      "left" : "digest.update(passwordBytes);",
      "right" : "digest.update(passwordBytes);",
      "info" : "ExpressionStatement[8646-8675]:ExpressionStatement[8654-8683]"
    }, {
      "left" : "digest.update(extra);",
      "right" : "digest.update(extra);",
      "info" : "ExpressionStatement[8704-8725]:ExpressionStatement[8712-8733]"
    }, {
      "left" : "for (int k = 0; k < extra.length; k++)",
      "right" : "for (int k = 0; k < extra.length; k++)",
      "info" : "ForStatement[8754-8998]:ForStatement[8762-9006]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8793-8998]:Block[8801-9006]"
    }, {
      "left" : "++extra[k];",
      "right" : "++extra[k];",
      "info" : "ExpressionStatement[8827-8838]:ExpressionStatement[8835-8846]"
    }, {
      "left" : "if (extra[k] != 0)",
      "right" : "if (extra[k] != 0)",
      "info" : "IfStatement[8871-8968]:IfStatement[8879-8976]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8890-8968]:Block[8898-8976]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[8928-8934]:BreakStatement[8936-8942]"
    }, {
      "left" : "aesKeyBytes = digest.digest();",
      "right" : "aesKeyBytes = digest.digest();",
      "info" : "ExpressionStatement[9049-9079]:ExpressionStatement[9057-9087]"
    }, {
      "left" : "final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");",
      "right" : "final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");",
      "info" : "VariableDeclarationStatement[9143-9206]:VariableDeclarationStatement[9151-9214]"
    }, {
      "left" : "try{...}",
      "right" : "try{...}",
      "info" : "TryStatement[9227-10303]:TryStatement[9235-10311]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9231-9607]:Block[9239-9615]"
    }, {
      "left" : "final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");",
      "right" : "final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");",
      "info" : "VariableDeclarationStatement[9257-9319]:VariableDeclarationStatement[9265-9327]"
    }, {
      "left" : "cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));",
      "right" : "cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));",
      "info" : "ExpressionStatement[9344-9410]:ExpressionStatement[9352-9418]"
    }, {
      "left" : "cipherInputStream = new CipherInputStream(in, cipher);",
      "right" : "cipherInputStream = new CipherInputStream(in, cipher);",
      "info" : "ExpressionStatement[9435-9489]:ExpressionStatement[9443-9497]"
    }, {
      "left" : "isInitialized = true;",
      "right" : "isInitialized = true;",
      "info" : "ExpressionStatement[9514-9535]:ExpressionStatement[9522-9543]"
    }, {
      "left" : "return cipherInputStream;",
      "right" : "return cipherInputStream;",
      "info" : "ReturnStatement[9560-9585]:ReturnStatement[9568-9593]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9666-10303]:Block[9674-10311]"
    }, {
      "left" : "IOException ioe = new IOException(\"Decryption error \" +\n                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");",
      "right" : "IOException ioe = new IOException(\"Decryption error \" +\n                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");",
      "info" : "VariableDeclarationStatement[9692-9861]:VariableDeclarationStatement[9700-9869]"
    }, {
      "left" : "ioe.initCause(generalSecurityException);",
      "right" : "ioe.initCause(generalSecurityException);",
      "info" : "ExpressionStatement[9886-9926]:ExpressionStatement[9894-9934]"
    }, {
      "left" : "throw ioe;",
      "right" : "throw ioe;",
      "info" : "ThrowStatement[9951-9961]:ThrowStatement[9959-9969]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10418-10479]:Block[10426-10487]"
    }, {
      "left" : "return init().read();",
      "right" : "return init().read();",
      "info" : "ReturnStatement[10440-10461]:ReturnStatement[10448-10469]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10602-10674]:Block[10610-10682]"
    }, {
      "left" : "return init().read(b, off, len);",
      "right" : "return init().read(b, off, len);",
      "info" : "ReturnStatement[10624-10656]:ReturnStatement[10632-10664]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10754-10773]:Block[10762-10781]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11190-11224]:Block[11198-11232]"
    }, {
      "left" : "super(in);",
      "right" : "super(in);",
      "info" : "SuperConstructorInvocation[11204-11214]:SuperConstructorInvocation[11212-11222]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11289-11494]:Block[11297-11502]"
    }, {
      "left" : "int result = super.read();",
      "right" : "int result = super.read();",
      "info" : "VariableDeclarationStatement[11303-11329]:VariableDeclarationStatement[11311-11337]"
    }, {
      "left" : "if (result == -1 && addDummyByte)",
      "right" : "if (result == -1 && addDummyByte)",
      "info" : "IfStatement[11342-11457]:IfStatement[11350-11465]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11376-11457]:Block[11384-11465]"
    }, {
      "left" : "addDummyByte = false;",
      "right" : "addDummyByte = false;",
      "info" : "ExpressionStatement[11394-11415]:ExpressionStatement[11402-11423]"
    }, {
      "left" : "result = 0;",
      "right" : "result = 0;",
      "info" : "ExpressionStatement[11432-11443]:ExpressionStatement[11440-11451]"
    }, {
      "left" : "return result;",
      "right" : "return result;",
      "info" : "ReturnStatement[11470-11484]:ReturnStatement[11478-11492]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11585-11827]:Block[11593-11835]"
    }, {
      "left" : "int result = super.read(b, off, len);",
      "right" : "int result = super.read(b, off, len);",
      "info" : "VariableDeclarationStatement[11599-11636]:VariableDeclarationStatement[11607-11644]"
    }, {
      "left" : "if (result == -1 && addDummyByte)",
      "right" : "if (result == -1 && addDummyByte)",
      "info" : "IfStatement[11649-11790]:IfStatement[11657-11798]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11683-11790]:Block[11691-11798]"
    }, {
      "left" : "addDummyByte = false;",
      "right" : "addDummyByte = false;",
      "info" : "ExpressionStatement[11701-11722]:ExpressionStatement[11709-11730]"
    }, {
      "left" : "b[off] = 0;",
      "right" : "b[off] = 0;",
      "info" : "ExpressionStatement[11739-11750]:ExpressionStatement[11747-11758]"
    }, {
      "left" : "return 1;",
      "right" : "return 1;",
      "info" : "ReturnStatement[11767-11776]:ReturnStatement[11775-11784]"
    }, {
      "left" : "return result;",
      "right" : "return result;",
      "info" : "ReturnStatement[11803-11817]:ReturnStatement[11811-11825]"
    } ]
  },
  "interFileMappings" : { }
}