{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "private final Scope jsScope;",
      "right" : "private final Scope jsScope;",
      "info" : "FieldDeclaration[1771-1799]:FieldDeclaration[1771-1799]"
    }, {
      "left" : "private final Set<Var> escaped;",
      "right" : "private final Set<Var> escaped;",
      "info" : "FieldDeclaration[1802-1833]:FieldDeclaration[1802-1833]"
    }, {
      "left" : "MaybeReachingVariableUse(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler)",
      "right" : "MaybeReachingVariableUse(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler)",
      "info" : "MethodDeclaration[1837-2197]:MethodDeclaration[1837-2197]"
    }, {
      "left" : "ReachingUses",
      "right" : "ReachingUses",
      "info" : "TypeDeclaration[2201-3634]:TypeDeclaration[2201-3634]"
    }, {
      "left" : "final Multimap<Var, Node> mayUseMap;",
      "right" : "final Multimap<Var, Node> mayUseMap;",
      "info" : "FieldDeclaration[3018-3054]:FieldDeclaration[3018-3054]"
    }, {
      "left" : "public ReachingUses()",
      "right" : "public ReachingUses()",
      "info" : "MethodDeclaration[3060-3130]:MethodDeclaration[3060-3130]"
    }, {
      "left" : "public ReachingUses(ReachingUses other)",
      "right" : "public ReachingUses(ReachingUses other)",
      "info" : "MethodDeclaration[3136-3368]:MethodDeclaration[3136-3368]"
    }, {
      "left" : "public boolean equals(Object other)",
      "right" : "public boolean equals(Object other)",
      "info" : "MethodDeclaration[3374-3546]:MethodDeclaration[3374-3546]"
    }, {
      "left" : "public int hashCode()",
      "right" : "public int hashCode()",
      "info" : "MethodDeclaration[3552-3630]:MethodDeclaration[3552-3630]"
    }, {
      "left" : "ReachingUsesJoinOp",
      "right" : "ReachingUsesJoinOp",
      "info" : "TypeDeclaration[3638-4172]:TypeDeclaration[3638-4172]"
    }, {
      "left" : "public ReachingUses apply(List<ReachingUses> from)",
      "right" : "public ReachingUses apply(List<ReachingUses> from)",
      "info" : "MethodDeclaration[3931-4168]:MethodDeclaration[3931-4168]"
    }, {
      "left" : "boolean isForward()",
      "right" : "boolean isForward()",
      "info" : "MethodDeclaration[4176-4231]:MethodDeclaration[4176-4231]"
    }, {
      "left" : "ReachingUses createEntryLattice()",
      "right" : "ReachingUses createEntryLattice()",
      "info" : "MethodDeclaration[4235-4317]:MethodDeclaration[4235-4317]"
    }, {
      "left" : "ReachingUses createInitialEstimateLattice()",
      "right" : "ReachingUses createInitialEstimateLattice()",
      "info" : "MethodDeclaration[4321-4413]:MethodDeclaration[4321-4413]"
    }, {
      "left" : "ReachingUses flowThrough(Node n, ReachingUses input)",
      "right" : "ReachingUses flowThrough(Node n, ReachingUses input)",
      "info" : "MethodDeclaration[4417-4824]:MethodDeclaration[4417-4824]"
    }, {
      "left" : "private void computeMayUse(\n      Node n, Node cfgNode, ReachingUses output, boolean conditional)",
      "right" : "private void computeMayUse(\n      Node n, Node cfgNode, ReachingUses output, boolean conditional)",
      "info" : "MethodDeclaration[4905-7695]:MethodDeclaration[5123-7913]"
    }, {
      "left" : "private void addToUseIfLocal(String name, Node node, ReachingUses use)",
      "right" : "private void addToUseIfLocal(String name, Node node, ReachingUses use)",
      "info" : "MethodDeclaration[7699-8131]:MethodDeclaration[7917-8349]"
    }, {
      "left" : "private void removeFromUseIfLocal(String name, ReachingUses use)",
      "right" : "private void removeFromUseIfLocal(String name, ReachingUses use)",
      "info" : "MethodDeclaration[8135-8566]:MethodDeclaration[8353-8784]"
    }, {
      "left" : "Collection<Node> getUses(String name, Node defNode)",
      "right" : "Collection<Node> getUses(String name, Node defNode)",
      "info" : "MethodDeclaration[8570-9275]:MethodDeclaration[8788-9493]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1939-2197]:Block[1939-2197]"
    }, {
      "left" : "super(cfg, new ReachingUsesJoinOp());",
      "right" : "super(cfg, new ReachingUsesJoinOp());",
      "info" : "SuperConstructorInvocation[1945-1982]:SuperConstructorInvocation[1945-1982]"
    }, {
      "left" : "this.jsScope = jsScope;",
      "right" : "this.jsScope = jsScope;",
      "info" : "ExpressionStatement[1987-2010]:ExpressionStatement[1987-2010]"
    }, {
      "left" : "this.escaped = Sets.newHashSet();",
      "right" : "this.escaped = Sets.newHashSet();",
      "info" : "ExpressionStatement[2015-2048]:ExpressionStatement[2015-2048]"
    }, {
      "left" : "computeEscaped(jsScope, escaped, compiler);",
      "right" : "computeEscaped(jsScope, escaped, compiler);",
      "info" : "ExpressionStatement[2150-2193]:ExpressionStatement[2150-2193]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3082-3130]:Block[3082-3130]"
    }, {
      "left" : "mayUseMap = HashMultimap.create();",
      "right" : "mayUseMap = HashMultimap.create();",
      "info" : "ExpressionStatement[3090-3124]:ExpressionStatement[3090-3124]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3305-3368]:Block[3305-3368]"
    }, {
      "left" : "mayUseMap = HashMultimap.create(other.mayUseMap);",
      "right" : "mayUseMap = HashMultimap.create(other.mayUseMap);",
      "info" : "ExpressionStatement[3313-3362]:ExpressionStatement[3313-3362]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3424-3546]:Block[3424-3546]"
    }, {
      "left" : "return (other instanceof ReachingUses) &&\n          ((ReachingUses) other).mayUseMap.equals(this.mayUseMap);",
      "right" : "return (other instanceof ReachingUses) &&\n          ((ReachingUses) other).mayUseMap.equals(this.mayUseMap);",
      "info" : "ReturnStatement[3432-3540]:ReturnStatement[3432-3540]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3588-3630]:Block[3588-3630]"
    }, {
      "left" : "return mayUseMap.hashCode();",
      "right" : "return mayUseMap.hashCode();",
      "info" : "ReturnStatement[3596-3624]:ReturnStatement[3596-3624]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3996-4168]:Block[3996-4168]"
    }, {
      "left" : "ReachingUses result = new ReachingUses();",
      "right" : "ReachingUses result = new ReachingUses();",
      "info" : "VariableDeclarationStatement[4004-4045]:VariableDeclarationStatement[4004-4045]"
    }, {
      "left" : "for (ReachingUses uses : from)",
      "right" : "for (ReachingUses uses : from)",
      "info" : "EnhancedForStatement[4052-4141]:EnhancedForStatement[4052-4141]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4083-4141]:Block[4083-4141]"
    }, {
      "left" : "result.mayUseMap.putAll(uses.mayUseMap);",
      "right" : "result.mayUseMap.putAll(uses.mayUseMap);",
      "info" : "ExpressionStatement[4093-4133]:ExpressionStatement[4093-4133]"
    }, {
      "left" : "return result;",
      "right" : "return result;",
      "info" : "ReturnStatement[4148-4162]:ReturnStatement[4148-4162]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4208-4231]:Block[4208-4231]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[4214-4227]:ReturnStatement[4214-4227]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4281-4317]:Block[4281-4317]"
    }, {
      "left" : "return new ReachingUses();",
      "right" : "return new ReachingUses();",
      "info" : "ReturnStatement[4287-4313]:ReturnStatement[4287-4313]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4377-4413]:Block[4377-4413]"
    }, {
      "left" : "return new ReachingUses();",
      "right" : "return new ReachingUses();",
      "info" : "ReturnStatement[4383-4409]:ReturnStatement[4383-4409]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4482-4824]:Block[4482-4824]"
    }, {
      "left" : "ReachingUses output = new ReachingUses(input);",
      "right" : "ReachingUses output = new ReachingUses(input);",
      "info" : "VariableDeclarationStatement[4488-4534]:VariableDeclarationStatement[4488-4534]"
    }, {
      "left" : "boolean conditional = hasExceptionHandler(n);",
      "right" : "boolean conditional = hasExceptionHandler(n);",
      "info" : "VariableDeclarationStatement[4709-4754]:VariableDeclarationStatement[4709-4754]"
    }, {
      "left" : "computeMayUse(n, n, output, conditional);",
      "right" : "computeMayUse(n, n, output, conditional);",
      "info" : "ExpressionStatement[4759-4800]:ExpressionStatement[4759-4800]"
    }, {
      "left" : "return output;",
      "right" : "return output;",
      "info" : "ReturnStatement[4806-4820]:ReturnStatement[4806-4820]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5003-7695]:Block[5221-7913]"
    }, {
      "left" : "switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.NAME:\n        addToUseIfLocal(n.getString(), cfgNode, output);\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName() && !conditional) {\n            removeFromUseIfLocal(lhs.getString(), output);\n          }\n          computeMayUse(rhs, cfgNode, output, conditional);\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.HOOK:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.VAR:\n        Node varName = n.getFirstChild();\n        Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");\n\n        if (varName.hasChildren()) {\n          computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);\n          if (!conditional) {\n            removeFromUseIfLocal(varName.getString(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n          Node name = n.getFirstChild();\n          if (!conditional) {\n            removeFromUseIfLocal(name.getString(), output);\n          }\n\n          // In case of a += \"Hello\". There is a read of a.\n          if (!n.isAssign()) {\n            addToUseIfLocal(name.getString(), cfgNode, output);\n          }\n\n          computeMayUse(name.getNext(), cfgNode, output, conditional);\n        } else {\n          /*\n           * We want to traverse in reverse order because we want the LAST\n           * definition in the sub-tree....\n           * But we have no better way to traverse in reverse other :'(\n           */\n          for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) {\n            computeMayUse(c, cfgNode, output, conditional);\n          }\n        }\n    }",
      "right" : "switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.NAME:\n        addToUseIfLocal(n.getString(), cfgNode, output);\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName() && !conditional) {\n            removeFromUseIfLocal(lhs.getString(), output);\n          }\n          computeMayUse(rhs, cfgNode, output, conditional);\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.HOOK:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.VAR:\n        Node varName = n.getFirstChild();\n        Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");\n\n        if (varName.hasChildren()) {\n          computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);\n          if (!conditional) {\n            removeFromUseIfLocal(varName.getString(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n          Node name = n.getFirstChild();\n          if (!conditional) {\n            removeFromUseIfLocal(name.getString(), output);\n          }\n\n          // In case of a += \"Hello\". There is a read of a.\n          if (!n.isAssign()) {\n            addToUseIfLocal(name.getString(), cfgNode, output);\n          }\n\n          computeMayUse(name.getNext(), cfgNode, output, conditional);\n        } else {\n          /*\n           * We want to traverse in reverse order because we want the LAST\n           * definition in the sub-tree....\n           * But we have no better way to traverse in reverse other :'(\n           */\n          for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) {\n            computeMayUse(c, cfgNode, output, conditional);\n          }\n        }\n    }",
      "info" : "SwitchStatement[5009-7691]:SwitchStatement[5227-7909]"
    }, {
      "left" : "case Token.BLOCK:",
      "right" : "case Token.BLOCK:",
      "info" : "SwitchCase[5039-5056]:SwitchCase[5257-5274]"
    }, {
      "left" : "case Token.FUNCTION:",
      "right" : "case Token.FUNCTION:",
      "info" : "SwitchCase[5063-5083]:SwitchCase[5281-5301]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[5092-5099]:ReturnStatement[5310-5317]"
    }, {
      "left" : "case Token.NAME:",
      "right" : "case Token.NAME:",
      "info" : "SwitchCase[5107-5123]:SwitchCase[5325-5341]"
    }, {
      "left" : "addToUseIfLocal(n.getString(), cfgNode, output);",
      "right" : "addToUseIfLocal(n.getString(), cfgNode, output);",
      "info" : "ExpressionStatement[5132-5180]:ExpressionStatement[5350-5398]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[5189-5196]:ReturnStatement[5407-5414]"
    }, {
      "left" : "case Token.WHILE:",
      "right" : "case Token.WHILE:",
      "info" : "SwitchCase[5204-5221]:SwitchCase[5422-5439]"
    }, {
      "left" : "case Token.DO:",
      "right" : "case Token.DO:",
      "info" : "SwitchCase[5228-5242]:SwitchCase[5446-5460]"
    }, {
      "left" : "case Token.IF:",
      "right" : "case Token.IF:",
      "info" : "SwitchCase[5249-5263]:SwitchCase[5467-5481]"
    }, {
      "left" : "computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);",
      "right" : "computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);",
      "info" : "ExpressionStatement[5272-5365]:ExpressionStatement[5490-5583]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[5374-5381]:ReturnStatement[5592-5599]"
    }, {
      "left" : "case Token.FOR:",
      "right" : "case Token.FOR:",
      "info" : "SwitchCase[5389-5404]:SwitchCase[5607-5622]"
    }, {
      "left" : "if (!NodeUtil.isForIn(n))",
      "right" : "if (!NodeUtil.isForIn(n))",
      "info" : "IfStatement[5413-5961]:IfStatement[5631-6179]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5439-5556]:Block[5657-5774]"
    }, {
      "left" : "computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);",
      "right" : "computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);",
      "info" : "ExpressionStatement[5451-5546]:ExpressionStatement[5669-5764]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5562-5961]:Block[5780-6179]"
    }, {
      "left" : "Node lhs = n.getFirstChild();",
      "right" : "Node lhs = n.getFirstChild();",
      "info" : "VariableDeclarationStatement[5605-5634]:VariableDeclarationStatement[5823-5852]"
    }, {
      "left" : "Node rhs = lhs.getNext();",
      "right" : "Node rhs = lhs.getNext();",
      "info" : "VariableDeclarationStatement[5645-5670]:VariableDeclarationStatement[5863-5888]"
    }, {
      "left" : "if (lhs.isVar())",
      "right" : "if (lhs.isVar())",
      "info" : "IfStatement[5681-5774]:IfStatement[5899-5992]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5698-5774]:Block[5916-5992]"
    }, {
      "left" : "lhs = lhs.getLastChild();",
      "right" : "lhs = lhs.getLastChild();",
      "info" : "ExpressionStatement[5712-5737]:ExpressionStatement[5930-5955]"
    }, {
      "left" : "if (lhs.isName() && !conditional)",
      "right" : "if (lhs.isName() && !conditional)",
      "info" : "IfStatement[5785-5891]:IfStatement[6003-6109]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5819-5891]:Block[6037-6109]"
    }, {
      "left" : "removeFromUseIfLocal(lhs.getString(), output);",
      "right" : "removeFromUseIfLocal(lhs.getString(), output);",
      "info" : "ExpressionStatement[5833-5879]:ExpressionStatement[6051-6097]"
    }, {
      "left" : "computeMayUse(rhs, cfgNode, output, conditional);",
      "right" : "computeMayUse(rhs, cfgNode, output, conditional);",
      "info" : "ExpressionStatement[5902-5951]:ExpressionStatement[6120-6169]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[5970-5977]:ReturnStatement[6188-6195]"
    }, {
      "left" : "case Token.AND:",
      "right" : "case Token.AND:",
      "info" : "SwitchCase[5985-6000]:SwitchCase[6203-6218]"
    }, {
      "left" : "case Token.OR:",
      "right" : "case Token.OR:",
      "info" : "SwitchCase[6007-6021]:SwitchCase[6225-6239]"
    }, {
      "left" : "computeMayUse(n.getLastChild(), cfgNode, output, true);",
      "right" : "computeMayUse(n.getLastChild(), cfgNode, output, true);",
      "info" : "ExpressionStatement[6030-6085]:ExpressionStatement[6248-6303]"
    }, {
      "left" : "computeMayUse(n.getFirstChild(), cfgNode, output, conditional);",
      "right" : "computeMayUse(n.getFirstChild(), cfgNode, output, conditional);",
      "info" : "ExpressionStatement[6094-6157]:ExpressionStatement[6312-6375]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[6166-6173]:ReturnStatement[6384-6391]"
    }, {
      "left" : "case Token.HOOK:",
      "right" : "case Token.HOOK:",
      "info" : "SwitchCase[6181-6197]:SwitchCase[6399-6415]"
    }, {
      "left" : "computeMayUse(n.getLastChild(), cfgNode, output, true);",
      "right" : "computeMayUse(n.getLastChild(), cfgNode, output, true);",
      "info" : "ExpressionStatement[6206-6261]:ExpressionStatement[6424-6479]"
    }, {
      "left" : "computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);",
      "right" : "computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);",
      "info" : "ExpressionStatement[6270-6336]:ExpressionStatement[6488-6554]"
    }, {
      "left" : "computeMayUse(n.getFirstChild(), cfgNode, output, conditional);",
      "right" : "computeMayUse(n.getFirstChild(), cfgNode, output, conditional);",
      "info" : "ExpressionStatement[6345-6408]:ExpressionStatement[6563-6626]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[6417-6424]:ReturnStatement[6635-6642]"
    }, {
      "left" : "case Token.VAR:",
      "right" : "case Token.VAR:",
      "info" : "SwitchCase[6432-6447]:SwitchCase[6650-6665]"
    }, {
      "left" : "Node varName = n.getFirstChild();",
      "right" : "Node varName = n.getFirstChild();",
      "info" : "VariableDeclarationStatement[6456-6489]:VariableDeclarationStatement[6674-6707]"
    }, {
      "left" : "Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");",
      "right" : "Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");",
      "info" : "ExpressionStatement[6498-6568]:ExpressionStatement[6716-6786]"
    }, {
      "left" : "if (varName.hasChildren())",
      "right" : "if (varName.hasChildren())",
      "info" : "IfStatement[6578-6801]:IfStatement[6796-7019]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6605-6801]:Block[6823-7019]"
    }, {
      "left" : "computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);",
      "right" : "computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);",
      "info" : "ExpressionStatement[6617-6686]:ExpressionStatement[6835-6904]"
    }, {
      "left" : "if (!conditional)",
      "right" : "if (!conditional)",
      "info" : "IfStatement[6697-6791]:IfStatement[6915-7009]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6715-6791]:Block[6933-7009]"
    }, {
      "left" : "removeFromUseIfLocal(varName.getString(), output);",
      "right" : "removeFromUseIfLocal(varName.getString(), output);",
      "info" : "ExpressionStatement[6729-6779]:ExpressionStatement[6947-6997]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[6810-6817]:ReturnStatement[7028-7035]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[6825-6833]:SwitchCase[7043-7051]"
    }, {
      "left" : "if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName())",
      "right" : "if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName())",
      "info" : "IfStatement[6842-7685]:IfStatement[7060-7903]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6904-7298]:Block[7122-7516]"
    }, {
      "left" : "Node name = n.getFirstChild();",
      "right" : "Node name = n.getFirstChild();",
      "info" : "VariableDeclarationStatement[6916-6946]:VariableDeclarationStatement[7134-7164]"
    }, {
      "left" : "if (!conditional)",
      "right" : "if (!conditional)",
      "info" : "IfStatement[6957-7048]:IfStatement[7175-7266]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6975-7048]:Block[7193-7266]"
    }, {
      "left" : "removeFromUseIfLocal(name.getString(), output);",
      "right" : "removeFromUseIfLocal(name.getString(), output);",
      "info" : "ExpressionStatement[6989-7036]:ExpressionStatement[7207-7254]"
    }, {
      "left" : "if (!n.isAssign())",
      "right" : "if (!n.isAssign())",
      "info" : "IfStatement[7120-7216]:IfStatement[7338-7434]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7139-7216]:Block[7357-7434]"
    }, {
      "left" : "addToUseIfLocal(name.getString(), cfgNode, output);",
      "right" : "addToUseIfLocal(name.getString(), cfgNode, output);",
      "info" : "ExpressionStatement[7153-7204]:ExpressionStatement[7371-7422]"
    }, {
      "left" : "computeMayUse(name.getNext(), cfgNode, output, conditional);",
      "right" : "computeMayUse(name.getNext(), cfgNode, output, conditional);",
      "info" : "ExpressionStatement[7228-7288]:ExpressionStatement[7446-7506]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7304-7685]:Block[7522-7903]"
    }, {
      "left" : "for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c))",
      "right" : "for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c))",
      "info" : "ForStatement[7534-7675]:ForStatement[7752-7893]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7602-7675]:Block[7820-7893]"
    }, {
      "left" : "computeMayUse(c, cfgNode, output, conditional);",
      "right" : "computeMayUse(c, cfgNode, output, conditional);",
      "info" : "ExpressionStatement[7616-7663]:ExpressionStatement[7834-7881]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7947-8131]:Block[8165-8349]"
    }, {
      "left" : "Var var = jsScope.getVar(name);",
      "right" : "Var var = jsScope.getVar(name);",
      "info" : "VariableDeclarationStatement[7953-7984]:VariableDeclarationStatement[8171-8202]"
    }, {
      "left" : "if (var == null || var.scope != jsScope)",
      "right" : "if (var == null || var.scope != jsScope)",
      "info" : "IfStatement[7989-8051]:IfStatement[8207-8269]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8030-8051]:Block[8248-8269]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[8038-8045]:ReturnStatement[8256-8263]"
    }, {
      "left" : "if (!escaped.contains(var))",
      "right" : "if (!escaped.contains(var))",
      "info" : "IfStatement[8056-8127]:IfStatement[8274-8345]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8084-8127]:Block[8302-8345]"
    }, {
      "left" : "use.mayUseMap.put(var, node);",
      "right" : "use.mayUseMap.put(var, node);",
      "info" : "ExpressionStatement[8092-8121]:ExpressionStatement[8310-8339]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8382-8566]:Block[8600-8784]"
    }, {
      "left" : "Var var = jsScope.getVar(name);",
      "right" : "Var var = jsScope.getVar(name);",
      "info" : "VariableDeclarationStatement[8388-8419]:VariableDeclarationStatement[8606-8637]"
    }, {
      "left" : "if (var == null || var.scope != jsScope)",
      "right" : "if (var == null || var.scope != jsScope)",
      "info" : "IfStatement[8424-8486]:IfStatement[8642-8704]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8465-8486]:Block[8683-8704]"
    }, {
      "left" : "return;",
      "right" : "return;",
      "info" : "ReturnStatement[8473-8480]:ReturnStatement[8691-8698]"
    }, {
      "left" : "if (!escaped.contains(var))",
      "right" : "if (!escaped.contains(var))",
      "info" : "IfStatement[8491-8562]:IfStatement[8709-8780]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8519-8562]:Block[8737-8780]"
    }, {
      "left" : "use.mayUseMap.removeAll(var);",
      "right" : "use.mayUseMap.removeAll(var);",
      "info" : "ExpressionStatement[8527-8556]:ExpressionStatement[8745-8774]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9058-9275]:Block[9276-9493]"
    }, {
      "left" : "GraphNode<Node, Branch> n = getCfg().getNode(defNode);",
      "right" : "GraphNode<Node, Branch> n = getCfg().getNode(defNode);",
      "info" : "VariableDeclarationStatement[9064-9118]:VariableDeclarationStatement[9282-9336]"
    }, {
      "left" : "Preconditions.checkNotNull(n);",
      "right" : "Preconditions.checkNotNull(n);",
      "info" : "ExpressionStatement[9123-9153]:ExpressionStatement[9341-9371]"
    }, {
      "left" : "FlowState<ReachingUses> state = n.getAnnotation();",
      "right" : "FlowState<ReachingUses> state = n.getAnnotation();",
      "info" : "VariableDeclarationStatement[9158-9208]:VariableDeclarationStatement[9376-9426]"
    }, {
      "left" : "return state.getOut().mayUseMap.get(jsScope.getVar(name));",
      "right" : "return state.getOut().mayUseMap.get(jsScope.getVar(name));",
      "info" : "ReturnStatement[9213-9271]:ReturnStatement[9431-9489]"
    } ]
  },
  "interFileMappings" : { }
}