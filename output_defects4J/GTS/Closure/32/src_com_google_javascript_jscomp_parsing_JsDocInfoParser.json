{
  "matchedElements" : [
 {
    "left" : "class : JsDocInfoParser",
    "right" : "class : JsDocInfoParser",
    "info" : "TypeDeclaration[1541-75263]:TypeDeclaration[1541-75755]"
  }, {
    "left" : "stream",
    "right" : "stream",
    "info" : "FieldDeclaration[1746-1784]:FieldDeclaration[1746-1784]"
  }, {
    "left" : "jsdocBuilder",
    "right" : "jsdocBuilder",
    "info" : "FieldDeclaration[1787-1831]:FieldDeclaration[1787-1831]"
  }, {
    "left" : "sourceFile",
    "right" : "sourceFile",
    "info" : "FieldDeclaration[1834-1876]:FieldDeclaration[1834-1876]"
  }, {
    "left" : "associatedNode",
    "right" : "associatedNode",
    "info" : "FieldDeclaration[1879-1913]:FieldDeclaration[1879-1913]"
  }, {
    "left" : "errorReporter",
    "right" : "errorReporter",
    "info" : "FieldDeclaration[1916-1958]:FieldDeclaration[1916-1958]"
  }, {
    "left" : "parser",
    "right" : "parser",
    "info" : "FieldDeclaration[1961-2030]:FieldDeclaration[1961-2030]"
  }, {
    "left" : "templateNode",
    "right" : "templateNode",
    "info" : "FieldDeclaration[2175-2207]:FieldDeclaration[2175-2207]"
  }, {
    "left" : "class : ErrorReporterParser",
    "right" : "class : ErrorReporterParser",
    "info" : "TypeDeclaration[2211-3201]:TypeDeclaration[2211-3201]"
  }, {
    "left" : "package addParserWarning(messageId , messageArg , lineno int, charno int) : void",
    "right" : "package addParserWarning(messageId , messageArg , lineno int, charno int) : void",
    "info" : "MethodDeclaration[2251-2477]:MethodDeclaration[2251-2477]"
  }, {
    "left" : "package addParserWarning(messageId , lineno int, charno int) : void",
    "right" : "package addParserWarning(messageId , lineno int, charno int) : void",
    "info" : "MethodDeclaration[2483-2670]:MethodDeclaration[2483-2670]"
  }, {
    "left" : "package addTypeWarning(messageId , messageArg , lineno int, charno int) : void",
    "right" : "package addTypeWarning(messageId , messageArg , lineno int, charno int) : void",
    "info" : "MethodDeclaration[2676-2959]:MethodDeclaration[2676-2959]"
  }, {
    "left" : "package addTypeWarning(messageId , lineno int, charno int) : void",
    "right" : "package addTypeWarning(messageId , lineno int, charno int) : void",
    "info" : "MethodDeclaration[2965-3197]:MethodDeclaration[2965-3197]"
  }, {
    "left" : "fileOverviewJSDocInfo",
    "right" : "fileOverviewJSDocInfo",
    "info" : "FieldDeclaration[3268-3315]:FieldDeclaration[3268-3315]"
  }, {
    "left" : "state",
    "right" : "state",
    "info" : "FieldDeclaration[3318-3338]:FieldDeclaration[3318-3338]"
  }, {
    "left" : "annotationNames",
    "right" : "annotationNames",
    "info" : "FieldDeclaration[3342-3396]:FieldDeclaration[3342-3396]"
  }, {
    "left" : "suppressionNames",
    "right" : "suppressionNames",
    "info" : "FieldDeclaration[3399-3442]:FieldDeclaration[3399-3442]"
  }, {
    "left" : "modifiesAnnotationKeywords",
    "right" : "modifiesAnnotationKeywords",
    "info" : "FieldDeclaration[3445-3558]:FieldDeclaration[3445-3558]"
  }, {
    "left" : "fileLevelJsDocBuilder",
    "right" : "fileLevelJsDocBuilder",
    "info" : "FieldDeclaration[3562-3619]:FieldDeclaration[3562-3619]"
  }, {
    "left" : "package setFileLevelJsDocBuilder(fileLevelJsDocBuilder ) : void",
    "right" : "package setFileLevelJsDocBuilder(fileLevelJsDocBuilder ) : void",
    "info" : "MethodDeclaration[3623-4001]:MethodDeclaration[3623-4001]"
  }, {
    "left" : "package setFileOverviewJSDocInfo(fileOverviewJSDocInfo ) : void",
    "right" : "package setFileOverviewJSDocInfo(fileOverviewJSDocInfo ) : void",
    "info" : "MethodDeclaration[4005-4258]:MethodDeclaration[4005-4258]"
  }, {
    "left" : "package JsDocInfoParser(stream , commentNode , associatedNode , config , errorReporter )",
    "right" : "package JsDocInfoParser(stream , commentNode , associatedNode , config , errorReporter )",
    "info" : "MethodDeclaration[4362-5169]:MethodDeclaration[4362-5169]"
  }, {
    "left" : "private getSourceName() : ",
    "right" : "private getSourceName() : ",
    "info" : "MethodDeclaration[5173-5270]:MethodDeclaration[5173-5270]"
  }, {
    "left" : "public parseTypeString(typeString ) : ",
    "right" : "public parseTypeString(typeString ) : ",
    "info" : "MethodDeclaration[5274-5890]:MethodDeclaration[5274-5890]"
  }, {
    "left" : "package parse() : boolean",
    "right" : "package parse() : boolean",
    "info" : "MethodDeclaration[5894-36247]:MethodDeclaration[5894-36247]"
  }, {
    "left" : "private checkExtendedTypes(extendedTypes ...) : void",
    "right" : "private checkExtendedTypes(extendedTypes ...) : void",
    "info" : "MethodDeclaration[36251-36889]:MethodDeclaration[36251-36889]"
  }, {
    "left" : "private parseSuppressTag(token ) : ",
    "right" : "private parseSuppressTag(token ) : ",
    "info" : "MethodDeclaration[36893-38253]:MethodDeclaration[36893-38253]"
  }, {
    "left" : "private parseModifiesTag(token ) : ",
    "right" : "private parseModifiesTag(token ) : ",
    "info" : "MethodDeclaration[38257-39668]:MethodDeclaration[38257-39668]"
  }, {
    "left" : "private parseAndRecordTypeNode(token ) : ",
    "right" : "private parseAndRecordTypeNode(token ) : ",
    "info" : "MethodDeclaration[39672-40030]:MethodDeclaration[39672-40030]"
  }, {
    "left" : "private parseAndRecordTypeNode(token , matchingLC boolean) : ",
    "right" : "private parseAndRecordTypeNode(token , matchingLC boolean) : ",
    "info" : "MethodDeclaration[40034-40525]:MethodDeclaration[40034-40525]"
  }, {
    "left" : "private parseAndRecordTypeNameNode(token , lineno int, startCharno int, matchingLC boolean) : ",
    "right" : "private parseAndRecordTypeNameNode(token , lineno int, startCharno int, matchingLC boolean) : ",
    "info" : "MethodDeclaration[40529-41199]:MethodDeclaration[40529-41199]"
  }, {
    "left" : "private parseAndRecordParamTypeNode(token ) : ",
    "right" : "private parseAndRecordParamTypeNode(token ) : ",
    "info" : "MethodDeclaration[41203-42165]:MethodDeclaration[41203-42165]"
  }, {
    "left" : "private parseAndRecordTypeNode(token , lineno int, startCharno int, matchingLC boolean, onlyParseSimpleNames boolean) : ",
    "right" : "private parseAndRecordTypeNode(token , lineno int, startCharno int, matchingLC boolean, onlyParseSimpleNames boolean) : ",
    "info" : "MethodDeclaration[42169-43583]:MethodDeclaration[42169-43583]"
  }, {
    "left" : "private toString(token ) : ",
    "right" : "private toString(token ) : ",
    "info" : "MethodDeclaration[43587-44529]:MethodDeclaration[43587-44529]"
  }, {
    "left" : "private createJSTypeExpression(n ) : ",
    "right" : "private createJSTypeExpression(n ) : ",
    "info" : "MethodDeclaration[44533-44769]:MethodDeclaration[44533-44769]"
  }, {
    "left" : "class : ExtractionInfo",
    "right" : "class : ExtractionInfo",
    "info" : "TypeDeclaration[44773-45150]:TypeDeclaration[44773-45150]"
  }, {
    "left" : "string",
    "right" : "string",
    "info" : "FieldDeclaration[44960-44988]:FieldDeclaration[44960-44988]"
  }, {
    "left" : "token",
    "right" : "token",
    "info" : "FieldDeclaration[44993-45024]:FieldDeclaration[44993-45024]"
  }, {
    "left" : "public ExtractionInfo(string , token )",
    "right" : "public ExtractionInfo(string , token )",
    "info" : "MethodDeclaration[45030-45146]:MethodDeclaration[45030-45146]"
  }, {
    "left" : "class : ExtendedTypeInfo",
    "right" : "class : ExtendedTypeInfo",
    "info" : "TypeDeclaration[45154-45490]:TypeDeclaration[45154-45490]"
  }, {
    "left" : "type",
    "right" : "type",
    "info" : "FieldDeclaration[45250-45278]:FieldDeclaration[45250-45278]"
  }, {
    "left" : "lineno",
    "right" : "lineno",
    "info" : "FieldDeclaration[45283-45300]:FieldDeclaration[45283-45300]"
  }, {
    "left" : "charno",
    "right" : "charno",
    "info" : "FieldDeclaration[45305-45322]:FieldDeclaration[45305-45322]"
  }, {
    "left" : "public ExtendedTypeInfo(type , lineno int, charno int)",
    "right" : "public ExtendedTypeInfo(type , lineno int, charno int)",
    "info" : "MethodDeclaration[45328-45486]:MethodDeclaration[45328-45486]"
  }, {
    "left" : "private extractSingleLineBlock() : ",
    "right" : "private extractSingleLineBlock() : ",
    "info" : "MethodDeclaration[45494-46229]:MethodDeclaration[45494-46229]"
  }, {
    "left" : "private extractMultilineTextualBlock(token ) : ",
    "right" : "private extractMultilineTextualBlock(token ) : ",
    "info" : "MethodDeclaration[46233-46386]:MethodDeclaration[46233-46386]"
  }, {
    "left" : "private extractMultilineTextualBlock(token , option ) : ",
    "right" : "private extractMultilineTextualBlock(token , option ) : ",
    "info" : "MethodDeclaration[46720-50203]:MethodDeclaration[46720-50695]"
  }, {
    "left" : "private extractBlockComment(token ) : ",
    "right" : "private extractBlockComment(token ) : ",
    "info" : "MethodDeclaration[50208-51705]:MethodDeclaration[50700-52197]"
  }, {
    "left" : "private trimEnd(s ...) : ",
    "right" : "private trimEnd(s ...) : ",
    "info" : "MethodDeclaration[51709-52471]:MethodDeclaration[52201-52963]"
  }, {
    "left" : "private parseTypeExpressionAnnotation(token ) : ",
    "right" : "private parseTypeExpressionAnnotation(token ) : ",
    "info" : "MethodDeclaration[52891-53453]:MethodDeclaration[53383-53945]"
  }, {
    "left" : "private parseParamTypeExpressionAnnotation(token ) : ",
    "right" : "private parseParamTypeExpressionAnnotation(token ) : ",
    "info" : "MethodDeclaration[53457-54632]:MethodDeclaration[53949-55124]"
  }, {
    "left" : "private parseTypeNameAnnotation(token ) : ",
    "right" : "private parseTypeNameAnnotation(token ) : ",
    "info" : "MethodDeclaration[54636-55137]:MethodDeclaration[55128-55629]"
  }, {
    "left" : "private parseTopLevelTypeExpression(token ) : ",
    "right" : "private parseTopLevelTypeExpression(token ) : ",
    "info" : "MethodDeclaration[55141-55799]:MethodDeclaration[55633-56291]"
  }, {
    "left" : "private parseTypeExpressionList(token ) : ",
    "right" : "private parseTypeExpressionList(token ) : ",
    "info" : "MethodDeclaration[55803-56413]:MethodDeclaration[56295-56905]"
  }, {
    "left" : "private parseTypeExpression(token ) : ",
    "right" : "private parseTypeExpression(token ) : ",
    "info" : "MethodDeclaration[56417-58159]:MethodDeclaration[56909-58651]"
  }, {
    "left" : "private parseBasicTypeExpression(token ) : ",
    "right" : "private parseBasicTypeExpression(token ) : ",
    "info" : "MethodDeclaration[58163-59161]:MethodDeclaration[58655-59653]"
  }, {
    "left" : "private parseTypeName(token ) : ",
    "right" : "private parseTypeName(token ) : ",
    "info" : "MethodDeclaration[59165-60288]:MethodDeclaration[59657-60780]"
  }, {
    "left" : "private parseFunctionType(token ) : ",
    "right" : "private parseFunctionType(token ) : ",
    "info" : "MethodDeclaration[60292-62370]:MethodDeclaration[60784-62862]"
  }, {
    "left" : "private parseParametersType(token ) : ",
    "right" : "private parseParametersType(token ) : ",
    "info" : "MethodDeclaration[62374-65469]:MethodDeclaration[62866-65961]"
  }, {
    "left" : "private parseResultType(token ) : ",
    "right" : "private parseResultType(token ) : ",
    "info" : "MethodDeclaration[65473-65908]:MethodDeclaration[65965-66400]"
  }, {
    "left" : "private parseUnionType(token ) : ",
    "right" : "private parseUnionType(token ) : ",
    "info" : "MethodDeclaration[65912-66186]:MethodDeclaration[66404-66678]"
  }, {
    "left" : "private parseUnionTypeWithAlternate(token , alternate ) : ",
    "right" : "private parseUnionTypeWithAlternate(token , alternate ) : ",
    "info" : "MethodDeclaration[66190-67388]:MethodDeclaration[66682-67880]"
  }, {
    "left" : "private parseArrayType(token ) : ",
    "right" : "private parseArrayType(token ) : ",
    "info" : "MethodDeclaration[67392-68335]:MethodDeclaration[67884-68827]"
  }, {
    "left" : "private parseRecordType(token ) : ",
    "right" : "private parseRecordType(token ) : ",
    "info" : "MethodDeclaration[68339-68825]:MethodDeclaration[68831-69317]"
  }, {
    "left" : "private parseFieldTypeList(token ) : ",
    "right" : "private parseFieldTypeList(token ) : ",
    "info" : "MethodDeclaration[68829-69429]:MethodDeclaration[69321-69921]"
  }, {
    "left" : "private parseFieldType(token ) : ",
    "right" : "private parseFieldType(token ) : ",
    "info" : "MethodDeclaration[69433-70140]:MethodDeclaration[69925-70632]"
  }, {
    "left" : "private parseFieldName(token ) : ",
    "right" : "private parseFieldName(token ) : ",
    "info" : "MethodDeclaration[70144-70463]:MethodDeclaration[70636-70955]"
  }, {
    "left" : "private wrapNode(type int, n ) : ",
    "right" : "private wrapNode(type int, n ) : ",
    "info" : "MethodDeclaration[70467-70650]:MethodDeclaration[70959-71142]"
  }, {
    "left" : "private newNode(type int) : ",
    "right" : "private newNode(type int) : ",
    "info" : "MethodDeclaration[70654-70794]:MethodDeclaration[71146-71286]"
  }, {
    "left" : "private newStringNode(s ...) : ",
    "right" : "private newStringNode(s ...) : ",
    "info" : "MethodDeclaration[70798-70909]:MethodDeclaration[71290-71401]"
  }, {
    "left" : "private newStringNode(s , lineno int, charno int) : ",
    "right" : "private newStringNode(s , lineno int, charno int) : ",
    "info" : "MethodDeclaration[70913-71099]:MethodDeclaration[71405-71591]"
  }, {
    "left" : "private createTemplateNode() : ",
    "right" : "private createTemplateNode() : ",
    "info" : "MethodDeclaration[71221-71501]:MethodDeclaration[71713-71993]"
  }, {
    "left" : "private reportTypeSyntaxWarning(warning ) : ",
    "right" : "private reportTypeSyntaxWarning(warning ) : ",
    "info" : "MethodDeclaration[71505-71656]:MethodDeclaration[71997-72148]"
  }, {
    "left" : "private reportGenericTypeSyntaxWarning() : ",
    "right" : "private reportGenericTypeSyntaxWarning() : ",
    "info" : "MethodDeclaration[71660-71772]:MethodDeclaration[72152-72264]"
  }, {
    "left" : "private eatTokensUntilEOL() : ",
    "right" : "private eatTokensUntilEOL() : ",
    "info" : "MethodDeclaration[71776-71998]:MethodDeclaration[72268-72490]"
  }, {
    "left" : "private eatTokensUntilEOL(token ) : ",
    "right" : "private eatTokensUntilEOL(token ) : ",
    "info" : "MethodDeclaration[72002-72428]:MethodDeclaration[72494-72920]"
  }, {
    "left" : "NO_UNREAD_TOKEN",
    "right" : "NO_UNREAD_TOKEN",
    "info" : "FieldDeclaration[72432-72579]:FieldDeclaration[72924-73071]"
  }, {
    "left" : "unreadToken",
    "right" : "unreadToken",
    "info" : "FieldDeclaration[72583-72667]:FieldDeclaration[73075-73159]"
  }, {
    "left" : "private restoreLookAhead(token ) : void",
    "right" : "private restoreLookAhead(token ) : void",
    "info" : "MethodDeclaration[72671-72807]:MethodDeclaration[73163-73299]"
  }, {
    "left" : "private match(token ) : boolean",
    "right" : "private match(token ) : boolean",
    "info" : "MethodDeclaration[72811-73015]:MethodDeclaration[73303-73507]"
  }, {
    "left" : "private match(token1 , token2 ) : boolean",
    "right" : "private match(token1 , token2 ) : boolean",
    "info" : "MethodDeclaration[73019-73275]:MethodDeclaration[73511-73767]"
  }, {
    "left" : "private next() : ",
    "right" : "private next() : ",
    "info" : "MethodDeclaration[73279-73551]:MethodDeclaration[73771-74043]"
  }, {
    "left" : "private current() : ",
    "right" : "private current() : ",
    "info" : "MethodDeclaration[73555-73743]:MethodDeclaration[74047-74235]"
  }, {
    "left" : "private skipEOLs() : void",
    "right" : "private skipEOLs() : void",
    "info" : "MethodDeclaration[73747-74032]:MethodDeclaration[74239-74524]"
  }, {
    "left" : "private hasParsedFileOverviewDocInfo() : boolean",
    "right" : "private hasParsedFileOverviewDocInfo() : boolean",
    "info" : "MethodDeclaration[74036-74252]:MethodDeclaration[74528-74744]"
  }, {
    "left" : "package hasParsedJSDocInfo() : boolean",
    "right" : "package hasParsedJSDocInfo() : boolean",
    "info" : "MethodDeclaration[74256-74329]:MethodDeclaration[74748-74821]"
  }, {
    "left" : "package retrieveAndResetParsedJSDocInfo() : ",
    "right" : "package retrieveAndResetParsedJSDocInfo() : ",
    "info" : "MethodDeclaration[74333-74429]:MethodDeclaration[74825-74921]"
  }, {
    "left" : "package getFileOverviewJSDocInfo() : ",
    "right" : "package getFileOverviewJSDocInfo() : ",
    "info" : "MethodDeclaration[74433-74567]:MethodDeclaration[74925-75059]"
  }, {
    "left" : "private lookAheadForTypeAnnotation() : boolean",
    "right" : "private lookAheadForTypeAnnotation() : boolean",
    "info" : "MethodDeclaration[74571-75261]:MethodDeclaration[75063-75753]"
  } ],
  "mappings" : [
 {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[1706-1712]:Modifier[1706-1712]"
  }, {
    "left" : "final",
    "right" : "final",
    "info" : "Modifier[1713-1718]:Modifier[1713-1718]"
  }, {
    "left" : "class",
    "right" : "class",
    "info" : "TYPE_DECLARATION_KIND[1719-1724]:TYPE_DECLARATION_KIND[1719-1724]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[2211-2218]:Modifier[2211-2218]"
  }, {
    "left" : "class",
    "right" : "class",
    "info" : "TYPE_DECLARATION_KIND[2219-2224]:TYPE_DECLARATION_KIND[2219-2224]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[2251-2255]:PrimitiveType[2251-2255]"
  }, {
    "left" : "addParserWarning",
    "right" : "addParserWarning",
    "info" : "SimpleName[2256-2272]:SimpleName[2256-2272]"
  }, {
    "left" : "String messageId",
    "right" : "String messageId",
    "info" : "SingleVariableDeclaration[2273-2289]:SingleVariableDeclaration[2273-2289]"
  }, {
    "left" : "String messageArg",
    "right" : "String messageArg",
    "info" : "SingleVariableDeclaration[2291-2308]:SingleVariableDeclaration[2291-2308]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[2310-2320]:SingleVariableDeclaration[2310-2320]"
  }, {
    "left" : "int charno",
    "right" : "int charno",
    "info" : "SingleVariableDeclaration[2330-2340]:SingleVariableDeclaration[2330-2340]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[2342-2477]:Block[2342-2477]"
  }, {
    "left" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
    "right" : "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
    "info" : "ExpressionStatement[2350-2471]:ExpressionStatement[2350-2471]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[2483-2487]:PrimitiveType[2483-2487]"
  }, {
    "left" : "addParserWarning",
    "right" : "addParserWarning",
    "info" : "SimpleName[2488-2504]:SimpleName[2488-2504]"
  }, {
    "left" : "String messageId",
    "right" : "String messageId",
    "info" : "SingleVariableDeclaration[2505-2521]:SingleVariableDeclaration[2505-2521]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[2523-2533]:SingleVariableDeclaration[2523-2533]"
  }, {
    "left" : "int charno",
    "right" : "int charno",
    "info" : "SingleVariableDeclaration[2535-2545]:SingleVariableDeclaration[2535-2545]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[2547-2670]:Block[2547-2670]"
  }, {
    "left" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
    "right" : "errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
    "info" : "ExpressionStatement[2555-2664]:ExpressionStatement[2555-2664]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[2676-2680]:PrimitiveType[2676-2680]"
  }, {
    "left" : "addTypeWarning",
    "right" : "addTypeWarning",
    "info" : "SimpleName[2681-2695]:SimpleName[2681-2695]"
  }, {
    "left" : "String messageId",
    "right" : "String messageId",
    "info" : "SingleVariableDeclaration[2696-2712]:SingleVariableDeclaration[2696-2712]"
  }, {
    "left" : "String messageArg",
    "right" : "String messageArg",
    "info" : "SingleVariableDeclaration[2714-2731]:SingleVariableDeclaration[2714-2731]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[2733-2743]:SingleVariableDeclaration[2733-2743]"
  }, {
    "left" : "int charno",
    "right" : "int charno",
    "info" : "SingleVariableDeclaration[2765-2775]:SingleVariableDeclaration[2765-2775]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[2777-2959]:Block[2777-2959]"
  }, {
    "left" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
    "right" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);",
    "info" : "ExpressionStatement[2785-2953]:ExpressionStatement[2785-2953]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[2965-2969]:PrimitiveType[2965-2969]"
  }, {
    "left" : "addTypeWarning",
    "right" : "addTypeWarning",
    "info" : "SimpleName[2970-2984]:SimpleName[2970-2984]"
  }, {
    "left" : "String messageId",
    "right" : "String messageId",
    "info" : "SingleVariableDeclaration[2985-3001]:SingleVariableDeclaration[2985-3001]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[3003-3013]:SingleVariableDeclaration[3003-3013]"
  }, {
    "left" : "int charno",
    "right" : "int charno",
    "info" : "SingleVariableDeclaration[3015-3025]:SingleVariableDeclaration[3015-3025]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[3027-3197]:Block[3027-3197]"
  }, {
    "left" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
    "right" : "errorReporter.warning(\n          \"Bad type annotation. \" +\n          ScriptRuntime.getMessage0(messageId),\n          getSourceName(), lineno, null, charno);",
    "info" : "ExpressionStatement[3035-3191]:ExpressionStatement[3035-3191]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[3853-3857]:PrimitiveType[3853-3857]"
  }, {
    "left" : "setFileLevelJsDocBuilder",
    "right" : "setFileLevelJsDocBuilder",
    "info" : "SimpleName[3858-3882]:SimpleName[3858-3882]"
  }, {
    "left" : "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder",
    "right" : "Node.FileLevelJsDocBuilder fileLevelJsDocBuilder",
    "info" : "SingleVariableDeclaration[3890-3938]:SingleVariableDeclaration[3890-3938]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[3940-4001]:Block[3940-4001]"
  }, {
    "left" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
    "right" : "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;",
    "info" : "ExpressionStatement[3946-3997]:ExpressionStatement[3946-3997]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[4134-4138]:PrimitiveType[4134-4138]"
  }, {
    "left" : "setFileOverviewJSDocInfo",
    "right" : "setFileOverviewJSDocInfo",
    "info" : "SimpleName[4139-4163]:SimpleName[4139-4163]"
  }, {
    "left" : "JSDocInfo fileOverviewJSDocInfo",
    "right" : "JSDocInfo fileOverviewJSDocInfo",
    "info" : "SingleVariableDeclaration[4164-4195]:SingleVariableDeclaration[4164-4195]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[4197-4258]:Block[4197-4258]"
  }, {
    "left" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
    "right" : "this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;",
    "info" : "ExpressionStatement[4203-4254]:ExpressionStatement[4203-4254]"
  }, {
    "left" : "JsDocInfoParser",
    "right" : "JsDocInfoParser",
    "info" : "SimpleName[4362-4377]:SimpleName[4362-4377]"
  }, {
    "left" : "JsDocTokenStream stream",
    "right" : "JsDocTokenStream stream",
    "info" : "SingleVariableDeclaration[4378-4401]:SingleVariableDeclaration[4378-4401]"
  }, {
    "left" : "Comment commentNode",
    "right" : "Comment commentNode",
    "info" : "SingleVariableDeclaration[4421-4440]:SingleVariableDeclaration[4421-4440]"
  }, {
    "left" : "Node associatedNode",
    "right" : "Node associatedNode",
    "info" : "SingleVariableDeclaration[4460-4479]:SingleVariableDeclaration[4460-4479]"
  }, {
    "left" : "Config config",
    "right" : "Config config",
    "info" : "SingleVariableDeclaration[4499-4512]:SingleVariableDeclaration[4499-4512]"
  }, {
    "left" : "ErrorReporter errorReporter",
    "right" : "ErrorReporter errorReporter",
    "info" : "SingleVariableDeclaration[4532-4559]:SingleVariableDeclaration[4532-4559]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[4561-5169]:Block[4561-5169]"
  }, {
    "left" : "this.stream = stream;",
    "right" : "this.stream = stream;",
    "info" : "ExpressionStatement[4567-4588]:ExpressionStatement[4567-4588]"
  }, {
    "left" : "this.associatedNode = associatedNode;",
    "right" : "this.associatedNode = associatedNode;",
    "info" : "ExpressionStatement[4593-4630]:ExpressionStatement[4593-4630]"
  }, {
    "left" : "this.sourceFile = associatedNode == null\n        ? null : associatedNode.getStaticSourceFile();",
    "right" : "this.sourceFile = associatedNode == null\n        ? null : associatedNode.getStaticSourceFile();",
    "info" : "ExpressionStatement[4681-4776]:ExpressionStatement[4681-4776]"
  }, {
    "left" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
    "right" : "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);",
    "info" : "ExpressionStatement[4782-4855]:ExpressionStatement[4782-4855]"
  }, {
    "left" : "if (commentNode != null)",
    "right" : "if (commentNode != null)",
    "info" : "IfStatement[4860-4969]:IfStatement[4860-4969]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[4885-4969]:Block[4885-4969]"
  }, {
    "left" : "this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());",
    "right" : "this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());",
    "info" : "ExpressionStatement[4893-4963]:ExpressionStatement[4893-4963]"
  }, {
    "left" : "this.annotationNames = config.annotationNames;",
    "right" : "this.annotationNames = config.annotationNames;",
    "info" : "ExpressionStatement[4974-5020]:ExpressionStatement[4974-5020]"
  }, {
    "left" : "this.suppressionNames = config.suppressionNames;",
    "right" : "this.suppressionNames = config.suppressionNames;",
    "info" : "ExpressionStatement[5025-5073]:ExpressionStatement[5025-5073]"
  }, {
    "left" : "this.errorReporter = errorReporter;",
    "right" : "this.errorReporter = errorReporter;",
    "info" : "ExpressionStatement[5079-5114]:ExpressionStatement[5079-5114]"
  }, {
    "left" : "this.templateNode = this.createTemplateNode();",
    "right" : "this.templateNode = this.createTemplateNode();",
    "info" : "ExpressionStatement[5119-5165]:ExpressionStatement[5119-5165]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[5173-5180]:Modifier[5173-5180]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[5181-5187]:SimpleType[5181-5187]"
  }, {
    "left" : "getSourceName",
    "right" : "getSourceName",
    "info" : "SimpleName[5188-5201]:SimpleName[5188-5201]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[5204-5270]:Block[5204-5270]"
  }, {
    "left" : "return sourceFile == null ? null : sourceFile.getName();",
    "right" : "return sourceFile == null ? null : sourceFile.getName();",
    "info" : "ReturnStatement[5210-5266]:ReturnStatement[5210-5266]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[5423-5429]:Modifier[5423-5429]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[5430-5436]:Modifier[5430-5436]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[5437-5441]:SimpleType[5437-5441]"
  }, {
    "left" : "parseTypeString",
    "right" : "parseTypeString",
    "info" : "SimpleName[5442-5457]:SimpleName[5442-5457]"
  }, {
    "left" : "String typeString",
    "right" : "String typeString",
    "info" : "SingleVariableDeclaration[5458-5475]:SingleVariableDeclaration[5458-5475]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[5477-5890]:Block[5477-5890]"
  }, {
    "left" : "Config config = new Config(\n        Sets.<String>newHashSet(),\n        Sets.<String>newHashSet(),\n        false,\n        LanguageMode.ECMASCRIPT3,\n        false);",
    "right" : "Config config = new Config(\n        Sets.<String>newHashSet(),\n        Sets.<String>newHashSet(),\n        false,\n        LanguageMode.ECMASCRIPT3,\n        false);",
    "info" : "VariableDeclarationStatement[5483-5645]:VariableDeclarationStatement[5483-5645]"
  }, {
    "left" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        null,\n        null,\n        config,\n        NullErrorReporter.forNewRhino());",
    "right" : "JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        null,\n        null,\n        config,\n        NullErrorReporter.forNewRhino());",
    "info" : "VariableDeclarationStatement[5650-5823]:VariableDeclarationStatement[5650-5823]"
  }, {
    "left" : "return parser.parseTopLevelTypeExpression(parser.next());",
    "right" : "return parser.parseTopLevelTypeExpression(parser.next());",
    "info" : "ReturnStatement[5829-5886]:ReturnStatement[5829-5886]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[6210-6217]:PrimitiveType[6210-6217]"
  }, {
    "left" : "parse",
    "right" : "parse",
    "info" : "SimpleName[6218-6223]:SimpleName[6218-6223]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6226-36247]:Block[6226-36247]"
  }, {
    "left" : "int lineno;",
    "right" : "int lineno;",
    "info" : "VariableDeclarationStatement[6232-6243]:VariableDeclarationStatement[6232-6243]"
  }, {
    "left" : "int charno;",
    "right" : "int charno;",
    "info" : "VariableDeclarationStatement[6248-6259]:VariableDeclarationStatement[6248-6259]"
  }, {
    "left" : "JSTypeExpression type;",
    "right" : "JSTypeExpression type;",
    "info" : "VariableDeclarationStatement[6341-6363]:VariableDeclarationStatement[6341-6363]"
  }, {
    "left" : "state = State.SEARCHING_ANNOTATION;",
    "right" : "state = State.SEARCHING_ANNOTATION;",
    "info" : "ExpressionStatement[6369-6404]:ExpressionStatement[6369-6404]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[6409-6420]:ExpressionStatement[6409-6420]"
  }, {
    "left" : "JsDocToken token = next();",
    "right" : "JsDocToken token = next();",
    "info" : "VariableDeclarationStatement[6426-6452]:VariableDeclarationStatement[6426-6452]"
  }, {
    "left" : "List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();",
    "right" : "List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();",
    "info" : "VariableDeclarationStatement[6458-6518]:VariableDeclarationStatement[6458-6518]"
  }, {
    "left" : "if (jsdocBuilder.shouldParseDocumentation())",
    "right" : "if (jsdocBuilder.shouldParseDocumentation())",
    "info" : "IfStatement[6569-7071]:IfStatement[6569-7071]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6614-6825]:Block[6614-6825]"
  }, {
    "left" : "ExtractionInfo blockInfo = extractBlockComment(token);",
    "right" : "ExtractionInfo blockInfo = extractBlockComment(token);",
    "info" : "VariableDeclarationStatement[6622-6676]:VariableDeclarationStatement[6622-6676]"
  }, {
    "left" : "token = blockInfo.token;",
    "right" : "token = blockInfo.token;",
    "info" : "ExpressionStatement[6683-6707]:ExpressionStatement[6683-6707]"
  }, {
    "left" : "if (!blockInfo.string.isEmpty())",
    "right" : "if (!blockInfo.string.isEmpty())",
    "info" : "IfStatement[6714-6819]:IfStatement[6714-6819]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6747-6819]:Block[6747-6819]"
  }, {
    "left" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
    "right" : "jsdocBuilder.recordBlockDescription(blockInfo.string);",
    "info" : "ExpressionStatement[6757-6811]:ExpressionStatement[6757-6811]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6831-7071]:Block[6831-7071]"
  }, {
    "left" : "if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC)",
    "right" : "if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC)",
    "info" : "IfStatement[6839-7065]:IfStatement[6839-7065]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[6912-7065]:Block[6912-7065]"
  }, {
    "left" : "jsdocBuilder.recordBlockDescription(\"\");",
    "right" : "jsdocBuilder.recordBlockDescription(\"\");",
    "info" : "ExpressionStatement[7017-7057]:ExpressionStatement[7017-7057]"
  }, {
    "left" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
    "right" : "retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }",
    "info" : "LabeledStatement[7108-36243]:LabeledStatement[7108-36243]"
  }, {
    "left" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
    "right" : "for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    })",
    "info" : "ForStatement[7115-36243]:ForStatement[7115-36243]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7124-36243]:Block[7124-36243]"
  }, {
    "left" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
    "right" : "switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }",
    "info" : "SwitchStatement[7132-36194]:SwitchStatement[7132-36194]"
  }, {
    "left" : "case ANNOTATION:",
    "right" : "case ANNOTATION:",
    "info" : "SwitchCase[7157-7173]:SwitchCase[7157-7173]"
  }, {
    "left" : "if (state == State.SEARCHING_ANNOTATION)",
    "right" : "if (state == State.SEARCHING_ANNOTATION)",
    "info" : "IfStatement[7184-35186]:IfStatement[7184-35186]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7225-35186]:Block[7225-35186]"
  }, {
    "left" : "state = State.SEARCHING_NEWLINE;",
    "right" : "state = State.SEARCHING_NEWLINE;",
    "info" : "ExpressionStatement[7239-7271]:ExpressionStatement[7239-7271]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[7284-7312]:ExpressionStatement[7284-7312]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[7325-7353]:ExpressionStatement[7325-7353]"
  }, {
    "left" : "String annotationName = stream.getString();",
    "right" : "String annotationName = stream.getString();",
    "info" : "VariableDeclarationStatement[7367-7410]:VariableDeclarationStatement[7367-7410]"
  }, {
    "left" : "Annotation annotation = annotationNames.get(annotationName);",
    "right" : "Annotation annotation = annotationNames.get(annotationName);",
    "info" : "VariableDeclarationStatement[7423-7483]:VariableDeclarationStatement[7423-7483]"
  }, {
    "left" : "if (annotation == null)",
    "right" : "if (annotation == null)",
    "info" : "IfStatement[7496-35174]:IfStatement[7496-35174]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7520-7669]:Block[7520-7669]"
  }, {
    "left" : "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[7536-7655]:ExpressionStatement[7536-7655]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7675-35174]:Block[7675-35174]"
  }, {
    "left" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
    "right" : "jsdocBuilder.markAnnotation(annotationName, lineno, charno);",
    "info" : "ExpressionStatement[7746-7806]:ExpressionStatement[7746-7806]"
  }, {
    "left" : "switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }",
    "right" : "switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }",
    "info" : "SwitchStatement[7822-35160]:SwitchStatement[7822-35160]"
  }, {
    "left" : "case AUTHOR:",
    "right" : "case AUTHOR:",
    "info" : "SwitchCase[7860-7872]:SwitchCase[7860-7872]"
  }, {
    "left" : "if (jsdocBuilder.shouldParseDocumentation())",
    "right" : "if (jsdocBuilder.shouldParseDocumentation())",
    "info" : "IfStatement[7891-8507]:IfStatement[7891-8507]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[7936-8426]:Block[7936-8426]"
  }, {
    "left" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
    "right" : "ExtractionInfo authorInfo = extractSingleLineBlock();",
    "info" : "VariableDeclarationStatement[7958-8011]:VariableDeclarationStatement[7958-8011]"
  }, {
    "left" : "String author = authorInfo.string;",
    "right" : "String author = authorInfo.string;",
    "info" : "VariableDeclarationStatement[8032-8066]:VariableDeclarationStatement[8032-8066]"
  }, {
    "left" : "if (author.length() == 0)",
    "right" : "if (author.length() == 0)",
    "info" : "IfStatement[8088-8360]:IfStatement[8088-8360]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8114-8277]:Block[8114-8277]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[8138-8255]:ExpressionStatement[8138-8255]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8283-8360]:Block[8283-8360]"
  }, {
    "left" : "jsdocBuilder.addAuthor(author);",
    "right" : "jsdocBuilder.addAuthor(author);",
    "info" : "ExpressionStatement[8307-8338]:ExpressionStatement[8307-8338]"
  }, {
    "left" : "token = authorInfo.token;",
    "right" : "token = authorInfo.token;",
    "info" : "ExpressionStatement[8381-8406]:ExpressionStatement[8381-8406]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8432-8507]:Block[8432-8507]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[8454-8487]:ExpressionStatement[8454-8487]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[8526-8541]:ContinueStatement[8526-8541]"
  }, {
    "left" : "case CONSISTENTIDGENERATOR:",
    "right" : "case CONSISTENTIDGENERATOR:",
    "info" : "SwitchCase[8559-8586]:SwitchCase[8559-8586]"
  }, {
    "left" : "if (!jsdocBuilder.recordConsistentIdGenerator())",
    "right" : "if (!jsdocBuilder.recordConsistentIdGenerator())",
    "info" : "IfStatement[8605-8808]:IfStatement[8605-8808]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8654-8808]:Block[8654-8808]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[8676-8788]:ExpressionStatement[8676-8788]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[8827-8855]:ExpressionStatement[8827-8855]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[8874-8889]:ContinueStatement[8874-8889]"
  }, {
    "left" : "case CONSTANT:",
    "right" : "case CONSTANT:",
    "info" : "SwitchCase[8907-8921]:SwitchCase[8907-8921]"
  }, {
    "left" : "if (!jsdocBuilder.recordConstancy())",
    "right" : "if (!jsdocBuilder.recordConstancy())",
    "info" : "IfStatement[8940-9126]:IfStatement[8940-9126]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8977-9126]:Block[8977-9126]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[8999-9106]:ExpressionStatement[8999-9106]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[9145-9173]:ExpressionStatement[9145-9173]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[9192-9207]:ContinueStatement[9192-9207]"
  }, {
    "left" : "case CONSTRUCTOR:",
    "right" : "case CONSTRUCTOR:",
    "info" : "SwitchCase[9225-9242]:SwitchCase[9225-9242]"
  }, {
    "left" : "if (!jsdocBuilder.recordConstructor())",
    "right" : "if (!jsdocBuilder.recordConstructor())",
    "info" : "IfStatement[9261-9718]:IfStatement[9261-9718]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[9300-9718]:Block[9300-9718]"
  }, {
    "left" : "if (jsdocBuilder.isInterfaceRecorded())",
    "right" : "if (jsdocBuilder.isInterfaceRecorded())",
    "info" : "IfStatement[9322-9698]:IfStatement[9322-9698]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[9362-9531]:Block[9362-9531]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[9386-9509]:ExpressionStatement[9386-9509]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[9537-9698]:Block[9537-9698]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[9561-9676]:ExpressionStatement[9561-9676]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[9737-9765]:ExpressionStatement[9737-9765]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[9784-9799]:ContinueStatement[9784-9799]"
  }, {
    "left" : "case DEPRECATED:",
    "right" : "case DEPRECATED:",
    "info" : "SwitchCase[9817-9833]:SwitchCase[9817-9833]"
  }, {
    "left" : "if (!jsdocBuilder.recordDeprecated())",
    "right" : "if (!jsdocBuilder.recordDeprecated())",
    "info" : "IfStatement[9852-10044]:IfStatement[9852-10044]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[9890-10044]:Block[9890-10044]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[9912-10024]:ExpressionStatement[9912-10024]"
  }, {
    "left" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
    "right" : "ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);",
    "info" : "VariableDeclarationStatement[10122-10208]:VariableDeclarationStatement[10122-10208]"
  }, {
    "left" : "String reason = reasonInfo.string;",
    "right" : "String reason = reasonInfo.string;",
    "info" : "VariableDeclarationStatement[10228-10262]:VariableDeclarationStatement[10228-10262]"
  }, {
    "left" : "if (reason.length() > 0)",
    "right" : "if (reason.length() > 0)",
    "info" : "IfStatement[10282-10394]:IfStatement[10282-10394]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[10307-10394]:Block[10307-10394]"
  }, {
    "left" : "jsdocBuilder.recordDeprecationReason(reason);",
    "right" : "jsdocBuilder.recordDeprecationReason(reason);",
    "info" : "ExpressionStatement[10329-10374]:ExpressionStatement[10329-10374]"
  }, {
    "left" : "token = reasonInfo.token;",
    "right" : "token = reasonInfo.token;",
    "info" : "ExpressionStatement[10414-10439]:ExpressionStatement[10414-10439]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[10458-10473]:ContinueStatement[10458-10473]"
  }, {
    "left" : "case INTERFACE:",
    "right" : "case INTERFACE:",
    "info" : "SwitchCase[10491-10506]:SwitchCase[10491-10506]"
  }, {
    "left" : "if (!jsdocBuilder.recordInterface())",
    "right" : "if (!jsdocBuilder.recordInterface())",
    "info" : "IfStatement[10525-10982]:IfStatement[10525-10982]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[10562-10982]:Block[10562-10982]"
  }, {
    "left" : "if (jsdocBuilder.isConstructorRecorded())",
    "right" : "if (jsdocBuilder.isConstructorRecorded())",
    "info" : "IfStatement[10584-10962]:IfStatement[10584-10962]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[10626-10795]:Block[10626-10795]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[10650-10773]:ExpressionStatement[10650-10773]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[10801-10962]:Block[10801-10962]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[10825-10940]:ExpressionStatement[10825-10940]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[11001-11029]:ExpressionStatement[11001-11029]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[11048-11063]:ContinueStatement[11048-11063]"
  }, {
    "left" : "case DESC:",
    "right" : "case DESC:",
    "info" : "SwitchCase[11081-11091]:SwitchCase[11081-11091]"
  }, {
    "left" : "if (jsdocBuilder.isDescriptionRecorded())",
    "right" : "if (jsdocBuilder.isDescriptionRecorded())",
    "info" : "IfStatement[11110-11751]:IfStatement[11110-11751]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[11152-11391]:Block[11152-11391]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[11174-11286]:ExpressionStatement[11174-11286]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[11307-11335]:ExpressionStatement[11307-11335]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[11356-11371]:ContinueStatement[11356-11371]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[11397-11751]:Block[11397-11751]"
  }, {
    "left" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
    "right" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
    "info" : "VariableDeclarationStatement[11419-11512]:VariableDeclarationStatement[11419-11512]"
  }, {
    "left" : "String description = descriptionInfo.string;",
    "right" : "String description = descriptionInfo.string;",
    "info" : "VariableDeclarationStatement[11534-11578]:VariableDeclarationStatement[11534-11578]"
  }, {
    "left" : "jsdocBuilder.recordDescription(description);",
    "right" : "jsdocBuilder.recordDescription(description);",
    "info" : "ExpressionStatement[11600-11644]:ExpressionStatement[11600-11644]"
  }, {
    "left" : "token = descriptionInfo.token;",
    "right" : "token = descriptionInfo.token;",
    "info" : "ExpressionStatement[11665-11695]:ExpressionStatement[11665-11695]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[11716-11731]:ContinueStatement[11716-11731]"
  }, {
    "left" : "case FILE_OVERVIEW:",
    "right" : "case FILE_OVERVIEW:",
    "info" : "SwitchCase[11769-11788]:SwitchCase[11769-11788]"
  }, {
    "left" : "String fileOverview = \"\";",
    "right" : "String fileOverview = \"\";",
    "info" : "VariableDeclarationStatement[11807-11832]:VariableDeclarationStatement[11807-11832]"
  }, {
    "left" : "if (jsdocBuilder.shouldParseDocumentation())",
    "right" : "if (jsdocBuilder.shouldParseDocumentation())",
    "info" : "IfStatement[11851-12278]:IfStatement[11851-12278]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[11896-12197]:Block[11896-12197]"
  }, {
    "left" : "ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);",
    "right" : "ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);",
    "info" : "VariableDeclarationStatement[11918-12063]:VariableDeclarationStatement[11918-12063]"
  }, {
    "left" : "fileOverview = fileOverviewInfo.string;",
    "right" : "fileOverview = fileOverviewInfo.string;",
    "info" : "ExpressionStatement[12085-12124]:ExpressionStatement[12085-12124]"
  }, {
    "left" : "token = fileOverviewInfo.token;",
    "right" : "token = fileOverviewInfo.token;",
    "info" : "ExpressionStatement[12146-12177]:ExpressionStatement[12146-12177]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12203-12278]:Block[12203-12278]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[12225-12258]:ExpressionStatement[12225-12258]"
  }, {
    "left" : "if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null)",
    "right" : "if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null)",
    "info" : "IfStatement[12298-12567]:IfStatement[12298-12567]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12405-12567]:Block[12405-12567]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[12427-12547]:ExpressionStatement[12427-12547]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[12586-12601]:ContinueStatement[12586-12601]"
  }, {
    "left" : "case LICENSE:",
    "right" : "case LICENSE:",
    "info" : "SwitchCase[12619-12632]:SwitchCase[12619-12632]"
  }, {
    "left" : "case PRESERVE:",
    "right" : "case PRESERVE:",
    "info" : "SwitchCase[12649-12663]:SwitchCase[12649-12663]"
  }, {
    "left" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
    "right" : "ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);",
    "info" : "VariableDeclarationStatement[12682-12848]:VariableDeclarationStatement[12682-12848]"
  }, {
    "left" : "String preserve = preserveInfo.string;",
    "right" : "String preserve = preserveInfo.string;",
    "info" : "VariableDeclarationStatement[12868-12906]:VariableDeclarationStatement[12868-12906]"
  }, {
    "left" : "if (preserve.length() > 0)",
    "right" : "if (preserve.length() > 0)",
    "info" : "IfStatement[12926-13115]:IfStatement[12926-13115]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12953-13115]:Block[12953-13115]"
  }, {
    "left" : "if (fileLevelJsDocBuilder != null)",
    "right" : "if (fileLevelJsDocBuilder != null)",
    "info" : "IfStatement[12975-13095]:IfStatement[12975-13095]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13010-13095]:Block[13010-13095]"
  }, {
    "left" : "fileLevelJsDocBuilder.append(preserve);",
    "right" : "fileLevelJsDocBuilder.append(preserve);",
    "info" : "ExpressionStatement[13034-13073]:ExpressionStatement[13034-13073]"
  }, {
    "left" : "token = preserveInfo.token;",
    "right" : "token = preserveInfo.token;",
    "info" : "ExpressionStatement[13135-13162]:ExpressionStatement[13135-13162]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[13181-13196]:ContinueStatement[13181-13196]"
  }, {
    "left" : "case ENUM:",
    "right" : "case ENUM:",
    "info" : "SwitchCase[13214-13224]:SwitchCase[13214-13224]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[13243-13258]:ExpressionStatement[13243-13258]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[13277-13305]:ExpressionStatement[13277-13305]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[13324-13352]:ExpressionStatement[13324-13352]"
  }, {
    "left" : "type = null;",
    "right" : "type = null;",
    "info" : "ExpressionStatement[13372-13384]:ExpressionStatement[13372-13384]"
  }, {
    "left" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
    "right" : "if (token != JsDocToken.EOL && token != JsDocToken.EOC)",
    "info" : "IfStatement[13403-13587]:IfStatement[13403-13587]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13459-13587]:Block[13459-13587]"
  }, {
    "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
    "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
    "info" : "ExpressionStatement[13481-13567]:ExpressionStatement[13481-13567]"
  }, {
    "left" : "if (type == null)",
    "right" : "if (type == null)",
    "info" : "IfStatement[13607-13722]:IfStatement[13607-13722]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13625-13722]:Block[13625-13722]"
  }, {
    "left" : "type = createJSTypeExpression(newStringNode(\"number\"));",
    "right" : "type = createJSTypeExpression(newStringNode(\"number\"));",
    "info" : "ExpressionStatement[13647-13702]:ExpressionStatement[13647-13702]"
  }, {
    "left" : "if (!jsdocBuilder.recordEnumParameterType(type))",
    "right" : "if (!jsdocBuilder.recordEnumParameterType(type))",
    "info" : "IfStatement[13741-13922]:IfStatement[13741-13922]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13790-13922]:Block[13790-13922]"
  }, {
    "left" : "parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);",
    "right" : "parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);",
    "info" : "ExpressionStatement[13812-13902]:ExpressionStatement[13812-13902]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[13941-13974]:ExpressionStatement[13941-13974]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[13993-14008]:ContinueStatement[13993-14008]"
  }, {
    "left" : "case EXPORT:",
    "right" : "case EXPORT:",
    "info" : "SwitchCase[14026-14038]:SwitchCase[14026-14038]"
  }, {
    "left" : "if (!jsdocBuilder.recordExport())",
    "right" : "if (!jsdocBuilder.recordExport())",
    "info" : "IfStatement[14057-14241]:IfStatement[14057-14241]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14091-14241]:Block[14091-14241]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[14113-14221]:ExpressionStatement[14113-14221]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[14260-14288]:ExpressionStatement[14260-14288]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[14307-14322]:ContinueStatement[14307-14322]"
  }, {
    "left" : "case EXPOSE:",
    "right" : "case EXPOSE:",
    "info" : "SwitchCase[14340-14352]:SwitchCase[14340-14352]"
  }, {
    "left" : "if (!jsdocBuilder.recordExpose())",
    "right" : "if (!jsdocBuilder.recordExpose())",
    "info" : "IfStatement[14371-14555]:IfStatement[14371-14555]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14405-14555]:Block[14405-14555]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[14427-14535]:ExpressionStatement[14427-14535]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[14574-14602]:ExpressionStatement[14574-14602]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[14621-14636]:ContinueStatement[14621-14636]"
  }, {
    "left" : "case EXTERNS:",
    "right" : "case EXTERNS:",
    "info" : "SwitchCase[14654-14667]:SwitchCase[14654-14667]"
  }, {
    "left" : "if (!jsdocBuilder.recordExterns())",
    "right" : "if (!jsdocBuilder.recordExterns())",
    "info" : "IfStatement[14686-14872]:IfStatement[14686-14872]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14721-14872]:Block[14721-14872]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[14743-14852]:ExpressionStatement[14743-14852]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[14891-14919]:ExpressionStatement[14891-14919]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[14938-14953]:ContinueStatement[14938-14953]"
  }, {
    "left" : "case JAVA_DISPATCH:",
    "right" : "case JAVA_DISPATCH:",
    "info" : "SwitchCase[14971-14990]:SwitchCase[14971-14990]"
  }, {
    "left" : "if (!jsdocBuilder.recordJavaDispatch())",
    "right" : "if (!jsdocBuilder.recordJavaDispatch())",
    "info" : "IfStatement[15009-15205]:IfStatement[15009-15205]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[15049-15205]:Block[15049-15205]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[15071-15185]:ExpressionStatement[15071-15185]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[15224-15252]:ExpressionStatement[15224-15252]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[15271-15286]:ContinueStatement[15271-15286]"
  }, {
    "left" : "case EXTENDS:",
    "right" : "case EXTENDS:",
    "info" : "SwitchCase[15304-15317]:SwitchCase[15304-15317]"
  }, {
    "left" : "case IMPLEMENTS:",
    "right" : "case IMPLEMENTS:",
    "info" : "SwitchCase[15334-15350]:SwitchCase[15334-15350]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[15369-15380]:ExpressionStatement[15369-15380]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[15399-15414]:ExpressionStatement[15399-15414]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[15433-15461]:ExpressionStatement[15433-15461]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[15480-15508]:ExpressionStatement[15480-15508]"
  }, {
    "left" : "boolean matchingRc = false;",
    "right" : "boolean matchingRc = false;",
    "info" : "VariableDeclarationStatement[15527-15554]:VariableDeclarationStatement[15527-15554]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[15574-15698]:IfStatement[15574-15698]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[15602-15698]:Block[15602-15698]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[15624-15639]:ExpressionStatement[15624-15639]"
  }, {
    "left" : "matchingRc = true;",
    "right" : "matchingRc = true;",
    "info" : "ExpressionStatement[15660-15678]:ExpressionStatement[15660-15678]"
  }, {
    "left" : "if (token == JsDocToken.STRING)",
    "right" : "if (token == JsDocToken.STRING)",
    "info" : "IfStatement[15718-17617]:IfStatement[15718-17617]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[15750-17511]:Block[15750-17511]"
  }, {
    "left" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
    "right" : "Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);",
    "info" : "VariableDeclarationStatement[15772-15875]:VariableDeclarationStatement[15772-15875]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[15897-15925]:ExpressionStatement[15897-15925]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[15946-15974]:ExpressionStatement[15946-15974]"
  }, {
    "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
    "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
    "info" : "ExpressionStatement[15996-16038]:ExpressionStatement[15996-16038]"
  }, {
    "left" : "if (typeNode != null && !matchingRc)",
    "right" : "if (typeNode != null && !matchingRc)",
    "info" : "IfStatement[16059-16193]:IfStatement[16059-16193]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16096-16193]:Block[16096-16193]"
  }, {
    "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
    "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
    "info" : "ExpressionStatement[16120-16171]:ExpressionStatement[16120-16171]"
  }, {
    "left" : "type = createJSTypeExpression(typeNode);",
    "right" : "type = createJSTypeExpression(typeNode);",
    "info" : "ExpressionStatement[16214-16254]:ExpressionStatement[16214-16254]"
  }, {
    "left" : "if (annotation == Annotation.EXTENDS)",
    "right" : "if (annotation == Annotation.EXTENDS)",
    "info" : "IfStatement[16276-16902]:IfStatement[16276-16902]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16314-16536]:Block[16314-16536]"
  }, {
    "left" : "extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));",
    "right" : "extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));",
    "info" : "ExpressionStatement[16401-16514]:ExpressionStatement[16401-16514]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16542-16902]:Block[16542-16902]"
  }, {
    "left" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
    "right" : "Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);",
    "info" : "ExpressionStatement[16566-16655]:ExpressionStatement[16566-16655]"
  }, {
    "left" : "if (!jsdocBuilder.recordImplementedInterface(type))",
    "right" : "if (!jsdocBuilder.recordImplementedInterface(type))",
    "info" : "IfStatement[16678-16880]:IfStatement[16678-16880]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16730-16880]:Block[16730-16880]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);",
    "info" : "ExpressionStatement[16756-16856]:ExpressionStatement[16756-16856]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[16923-16938]:ExpressionStatement[16923-16938]"
  }, {
    "left" : "if (matchingRc)",
    "right" : "if (matchingRc)",
    "info" : "IfStatement[16959-17491]:IfStatement[16959-17491]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[16975-17213]:Block[16975-17213]"
  }, {
    "left" : "if (token != JsDocToken.RC)",
    "right" : "if (token != JsDocToken.RC)",
    "info" : "IfStatement[16999-17191]:IfStatement[16999-17191]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17027-17191]:Block[17027-17191]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[17053-17167]:ExpressionStatement[17053-17167]"
  }, {
    "left" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
    "right" : "if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC)",
    "info" : "IfStatement[17219-17491]:IfStatement[17219-17491]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17326-17491]:Block[17326-17491]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[17350-17469]:ExpressionStatement[17350-17469]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17517-17617]:Block[17517-17617]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);",
    "right" : "parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);",
    "info" : "ExpressionStatement[17539-17597]:ExpressionStatement[17539-17597]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[17636-17669]:ExpressionStatement[17636-17669]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[17688-17703]:ContinueStatement[17688-17703]"
  }, {
    "left" : "case HIDDEN:",
    "right" : "case HIDDEN:",
    "info" : "SwitchCase[17721-17733]:SwitchCase[17721-17733]"
  }, {
    "left" : "if (!jsdocBuilder.recordHiddenness())",
    "right" : "if (!jsdocBuilder.recordHiddenness())",
    "info" : "IfStatement[17752-17940]:IfStatement[17752-17940]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17790-17940]:Block[17790-17940]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[17812-17920]:ExpressionStatement[17812-17920]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[17959-17987]:ExpressionStatement[17959-17987]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[18006-18021]:ContinueStatement[18006-18021]"
  }, {
    "left" : "case LENDS:",
    "right" : "case LENDS:",
    "info" : "SwitchCase[18039-18050]:SwitchCase[18039-18050]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[18069-18080]:ExpressionStatement[18069-18080]"
  }, {
    "left" : "matchingRc = false;",
    "right" : "matchingRc = false;",
    "info" : "ExpressionStatement[18100-18119]:ExpressionStatement[18100-18119]"
  }, {
    "left" : "if (match(JsDocToken.LC))",
    "right" : "if (match(JsDocToken.LC))",
    "info" : "IfStatement[18138-18260]:IfStatement[18138-18260]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18164-18260]:Block[18164-18260]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[18186-18201]:ExpressionStatement[18186-18201]"
  }, {
    "left" : "matchingRc = true;",
    "right" : "matchingRc = true;",
    "info" : "ExpressionStatement[18222-18240]:ExpressionStatement[18222-18240]"
  }, {
    "left" : "if (match(JsDocToken.STRING))",
    "right" : "if (match(JsDocToken.STRING))",
    "info" : "IfStatement[18280-18766]:IfStatement[18280-18766]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18310-18605]:Block[18310-18605]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[18332-18347]:ExpressionStatement[18332-18347]"
  }, {
    "left" : "if (!jsdocBuilder.recordLends(stream.getString()))",
    "right" : "if (!jsdocBuilder.recordLends(stream.getString()))",
    "info" : "IfStatement[18368-18585]:IfStatement[18368-18585]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18419-18585]:Block[18419-18585]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[18443-18563]:ExpressionStatement[18443-18563]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18611-18766]:Block[18611-18766]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[18633-18746]:ExpressionStatement[18633-18746]"
  }, {
    "left" : "if (matchingRc && !match(JsDocToken.RC))",
    "right" : "if (matchingRc && !match(JsDocToken.RC))",
    "info" : "IfStatement[18786-18979]:IfStatement[18786-18979]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[18827-18979]:Block[18827-18979]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[18849-18959]:ExpressionStatement[18849-18959]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[18998-19026]:ExpressionStatement[18998-19026]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[19045-19060]:ContinueStatement[19045-19060]"
  }, {
    "left" : "case MEANING:",
    "right" : "case MEANING:",
    "info" : "SwitchCase[19078-19091]:SwitchCase[19078-19091]"
  }, {
    "left" : "ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);",
    "right" : "ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);",
    "info" : "VariableDeclarationStatement[19110-19197]:VariableDeclarationStatement[19110-19197]"
  }, {
    "left" : "String meaning = meaningInfo.string;",
    "right" : "String meaning = meaningInfo.string;",
    "info" : "VariableDeclarationStatement[19216-19252]:VariableDeclarationStatement[19216-19252]"
  }, {
    "left" : "token = meaningInfo.token;",
    "right" : "token = meaningInfo.token;",
    "info" : "ExpressionStatement[19271-19297]:ExpressionStatement[19271-19297]"
  }, {
    "left" : "if (!jsdocBuilder.recordMeaning(meaning))",
    "right" : "if (!jsdocBuilder.recordMeaning(meaning))",
    "info" : "IfStatement[19316-19515]:IfStatement[19316-19515]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19358-19515]:Block[19358-19515]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[19380-19495]:ExpressionStatement[19380-19495]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[19534-19549]:ContinueStatement[19534-19549]"
  }, {
    "left" : "case NO_ALIAS:",
    "right" : "case NO_ALIAS:",
    "info" : "SwitchCase[19567-19581]:SwitchCase[19567-19581]"
  }, {
    "left" : "if (!jsdocBuilder.recordNoAlias())",
    "right" : "if (!jsdocBuilder.recordNoAlias())",
    "info" : "IfStatement[19600-19786]:IfStatement[19600-19786]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19635-19786]:Block[19635-19786]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[19657-19766]:ExpressionStatement[19657-19766]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[19805-19833]:ExpressionStatement[19805-19833]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[19852-19867]:ContinueStatement[19852-19867]"
  }, {
    "left" : "case NO_COMPILE:",
    "right" : "case NO_COMPILE:",
    "info" : "SwitchCase[19885-19901]:SwitchCase[19885-19901]"
  }, {
    "left" : "if (!jsdocBuilder.recordNoCompile())",
    "right" : "if (!jsdocBuilder.recordNoCompile())",
    "info" : "IfStatement[19920-20110]:IfStatement[19920-20110]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19957-20110]:Block[19957-20110]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[19979-20090]:ExpressionStatement[19979-20090]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[20129-20157]:ExpressionStatement[20129-20157]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[20176-20191]:ContinueStatement[20176-20191]"
  }, {
    "left" : "case NO_TYPE_CHECK:",
    "right" : "case NO_TYPE_CHECK:",
    "info" : "SwitchCase[20209-20228]:SwitchCase[20209-20228]"
  }, {
    "left" : "if (!jsdocBuilder.recordNoTypeCheck())",
    "right" : "if (!jsdocBuilder.recordNoTypeCheck())",
    "info" : "IfStatement[20247-20437]:IfStatement[20247-20437]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20286-20437]:Block[20286-20437]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[20308-20417]:ExpressionStatement[20308-20417]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[20456-20484]:ExpressionStatement[20456-20484]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[20503-20518]:ContinueStatement[20503-20518]"
  }, {
    "left" : "case NOT_IMPLEMENTED:",
    "right" : "case NOT_IMPLEMENTED:",
    "info" : "SwitchCase[20536-20557]:SwitchCase[20536-20557]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[20576-20604]:ExpressionStatement[20576-20604]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[20623-20638]:ContinueStatement[20623-20638]"
  }, {
    "left" : "case INHERIT_DOC:",
    "right" : "case INHERIT_DOC:",
    "info" : "SwitchCase[20656-20673]:SwitchCase[20656-20673]"
  }, {
    "left" : "case OVERRIDE:",
    "right" : "case OVERRIDE:",
    "info" : "SwitchCase[20690-20704]:SwitchCase[20690-20704]"
  }, {
    "left" : "if (!jsdocBuilder.recordOverride())",
    "right" : "if (!jsdocBuilder.recordOverride())",
    "info" : "IfStatement[20723-20909]:IfStatement[20723-20909]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20759-20909]:Block[20759-20909]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[20781-20889]:ExpressionStatement[20781-20889]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[20928-20956]:ExpressionStatement[20928-20956]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[20975-20990]:ContinueStatement[20975-20990]"
  }, {
    "left" : "case THROWS:",
    "right" : "case THROWS:",
    "info" : "SwitchCase[21008-21020]:SwitchCase[21008-21020]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[21039-21050]:ExpressionStatement[21039-21050]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[21069-21084]:ExpressionStatement[21069-21084]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[21103-21131]:ExpressionStatement[21103-21131]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[21150-21178]:ExpressionStatement[21150-21178]"
  }, {
    "left" : "type = null;",
    "right" : "type = null;",
    "info" : "ExpressionStatement[21197-21209]:ExpressionStatement[21197-21209]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[21229-21654]:IfStatement[21229-21654]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21257-21654]:Block[21257-21654]"
  }, {
    "left" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
    "right" : "type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));",
    "info" : "ExpressionStatement[21279-21365]:ExpressionStatement[21279-21365]"
  }, {
    "left" : "if (type == null)",
    "right" : "if (type == null)",
    "info" : "IfStatement[21387-21634]:IfStatement[21387-21634]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21405-21634]:Block[21405-21634]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[21546-21574]:ExpressionStatement[21546-21574]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[21597-21612]:ContinueStatement[21597-21612]"
  }, {
    "left" : "token = current();",
    "right" : "token = current();",
    "info" : "ExpressionStatement[21749-21767]:ExpressionStatement[21749-21767]"
  }, {
    "left" : "jsdocBuilder.recordThrowType(type);",
    "right" : "jsdocBuilder.recordThrowType(type);",
    "info" : "ExpressionStatement[21829-21864]:ExpressionStatement[21829-21864]"
  }, {
    "left" : "if (jsdocBuilder.shouldParseDocumentation())",
    "right" : "if (jsdocBuilder.shouldParseDocumentation())",
    "info" : "IfStatement[21951-22483]:IfStatement[21951-22483]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21996-22402]:Block[21996-22402]"
  }, {
    "left" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
    "right" : "ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);",
    "info" : "VariableDeclarationStatement[22018-22111]:VariableDeclarationStatement[22018-22111]"
  }, {
    "left" : "String description = descriptionInfo.string;",
    "right" : "String description = descriptionInfo.string;",
    "info" : "VariableDeclarationStatement[22133-22177]:VariableDeclarationStatement[22133-22177]"
  }, {
    "left" : "if (description.length() > 0)",
    "right" : "if (description.length() > 0)",
    "info" : "IfStatement[22199-22330]:IfStatement[22199-22330]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22229-22330]:Block[22229-22330]"
  }, {
    "left" : "jsdocBuilder.recordThrowDescription(type, description);",
    "right" : "jsdocBuilder.recordThrowDescription(type, description);",
    "info" : "ExpressionStatement[22253-22308]:ExpressionStatement[22253-22308]"
  }, {
    "left" : "token = descriptionInfo.token;",
    "right" : "token = descriptionInfo.token;",
    "info" : "ExpressionStatement[22352-22382]:ExpressionStatement[22352-22382]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22408-22483]:Block[22408-22483]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[22430-22463]:ExpressionStatement[22430-22463]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[22502-22517]:ContinueStatement[22502-22517]"
  }, {
    "left" : "case PARAM:",
    "right" : "case PARAM:",
    "info" : "SwitchCase[22535-22546]:SwitchCase[22535-22546]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[22565-22576]:ExpressionStatement[22565-22576]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[22595-22610]:ExpressionStatement[22595-22610]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[22629-22657]:ExpressionStatement[22629-22657]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[22676-22704]:ExpressionStatement[22676-22704]"
  }, {
    "left" : "type = null;",
    "right" : "type = null;",
    "info" : "ExpressionStatement[22723-22735]:ExpressionStatement[22723-22735]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[22755-23351]:IfStatement[22755-23351]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22783-23351]:Block[22783-23351]"
  }, {
    "left" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
    "right" : "type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));",
    "info" : "ExpressionStatement[22805-22896]:ExpressionStatement[22805-22896]"
  }, {
    "left" : "if (type == null)",
    "right" : "if (type == null)",
    "info" : "IfStatement[22918-23165]:IfStatement[22918-23165]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22936-23165]:Block[22936-23165]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[23077-23105]:ExpressionStatement[23077-23105]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[23128-23143]:ContinueStatement[23128-23143]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[23186-23197]:ExpressionStatement[23186-23197]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[23218-23233]:ExpressionStatement[23218-23233]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[23254-23282]:ExpressionStatement[23254-23282]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[23303-23331]:ExpressionStatement[23303-23331]"
  }, {
    "left" : "String name = null;",
    "right" : "String name = null;",
    "info" : "VariableDeclarationStatement[23371-23390]:VariableDeclarationStatement[23371-23390]"
  }, {
    "left" : "boolean isBracketedParam = JsDocToken.LB == token;",
    "right" : "boolean isBracketedParam = JsDocToken.LB == token;",
    "info" : "VariableDeclarationStatement[23409-23459]:VariableDeclarationStatement[23409-23459]"
  }, {
    "left" : "if (isBracketedParam)",
    "right" : "if (isBracketedParam)",
    "info" : "IfStatement[23478-23557]:IfStatement[23478-23557]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23500-23557]:Block[23500-23557]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[23522-23537]:ExpressionStatement[23522-23537]"
  }, {
    "left" : "if (JsDocToken.STRING != token)",
    "right" : "if (JsDocToken.STRING != token)",
    "info" : "IfStatement[23577-25475]:IfStatement[23577-25475]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23609-23742]:Block[23609-23742]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
    "right" : "parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);",
    "info" : "ExpressionStatement[23631-23722]:ExpressionStatement[23631-23722]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23748-25475]:Block[23748-25475]"
  }, {
    "left" : "name = stream.getString();",
    "right" : "name = stream.getString();",
    "info" : "ExpressionStatement[23770-23796]:ExpressionStatement[23770-23796]"
  }, {
    "left" : "if (isBracketedParam)",
    "right" : "if (isBracketedParam)",
    "info" : "IfStatement[23818-24702]:IfStatement[23818-24702]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23840-24702]:Block[23840-24702]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[23864-23879]:ExpressionStatement[23864-23879]"
  }, {
    "left" : "if (JsDocToken.EQUALS == token)",
    "right" : "if (JsDocToken.EQUALS == token)",
    "info" : "IfStatement[24077-24300]:IfStatement[24077-24300]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24109-24300]:Block[24109-24300]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[24135-24150]:ExpressionStatement[24135-24150]"
  }, {
    "left" : "if (JsDocToken.STRING == token)",
    "right" : "if (JsDocToken.STRING == token)",
    "info" : "IfStatement[24175-24276]:IfStatement[24175-24276]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24207-24276]:Block[24207-24276]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[24235-24250]:ExpressionStatement[24235-24250]"
  }, {
    "left" : "if (JsDocToken.RB != token)",
    "right" : "if (JsDocToken.RB != token)",
    "info" : "IfStatement[24324-24680]:IfStatement[24324-24680]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24352-24450]:Block[24352-24450]"
  }, {
    "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
    "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
    "info" : "ExpressionStatement[24378-24426]:ExpressionStatement[24378-24426]"
  }, {
    "left" : "if (type != null)",
    "right" : "if (type != null)",
    "info" : "IfStatement[24456-24680]:IfStatement[24456-24680]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24474-24680]:Block[24474-24680]"
  }, {
    "left" : "type = JSTypeExpression.makeOptionalArg(type);",
    "right" : "type = JSTypeExpression.makeOptionalArg(type);",
    "info" : "ExpressionStatement[24610-24656]:ExpressionStatement[24610-24656]"
  }, {
    "left" : "if (name.indexOf('.') > -1)",
    "right" : "if (name.indexOf('.') > -1)",
    "info" : "IfStatement[24931-25455]:IfStatement[24931-25455]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24959-25017]:Block[24959-25017]"
  }, {
    "left" : "name = null;",
    "right" : "name = null;",
    "info" : "ExpressionStatement[24983-24995]:ExpressionStatement[24983-24995]"
  }, {
    "left" : "if (!jsdocBuilder.recordParameter(name, type))",
    "right" : "if (!jsdocBuilder.recordParameter(name, type))",
    "info" : "IfStatement[25023-25455]:IfStatement[25023-25455]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25070-25455]:Block[25070-25455]"
  }, {
    "left" : "if (jsdocBuilder.hasParameter(name))",
    "right" : "if (jsdocBuilder.hasParameter(name))",
    "info" : "IfStatement[25094-25433]:IfStatement[25094-25433]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25131-25278]:Block[25131-25278]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
    "right" : "parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);",
    "info" : "ExpressionStatement[25157-25254]:ExpressionStatement[25157-25254]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25284-25433]:Block[25284-25433]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);",
    "info" : "ExpressionStatement[25310-25409]:ExpressionStatement[25310-25409]"
  }, {
    "left" : "if (name == null)",
    "right" : "if (name == null)",
    "info" : "IfStatement[25495-25624]:IfStatement[25495-25624]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25513-25624]:Block[25513-25624]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[25535-25568]:ExpressionStatement[25535-25568]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[25589-25604]:ContinueStatement[25589-25604]"
  }, {
    "left" : "jsdocBuilder.markName(name, sourceFile, lineno, charno);",
    "right" : "jsdocBuilder.markName(name, sourceFile, lineno, charno);",
    "info" : "ExpressionStatement[25644-25700]:ExpressionStatement[25644-25700]"
  }, {
    "left" : "if (jsdocBuilder.shouldParseDocumentation())",
    "right" : "if (jsdocBuilder.shouldParseDocumentation())",
    "info" : "IfStatement[25791-26383]:IfStatement[25791-26383]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25836-26302]:Block[25836-26302]"
  }, {
    "left" : "ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);",
    "right" : "ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);",
    "info" : "VariableDeclarationStatement[25858-25956]:VariableDeclarationStatement[25858-25956]"
  }, {
    "left" : "String paramDescription = paramDescriptionInfo.string;",
    "right" : "String paramDescription = paramDescriptionInfo.string;",
    "info" : "VariableDeclarationStatement[25978-26032]:VariableDeclarationStatement[25978-26032]"
  }, {
    "left" : "if (paramDescription.length() > 0)",
    "right" : "if (paramDescription.length() > 0)",
    "info" : "IfStatement[26054-26225]:IfStatement[26054-26225]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26089-26225]:Block[26089-26225]"
  }, {
    "left" : "jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);",
    "right" : "jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);",
    "info" : "ExpressionStatement[26113-26203]:ExpressionStatement[26113-26203]"
  }, {
    "left" : "token = paramDescriptionInfo.token;",
    "right" : "token = paramDescriptionInfo.token;",
    "info" : "ExpressionStatement[26247-26282]:ExpressionStatement[26247-26282]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26308-26383]:Block[26308-26383]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[26330-26363]:ExpressionStatement[26330-26363]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[26402-26417]:ContinueStatement[26402-26417]"
  }, {
    "left" : "case PRESERVE_TRY:",
    "right" : "case PRESERVE_TRY:",
    "info" : "SwitchCase[26435-26453]:SwitchCase[26435-26453]"
  }, {
    "left" : "if (!jsdocBuilder.recordPreserveTry())",
    "right" : "if (!jsdocBuilder.recordPreserveTry())",
    "info" : "IfStatement[26472-26667]:IfStatement[26472-26667]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26511-26667]:Block[26511-26667]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[26533-26647]:ExpressionStatement[26533-26647]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[26686-26714]:ExpressionStatement[26686-26714]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[26733-26748]:ContinueStatement[26733-26748]"
  }, {
    "left" : "case PRIVATE:",
    "right" : "case PRIVATE:",
    "info" : "SwitchCase[26766-26779]:SwitchCase[26766-26779]"
  }, {
    "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
    "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE))",
    "info" : "IfStatement[26798-27016]:IfStatement[26798-27016]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26854-27016]:Block[26854-27016]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[26876-26996]:ExpressionStatement[26876-26996]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[27035-27063]:ExpressionStatement[27035-27063]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[27082-27097]:ContinueStatement[27082-27097]"
  }, {
    "left" : "case PROTECTED:",
    "right" : "case PROTECTED:",
    "info" : "SwitchCase[27115-27130]:SwitchCase[27115-27130]"
  }, {
    "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
    "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED))",
    "info" : "IfStatement[27149-27371]:IfStatement[27149-27371]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27207-27371]:Block[27207-27371]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[27229-27351]:ExpressionStatement[27229-27351]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[27390-27418]:ExpressionStatement[27390-27418]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[27437-27452]:ContinueStatement[27437-27452]"
  }, {
    "left" : "case PUBLIC:",
    "right" : "case PUBLIC:",
    "info" : "SwitchCase[27470-27482]:SwitchCase[27470-27482]"
  }, {
    "left" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
    "right" : "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC))",
    "info" : "IfStatement[27501-27717]:IfStatement[27501-27717]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27556-27717]:Block[27556-27717]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[27578-27697]:ExpressionStatement[27578-27697]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[27736-27764]:ExpressionStatement[27736-27764]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[27783-27798]:ContinueStatement[27783-27798]"
  }, {
    "left" : "case NO_SHADOW:",
    "right" : "case NO_SHADOW:",
    "info" : "SwitchCase[27816-27831]:SwitchCase[27816-27831]"
  }, {
    "left" : "if (!jsdocBuilder.recordNoShadow())",
    "right" : "if (!jsdocBuilder.recordNoShadow())",
    "info" : "IfStatement[27850-28038]:IfStatement[27850-28038]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27886-28038]:Block[27886-28038]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[27908-28018]:ExpressionStatement[27908-28018]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[28057-28085]:ExpressionStatement[28057-28085]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[28104-28119]:ContinueStatement[28104-28119]"
  }, {
    "left" : "case NO_SIDE_EFFECTS:",
    "right" : "case NO_SIDE_EFFECTS:",
    "info" : "SwitchCase[28137-28158]:SwitchCase[28137-28158]"
  }, {
    "left" : "if (!jsdocBuilder.recordNoSideEffects())",
    "right" : "if (!jsdocBuilder.recordNoSideEffects())",
    "info" : "IfStatement[28177-28375]:IfStatement[28177-28375]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28218-28375]:Block[28218-28375]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[28240-28355]:ExpressionStatement[28240-28355]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[28394-28422]:ExpressionStatement[28394-28422]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[28441-28456]:ContinueStatement[28441-28456]"
  }, {
    "left" : "case MODIFIES:",
    "right" : "case MODIFIES:",
    "info" : "SwitchCase[28474-28488]:SwitchCase[28474-28488]"
  }, {
    "left" : "token = parseModifiesTag(next());",
    "right" : "token = parseModifiesTag(next());",
    "info" : "ExpressionStatement[28507-28540]:ExpressionStatement[28507-28540]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[28559-28574]:ContinueStatement[28559-28574]"
  }, {
    "left" : "case IMPLICIT_CAST:",
    "right" : "case IMPLICIT_CAST:",
    "info" : "SwitchCase[28592-28611]:SwitchCase[28592-28611]"
  }, {
    "left" : "if (!jsdocBuilder.recordImplicitCast())",
    "right" : "if (!jsdocBuilder.recordImplicitCast())",
    "info" : "IfStatement[28630-28824]:IfStatement[28630-28824]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28670-28824]:Block[28670-28824]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[28692-28804]:ExpressionStatement[28692-28804]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[28843-28871]:ExpressionStatement[28843-28871]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[28890-28905]:ContinueStatement[28890-28905]"
  }, {
    "left" : "case SEE:",
    "right" : "case SEE:",
    "info" : "SwitchCase[28923-28932]:SwitchCase[28923-28932]"
  }, {
    "left" : "if (jsdocBuilder.shouldParseDocumentation())",
    "right" : "if (jsdocBuilder.shouldParseDocumentation())",
    "info" : "IfStatement[28951-29586]:IfStatement[28951-29586]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28996-29505]:Block[28996-29505]"
  }, {
    "left" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
    "right" : "ExtractionInfo referenceInfo = extractSingleLineBlock();",
    "info" : "VariableDeclarationStatement[29018-29074]:VariableDeclarationStatement[29018-29074]"
  }, {
    "left" : "String reference = referenceInfo.string;",
    "right" : "String reference = referenceInfo.string;",
    "info" : "VariableDeclarationStatement[29095-29135]:VariableDeclarationStatement[29095-29135]"
  }, {
    "left" : "if (reference.length() == 0)",
    "right" : "if (reference.length() == 0)",
    "info" : "IfStatement[29157-29435]:IfStatement[29157-29435]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29186-29346]:Block[29186-29346]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[29210-29324]:ExpressionStatement[29210-29324]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29352-29435]:Block[29352-29435]"
  }, {
    "left" : "jsdocBuilder.addReference(reference);",
    "right" : "jsdocBuilder.addReference(reference);",
    "info" : "ExpressionStatement[29376-29413]:ExpressionStatement[29376-29413]"
  }, {
    "left" : "token = referenceInfo.token;",
    "right" : "token = referenceInfo.token;",
    "info" : "ExpressionStatement[29457-29485]:ExpressionStatement[29457-29485]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29511-29586]:Block[29511-29586]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[29533-29566]:ExpressionStatement[29533-29566]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[29605-29620]:ContinueStatement[29605-29620]"
  }, {
    "left" : "case SUPPRESS:",
    "right" : "case SUPPRESS:",
    "info" : "SwitchCase[29638-29652]:SwitchCase[29638-29652]"
  }, {
    "left" : "token = parseSuppressTag(next());",
    "right" : "token = parseSuppressTag(next());",
    "info" : "ExpressionStatement[29671-29704]:ExpressionStatement[29671-29704]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[29723-29738]:ContinueStatement[29723-29738]"
  }, {
    "left" : "case TEMPLATE:",
    "right" : "case TEMPLATE:",
    "info" : "SwitchCase[29756-29770]:SwitchCase[29756-29770]"
  }, {
    "left" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
    "right" : "ExtractionInfo templateInfo = extractSingleLineBlock();",
    "info" : "VariableDeclarationStatement[29789-29844]:VariableDeclarationStatement[29789-29844]"
  }, {
    "left" : "String templateTypeName = templateInfo.string;",
    "right" : "String templateTypeName = templateInfo.string;",
    "info" : "VariableDeclarationStatement[29863-29909]:VariableDeclarationStatement[29863-29909]"
  }, {
    "left" : "if (templateTypeName.length() == 0)",
    "right" : "if (templateTypeName.length() == 0)",
    "info" : "IfStatement[29929-30376]:IfStatement[29929-30376]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29965-30124]:Block[29965-30124]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[29987-30104]:ExpressionStatement[29987-30104]"
  }, {
    "left" : "if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName))",
    "right" : "if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName))",
    "info" : "IfStatement[30130-30376]:IfStatement[30130-30376]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30213-30376]:Block[30213-30376]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[30235-30356]:ExpressionStatement[30235-30356]"
  }, {
    "left" : "token = templateInfo.token;",
    "right" : "token = templateInfo.token;",
    "info" : "ExpressionStatement[30396-30423]:ExpressionStatement[30396-30423]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[30442-30457]:ContinueStatement[30442-30457]"
  }, {
    "left" : "case IDGENERATOR:",
    "right" : "case IDGENERATOR:",
    "info" : "SwitchCase[30475-30492]:SwitchCase[30475-30492]"
  }, {
    "left" : "if (!jsdocBuilder.recordIdGenerator())",
    "right" : "if (!jsdocBuilder.recordIdGenerator())",
    "info" : "IfStatement[30511-30697]:IfStatement[30511-30697]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30550-30697]:Block[30550-30697]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[30572-30677]:ExpressionStatement[30572-30677]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[30716-30744]:ExpressionStatement[30716-30744]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[30763-30778]:ContinueStatement[30763-30778]"
  }, {
    "left" : "case VERSION:",
    "right" : "case VERSION:",
    "info" : "SwitchCase[30796-30809]:SwitchCase[30796-30809]"
  }, {
    "left" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
    "right" : "ExtractionInfo versionInfo = extractSingleLineBlock();",
    "info" : "VariableDeclarationStatement[30828-30882]:VariableDeclarationStatement[30828-30882]"
  }, {
    "left" : "String version = versionInfo.string;",
    "right" : "String version = versionInfo.string;",
    "info" : "VariableDeclarationStatement[30901-30937]:VariableDeclarationStatement[30901-30937]"
  }, {
    "left" : "if (version.length() == 0)",
    "right" : "if (version.length() == 0)",
    "info" : "IfStatement[30957-31397]:IfStatement[30957-31397]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30984-31144]:Block[30984-31144]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[31006-31124]:ExpressionStatement[31006-31124]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31150-31397]:Block[31150-31397]"
  }, {
    "left" : "if (!jsdocBuilder.recordVersion(version))",
    "right" : "if (!jsdocBuilder.recordVersion(version))",
    "info" : "IfStatement[31172-31377]:IfStatement[31172-31377]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31214-31377]:Block[31214-31377]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[31239-31355]:ExpressionStatement[31239-31355]"
  }, {
    "left" : "token = versionInfo.token;",
    "right" : "token = versionInfo.token;",
    "info" : "ExpressionStatement[31417-31443]:ExpressionStatement[31417-31443]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[31462-31477]:ContinueStatement[31462-31477]"
  }, {
    "left" : "case DEFINE:",
    "right" : "case DEFINE:",
    "info" : "SwitchCase[31495-31507]:SwitchCase[31495-31507]"
  }, {
    "left" : "case RETURN:",
    "right" : "case RETURN:",
    "info" : "SwitchCase[31524-31536]:SwitchCase[31524-31536]"
  }, {
    "left" : "case THIS:",
    "right" : "case THIS:",
    "info" : "SwitchCase[31553-31563]:SwitchCase[31553-31563]"
  }, {
    "left" : "case TYPE:",
    "right" : "case TYPE:",
    "info" : "SwitchCase[31580-31590]:SwitchCase[31580-31590]"
  }, {
    "left" : "case TYPEDEF:",
    "right" : "case TYPEDEF:",
    "info" : "SwitchCase[31607-31620]:SwitchCase[31607-31620]"
  }, {
    "left" : "lineno = stream.getLineno();",
    "right" : "lineno = stream.getLineno();",
    "info" : "ExpressionStatement[31639-31667]:ExpressionStatement[31639-31667]"
  }, {
    "left" : "charno = stream.getCharno();",
    "right" : "charno = stream.getCharno();",
    "info" : "ExpressionStatement[31686-31714]:ExpressionStatement[31686-31714]"
  }, {
    "left" : "Node typeNode = null;",
    "right" : "Node typeNode = null;",
    "info" : "VariableDeclarationStatement[31734-31755]:VariableDeclarationStatement[31734-31755]"
  }, {
    "left" : "if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN)",
    "right" : "if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN)",
    "info" : "IfStatement[31774-32216]:IfStatement[31774-32216]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31866-32059]:Block[31866-32059]"
  }, {
    "left" : "typeNode = newNode(Token.QMARK);",
    "right" : "typeNode = newNode(Token.QMARK);",
    "info" : "ExpressionStatement[32007-32039]:ExpressionStatement[32007-32039]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32065-32216]:Block[32065-32216]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[32087-32098]:ExpressionStatement[32087-32098]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[32119-32134]:ExpressionStatement[32119-32134]"
  }, {
    "left" : "typeNode = parseAndRecordTypeNode(token);",
    "right" : "typeNode = parseAndRecordTypeNode(token);",
    "info" : "ExpressionStatement[32155-32196]:ExpressionStatement[32155-32196]"
  }, {
    "left" : "if (annotation == Annotation.THIS)",
    "right" : "if (annotation == Annotation.THIS)",
    "info" : "IfStatement[32236-32521]:IfStatement[32236-32521]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32271-32521]:Block[32271-32521]"
  }, {
    "left" : "typeNode = wrapNode(Token.BANG, typeNode);",
    "right" : "typeNode = wrapNode(Token.BANG, typeNode);",
    "info" : "ExpressionStatement[32293-32335]:ExpressionStatement[32293-32335]"
  }, {
    "left" : "if (typeNode != null && token != JsDocToken.LC)",
    "right" : "if (typeNode != null && token != JsDocToken.LC)",
    "info" : "IfStatement[32356-32501]:IfStatement[32356-32501]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32404-32501]:Block[32404-32501]"
  }, {
    "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
    "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
    "info" : "ExpressionStatement[32428-32479]:ExpressionStatement[32428-32479]"
  }, {
    "left" : "type = createJSTypeExpression(typeNode);",
    "right" : "type = createJSTypeExpression(typeNode);",
    "info" : "ExpressionStatement[32540-32580]:ExpressionStatement[32540-32580]"
  }, {
    "left" : "if (type == null)",
    "right" : "if (type == null)",
    "info" : "IfStatement[32600-35062]:IfStatement[32600-35062]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32618-32744]:Block[32618-32744]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32750-35062]:Block[32750-35062]"
  }, {
    "left" : "switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
    "right" : "switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }",
    "info" : "SwitchStatement[32772-35042]:SwitchStatement[32772-35042]"
  }, {
    "left" : "case DEFINE:",
    "right" : "case DEFINE:",
    "info" : "SwitchCase[32816-32828]:SwitchCase[32816-32828]"
  }, {
    "left" : "if (!jsdocBuilder.recordDefineType(type))",
    "right" : "if (!jsdocBuilder.recordDefineType(type))",
    "info" : "IfStatement[32853-33039]:IfStatement[32853-33039]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32895-33039]:Block[32895-33039]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
    "right" : "parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);",
    "info" : "ExpressionStatement[32923-33013]:ExpressionStatement[32923-33013]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[33064-33070]:BreakStatement[33064-33070]"
  }, {
    "left" : "case RETURN:",
    "right" : "case RETURN:",
    "info" : "SwitchCase[33094-33106]:SwitchCase[33094-33106]"
  }, {
    "left" : "if (!jsdocBuilder.recordReturnType(type))",
    "right" : "if (!jsdocBuilder.recordReturnType(type))",
    "info" : "IfStatement[33131-33356]:IfStatement[33131-33356]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33173-33356]:Block[33173-33356]"
  }, {
    "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "info" : "ExpressionStatement[33201-33297]:ExpressionStatement[33201-33297]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[33324-33330]:BreakStatement[33324-33330]"
  }, {
    "left" : "if (jsdocBuilder.shouldParseDocumentation())",
    "right" : "if (jsdocBuilder.shouldParseDocumentation())",
    "info" : "IfStatement[33456-34142]:IfStatement[33456-34142]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33501-34049]:Block[33501-34049]"
  }, {
    "left" : "ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);",
    "right" : "ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);",
    "info" : "VariableDeclarationStatement[33529-33634]:VariableDeclarationStatement[33529-33634]"
  }, {
    "left" : "String returnDescription =\n                              returnDescriptionInfo.string;",
    "right" : "String returnDescription =\n                              returnDescriptionInfo.string;",
    "info" : "VariableDeclarationStatement[33662-33748]:VariableDeclarationStatement[33662-33748]"
  }, {
    "left" : "if (returnDescription.length() > 0)",
    "right" : "if (returnDescription.length() > 0)",
    "info" : "IfStatement[33776-33959]:IfStatement[33776-33959]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33812-33959]:Block[33812-33959]"
  }, {
    "left" : "jsdocBuilder.recordReturnDescription(\n                                returnDescription);",
    "right" : "jsdocBuilder.recordReturnDescription(\n                                returnDescription);",
    "info" : "ExpressionStatement[33842-33931]:ExpressionStatement[33842-33931]"
  }, {
    "left" : "token = returnDescriptionInfo.token;",
    "right" : "token = returnDescriptionInfo.token;",
    "info" : "ExpressionStatement[33987-34023]:ExpressionStatement[33987-34023]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34055-34142]:Block[34055-34142]"
  }, {
    "left" : "token = eatTokensUntilEOL(token);",
    "right" : "token = eatTokensUntilEOL(token);",
    "info" : "ExpressionStatement[34083-34116]:ExpressionStatement[34083-34116]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[34167-34182]:ContinueStatement[34167-34182]"
  }, {
    "left" : "case THIS:",
    "right" : "case THIS:",
    "info" : "SwitchCase[34206-34216]:SwitchCase[34206-34216]"
  }, {
    "left" : "if (!jsdocBuilder.recordThisType(type))",
    "right" : "if (!jsdocBuilder.recordThisType(type))",
    "info" : "IfStatement[34241-34431]:IfStatement[34241-34431]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34281-34431]:Block[34281-34431]"
  }, {
    "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "info" : "ExpressionStatement[34309-34405]:ExpressionStatement[34309-34405]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[34456-34462]:BreakStatement[34456-34462]"
  }, {
    "left" : "case TYPE:",
    "right" : "case TYPE:",
    "info" : "SwitchCase[34486-34496]:SwitchCase[34486-34496]"
  }, {
    "left" : "if (!jsdocBuilder.recordType(type))",
    "right" : "if (!jsdocBuilder.recordType(type))",
    "info" : "IfStatement[34521-34707]:IfStatement[34521-34707]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34557-34707]:Block[34557-34707]"
  }, {
    "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "info" : "ExpressionStatement[34585-34681]:ExpressionStatement[34585-34681]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[34732-34738]:BreakStatement[34732-34738]"
  }, {
    "left" : "case TYPEDEF:",
    "right" : "case TYPEDEF:",
    "info" : "SwitchCase[34762-34775]:SwitchCase[34762-34775]"
  }, {
    "left" : "if (!jsdocBuilder.recordTypedef(type))",
    "right" : "if (!jsdocBuilder.recordTypedef(type))",
    "info" : "IfStatement[34800-34989]:IfStatement[34800-34989]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34839-34989]:Block[34839-34989]"
  }, {
    "left" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "right" : "parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);",
    "info" : "ExpressionStatement[34867-34963]:ExpressionStatement[34867-34963]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[35014-35020]:BreakStatement[35014-35020]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[35082-35110]:ExpressionStatement[35082-35110]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[35129-35144]:ContinueStatement[35129-35144]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[35197-35203]:BreakStatement[35197-35203]"
  }, {
    "left" : "case EOC:",
    "right" : "case EOC:",
    "info" : "SwitchCase[35213-35222]:SwitchCase[35213-35222]"
  }, {
    "left" : "if (hasParsedFileOverviewDocInfo())",
    "right" : "if (hasParsedFileOverviewDocInfo())",
    "info" : "IfStatement[35233-35353]:IfStatement[35233-35353]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35269-35353]:Block[35269-35353]"
  }, {
    "left" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
    "right" : "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();",
    "info" : "ExpressionStatement[35283-35341]:ExpressionStatement[35283-35341]"
  }, {
    "left" : "checkExtendedTypes(extendedTypes);",
    "right" : "checkExtendedTypes(extendedTypes);",
    "info" : "ExpressionStatement[35364-35398]:ExpressionStatement[35364-35398]"
  }, {
    "left" : "return true;",
    "right" : "return true;",
    "info" : "ReturnStatement[35409-35421]:ReturnStatement[35409-35421]"
  }, {
    "left" : "case EOF:",
    "right" : "case EOF:",
    "info" : "SwitchCase[35431-35440]:SwitchCase[35431-35440]"
  }, {
    "left" : "jsdocBuilder.build(null);",
    "right" : "jsdocBuilder.build(null);",
    "info" : "ExpressionStatement[35500-35525]:ExpressionStatement[35500-35525]"
  }, {
    "left" : "parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[35536-35636]:ExpressionStatement[35536-35636]"
  }, {
    "left" : "checkExtendedTypes(extendedTypes);",
    "right" : "checkExtendedTypes(extendedTypes);",
    "info" : "ExpressionStatement[35647-35681]:ExpressionStatement[35647-35681]"
  }, {
    "left" : "return false;",
    "right" : "return false;",
    "info" : "ReturnStatement[35692-35705]:ReturnStatement[35692-35705]"
  }, {
    "left" : "case EOL:",
    "right" : "case EOL:",
    "info" : "SwitchCase[35715-35724]:SwitchCase[35715-35724]"
  }, {
    "left" : "if (state == State.SEARCHING_NEWLINE)",
    "right" : "if (state == State.SEARCHING_NEWLINE)",
    "info" : "IfStatement[35735-35834]:IfStatement[35735-35834]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35773-35834]:Block[35773-35834]"
  }, {
    "left" : "state = State.SEARCHING_ANNOTATION;",
    "right" : "state = State.SEARCHING_ANNOTATION;",
    "info" : "ExpressionStatement[35787-35822]:ExpressionStatement[35787-35822]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[35845-35860]:ExpressionStatement[35845-35860]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[35871-35886]:ContinueStatement[35871-35886]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[35896-35904]:SwitchCase[35896-35904]"
  }, {
    "left" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
    "right" : "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION)",
    "info" : "IfStatement[35915-36186]:IfStatement[35915-36186]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35984-36053]:Block[35984-36053]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[35998-36013]:ExpressionStatement[35998-36013]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[36026-36041]:ContinueStatement[36026-36041]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36059-36186]:Block[36059-36186]"
  }, {
    "left" : "state = State.SEARCHING_NEWLINE;",
    "right" : "state = State.SEARCHING_NEWLINE;",
    "info" : "ExpressionStatement[36073-36105]:ExpressionStatement[36073-36105]"
  }, {
    "left" : "token = eatTokensUntilEOL();",
    "right" : "token = eatTokensUntilEOL();",
    "info" : "ExpressionStatement[36118-36146]:ExpressionStatement[36118-36146]"
  }, {
    "left" : "continue retry;",
    "right" : "continue retry;",
    "info" : "ContinueStatement[36159-36174]:ContinueStatement[36159-36174]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[36222-36237]:ExpressionStatement[36222-36237]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[36251-36258]:Modifier[36251-36258]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[36259-36263]:PrimitiveType[36259-36263]"
  }, {
    "left" : "checkExtendedTypes",
    "right" : "checkExtendedTypes",
    "info" : "SimpleName[36264-36282]:SimpleName[36264-36282]"
  }, {
    "left" : "List<ExtendedTypeInfo> extendedTypes",
    "right" : "List<ExtendedTypeInfo> extendedTypes",
    "info" : "SingleVariableDeclaration[36283-36319]:SingleVariableDeclaration[36283-36319]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36321-36889]:Block[36321-36889]"
  }, {
    "left" : "for (ExtendedTypeInfo typeInfo : extendedTypes)",
    "right" : "for (ExtendedTypeInfo typeInfo : extendedTypes)",
    "info" : "EnhancedForStatement[36327-36885]:EnhancedForStatement[36327-36885]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36375-36885]:Block[36375-36885]"
  }, {
    "left" : "if (jsdocBuilder.isInterfaceRecorded())",
    "right" : "if (jsdocBuilder.isInterfaceRecorded())",
    "info" : "IfStatement[36446-36879]:IfStatement[36446-36879]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36486-36687]:Block[36486-36687]"
  }, {
    "left" : "if (!jsdocBuilder.recordExtendedInterface(typeInfo.type))",
    "right" : "if (!jsdocBuilder.recordExtendedInterface(typeInfo.type))",
    "info" : "IfStatement[36496-36679]:IfStatement[36496-36679]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36554-36679]:Block[36554-36679]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);",
    "right" : "parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);",
    "info" : "ExpressionStatement[36566-36669]:ExpressionStatement[36566-36669]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36693-36879]:Block[36693-36879]"
  }, {
    "left" : "if (!jsdocBuilder.recordBaseType(typeInfo.type))",
    "right" : "if (!jsdocBuilder.recordBaseType(typeInfo.type))",
    "info" : "IfStatement[36703-36871]:IfStatement[36703-36871]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36752-36871]:Block[36752-36871]"
  }, {
    "left" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);",
    "right" : "parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);",
    "info" : "ExpressionStatement[36764-36861]:ExpressionStatement[36764-36861]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[37047-37054]:Modifier[37047-37054]"
  }, {
    "left" : "JsDocToken",
    "right" : "JsDocToken",
    "info" : "SimpleType[37055-37065]:SimpleType[37055-37065]"
  }, {
    "left" : "parseSuppressTag",
    "right" : "parseSuppressTag",
    "info" : "SimpleName[37066-37082]:SimpleName[37066-37082]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[37083-37099]:SingleVariableDeclaration[37083-37099]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37101-38253]:Block[37101-38253]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[37107-38231]:IfStatement[37107-38231]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37135-38231]:Block[37135-38231]"
  }, {
    "left" : "Set<String> suppressions = new HashSet<String>();",
    "right" : "Set<String> suppressions = new HashSet<String>();",
    "info" : "VariableDeclarationStatement[37143-37192]:VariableDeclarationStatement[37143-37192]"
  }, {
    "left" : "while (true)",
    "right" : "while (true)",
    "info" : "WhileStatement[37199-37842]:WhileStatement[37199-37842]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37212-37842]:Block[37212-37842]"
  }, {
    "left" : "if (match(JsDocToken.STRING))",
    "right" : "if (match(JsDocToken.STRING))",
    "info" : "IfStatement[37222-37725]:IfStatement[37222-37725]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37252-37573]:Block[37252-37573]"
  }, {
    "left" : "String name = stream.getString();",
    "right" : "String name = stream.getString();",
    "info" : "VariableDeclarationStatement[37264-37297]:VariableDeclarationStatement[37264-37297]"
  }, {
    "left" : "if (!suppressionNames.contains(name))",
    "right" : "if (!suppressionNames.contains(name))",
    "info" : "IfStatement[37308-37488]:IfStatement[37308-37488]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37346-37488]:Block[37346-37488]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[37360-37476]:ExpressionStatement[37360-37476]"
  }, {
    "left" : "suppressions.add(stream.getString());",
    "right" : "suppressions.add(stream.getString());",
    "info" : "ExpressionStatement[37500-37537]:ExpressionStatement[37500-37537]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[37548-37563]:ExpressionStatement[37548-37563]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37579-37725]:Block[37579-37725]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[37591-37691]:ExpressionStatement[37591-37691]"
  }, {
    "left" : "return token;",
    "right" : "return token;",
    "info" : "ReturnStatement[37702-37715]:ReturnStatement[37702-37715]"
  }, {
    "left" : "if (match(JsDocToken.PIPE))",
    "right" : "if (match(JsDocToken.PIPE))",
    "info" : "IfStatement[37735-37834]:IfStatement[37735-37834]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37763-37800]:Block[37763-37800]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[37775-37790]:ExpressionStatement[37775-37790]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37806-37834]:Block[37806-37834]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[37818-37824]:BreakStatement[37818-37824]"
  }, {
    "left" : "if (!match(JsDocToken.RC))",
    "right" : "if (!match(JsDocToken.RC))",
    "info" : "IfStatement[37850-38225]:IfStatement[37850-38225]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37877-37993]:Block[37877-37993]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[37887-37985]:ExpressionStatement[37887-37985]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37999-38225]:Block[37999-38225]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[38009-38024]:ExpressionStatement[38009-38024]"
  }, {
    "left" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
    "right" : "if (!jsdocBuilder.recordSuppressions(suppressions))",
    "info" : "IfStatement[38033-38217]:IfStatement[38033-38217]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38085-38217]:Block[38085-38217]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[38097-38207]:ExpressionStatement[38097-38207]"
  }, {
    "left" : "return token;",
    "right" : "return token;",
    "info" : "ReturnStatement[38236-38249]:ReturnStatement[38236-38249]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[38414-38421]:Modifier[38414-38421]"
  }, {
    "left" : "JsDocToken",
    "right" : "JsDocToken",
    "info" : "SimpleType[38422-38432]:SimpleType[38422-38432]"
  }, {
    "left" : "parseModifiesTag",
    "right" : "parseModifiesTag",
    "info" : "SimpleName[38433-38449]:SimpleName[38433-38449]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[38450-38466]:SingleVariableDeclaration[38450-38466]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38468-39668]:Block[38468-39668]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[38474-39646]:IfStatement[38474-39646]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38502-39646]:Block[38502-39646]"
  }, {
    "left" : "Set<String> modifies = new HashSet<String>();",
    "right" : "Set<String> modifies = new HashSet<String>();",
    "info" : "VariableDeclarationStatement[38510-38555]:VariableDeclarationStatement[38510-38555]"
  }, {
    "left" : "while (true)",
    "right" : "while (true)",
    "info" : "WhileStatement[38562-39265]:WhileStatement[38562-39265]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38575-39265]:Block[38575-39265]"
  }, {
    "left" : "if (match(JsDocToken.STRING))",
    "right" : "if (match(JsDocToken.STRING))",
    "info" : "IfStatement[38585-39148]:IfStatement[38585-39148]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38615-38996]:Block[38615-38996]"
  }, {
    "left" : "String name = stream.getString();",
    "right" : "String name = stream.getString();",
    "info" : "VariableDeclarationStatement[38627-38660]:VariableDeclarationStatement[38627-38660]"
  }, {
    "left" : "if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name))",
    "right" : "if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name))",
    "info" : "IfStatement[38671-38915]:IfStatement[38671-38915]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38769-38915]:Block[38769-38915]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[38785-38903]:ExpressionStatement[38785-38903]"
  }, {
    "left" : "modifies.add(stream.getString());",
    "right" : "modifies.add(stream.getString());",
    "info" : "ExpressionStatement[38927-38960]:ExpressionStatement[38927-38960]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[38971-38986]:ExpressionStatement[38971-38986]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39002-39148]:Block[39002-39148]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[39014-39114]:ExpressionStatement[39014-39114]"
  }, {
    "left" : "return token;",
    "right" : "return token;",
    "info" : "ReturnStatement[39125-39138]:ReturnStatement[39125-39138]"
  }, {
    "left" : "if (match(JsDocToken.PIPE))",
    "right" : "if (match(JsDocToken.PIPE))",
    "info" : "IfStatement[39158-39257]:IfStatement[39158-39257]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39186-39223]:Block[39186-39223]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[39198-39213]:ExpressionStatement[39198-39213]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39229-39257]:Block[39229-39257]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[39241-39247]:BreakStatement[39241-39247]"
  }, {
    "left" : "if (!match(JsDocToken.RC))",
    "right" : "if (!match(JsDocToken.RC))",
    "info" : "IfStatement[39273-39640]:IfStatement[39273-39640]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39300-39416]:Block[39300-39416]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[39310-39408]:ExpressionStatement[39310-39408]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39422-39640]:Block[39422-39640]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[39432-39447]:ExpressionStatement[39432-39447]"
  }, {
    "left" : "if (!jsdocBuilder.recordModifies(modifies))",
    "right" : "if (!jsdocBuilder.recordModifies(modifies))",
    "info" : "IfStatement[39456-39632]:IfStatement[39456-39632]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39500-39632]:Block[39500-39632]"
  }, {
    "left" : "parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());",
    "right" : "parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[39512-39622]:ExpressionStatement[39512-39622]"
  }, {
    "left" : "return token;",
    "right" : "return token;",
    "info" : "ReturnStatement[39651-39664]:ReturnStatement[39651-39664]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[39905-39912]:Modifier[39905-39912]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[39913-39917]:SimpleType[39913-39917]"
  }, {
    "left" : "parseAndRecordTypeNode",
    "right" : "parseAndRecordTypeNode",
    "info" : "SimpleName[39918-39940]:SimpleName[39918-39940]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[39941-39957]:SingleVariableDeclaration[39941-39957]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39959-40030]:Block[39959-40030]"
  }, {
    "left" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
    "right" : "return parseAndRecordTypeNode(token, token == JsDocToken.LC);",
    "info" : "ReturnStatement[39965-40026]:ReturnStatement[39965-40026]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[40337-40344]:Modifier[40337-40344]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[40345-40349]:SimpleType[40345-40349]"
  }, {
    "left" : "parseAndRecordTypeNode",
    "right" : "parseAndRecordTypeNode",
    "info" : "SimpleName[40350-40372]:SimpleName[40350-40372]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[40373-40389]:SingleVariableDeclaration[40373-40389]"
  }, {
    "left" : "boolean matchingLC",
    "right" : "boolean matchingLC",
    "info" : "SingleVariableDeclaration[40391-40409]:SingleVariableDeclaration[40391-40409]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[40411-40525]:Block[40411-40525]"
  }, {
    "left" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
    "right" : "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);",
    "info" : "ReturnStatement[40417-40521]:ReturnStatement[40417-40521]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[40964-40971]:Modifier[40964-40971]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[40972-40976]:SimpleType[40972-40976]"
  }, {
    "left" : "parseAndRecordTypeNameNode",
    "right" : "parseAndRecordTypeNameNode",
    "info" : "SimpleName[40977-41003]:SimpleName[40977-41003]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[41004-41020]:SingleVariableDeclaration[41004-41020]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[41022-41032]:SingleVariableDeclaration[41022-41032]"
  }, {
    "left" : "int startCharno",
    "right" : "int startCharno",
    "info" : "SingleVariableDeclaration[41076-41091]:SingleVariableDeclaration[41076-41091]"
  }, {
    "left" : "boolean matchingLC",
    "right" : "boolean matchingLC",
    "info" : "SingleVariableDeclaration[41093-41111]:SingleVariableDeclaration[41093-41111]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41113-41199]:Block[41113-41199]"
  }, {
    "left" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
    "right" : "return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);",
    "info" : "ReturnStatement[41119-41195]:ReturnStatement[41119-41195]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[41659-41666]:Modifier[41659-41666]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[41667-41671]:SimpleType[41667-41671]"
  }, {
    "left" : "parseAndRecordParamTypeNode",
    "right" : "parseAndRecordParamTypeNode",
    "info" : "SimpleName[41672-41699]:SimpleName[41672-41699]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[41700-41716]:SingleVariableDeclaration[41700-41716]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41718-42165]:Block[41718-42165]"
  }, {
    "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
    "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
    "info" : "ExpressionStatement[41724-41776]:ExpressionStatement[41724-41776]"
  }, {
    "left" : "int lineno = stream.getLineno();",
    "right" : "int lineno = stream.getLineno();",
    "info" : "VariableDeclarationStatement[41781-41813]:VariableDeclarationStatement[41781-41813]"
  }, {
    "left" : "int startCharno = stream.getCharno();",
    "right" : "int startCharno = stream.getCharno();",
    "info" : "VariableDeclarationStatement[41818-41855]:VariableDeclarationStatement[41818-41855]"
  }, {
    "left" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
    "right" : "Node typeNode = parseParamTypeExpressionAnnotation(token);",
    "info" : "VariableDeclarationStatement[41861-41919]:VariableDeclarationStatement[41861-41919]"
  }, {
    "left" : "if (typeNode != null)",
    "right" : "if (typeNode != null)",
    "info" : "IfStatement[41924-42140]:IfStatement[41924-42140]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41946-42140]:Block[41946-42140]"
  }, {
    "left" : "int endLineno = stream.getLineno();",
    "right" : "int endLineno = stream.getLineno();",
    "info" : "VariableDeclarationStatement[41954-41989]:VariableDeclarationStatement[41954-41989]"
  }, {
    "left" : "int endCharno = stream.getCharno();",
    "right" : "int endCharno = stream.getCharno();",
    "info" : "VariableDeclarationStatement[41996-42031]:VariableDeclarationStatement[41996-42031]"
  }, {
    "left" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n          endLineno, endCharno, true);",
    "right" : "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n          endLineno, endCharno, true);",
    "info" : "ExpressionStatement[42039-42134]:ExpressionStatement[42039-42134]"
  }, {
    "left" : "return typeNode;",
    "right" : "return typeNode;",
    "info" : "ReturnStatement[42145-42161]:ReturnStatement[42145-42161]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[42790-42797]:Modifier[42790-42797]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[42798-42802]:SimpleType[42798-42802]"
  }, {
    "left" : "parseAndRecordTypeNode",
    "right" : "parseAndRecordTypeNode",
    "info" : "SimpleName[42803-42825]:SimpleName[42803-42825]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[42826-42842]:SingleVariableDeclaration[42826-42842]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[42844-42854]:SingleVariableDeclaration[42844-42854]"
  }, {
    "left" : "int startCharno",
    "right" : "int startCharno",
    "info" : "SingleVariableDeclaration[42894-42909]:SingleVariableDeclaration[42894-42909]"
  }, {
    "left" : "boolean matchingLC",
    "right" : "boolean matchingLC",
    "info" : "SingleVariableDeclaration[42949-42967]:SingleVariableDeclaration[42949-42967]"
  }, {
    "left" : "boolean onlyParseSimpleNames",
    "right" : "boolean onlyParseSimpleNames",
    "info" : "SingleVariableDeclaration[43007-43035]:SingleVariableDeclaration[43007-43035]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43037-43583]:Block[43037-43583]"
  }, {
    "left" : "Node typeNode = null;",
    "right" : "Node typeNode = null;",
    "info" : "VariableDeclarationStatement[43043-43064]:VariableDeclarationStatement[43043-43064]"
  }, {
    "left" : "if (onlyParseSimpleNames)",
    "right" : "if (onlyParseSimpleNames)",
    "info" : "IfStatement[43070-43220]:IfStatement[43070-43220]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43096-43152]:Block[43096-43152]"
  }, {
    "left" : "typeNode = parseTypeNameAnnotation(token);",
    "right" : "typeNode = parseTypeNameAnnotation(token);",
    "info" : "ExpressionStatement[43104-43146]:ExpressionStatement[43104-43146]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43158-43220]:Block[43158-43220]"
  }, {
    "left" : "typeNode = parseTypeExpressionAnnotation(token);",
    "right" : "typeNode = parseTypeExpressionAnnotation(token);",
    "info" : "ExpressionStatement[43166-43214]:ExpressionStatement[43166-43214]"
  }, {
    "left" : "if (typeNode != null && !matchingLC)",
    "right" : "if (typeNode != null && !matchingLC)",
    "info" : "IfStatement[43226-43328]:IfStatement[43226-43328]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43263-43328]:Block[43263-43328]"
  }, {
    "left" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
    "right" : "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);",
    "info" : "ExpressionStatement[43271-43322]:ExpressionStatement[43271-43322]"
  }, {
    "left" : "if (typeNode != null)",
    "right" : "if (typeNode != null)",
    "info" : "IfStatement[43334-43557]:IfStatement[43334-43557]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43356-43557]:Block[43356-43557]"
  }, {
    "left" : "int endLineno = stream.getLineno();",
    "right" : "int endLineno = stream.getLineno();",
    "info" : "VariableDeclarationStatement[43364-43399]:VariableDeclarationStatement[43364-43399]"
  }, {
    "left" : "int endCharno = stream.getCharno();",
    "right" : "int endCharno = stream.getCharno();",
    "info" : "VariableDeclarationStatement[43406-43441]:VariableDeclarationStatement[43406-43441]"
  }, {
    "left" : "jsdocBuilder.markTypeNode(\n          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);",
    "right" : "jsdocBuilder.markTypeNode(\n          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);",
    "info" : "ExpressionStatement[43449-43551]:ExpressionStatement[43449-43551]"
  }, {
    "left" : "return typeNode;",
    "right" : "return typeNode;",
    "info" : "ReturnStatement[43563-43579]:ReturnStatement[43563-43579]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[43657-43664]:Modifier[43657-43664]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[43665-43671]:SimpleType[43665-43671]"
  }, {
    "left" : "toString",
    "right" : "toString",
    "info" : "SimpleName[43672-43680]:SimpleName[43672-43680]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[43681-43697]:SingleVariableDeclaration[43681-43697]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43699-44529]:Block[43699-44529]"
  }, {
    "left" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
    "right" : "switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }",
    "info" : "SwitchStatement[43705-44525]:SwitchStatement[43705-44525]"
  }, {
    "left" : "case ANNOTATION:",
    "right" : "case ANNOTATION:",
    "info" : "SwitchCase[43728-43744]:SwitchCase[43728-43744]"
  }, {
    "left" : "return \"@\" + stream.getString();",
    "right" : "return \"@\" + stream.getString();",
    "info" : "ReturnStatement[43753-43785]:ReturnStatement[43753-43785]"
  }, {
    "left" : "case BANG:",
    "right" : "case BANG:",
    "info" : "SwitchCase[43793-43803]:SwitchCase[43793-43803]"
  }, {
    "left" : "return \"!\";",
    "right" : "return \"!\";",
    "info" : "ReturnStatement[43812-43823]:ReturnStatement[43812-43823]"
  }, {
    "left" : "case COMMA:",
    "right" : "case COMMA:",
    "info" : "SwitchCase[43831-43842]:SwitchCase[43831-43842]"
  }, {
    "left" : "return \",\";",
    "right" : "return \",\";",
    "info" : "ReturnStatement[43851-43862]:ReturnStatement[43851-43862]"
  }, {
    "left" : "case COLON:",
    "right" : "case COLON:",
    "info" : "SwitchCase[43870-43881]:SwitchCase[43870-43881]"
  }, {
    "left" : "return \":\";",
    "right" : "return \":\";",
    "info" : "ReturnStatement[43890-43901]:ReturnStatement[43890-43901]"
  }, {
    "left" : "case GT:",
    "right" : "case GT:",
    "info" : "SwitchCase[43909-43917]:SwitchCase[43909-43917]"
  }, {
    "left" : "return \">\";",
    "right" : "return \">\";",
    "info" : "ReturnStatement[43926-43937]:ReturnStatement[43926-43937]"
  }, {
    "left" : "case LB:",
    "right" : "case LB:",
    "info" : "SwitchCase[43945-43953]:SwitchCase[43945-43953]"
  }, {
    "left" : "return \"[\";",
    "right" : "return \"[\";",
    "info" : "ReturnStatement[43962-43973]:ReturnStatement[43962-43973]"
  }, {
    "left" : "case LC:",
    "right" : "case LC:",
    "info" : "SwitchCase[43981-43989]:SwitchCase[43981-43989]"
  }, {
    "left" : "return \"{\";",
    "right" : "return \"{\";",
    "info" : "ReturnStatement[43998-44009]:ReturnStatement[43998-44009]"
  }, {
    "left" : "case LP:",
    "right" : "case LP:",
    "info" : "SwitchCase[44017-44025]:SwitchCase[44017-44025]"
  }, {
    "left" : "return \"(\";",
    "right" : "return \"(\";",
    "info" : "ReturnStatement[44034-44045]:ReturnStatement[44034-44045]"
  }, {
    "left" : "case LT:",
    "right" : "case LT:",
    "info" : "SwitchCase[44053-44061]:SwitchCase[44053-44061]"
  }, {
    "left" : "return \".<\";",
    "right" : "return \".<\";",
    "info" : "ReturnStatement[44070-44082]:ReturnStatement[44070-44082]"
  }, {
    "left" : "case QMARK:",
    "right" : "case QMARK:",
    "info" : "SwitchCase[44090-44101]:SwitchCase[44090-44101]"
  }, {
    "left" : "return \"?\";",
    "right" : "return \"?\";",
    "info" : "ReturnStatement[44110-44121]:ReturnStatement[44110-44121]"
  }, {
    "left" : "case PIPE:",
    "right" : "case PIPE:",
    "info" : "SwitchCase[44129-44139]:SwitchCase[44129-44139]"
  }, {
    "left" : "return \"|\";",
    "right" : "return \"|\";",
    "info" : "ReturnStatement[44148-44159]:ReturnStatement[44148-44159]"
  }, {
    "left" : "case RB:",
    "right" : "case RB:",
    "info" : "SwitchCase[44167-44175]:SwitchCase[44167-44175]"
  }, {
    "left" : "return \"]\";",
    "right" : "return \"]\";",
    "info" : "ReturnStatement[44184-44195]:ReturnStatement[44184-44195]"
  }, {
    "left" : "case RC:",
    "right" : "case RC:",
    "info" : "SwitchCase[44203-44211]:SwitchCase[44203-44211]"
  }, {
    "left" : "return \"}\";",
    "right" : "return \"}\";",
    "info" : "ReturnStatement[44220-44231]:ReturnStatement[44220-44231]"
  }, {
    "left" : "case RP:",
    "right" : "case RP:",
    "info" : "SwitchCase[44239-44247]:SwitchCase[44239-44247]"
  }, {
    "left" : "return \")\";",
    "right" : "return \")\";",
    "info" : "ReturnStatement[44256-44267]:ReturnStatement[44256-44267]"
  }, {
    "left" : "case STAR:",
    "right" : "case STAR:",
    "info" : "SwitchCase[44275-44285]:SwitchCase[44275-44285]"
  }, {
    "left" : "return \"*\";",
    "right" : "return \"*\";",
    "info" : "ReturnStatement[44294-44305]:ReturnStatement[44294-44305]"
  }, {
    "left" : "case ELLIPSIS:",
    "right" : "case ELLIPSIS:",
    "info" : "SwitchCase[44313-44327]:SwitchCase[44313-44327]"
  }, {
    "left" : "return \"...\";",
    "right" : "return \"...\";",
    "info" : "ReturnStatement[44336-44349]:ReturnStatement[44336-44349]"
  }, {
    "left" : "case EQUALS:",
    "right" : "case EQUALS:",
    "info" : "SwitchCase[44357-44369]:SwitchCase[44357-44369]"
  }, {
    "left" : "return \"=\";",
    "right" : "return \"=\";",
    "info" : "ReturnStatement[44378-44389]:ReturnStatement[44378-44389]"
  }, {
    "left" : "case STRING:",
    "right" : "case STRING:",
    "info" : "SwitchCase[44397-44409]:SwitchCase[44397-44409]"
  }, {
    "left" : "return stream.getString();",
    "right" : "return stream.getString();",
    "info" : "ReturnStatement[44418-44444]:ReturnStatement[44418-44444]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[44452-44460]:SwitchCase[44452-44460]"
  }, {
    "left" : "throw new IllegalStateException(token.toString());",
    "right" : "throw new IllegalStateException(token.toString());",
    "info" : "ThrowStatement[44469-44519]:ThrowStatement[44469-44519]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[44628-44635]:Modifier[44628-44635]"
  }, {
    "left" : "JSTypeExpression",
    "right" : "JSTypeExpression",
    "info" : "SimpleType[44636-44652]:SimpleType[44636-44652]"
  }, {
    "left" : "createJSTypeExpression",
    "right" : "createJSTypeExpression",
    "info" : "SimpleName[44653-44675]:SimpleName[44653-44675]"
  }, {
    "left" : "Node n",
    "right" : "Node n",
    "info" : "SingleVariableDeclaration[44676-44682]:SingleVariableDeclaration[44676-44682]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[44684-44769]:Block[44684-44769]"
  }, {
    "left" : "return n == null ? null :\n        new JSTypeExpression(n, getSourceName());",
    "right" : "return n == null ? null :\n        new JSTypeExpression(n, getSourceName());",
    "info" : "ReturnStatement[44690-44765]:ReturnStatement[44690-44765]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[44918-44925]:Modifier[44918-44925]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[44926-44932]:Modifier[44926-44932]"
  }, {
    "left" : "class",
    "right" : "class",
    "info" : "TYPE_DECLARATION_KIND[44933-44938]:TYPE_DECLARATION_KIND[44933-44938]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[45030-45036]:Modifier[45030-45036]"
  }, {
    "left" : "ExtractionInfo",
    "right" : "ExtractionInfo",
    "info" : "SimpleName[45037-45051]:SimpleName[45037-45051]"
  }, {
    "left" : "String string",
    "right" : "String string",
    "info" : "SingleVariableDeclaration[45052-45065]:SingleVariableDeclaration[45052-45065]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[45067-45083]:SingleVariableDeclaration[45067-45083]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45085-45146]:Block[45085-45146]"
  }, {
    "left" : "this.string = string;",
    "right" : "this.string = string;",
    "info" : "ExpressionStatement[45093-45114]:ExpressionStatement[45093-45114]"
  }, {
    "left" : "this.token = token;",
    "right" : "this.token = token;",
    "info" : "ExpressionStatement[45121-45140]:ExpressionStatement[45121-45140]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[45206-45213]:Modifier[45206-45213]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[45214-45220]:Modifier[45214-45220]"
  }, {
    "left" : "class",
    "right" : "class",
    "info" : "TYPE_DECLARATION_KIND[45221-45226]:TYPE_DECLARATION_KIND[45221-45226]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[45328-45334]:Modifier[45328-45334]"
  }, {
    "left" : "ExtendedTypeInfo",
    "right" : "ExtendedTypeInfo",
    "info" : "SimpleName[45335-45351]:SimpleName[45335-45351]"
  }, {
    "left" : "JSTypeExpression type",
    "right" : "JSTypeExpression type",
    "info" : "SingleVariableDeclaration[45352-45373]:SingleVariableDeclaration[45352-45373]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[45375-45385]:SingleVariableDeclaration[45375-45385]"
  }, {
    "left" : "int charno",
    "right" : "int charno",
    "info" : "SingleVariableDeclaration[45387-45397]:SingleVariableDeclaration[45387-45397]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45399-45486]:Block[45399-45486]"
  }, {
    "left" : "this.type = type;",
    "right" : "this.type = type;",
    "info" : "ExpressionStatement[45407-45424]:ExpressionStatement[45407-45424]"
  }, {
    "left" : "this.lineno = lineno;",
    "right" : "this.lineno = lineno;",
    "info" : "ExpressionStatement[45431-45452]:ExpressionStatement[45431-45452]"
  }, {
    "left" : "this.charno = charno;",
    "right" : "this.charno = charno;",
    "info" : "ExpressionStatement[45459-45480]:ExpressionStatement[45459-45480]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[45747-45754]:Modifier[45747-45754]"
  }, {
    "left" : "ExtractionInfo",
    "right" : "ExtractionInfo",
    "info" : "SimpleType[45755-45769]:SimpleType[45755-45769]"
  }, {
    "left" : "extractSingleLineBlock",
    "right" : "extractSingleLineBlock",
    "info" : "SimpleName[45770-45792]:SimpleName[45770-45792]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45795-46229]:Block[45795-46229]"
  }, {
    "left" : "stream.update();",
    "right" : "stream.update();",
    "info" : "ExpressionStatement[45841-45857]:ExpressionStatement[45841-45857]"
  }, {
    "left" : "int lineno = stream.getLineno();",
    "right" : "int lineno = stream.getLineno();",
    "info" : "VariableDeclarationStatement[45862-45894]:VariableDeclarationStatement[45862-45894]"
  }, {
    "left" : "int charno = stream.getCharno() + 1;",
    "right" : "int charno = stream.getCharno() + 1;",
    "info" : "VariableDeclarationStatement[45899-45935]:VariableDeclarationStatement[45899-45935]"
  }, {
    "left" : "String line = stream.getRemainingJSDocLine().trim();",
    "right" : "String line = stream.getRemainingJSDocLine().trim();",
    "info" : "VariableDeclarationStatement[45941-45993]:VariableDeclarationStatement[45941-45993]"
  }, {
    "left" : "if (line.length() > 0)",
    "right" : "if (line.length() > 0)",
    "info" : "IfStatement[46038-46179]:IfStatement[46038-46179]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46061-46179]:Block[46061-46179]"
  }, {
    "left" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
    "right" : "jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());",
    "info" : "ExpressionStatement[46069-46173]:ExpressionStatement[46069-46173]"
  }, {
    "left" : "return new ExtractionInfo(line, next());",
    "right" : "return new ExtractionInfo(line, next());",
    "info" : "ReturnStatement[46185-46225]:ReturnStatement[46185-46225]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[46233-46240]:Modifier[46233-46240]"
  }, {
    "left" : "ExtractionInfo",
    "right" : "ExtractionInfo",
    "info" : "SimpleType[46241-46255]:SimpleType[46241-46255]"
  }, {
    "left" : "extractMultilineTextualBlock",
    "right" : "extractMultilineTextualBlock",
    "info" : "SimpleName[46256-46284]:SimpleName[46256-46284]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[46285-46301]:SingleVariableDeclaration[46285-46301]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46303-46386]:Block[46303-46386]"
  }, {
    "left" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
    "right" : "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);",
    "info" : "ReturnStatement[46309-46382]:ReturnStatement[46309-46382]"
  }, {
    "left" : "@SuppressWarnings(\"fallthrough\")",
    "right" : "@SuppressWarnings(\"fallthrough\")",
    "info" : "SingleMemberAnnotation[47295-47327]:SingleMemberAnnotation[47295-47327]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[47330-47337]:Modifier[47330-47337]"
  }, {
    "left" : "ExtractionInfo",
    "right" : "ExtractionInfo",
    "info" : "SimpleType[47338-47352]:SimpleType[47338-47352]"
  }, {
    "left" : "extractMultilineTextualBlock",
    "right" : "extractMultilineTextualBlock",
    "info" : "SimpleName[47353-47381]:SimpleName[47353-47381]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[47382-47398]:SingleVariableDeclaration[47382-47398]"
  }, {
    "left" : "WhitespaceOption option",
    "right" : "WhitespaceOption option",
    "info" : "SingleVariableDeclaration[47454-47477]:SingleVariableDeclaration[47454-47477]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[47479-50203]:Block[47479-50695]"
  }, {
    "left" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
    "right" : "if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF)",
    "info" : "IfStatement[47486-47628]:IfStatement[47486-47628]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[47577-47628]:Block[47577-47628]"
  }, {
    "left" : "return new ExtractionInfo(\"\", token);",
    "right" : "return new ExtractionInfo(\"\", token);",
    "info" : "ReturnStatement[47585-47622]:ReturnStatement[47585-47622]"
  }, {
    "left" : "stream.update();",
    "right" : "stream.update();",
    "info" : "ExpressionStatement[47634-47650]:ExpressionStatement[47634-47650]"
  }, {
    "left" : "int startLineno = stream.getLineno();",
    "right" : "int startLineno = stream.getLineno();",
    "info" : "VariableDeclarationStatement[47655-47692]:VariableDeclarationStatement[47655-47692]"
  }, {
    "left" : "int startCharno = stream.getCharno() + 1;",
    "right" : "int startCharno = stream.getCharno() + 1;",
    "info" : "VariableDeclarationStatement[47697-47738]:VariableDeclarationStatement[47697-47738]"
  }, {
    "left" : "String line = stream.getRemainingJSDocLine();",
    "right" : "String line = stream.getRemainingJSDocLine();",
    "info" : "VariableDeclarationStatement[47789-47834]:VariableDeclarationStatement[47789-47834]"
  }, {
    "left" : "if (option != WhitespaceOption.PRESERVE)",
    "right" : "if (option != WhitespaceOption.PRESERVE)",
    "info" : "IfStatement[47839-47913]:IfStatement[47839-47913]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[47880-47913]:Block[47880-47913]"
  }, {
    "left" : "line = line.trim();",
    "right" : "line = line.trim();",
    "info" : "ExpressionStatement[47888-47907]:ExpressionStatement[47888-47907]"
  }, {
    "left" : "StringBuilder builder = new StringBuilder();",
    "right" : "StringBuilder builder = new StringBuilder();",
    "info" : "VariableDeclarationStatement[47919-47963]:VariableDeclarationStatement[47919-47963]"
  }, {
    "left" : "builder.append(line);",
    "right" : "builder.append(line);",
    "info" : "ExpressionStatement[47968-47989]:ExpressionStatement[47968-47989]"
  }, {
    "left" : "state = State.SEARCHING_ANNOTATION;",
    "right" : "state = State.SEARCHING_ANNOTATION;",
    "info" : "ExpressionStatement[47995-48030]:ExpressionStatement[47995-48030]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[48035-48050]:ExpressionStatement[48035-48050]"
  }, {
    "left" : "boolean ignoreStar = false;",
    "right" : "boolean ignoreStar = false;",
    "info" : "VariableDeclarationStatement[48056-48083]:VariableDeclarationStatement[48056-48083]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[48265-50199]:DoStatement[48293-50691]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48268-50185]:Block[48296-50677]"
  }, {
    "left" : "switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Mark the position after the star as the new start of the line.\n          } else {\n            // The star is part of the comment.\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n              // All tokens must be separated by a space.\n\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are ok.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
    "right" : "switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Mark the position after the star as the new start of the line.\n            lineStartChar = stream.getCharno() + 1;\n          } else {\n            // The star is part of the comment.\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          lineStartChar = 0;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          boolean isEOC = token == JsDocToken.EOC;\n          if (!isEOC) {\n            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n              int numSpaces = stream.getCharno() - lineStartChar;\n              for (int i = 0; i < numSpaces; i++) {\n                builder.append(' ');\n              }\n              lineStartChar = -1;\n            } else if (builder.length() > 0) {\n              // All tokens must be separated by a space.\n              builder.append(' ');\n            }\n          }\n\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are ok.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }",
    "info" : "SwitchStatement[48276-50179]:SwitchStatement[48304-50671]"
  }, {
    "left" : "case STAR:",
    "right" : "case STAR:",
    "info" : "SwitchCase[48301-48311]:SwitchCase[48329-48339]"
  }, {
    "left" : "if (ignoreStar)",
    "right" : "if (ignoreStar)",
    "info" : "IfStatement[48322-48619]:IfStatement[48350-48699]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48435-48619]:Block[48515-48699]"
  }, {
    "left" : "if (builder.length() > 0)",
    "right" : "if (builder.length() > 0)",
    "info" : "IfStatement[48497-48573]:IfStatement[48577-48653]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48523-48573]:Block[48603-48653]"
  }, {
    "left" : "builder.append(' ');",
    "right" : "builder.append(' ');",
    "info" : "ExpressionStatement[48539-48559]:ExpressionStatement[48619-48639]"
  }, {
    "left" : "builder.append('*');",
    "right" : "builder.append('*');",
    "info" : "ExpressionStatement[48587-48607]:ExpressionStatement[48667-48687]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[48631-48646]:ExpressionStatement[48711-48726]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[48657-48666]:ContinueStatement[48737-48746]"
  }, {
    "left" : "case EOL:",
    "right" : "case EOL:",
    "info" : "SwitchCase[48676-48685]:SwitchCase[48756-48765]"
  }, {
    "left" : "if (option != WhitespaceOption.SINGLE_LINE)",
    "right" : "if (option != WhitespaceOption.SINGLE_LINE)",
    "info" : "IfStatement[48696-48787]:IfStatement[48776-48867]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48740-48787]:Block[48820-48867]"
  }, {
    "left" : "builder.append(\"\\n\");",
    "right" : "builder.append(\"\\n\");",
    "info" : "ExpressionStatement[48754-48775]:ExpressionStatement[48834-48855]"
  }, {
    "left" : "ignoreStar = true;",
    "right" : "ignoreStar = true;",
    "info" : "ExpressionStatement[48799-48817]:ExpressionStatement[48879-48897]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[48828-48843]:ExpressionStatement[48937-48952]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[48854-48863]:ContinueStatement[48963-48972]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[48873-48881]:SwitchCase[48982-48990]"
  }, {
    "left" : "ignoreStar = false;",
    "right" : "ignoreStar = false;",
    "info" : "ExpressionStatement[48892-48911]:ExpressionStatement[49001-49020]"
  }, {
    "left" : "state = State.SEARCHING_ANNOTATION;",
    "right" : "state = State.SEARCHING_ANNOTATION;",
    "info" : "ExpressionStatement[48922-48957]:ExpressionStatement[49031-49066]"
  }, {
    "left" : "if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are ok.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE))",
    "right" : "if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are ok.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE))",
    "info" : "IfStatement[49028-49835]:IfStatement[49603-50410]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49307-49835]:Block[49882-50410]"
  }, {
    "left" : "String multilineText = builder.toString();",
    "right" : "String multilineText = builder.toString();",
    "info" : "VariableDeclarationStatement[49321-49363]:VariableDeclarationStatement[49896-49938]"
  }, {
    "left" : "if (option != WhitespaceOption.PRESERVE)",
    "right" : "if (option != WhitespaceOption.PRESERVE)",
    "info" : "IfStatement[49377-49485]:IfStatement[49952-50060]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49418-49485]:Block[49993-50060]"
  }, {
    "left" : "multilineText = multilineText.trim();",
    "right" : "multilineText = multilineText.trim();",
    "info" : "ExpressionStatement[49434-49471]:ExpressionStatement[50009-50046]"
  }, {
    "left" : "int endLineno = stream.getLineno();",
    "right" : "int endLineno = stream.getLineno();",
    "info" : "VariableDeclarationStatement[49499-49534]:VariableDeclarationStatement[50074-50109]"
  }, {
    "left" : "int endCharno = stream.getCharno();",
    "right" : "int endCharno = stream.getCharno();",
    "info" : "VariableDeclarationStatement[49547-49582]:VariableDeclarationStatement[50122-50157]"
  }, {
    "left" : "if (multilineText.length() > 0)",
    "right" : "if (multilineText.length() > 0)",
    "info" : "IfStatement[49596-49761]:IfStatement[50171-50336]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49628-49761]:Block[50203-50336]"
  }, {
    "left" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
    "right" : "jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);",
    "info" : "ExpressionStatement[49644-49747]:ExpressionStatement[50219-50322]"
  }, {
    "left" : "return new ExtractionInfo(multilineText, token);",
    "right" : "return new ExtractionInfo(multilineText, token);",
    "info" : "ReturnStatement[49775-49823]:ReturnStatement[50350-50398]"
  }, {
    "left" : "if (builder.length() > 0)",
    "right" : "if (builder.length() > 0)",
    "info" : "IfStatement[49847-49919]:IfStatement[49445-49579]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49873-49919]:Block[49471-49579]"
  }, {
    "left" : "builder.append(' ');",
    "right" : "builder.append(' ');",
    "info" : "ExpressionStatement[49887-49907]:ExpressionStatement[49545-49565]"
  }, {
    "left" : "builder.append(toString(token));",
    "right" : "builder.append(toString(token));",
    "info" : "ExpressionStatement[49930-49962]:ExpressionStatement[50422-50454]"
  }, {
    "left" : "line = stream.getRemainingJSDocLine();",
    "right" : "line = stream.getRemainingJSDocLine();",
    "info" : "ExpressionStatement[49974-50012]:ExpressionStatement[50466-50504]"
  }, {
    "left" : "if (option != WhitespaceOption.PRESERVE)",
    "right" : "if (option != WhitespaceOption.PRESERVE)",
    "info" : "IfStatement[50024-50112]:IfStatement[50516-50604]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50065-50112]:Block[50557-50604]"
  }, {
    "left" : "line = trimEnd(line);",
    "right" : "line = trimEnd(line);",
    "info" : "ExpressionStatement[50079-50100]:ExpressionStatement[50571-50592]"
  }, {
    "left" : "builder.append(line);",
    "right" : "builder.append(line);",
    "info" : "ExpressionStatement[50124-50145]:ExpressionStatement[50616-50637]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[50156-50171]:ExpressionStatement[50648-50663]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[50670-50677]:Modifier[51162-51169]"
  }, {
    "left" : "ExtractionInfo",
    "right" : "ExtractionInfo",
    "info" : "SimpleType[50678-50692]:SimpleType[51170-51184]"
  }, {
    "left" : "extractBlockComment",
    "right" : "extractBlockComment",
    "info" : "SimpleName[50693-50712]:SimpleName[51185-51204]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[50713-50729]:SingleVariableDeclaration[51205-51221]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50731-51705]:Block[51223-52197]"
  }, {
    "left" : "StringBuilder builder = new StringBuilder();",
    "right" : "StringBuilder builder = new StringBuilder();",
    "info" : "VariableDeclarationStatement[50737-50781]:VariableDeclarationStatement[51229-51273]"
  }, {
    "left" : "boolean ignoreStar = true;",
    "right" : "boolean ignoreStar = true;",
    "info" : "VariableDeclarationStatement[50787-50813]:VariableDeclarationStatement[51279-51305]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[50819-51701]:DoStatement[51311-52193]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50822-51687]:Block[51314-52179]"
  }, {
    "left" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
    "right" : "switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }",
    "info" : "SwitchStatement[50830-51681]:SwitchStatement[51322-52173]"
  }, {
    "left" : "case ANNOTATION:",
    "right" : "case ANNOTATION:",
    "info" : "SwitchCase[50855-50871]:SwitchCase[51347-51363]"
  }, {
    "left" : "case EOC:",
    "right" : "case EOC:",
    "info" : "SwitchCase[50880-50889]:SwitchCase[51372-51381]"
  }, {
    "left" : "case EOF:",
    "right" : "case EOF:",
    "info" : "SwitchCase[50898-50907]:SwitchCase[51390-51399]"
  }, {
    "left" : "return new ExtractionInfo(builder.toString().trim(), token);",
    "right" : "return new ExtractionInfo(builder.toString().trim(), token);",
    "info" : "ReturnStatement[50918-50978]:ReturnStatement[51410-51470]"
  }, {
    "left" : "case STAR:",
    "right" : "case STAR:",
    "info" : "SwitchCase[50988-50998]:SwitchCase[51480-51490]"
  }, {
    "left" : "if (!ignoreStar)",
    "right" : "if (!ignoreStar)",
    "info" : "IfStatement[51009-51162]:IfStatement[51501-51654]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[51026-51162]:Block[51518-51654]"
  }, {
    "left" : "if (builder.length() > 0)",
    "right" : "if (builder.length() > 0)",
    "info" : "IfStatement[51040-51116]:IfStatement[51532-51608]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[51066-51116]:Block[51558-51608]"
  }, {
    "left" : "builder.append(' ');",
    "right" : "builder.append(' ');",
    "info" : "ExpressionStatement[51082-51102]:ExpressionStatement[51574-51594]"
  }, {
    "left" : "builder.append('*');",
    "right" : "builder.append('*');",
    "info" : "ExpressionStatement[51130-51150]:ExpressionStatement[51622-51642]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[51174-51189]:ExpressionStatement[51666-51681]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[51200-51209]:ContinueStatement[51692-51701]"
  }, {
    "left" : "case EOL:",
    "right" : "case EOL:",
    "info" : "SwitchCase[51219-51228]:SwitchCase[51711-51720]"
  }, {
    "left" : "ignoreStar = true;",
    "right" : "ignoreStar = true;",
    "info" : "ExpressionStatement[51239-51257]:ExpressionStatement[51731-51749]"
  }, {
    "left" : "builder.append('\\n');",
    "right" : "builder.append('\\n');",
    "info" : "ExpressionStatement[51268-51289]:ExpressionStatement[51760-51781]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[51300-51315]:ExpressionStatement[51792-51807]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[51326-51335]:ContinueStatement[51818-51827]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[51345-51353]:SwitchCase[51837-51845]"
  }, {
    "left" : "if (!ignoreStar && builder.length() > 0)",
    "right" : "if (!ignoreStar && builder.length() > 0)",
    "info" : "IfStatement[51364-51451]:IfStatement[51856-51943]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[51405-51451]:Block[51897-51943]"
  }, {
    "left" : "builder.append(' ');",
    "right" : "builder.append(' ');",
    "info" : "ExpressionStatement[51419-51439]:ExpressionStatement[51911-51931]"
  }, {
    "left" : "ignoreStar = false;",
    "right" : "ignoreStar = false;",
    "info" : "ExpressionStatement[51463-51482]:ExpressionStatement[51955-51974]"
  }, {
    "left" : "builder.append(toString(token));",
    "right" : "builder.append(toString(token));",
    "info" : "ExpressionStatement[51494-51526]:ExpressionStatement[51986-52018]"
  }, {
    "left" : "String line = stream.getRemainingJSDocLine();",
    "right" : "String line = stream.getRemainingJSDocLine();",
    "info" : "VariableDeclarationStatement[51538-51583]:VariableDeclarationStatement[52030-52075]"
  }, {
    "left" : "line = trimEnd(line);",
    "right" : "line = trimEnd(line);",
    "info" : "ExpressionStatement[51594-51615]:ExpressionStatement[52086-52107]"
  }, {
    "left" : "builder.append(line);",
    "right" : "builder.append(line);",
    "info" : "ExpressionStatement[51626-51647]:ExpressionStatement[52118-52139]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[51658-51673]:ExpressionStatement[52150-52165]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[52107-52114]:Modifier[52599-52606]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[52115-52121]:Modifier[52607-52613]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[52122-52128]:SimpleType[52614-52620]"
  }, {
    "left" : "trimEnd",
    "right" : "trimEnd",
    "info" : "SimpleName[52129-52136]:SimpleName[52621-52628]"
  }, {
    "left" : "String s",
    "right" : "String s",
    "info" : "SingleVariableDeclaration[52137-52145]:SingleVariableDeclaration[52629-52637]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52147-52471]:Block[52639-52963]"
  }, {
    "left" : "int trimCount = 0;",
    "right" : "int trimCount = 0;",
    "info" : "VariableDeclarationStatement[52153-52171]:VariableDeclarationStatement[52645-52663]"
  }, {
    "left" : "while (trimCount < s.length())",
    "right" : "while (trimCount < s.length())",
    "info" : "WhileStatement[52176-52367]:WhileStatement[52668-52859]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52207-52367]:Block[52699-52859]"
  }, {
    "left" : "char ch = s.charAt(s.length() - trimCount - 1);",
    "right" : "char ch = s.charAt(s.length() - trimCount - 1);",
    "info" : "VariableDeclarationStatement[52215-52262]:VariableDeclarationStatement[52707-52754]"
  }, {
    "left" : "if (Character.isWhitespace(ch))",
    "right" : "if (Character.isWhitespace(ch))",
    "info" : "IfStatement[52269-52361]:IfStatement[52761-52853]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52301-52331]:Block[52793-52823]"
  }, {
    "left" : "trimCount++;",
    "right" : "trimCount++;",
    "info" : "ExpressionStatement[52311-52323]:ExpressionStatement[52803-52815]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52337-52361]:Block[52829-52853]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[52347-52353]:BreakStatement[52839-52845]"
  }, {
    "left" : "if (trimCount == 0)",
    "right" : "if (trimCount == 0)",
    "info" : "IfStatement[52373-52416]:IfStatement[52865-52908]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52393-52416]:Block[52885-52908]"
  }, {
    "left" : "return s;",
    "right" : "return s;",
    "info" : "ReturnStatement[52401-52410]:ReturnStatement[52893-52902]"
  }, {
    "left" : "return s.substring(0, s.length() - trimCount);",
    "right" : "return s.substring(0, s.length() - trimCount);",
    "info" : "ReturnStatement[52421-52467]:ReturnStatement[52913-52959]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[52993-53000]:Modifier[53485-53492]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[53001-53005]:SimpleType[53493-53497]"
  }, {
    "left" : "parseTypeExpressionAnnotation",
    "right" : "parseTypeExpressionAnnotation",
    "info" : "SimpleName[53006-53035]:SimpleName[53498-53527]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[53036-53052]:SingleVariableDeclaration[53528-53544]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53054-53453]:Block[53546-53945]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[53060-53449]:IfStatement[53552-53941]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53088-53395]:Block[53580-53887]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[53096-53107]:ExpressionStatement[53588-53599]"
  }, {
    "left" : "Node typeNode = parseTopLevelTypeExpression(next());",
    "right" : "Node typeNode = parseTopLevelTypeExpression(next());",
    "info" : "VariableDeclarationStatement[53114-53166]:VariableDeclarationStatement[53606-53658]"
  }, {
    "left" : "if (typeNode != null)",
    "right" : "if (typeNode != null)",
    "info" : "IfStatement[53173-53365]:IfStatement[53665-53857]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53195-53365]:Block[53687-53857]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[53205-53216]:ExpressionStatement[53697-53708]"
  }, {
    "left" : "if (!match(JsDocToken.RC))",
    "right" : "if (!match(JsDocToken.RC))",
    "info" : "IfStatement[53225-53357]:IfStatement[53717-53849]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53252-53322]:Block[53744-53814]"
  }, {
    "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "info" : "ExpressionStatement[53264-53312]:ExpressionStatement[53756-53804]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53328-53357]:Block[53820-53849]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[53340-53347]:ExpressionStatement[53832-53839]"
  }, {
    "left" : "return typeNode;",
    "right" : "return typeNode;",
    "info" : "ReturnStatement[53373-53389]:ReturnStatement[53865-53881]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53401-53449]:Block[53893-53941]"
  }, {
    "left" : "return parseTypeExpression(token);",
    "right" : "return parseTypeExpression(token);",
    "info" : "ReturnStatement[53409-53443]:ReturnStatement[53901-53935]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[53707-53714]:Modifier[54199-54206]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[53715-53719]:SimpleType[54207-54211]"
  }, {
    "left" : "parseParamTypeExpressionAnnotation",
    "right" : "parseParamTypeExpressionAnnotation",
    "info" : "SimpleName[53720-53754]:SimpleName[54212-54246]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[53755-53771]:SingleVariableDeclaration[54247-54263]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53773-54632]:Block[54265-55124]"
  }, {
    "left" : "Preconditions.checkArgument(token == JsDocToken.LC);",
    "right" : "Preconditions.checkArgument(token == JsDocToken.LC);",
    "info" : "ExpressionStatement[53779-53831]:ExpressionStatement[54271-54323]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[53837-53848]:ExpressionStatement[54329-54340]"
  }, {
    "left" : "boolean restArg = false;",
    "right" : "boolean restArg = false;",
    "info" : "VariableDeclarationStatement[53854-53878]:VariableDeclarationStatement[54346-54370]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[53883-53898]:ExpressionStatement[54375-54390]"
  }, {
    "left" : "if (token == JsDocToken.ELLIPSIS)",
    "right" : "if (token == JsDocToken.ELLIPSIS)",
    "info" : "IfStatement[53903-54147]:IfStatement[54395-54639]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53937-54147]:Block[54429-54639]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[53945-53960]:ExpressionStatement[54437-54452]"
  }, {
    "left" : "if (token == JsDocToken.RC)",
    "right" : "if (token == JsDocToken.RC)",
    "info" : "IfStatement[53967-54119]:IfStatement[54459-54611]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53995-54119]:Block[54487-54611]"
  }, {
    "left" : "return wrapNode(Token.ELLIPSIS, IR.empty());",
    "right" : "return wrapNode(Token.ELLIPSIS, IR.empty());",
    "info" : "ReturnStatement[54067-54111]:ReturnStatement[54559-54603]"
  }, {
    "left" : "restArg = true;",
    "right" : "restArg = true;",
    "info" : "ExpressionStatement[54126-54141]:ExpressionStatement[54618-54633]"
  }, {
    "left" : "Node typeNode = parseTopLevelTypeExpression(token);",
    "right" : "Node typeNode = parseTopLevelTypeExpression(token);",
    "info" : "VariableDeclarationStatement[54153-54204]:VariableDeclarationStatement[54645-54696]"
  }, {
    "left" : "if (typeNode != null)",
    "right" : "if (typeNode != null)",
    "info" : "IfStatement[54209-54606]:IfStatement[54701-55098]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54231-54606]:Block[54723-55098]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[54239-54250]:ExpressionStatement[54731-54742]"
  }, {
    "left" : "if (restArg)",
    "right" : "if (restArg)",
    "info" : "IfStatement[54257-54468]:IfStatement[54749-54960]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54270-54334]:Block[54762-54826]"
  }, {
    "left" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
    "right" : "typeNode = wrapNode(Token.ELLIPSIS, typeNode);",
    "info" : "ExpressionStatement[54280-54326]:ExpressionStatement[54772-54818]"
  }, {
    "left" : "if (match(JsDocToken.EQUALS))",
    "right" : "if (match(JsDocToken.EQUALS))",
    "info" : "IfStatement[54340-54468]:IfStatement[54832-54960]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54370-54468]:Block[54862-54960]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[54380-54387]:ExpressionStatement[54872-54879]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[54396-54407]:ExpressionStatement[54888-54899]"
  }, {
    "left" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
    "right" : "typeNode = wrapNode(Token.EQUALS, typeNode);",
    "info" : "ExpressionStatement[54416-54460]:ExpressionStatement[54908-54952]"
  }, {
    "left" : "if (!match(JsDocToken.RC))",
    "right" : "if (!match(JsDocToken.RC))",
    "info" : "IfStatement[54476-54600]:IfStatement[54968-55092]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54503-54569]:Block[54995-55061]"
  }, {
    "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "info" : "ExpressionStatement[54513-54561]:ExpressionStatement[55005-55053]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54575-54600]:Block[55067-55092]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[54585-54592]:ExpressionStatement[55077-55084]"
  }, {
    "left" : "return typeNode;",
    "right" : "return typeNode;",
    "info" : "ReturnStatement[54612-54628]:ReturnStatement[55104-55120]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[54703-54710]:Modifier[55195-55202]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[54711-54715]:SimpleType[55203-55207]"
  }, {
    "left" : "parseTypeNameAnnotation",
    "right" : "parseTypeNameAnnotation",
    "info" : "SimpleName[54716-54739]:SimpleName[55208-55231]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[54740-54756]:SingleVariableDeclaration[55232-55248]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54758-55137]:Block[55250-55629]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[54764-55133]:IfStatement[55256-55625]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54792-55085]:Block[55284-55577]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[54800-54811]:ExpressionStatement[55292-55303]"
  }, {
    "left" : "Node typeNode = parseTypeName(next());",
    "right" : "Node typeNode = parseTypeName(next());",
    "info" : "VariableDeclarationStatement[54818-54856]:VariableDeclarationStatement[55310-55348]"
  }, {
    "left" : "if (typeNode != null)",
    "right" : "if (typeNode != null)",
    "info" : "IfStatement[54863-55055]:IfStatement[55355-55547]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54885-55055]:Block[55377-55547]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[54895-54906]:ExpressionStatement[55387-55398]"
  }, {
    "left" : "if (!match(JsDocToken.RC))",
    "right" : "if (!match(JsDocToken.RC))",
    "info" : "IfStatement[54915-55047]:IfStatement[55407-55539]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54942-55012]:Block[55434-55504]"
  }, {
    "left" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "right" : "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "info" : "ExpressionStatement[54954-55002]:ExpressionStatement[55446-55494]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55018-55047]:Block[55510-55539]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[55030-55037]:ExpressionStatement[55522-55529]"
  }, {
    "left" : "return typeNode;",
    "right" : "return typeNode;",
    "info" : "ReturnStatement[55063-55079]:ReturnStatement[55555-55571]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55091-55133]:Block[55583-55625]"
  }, {
    "left" : "return parseTypeName(token);",
    "right" : "return parseTypeName(token);",
    "info" : "ReturnStatement[55099-55127]:ReturnStatement[55591-55619]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[55297-55304]:Modifier[55789-55796]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[55305-55309]:SimpleType[55797-55801]"
  }, {
    "left" : "parseTopLevelTypeExpression",
    "right" : "parseTopLevelTypeExpression",
    "info" : "SimpleName[55310-55337]:SimpleName[55802-55829]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[55338-55354]:SingleVariableDeclaration[55830-55846]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55356-55799]:Block[55848-56291]"
  }, {
    "left" : "Node typeExpr = parseTypeExpression(token);",
    "right" : "Node typeExpr = parseTypeExpression(token);",
    "info" : "VariableDeclarationStatement[55362-55405]:VariableDeclarationStatement[55854-55897]"
  }, {
    "left" : "if (typeExpr != null)",
    "right" : "if (typeExpr != null)",
    "info" : "IfStatement[55410-55774]:IfStatement[55902-56266]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55432-55774]:Block[55924-56266]"
  }, {
    "left" : "if (match(JsDocToken.PIPE))",
    "right" : "if (match(JsDocToken.PIPE))",
    "info" : "IfStatement[55478-55768]:IfStatement[55970-56260]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55506-55768]:Block[55998-56260]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[55516-55523]:ExpressionStatement[56008-56015]"
  }, {
    "left" : "if (match(JsDocToken.PIPE))",
    "right" : "if (match(JsDocToken.PIPE))",
    "info" : "IfStatement[55532-55655]:IfStatement[56024-56147]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55560-55655]:Block[56052-56147]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[55638-55645]:ExpressionStatement[56130-56137]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[55664-55675]:ExpressionStatement[56156-56167]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[55684-55699]:ExpressionStatement[56176-56191]"
  }, {
    "left" : "return parseUnionTypeWithAlternate(token, typeExpr);",
    "right" : "return parseUnionTypeWithAlternate(token, typeExpr);",
    "info" : "ReturnStatement[55708-55760]:ReturnStatement[56200-56252]"
  }, {
    "left" : "return typeExpr;",
    "right" : "return typeExpr;",
    "info" : "ReturnStatement[55779-55795]:ReturnStatement[56271-56287]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[55922-55929]:Modifier[56414-56421]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[55930-55934]:SimpleType[56422-56426]"
  }, {
    "left" : "parseTypeExpressionList",
    "right" : "parseTypeExpressionList",
    "info" : "SimpleName[55935-55958]:SimpleName[56427-56450]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[55959-55975]:SingleVariableDeclaration[56451-56467]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55977-56413]:Block[56469-56905]"
  }, {
    "left" : "Node typeExpr = parseTopLevelTypeExpression(token);",
    "right" : "Node typeExpr = parseTopLevelTypeExpression(token);",
    "info" : "VariableDeclarationStatement[55983-56034]:VariableDeclarationStatement[56475-56526]"
  }, {
    "left" : "if (typeExpr == null)",
    "right" : "if (typeExpr == null)",
    "info" : "IfStatement[56039-56087]:IfStatement[56531-56579]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56061-56087]:Block[56553-56579]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[56069-56081]:ReturnStatement[56561-56573]"
  }, {
    "left" : "Node typeList = IR.block();",
    "right" : "Node typeList = IR.block();",
    "info" : "VariableDeclarationStatement[56092-56119]:VariableDeclarationStatement[56584-56611]"
  }, {
    "left" : "typeList.addChildToBack(typeExpr);",
    "right" : "typeList.addChildToBack(typeExpr);",
    "info" : "ExpressionStatement[56124-56158]:ExpressionStatement[56616-56650]"
  }, {
    "left" : "while (match(JsDocToken.COMMA))",
    "right" : "while (match(JsDocToken.COMMA))",
    "info" : "WhileStatement[56163-56388]:WhileStatement[56655-56880]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56195-56388]:Block[56687-56880]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[56203-56210]:ExpressionStatement[56695-56702]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[56217-56228]:ExpressionStatement[56709-56720]"
  }, {
    "left" : "typeExpr = parseTopLevelTypeExpression(next());",
    "right" : "typeExpr = parseTopLevelTypeExpression(next());",
    "info" : "ExpressionStatement[56235-56282]:ExpressionStatement[56727-56774]"
  }, {
    "left" : "if (typeExpr == null)",
    "right" : "if (typeExpr == null)",
    "info" : "IfStatement[56289-56341]:IfStatement[56781-56833]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56311-56341]:Block[56803-56833]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[56321-56333]:ReturnStatement[56813-56825]"
  }, {
    "left" : "typeList.addChildToBack(typeExpr);",
    "right" : "typeList.addChildToBack(typeExpr);",
    "info" : "ExpressionStatement[56348-56382]:ExpressionStatement[56840-56874]"
  }, {
    "left" : "return typeList;",
    "right" : "return typeList;",
    "info" : "ReturnStatement[56393-56409]:ReturnStatement[56885-56901]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[56627-56634]:Modifier[57119-57126]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[56635-56639]:SimpleType[57127-57131]"
  }, {
    "left" : "parseTypeExpression",
    "right" : "parseTypeExpression",
    "info" : "SimpleName[56640-56659]:SimpleName[57132-57151]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[56660-56676]:SingleVariableDeclaration[57152-57168]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56678-58159]:Block[57170-58651]"
  }, {
    "left" : "if (token == JsDocToken.QMARK)",
    "right" : "if (token == JsDocToken.QMARK)",
    "info" : "IfStatement[56684-58155]:IfStatement[57176-58647]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56715-57659]:Block[57207-58151]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[57265-57280]:ExpressionStatement[57757-57772]"
  }, {
    "left" : "if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE)",
    "right" : "if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE)",
    "info" : "IfStatement[57287-57583]:IfStatement[57779-58075]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57504-57583]:Block[57996-58075]"
  }, {
    "left" : "restoreLookAhead(token);",
    "right" : "restoreLookAhead(token);",
    "info" : "ExpressionStatement[57514-57538]:ExpressionStatement[58006-58030]"
  }, {
    "left" : "return newNode(Token.QMARK);",
    "right" : "return newNode(Token.QMARK);",
    "info" : "ReturnStatement[57547-57575]:ReturnStatement[58039-58067]"
  }, {
    "left" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(token));",
    "right" : "return wrapNode(Token.QMARK, parseBasicTypeExpression(token));",
    "info" : "ReturnStatement[57591-57653]:ReturnStatement[58083-58145]"
  }, {
    "left" : "if (token == JsDocToken.BANG)",
    "right" : "if (token == JsDocToken.BANG)",
    "info" : "IfStatement[57665-58155]:IfStatement[58157-58647]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57695-57771]:Block[58187-58263]"
  }, {
    "left" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
    "right" : "return wrapNode(Token.BANG, parseBasicTypeExpression(next()));",
    "info" : "ReturnStatement[57703-57765]:ReturnStatement[58195-58257]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57777-58155]:Block[58269-58647]"
  }, {
    "left" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
    "right" : "Node basicTypeExpr = parseBasicTypeExpression(token);",
    "info" : "VariableDeclarationStatement[57785-57838]:VariableDeclarationStatement[58277-58330]"
  }, {
    "left" : "if (basicTypeExpr != null)",
    "right" : "if (basicTypeExpr != null)",
    "info" : "IfStatement[57845-58120]:IfStatement[58337-58612]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57872-58120]:Block[58364-58612]"
  }, {
    "left" : "if (match(JsDocToken.QMARK))",
    "right" : "if (match(JsDocToken.QMARK))",
    "info" : "IfStatement[57882-58112]:IfStatement[58374-58604]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57911-57995]:Block[58403-58487]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[57923-57930]:ExpressionStatement[58415-58422]"
  }, {
    "left" : "return wrapNode(Token.QMARK, basicTypeExpr);",
    "right" : "return wrapNode(Token.QMARK, basicTypeExpr);",
    "info" : "ReturnStatement[57941-57985]:ReturnStatement[58433-58477]"
  }, {
    "left" : "if (match(JsDocToken.BANG))",
    "right" : "if (match(JsDocToken.BANG))",
    "info" : "IfStatement[58001-58112]:IfStatement[58493-58604]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58029-58112]:Block[58521-58604]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[58041-58048]:ExpressionStatement[58533-58540]"
  }, {
    "left" : "return wrapNode(Token.BANG, basicTypeExpr);",
    "right" : "return wrapNode(Token.BANG, basicTypeExpr);",
    "info" : "ReturnStatement[58059-58102]:ReturnStatement[58551-58594]"
  }, {
    "left" : "return basicTypeExpr;",
    "right" : "return basicTypeExpr;",
    "info" : "ReturnStatement[58128-58149]:ReturnStatement[58620-58641]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[58302-58309]:Modifier[58794-58801]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[58310-58314]:SimpleType[58802-58806]"
  }, {
    "left" : "parseBasicTypeExpression",
    "right" : "parseBasicTypeExpression",
    "info" : "SimpleName[58315-58339]:SimpleName[58807-58831]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[58340-58356]:SingleVariableDeclaration[58832-58848]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58358-59161]:Block[58850-59653]"
  }, {
    "left" : "if (token == JsDocToken.STAR)",
    "right" : "if (token == JsDocToken.STAR)",
    "info" : "IfStatement[58364-59082]:IfStatement[58856-59574]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58394-58435]:Block[58886-58927]"
  }, {
    "left" : "return newNode(Token.STAR);",
    "right" : "return newNode(Token.STAR);",
    "info" : "ReturnStatement[58402-58429]:ReturnStatement[58894-58921]"
  }, {
    "left" : "if (token == JsDocToken.LB)",
    "right" : "if (token == JsDocToken.LB)",
    "info" : "IfStatement[58441-59082]:IfStatement[58933-59574]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58469-58531]:Block[58961-59023]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[58477-58488]:ExpressionStatement[58969-58980]"
  }, {
    "left" : "return parseArrayType(next());",
    "right" : "return parseArrayType(next());",
    "info" : "ReturnStatement[58495-58525]:ReturnStatement[58987-59017]"
  }, {
    "left" : "if (token == JsDocToken.LC)",
    "right" : "if (token == JsDocToken.LC)",
    "info" : "IfStatement[58537-59082]:IfStatement[59029-59574]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58565-58628]:Block[59057-59120]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[58573-58584]:ExpressionStatement[59065-59076]"
  }, {
    "left" : "return parseRecordType(next());",
    "right" : "return parseRecordType(next());",
    "info" : "ReturnStatement[58591-58622]:ReturnStatement[59083-59114]"
  }, {
    "left" : "if (token == JsDocToken.LP)",
    "right" : "if (token == JsDocToken.LP)",
    "info" : "IfStatement[58634-59082]:IfStatement[59126-59574]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58662-58724]:Block[59154-59216]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[58670-58681]:ExpressionStatement[59162-59173]"
  }, {
    "left" : "return parseUnionType(next());",
    "right" : "return parseUnionType(next());",
    "info" : "ReturnStatement[58688-58718]:ReturnStatement[59180-59210]"
  }, {
    "left" : "if (token == JsDocToken.STRING)",
    "right" : "if (token == JsDocToken.STRING)",
    "info" : "IfStatement[58730-59082]:IfStatement[59222-59574]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58762-59082]:Block[59254-59574]"
  }, {
    "left" : "String string = stream.getString();",
    "right" : "String string = stream.getString();",
    "info" : "VariableDeclarationStatement[58770-58805]:VariableDeclarationStatement[59262-59297]"
  }, {
    "left" : "if (\"function\".equals(string))",
    "right" : "if (\"function\".equals(string))",
    "info" : "IfStatement[58812-59076]:IfStatement[59304-59568]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58843-58914]:Block[59335-59406]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[58853-58864]:ExpressionStatement[59345-59356]"
  }, {
    "left" : "return parseFunctionType(next());",
    "right" : "return parseFunctionType(next());",
    "info" : "ReturnStatement[58873-58906]:ReturnStatement[59365-59398]"
  }, {
    "left" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
    "right" : "if (\"null\".equals(string) || \"undefined\".equals(string))",
    "info" : "IfStatement[58920-59076]:IfStatement[59412-59568]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[58977-59024]:Block[59469-59516]"
  }, {
    "left" : "return newStringNode(string);",
    "right" : "return newStringNode(string);",
    "info" : "ReturnStatement[58987-59016]:ReturnStatement[59479-59508]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59030-59076]:Block[59522-59568]"
  }, {
    "left" : "return parseTypeName(token);",
    "right" : "return parseTypeName(token);",
    "info" : "ReturnStatement[59040-59068]:ReturnStatement[59532-59560]"
  }, {
    "left" : "restoreLookAhead(token);",
    "right" : "restoreLookAhead(token);",
    "info" : "ExpressionStatement[59088-59112]:ExpressionStatement[59580-59604]"
  }, {
    "left" : "return reportGenericTypeSyntaxWarning();",
    "right" : "return reportGenericTypeSyntaxWarning();",
    "info" : "ReturnStatement[59117-59157]:ReturnStatement[59609-59649]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[59351-59358]:Modifier[59843-59850]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[59359-59363]:SimpleType[59851-59855]"
  }, {
    "left" : "parseTypeName",
    "right" : "parseTypeName",
    "info" : "SimpleName[59364-59377]:SimpleName[59856-59869]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[59378-59394]:SingleVariableDeclaration[59870-59886]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59396-60288]:Block[59888-60780]"
  }, {
    "left" : "if (token != JsDocToken.STRING)",
    "right" : "if (token != JsDocToken.STRING)",
    "info" : "IfStatement[59402-59488]:IfStatement[59894-59980]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59434-59488]:Block[59926-59980]"
  }, {
    "left" : "return reportGenericTypeSyntaxWarning();",
    "right" : "return reportGenericTypeSyntaxWarning();",
    "info" : "ReturnStatement[59442-59482]:ReturnStatement[59934-59974]"
  }, {
    "left" : "String typeName = stream.getString();",
    "right" : "String typeName = stream.getString();",
    "info" : "VariableDeclarationStatement[59494-59531]:VariableDeclarationStatement[59986-60023]"
  }, {
    "left" : "int lineno = stream.getLineno();",
    "right" : "int lineno = stream.getLineno();",
    "info" : "VariableDeclarationStatement[59536-59568]:VariableDeclarationStatement[60028-60060]"
  }, {
    "left" : "int charno = stream.getCharno();",
    "right" : "int charno = stream.getCharno();",
    "info" : "VariableDeclarationStatement[59573-59605]:VariableDeclarationStatement[60065-60097]"
  }, {
    "left" : "while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.')",
    "right" : "while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.')",
    "info" : "WhileStatement[59610-59824]:WhileStatement[60102-60316]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59697-59824]:Block[60189-60316]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[59705-59716]:ExpressionStatement[60197-60208]"
  }, {
    "left" : "if (match(JsDocToken.STRING))",
    "right" : "if (match(JsDocToken.STRING))",
    "info" : "IfStatement[59723-59818]:IfStatement[60215-60310]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59753-59818]:Block[60245-60310]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[59763-59770]:ExpressionStatement[60255-60262]"
  }, {
    "left" : "typeName += stream.getString();",
    "right" : "typeName += stream.getString();",
    "info" : "ExpressionStatement[59779-59810]:ExpressionStatement[60271-60302]"
  }, {
    "left" : "Node typeNameNode = newStringNode(typeName, lineno, charno);",
    "right" : "Node typeNameNode = newStringNode(typeName, lineno, charno);",
    "info" : "VariableDeclarationStatement[59830-59890]:VariableDeclarationStatement[60322-60382]"
  }, {
    "left" : "if (match(JsDocToken.LT))",
    "right" : "if (match(JsDocToken.LT))",
    "info" : "IfStatement[59896-60259]:IfStatement[60388-60751]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59922-60259]:Block[60414-60751]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[59930-59937]:ExpressionStatement[60422-60429]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[59944-59955]:ExpressionStatement[60436-60447]"
  }, {
    "left" : "Node memberType = parseTypeExpressionList(next());",
    "right" : "Node memberType = parseTypeExpressionList(next());",
    "info" : "VariableDeclarationStatement[59962-60012]:VariableDeclarationStatement[60454-60504]"
  }, {
    "left" : "if (memberType != null)",
    "right" : "if (memberType != null)",
    "info" : "IfStatement[60019-60253]:IfStatement[60511-60745]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60043-60253]:Block[60535-60745]"
  }, {
    "left" : "typeNameNode.addChildToFront(memberType);",
    "right" : "typeNameNode.addChildToFront(memberType);",
    "info" : "ExpressionStatement[60053-60094]:ExpressionStatement[60545-60586]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[60104-60115]:ExpressionStatement[60596-60607]"
  }, {
    "left" : "if (!match(JsDocToken.GT))",
    "right" : "if (!match(JsDocToken.GT))",
    "info" : "IfStatement[60124-60228]:IfStatement[60616-60720]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60151-60228]:Block[60643-60720]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");",
    "info" : "ReturnStatement[60163-60218]:ReturnStatement[60655-60710]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[60238-60245]:ExpressionStatement[60730-60737]"
  }, {
    "left" : "return typeNameNode;",
    "right" : "return typeNameNode;",
    "info" : "ReturnStatement[60264-60284]:ReturnStatement[60756-60776]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[60466-60473]:Modifier[60958-60965]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[60474-60478]:SimpleType[60966-60970]"
  }, {
    "left" : "parseFunctionType",
    "right" : "parseFunctionType",
    "info" : "SimpleName[60479-60496]:SimpleName[60971-60988]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[60497-60513]:SingleVariableDeclaration[60989-61005]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60515-62370]:Block[61007-62862]"
  }, {
    "left" : "if (token != JsDocToken.LP)",
    "right" : "if (token != JsDocToken.LP)",
    "info" : "IfStatement[60634-60762]:IfStatement[61126-61254]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60662-60762]:Block[61154-61254]"
  }, {
    "left" : "restoreLookAhead(token);",
    "right" : "restoreLookAhead(token);",
    "info" : "ExpressionStatement[60670-60694]:ExpressionStatement[61162-61186]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");",
    "info" : "ReturnStatement[60701-60756]:ReturnStatement[61193-61248]"
  }, {
    "left" : "Node functionType = newNode(Token.FUNCTION);",
    "right" : "Node functionType = newNode(Token.FUNCTION);",
    "info" : "VariableDeclarationStatement[60768-60812]:VariableDeclarationStatement[61260-61304]"
  }, {
    "left" : "Node parameters = null;",
    "right" : "Node parameters = null;",
    "info" : "VariableDeclarationStatement[60817-60840]:VariableDeclarationStatement[61309-61332]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[60845-60856]:ExpressionStatement[61337-61348]"
  }, {
    "left" : "if (!match(JsDocToken.RP))",
    "right" : "if (!match(JsDocToken.RP))",
    "info" : "IfStatement[60861-61960]:IfStatement[61353-62452]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60888-61960]:Block[61380-62452]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[60896-60911]:ExpressionStatement[61388-61403]"
  }, {
    "left" : "boolean hasParams = true;",
    "right" : "boolean hasParams = true;",
    "info" : "VariableDeclarationStatement[60919-60944]:VariableDeclarationStatement[61411-61436]"
  }, {
    "left" : "if (token == JsDocToken.STRING)",
    "right" : "if (token == JsDocToken.STRING)",
    "info" : "IfStatement[60951-61806]:IfStatement[61443-62298]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60983-61806]:Block[61475-62298]"
  }, {
    "left" : "String tokenStr = stream.getString();",
    "right" : "String tokenStr = stream.getString();",
    "info" : "VariableDeclarationStatement[60993-61030]:VariableDeclarationStatement[61485-61522]"
  }, {
    "left" : "boolean isThis = \"this\".equals(tokenStr);",
    "right" : "boolean isThis = \"this\".equals(tokenStr);",
    "info" : "VariableDeclarationStatement[61039-61080]:VariableDeclarationStatement[61531-61572]"
  }, {
    "left" : "boolean isNew = \"new\".equals(tokenStr);",
    "right" : "boolean isNew = \"new\".equals(tokenStr);",
    "info" : "VariableDeclarationStatement[61089-61128]:VariableDeclarationStatement[61581-61620]"
  }, {
    "left" : "if (isThis || isNew)",
    "right" : "if (isThis || isNew)",
    "info" : "IfStatement[61137-61798]:IfStatement[61629-62290]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61158-61798]:Block[61650-62290]"
  }, {
    "left" : "if (match(JsDocToken.COLON))",
    "right" : "if (match(JsDocToken.COLON))",
    "info" : "IfStatement[61170-61612]:IfStatement[61662-62104]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61199-61522]:Block[61691-62014]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[61213-61220]:ExpressionStatement[61705-61712]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[61233-61244]:ExpressionStatement[61725-61736]"
  }, {
    "left" : "Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));",
    "right" : "Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));",
    "info" : "VariableDeclarationStatement[61257-61374]:VariableDeclarationStatement[61749-61866]"
  }, {
    "left" : "if (contextType == null)",
    "right" : "if (contextType == null)",
    "info" : "IfStatement[61387-61454]:IfStatement[61879-61946]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61412-61454]:Block[61904-61946]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[61428-61440]:ReturnStatement[61920-61932]"
  }, {
    "left" : "functionType.addChildToFront(contextType);",
    "right" : "functionType.addChildToFront(contextType);",
    "info" : "ExpressionStatement[61468-61510]:ExpressionStatement[61960-62002]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61528-61612]:Block[62020-62104]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");",
    "info" : "ReturnStatement[61542-61600]:ReturnStatement[62034-62092]"
  }, {
    "left" : "if (match(JsDocToken.COMMA))",
    "right" : "if (match(JsDocToken.COMMA))",
    "info" : "IfStatement[61624-61788]:IfStatement[62116-62280]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61653-61738]:Block[62145-62230]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[61667-61674]:ExpressionStatement[62159-62166]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[61687-61698]:ExpressionStatement[62179-62190]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[61711-61726]:ExpressionStatement[62203-62218]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61744-61788]:Block[62236-62280]"
  }, {
    "left" : "hasParams = false;",
    "right" : "hasParams = false;",
    "info" : "ExpressionStatement[61758-61776]:ExpressionStatement[62250-62268]"
  }, {
    "left" : "if (hasParams)",
    "right" : "if (hasParams)",
    "info" : "IfStatement[61814-61954]:IfStatement[62306-62446]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61829-61954]:Block[62321-62446]"
  }, {
    "left" : "parameters = parseParametersType(token);",
    "right" : "parameters = parseParametersType(token);",
    "info" : "ExpressionStatement[61839-61879]:ExpressionStatement[62331-62371]"
  }, {
    "left" : "if (parameters == null)",
    "right" : "if (parameters == null)",
    "info" : "IfStatement[61888-61946]:IfStatement[62380-62438]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61912-61946]:Block[62404-62438]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[61924-61936]:ReturnStatement[62416-62428]"
  }, {
    "left" : "if (parameters != null)",
    "right" : "if (parameters != null)",
    "info" : "IfStatement[61966-62044]:IfStatement[62458-62536]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61990-62044]:Block[62482-62536]"
  }, {
    "left" : "functionType.addChildToBack(parameters);",
    "right" : "functionType.addChildToBack(parameters);",
    "info" : "ExpressionStatement[61998-62038]:ExpressionStatement[62490-62530]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[62050-62061]:ExpressionStatement[62542-62553]"
  }, {
    "left" : "if (!match(JsDocToken.RP))",
    "right" : "if (!match(JsDocToken.RP))",
    "info" : "IfStatement[62066-62162]:IfStatement[62558-62654]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62093-62162]:Block[62585-62654]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
    "info" : "ReturnStatement[62101-62156]:ReturnStatement[62593-62648]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[62168-62179]:ExpressionStatement[62660-62671]"
  }, {
    "left" : "Node resultType = parseResultType(next());",
    "right" : "Node resultType = parseResultType(next());",
    "info" : "VariableDeclarationStatement[62184-62226]:VariableDeclarationStatement[62676-62718]"
  }, {
    "left" : "if (resultType == null)",
    "right" : "if (resultType == null)",
    "info" : "IfStatement[62231-62341]:IfStatement[62723-62833]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62255-62281]:Block[62747-62773]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[62263-62275]:ReturnStatement[62755-62767]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62287-62341]:Block[62779-62833]"
  }, {
    "left" : "functionType.addChildToBack(resultType);",
    "right" : "functionType.addChildToBack(resultType);",
    "info" : "ExpressionStatement[62295-62335]:ExpressionStatement[62787-62827]"
  }, {
    "left" : "return functionType;",
    "right" : "return functionType;",
    "info" : "ReturnStatement[62346-62366]:ReturnStatement[62838-62858]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[63565-63572]:Modifier[64057-64064]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[63573-63577]:SimpleType[64065-64069]"
  }, {
    "left" : "parseParametersType",
    "right" : "parseParametersType",
    "info" : "SimpleName[63578-63597]:SimpleName[64070-64089]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[63598-63614]:SingleVariableDeclaration[64090-64106]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63616-65469]:Block[64108-65961]"
  }, {
    "left" : "Node paramsType = newNode(Token.PARAM_LIST);",
    "right" : "Node paramsType = newNode(Token.PARAM_LIST);",
    "info" : "VariableDeclarationStatement[63622-63666]:VariableDeclarationStatement[64114-64158]"
  }, {
    "left" : "boolean isVarArgs = false;",
    "right" : "boolean isVarArgs = false;",
    "info" : "VariableDeclarationStatement[63671-63697]:VariableDeclarationStatement[64163-64189]"
  }, {
    "left" : "Node paramType = null;",
    "right" : "Node paramType = null;",
    "info" : "VariableDeclarationStatement[63702-63724]:VariableDeclarationStatement[64194-64216]"
  }, {
    "left" : "if (token != JsDocToken.RP)",
    "right" : "if (token != JsDocToken.RP)",
    "info" : "IfStatement[63729-65257]:IfStatement[64221-65749]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63757-65257]:Block[64249-65749]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[63765-65251]:DoStatement[64257-65743]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63768-65218]:Block[64260-65710]"
  }, {
    "left" : "if (paramType != null)",
    "right" : "if (paramType != null)",
    "info" : "IfStatement[63778-63911]:IfStatement[64270-64403]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63801-63911]:Block[64293-64403]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[63846-63853]:ExpressionStatement[64338-64345]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[63864-63875]:ExpressionStatement[64356-64367]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[63886-63901]:ExpressionStatement[64378-64393]"
  }, {
    "left" : "if (token == JsDocToken.ELLIPSIS)",
    "right" : "if (token == JsDocToken.ELLIPSIS)",
    "info" : "IfStatement[63921-65045]:IfStatement[64413-65537]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63955-64821]:Block[64447-65313]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[64187-64198]:ExpressionStatement[64679-64690]"
  }, {
    "left" : "if (match(JsDocToken.RP))",
    "right" : "if (match(JsDocToken.RP))",
    "info" : "IfStatement[64209-64782]:IfStatement[64701-65274]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64235-64297]:Block[64727-64789]"
  }, {
    "left" : "paramType = newNode(Token.ELLIPSIS);",
    "right" : "paramType = newNode(Token.ELLIPSIS);",
    "info" : "ExpressionStatement[64249-64285]:ExpressionStatement[64741-64777]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64303-64782]:Block[64795-65274]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[64317-64328]:ExpressionStatement[64809-64820]"
  }, {
    "left" : "if (!match(JsDocToken.LB))",
    "right" : "if (!match(JsDocToken.LB))",
    "info" : "IfStatement[64341-64453]:IfStatement[64833-64945]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64368-64453]:Block[64860-64945]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");",
    "info" : "ReturnStatement[64384-64439]:ReturnStatement[64876-64931]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[64467-64474]:ExpressionStatement[64959-64966]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[64487-64498]:ExpressionStatement[64979-64990]"
  }, {
    "left" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
    "right" : "paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
    "info" : "ExpressionStatement[64511-64577]:ExpressionStatement[65003-65069]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[64590-64601]:ExpressionStatement[65082-65093]"
  }, {
    "left" : "if (!match(JsDocToken.RB))",
    "right" : "if (!match(JsDocToken.RB))",
    "info" : "IfStatement[64614-64726]:IfStatement[65106-65218]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64641-64726]:Block[65133-65218]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
    "info" : "ReturnStatement[64657-64712]:ReturnStatement[65149-65204]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[64739-64750]:ExpressionStatement[65231-65242]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[64763-64770]:ExpressionStatement[65255-65262]"
  }, {
    "left" : "isVarArgs = true;",
    "right" : "isVarArgs = true;",
    "info" : "ExpressionStatement[64794-64811]:ExpressionStatement[65286-65303]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64827-65045]:Block[65319-65537]"
  }, {
    "left" : "paramType = parseTypeExpression(token);",
    "right" : "paramType = parseTypeExpression(token);",
    "info" : "ExpressionStatement[64839-64878]:ExpressionStatement[65331-65370]"
  }, {
    "left" : "if (match(JsDocToken.EQUALS))",
    "right" : "if (match(JsDocToken.EQUALS))",
    "info" : "IfStatement[64889-65035]:IfStatement[65381-65527]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64919-65035]:Block[65411-65527]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[64933-64944]:ExpressionStatement[65425-65436]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[64957-64964]:ExpressionStatement[65449-65456]"
  }, {
    "left" : "paramType = wrapNode(Token.EQUALS, paramType);",
    "right" : "paramType = wrapNode(Token.EQUALS, paramType);",
    "info" : "ExpressionStatement[64977-65023]:ExpressionStatement[65469-65515]"
  }, {
    "left" : "if (paramType == null)",
    "right" : "if (paramType == null)",
    "info" : "IfStatement[65055-65112]:IfStatement[65547-65604]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65078-65112]:Block[65570-65604]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[65090-65102]:ReturnStatement[65582-65594]"
  }, {
    "left" : "paramsType.addChildToBack(paramType);",
    "right" : "paramsType.addChildToBack(paramType);",
    "info" : "ExpressionStatement[65121-65158]:ExpressionStatement[65613-65650]"
  }, {
    "left" : "if (isVarArgs)",
    "right" : "if (isVarArgs)",
    "info" : "IfStatement[65167-65210]:IfStatement[65659-65702]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65182-65210]:Block[65674-65702]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[65194-65200]:BreakStatement[65686-65692]"
  }, {
    "left" : "if (isVarArgs && match(JsDocToken.COMMA))",
    "right" : "if (isVarArgs && match(JsDocToken.COMMA))",
    "info" : "IfStatement[65263-65380]:IfStatement[65755-65872]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65305-65380]:Block[65797-65872]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");",
    "info" : "ReturnStatement[65313-65374]:ReturnStatement[65805-65866]"
  }, {
    "left" : "return paramsType;",
    "right" : "return paramsType;",
    "info" : "ReturnStatement[65447-65465]:ReturnStatement[65939-65957]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[65544-65551]:Modifier[66036-66043]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[65552-65556]:SimpleType[66044-66048]"
  }, {
    "left" : "parseResultType",
    "right" : "parseResultType",
    "info" : "SimpleName[65557-65572]:SimpleName[66049-66064]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[65573-65589]:SingleVariableDeclaration[66065-66081]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65591-65908]:Block[66083-66400]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[65597-65608]:ExpressionStatement[66089-66100]"
  }, {
    "left" : "if (!match(JsDocToken.COLON))",
    "right" : "if (!match(JsDocToken.COLON))",
    "info" : "IfStatement[65613-65685]:IfStatement[66105-66177]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65643-65685]:Block[66135-66177]"
  }, {
    "left" : "return newNode(Token.EMPTY);",
    "right" : "return newNode(Token.EMPTY);",
    "info" : "ReturnStatement[65651-65679]:ReturnStatement[66143-66171]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[65691-65706]:ExpressionStatement[66183-66198]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[65711-65722]:ExpressionStatement[66203-66214]"
  }, {
    "left" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
    "right" : "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString()))",
    "info" : "IfStatement[65727-65904]:IfStatement[66219-66396]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65794-65849]:Block[66286-66341]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[65802-65809]:ExpressionStatement[66294-66301]"
  }, {
    "left" : "return newNode(Token.VOID);",
    "right" : "return newNode(Token.VOID);",
    "info" : "ReturnStatement[65816-65843]:ReturnStatement[66308-66335]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65855-65904]:Block[66347-66396]"
  }, {
    "left" : "return parseTypeExpression(next());",
    "right" : "return parseTypeExpression(next());",
    "info" : "ReturnStatement[65863-65898]:ReturnStatement[66355-66390]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[66082-66089]:Modifier[66574-66581]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[66090-66094]:SimpleType[66582-66586]"
  }, {
    "left" : "parseUnionType",
    "right" : "parseUnionType",
    "info" : "SimpleName[66095-66109]:SimpleName[66587-66601]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[66110-66126]:SingleVariableDeclaration[66602-66618]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66128-66186]:Block[66620-66678]"
  }, {
    "left" : "return parseUnionTypeWithAlternate(token, null);",
    "right" : "return parseUnionTypeWithAlternate(token, null);",
    "info" : "ReturnStatement[66134-66182]:ReturnStatement[66626-66674]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[66312-66319]:Modifier[66804-66811]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[66320-66324]:SimpleType[66812-66816]"
  }, {
    "left" : "parseUnionTypeWithAlternate",
    "right" : "parseUnionTypeWithAlternate",
    "info" : "SimpleName[66325-66352]:SimpleName[66817-66844]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[66353-66369]:SingleVariableDeclaration[66845-66861]"
  }, {
    "left" : "Node alternate",
    "right" : "Node alternate",
    "info" : "SingleVariableDeclaration[66371-66385]:SingleVariableDeclaration[66863-66877]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66387-67388]:Block[66879-67880]"
  }, {
    "left" : "Node union = newNode(Token.PIPE);",
    "right" : "Node union = newNode(Token.PIPE);",
    "info" : "VariableDeclarationStatement[66393-66426]:VariableDeclarationStatement[66885-66918]"
  }, {
    "left" : "if (alternate != null)",
    "right" : "if (alternate != null)",
    "info" : "IfStatement[66431-66500]:IfStatement[66923-66992]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66454-66500]:Block[66946-66992]"
  }, {
    "left" : "union.addChildToBack(alternate);",
    "right" : "union.addChildToBack(alternate);",
    "info" : "ExpressionStatement[66462-66494]:ExpressionStatement[66954-66986]"
  }, {
    "left" : "Node expr = null;",
    "right" : "Node expr = null;",
    "info" : "VariableDeclarationStatement[66506-66523]:VariableDeclarationStatement[66998-67015]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[66528-67191]:DoStatement[67020-67683]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66531-67141]:Block[67023-67633]"
  }, {
    "left" : "if (expr != null)",
    "right" : "if (expr != null)",
    "info" : "IfStatement[66539-66949]:IfStatement[67031-67441]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66557-66949]:Block[67049-67441]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[66567-66578]:ExpressionStatement[67059-67070]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[66587-66602]:ExpressionStatement[67079-67094]"
  }, {
    "left" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
    "right" : "Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);",
    "info" : "ExpressionStatement[66611-66704]:ExpressionStatement[67103-67196]"
  }, {
    "left" : "boolean isPipe = token == JsDocToken.PIPE;",
    "right" : "boolean isPipe = token == JsDocToken.PIPE;",
    "info" : "VariableDeclarationStatement[66714-66756]:VariableDeclarationStatement[67206-67248]"
  }, {
    "left" : "if (isPipe && match(JsDocToken.PIPE))",
    "right" : "if (isPipe && match(JsDocToken.PIPE))",
    "info" : "IfStatement[66765-66897]:IfStatement[67257-67389]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66803-66897]:Block[67295-67389]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[66880-66887]:ExpressionStatement[67372-67379]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[66906-66917]:ExpressionStatement[67398-67409]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[66926-66941]:ExpressionStatement[67418-67433]"
  }, {
    "left" : "expr = parseTypeExpression(token);",
    "right" : "expr = parseTypeExpression(token);",
    "info" : "ExpressionStatement[66956-66990]:ExpressionStatement[67448-67482]"
  }, {
    "left" : "if (expr == null)",
    "right" : "if (expr == null)",
    "info" : "IfStatement[66997-67045]:IfStatement[67489-67537]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67015-67045]:Block[67507-67537]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[67025-67037]:ReturnStatement[67517-67529]"
  }, {
    "left" : "union.addChildToBack(expr);",
    "right" : "union.addChildToBack(expr);",
    "info" : "ExpressionStatement[67053-67080]:ExpressionStatement[67545-67572]"
  }, {
    "left" : "if (alternate == null)",
    "right" : "if (alternate == null)",
    "info" : "IfStatement[67197-67366]:IfStatement[67689-67858]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67220-67366]:Block[67712-67858]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[67228-67239]:ExpressionStatement[67720-67731]"
  }, {
    "left" : "if (!match(JsDocToken.RP))",
    "right" : "if (!match(JsDocToken.RP))",
    "info" : "IfStatement[67246-67346]:IfStatement[67738-67838]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67273-67346]:Block[67765-67838]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");",
    "info" : "ReturnStatement[67283-67338]:ReturnStatement[67775-67830]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[67353-67360]:ExpressionStatement[67845-67852]"
  }, {
    "left" : "return union;",
    "right" : "return union;",
    "info" : "ReturnStatement[67371-67384]:ReturnStatement[67863-67876]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[67564-67571]:Modifier[68056-68063]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[67572-67576]:SimpleType[68064-68068]"
  }, {
    "left" : "parseArrayType",
    "right" : "parseArrayType",
    "info" : "SimpleName[67577-67591]:SimpleName[68069-68083]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[67592-67608]:SingleVariableDeclaration[68084-68100]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67610-68335]:Block[68102-68827]"
  }, {
    "left" : "Node array = newNode(Token.LB);",
    "right" : "Node array = newNode(Token.LB);",
    "info" : "VariableDeclarationStatement[67616-67647]:VariableDeclarationStatement[68108-68139]"
  }, {
    "left" : "Node arg = null;",
    "right" : "Node arg = null;",
    "info" : "VariableDeclarationStatement[67652-67668]:VariableDeclarationStatement[68144-68160]"
  }, {
    "left" : "boolean hasVarArgs = false;",
    "right" : "boolean hasVarArgs = false;",
    "info" : "VariableDeclarationStatement[67673-67700]:VariableDeclarationStatement[68165-68192]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[67706-68199]:DoStatement[68198-68691]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67709-68166]:Block[68201-68658]"
  }, {
    "left" : "if (arg != null)",
    "right" : "if (arg != null)",
    "info" : "IfStatement[67717-67803]:IfStatement[68209-68295]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67734-67803]:Block[68226-68295]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[67744-67751]:ExpressionStatement[68236-68243]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[67760-67771]:ExpressionStatement[68252-68263]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[67780-67795]:ExpressionStatement[68272-68287]"
  }, {
    "left" : "if (token == JsDocToken.ELLIPSIS)",
    "right" : "if (token == JsDocToken.ELLIPSIS)",
    "info" : "IfStatement[67810-68006]:IfStatement[68302-68498]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67844-67949]:Block[68336-68441]"
  }, {
    "left" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
    "right" : "arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));",
    "info" : "ExpressionStatement[67854-67914]:ExpressionStatement[68346-68406]"
  }, {
    "left" : "hasVarArgs = true;",
    "right" : "hasVarArgs = true;",
    "info" : "ExpressionStatement[67923-67941]:ExpressionStatement[68415-68433]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67955-68006]:Block[68447-68498]"
  }, {
    "left" : "arg = parseTypeExpression(token);",
    "right" : "arg = parseTypeExpression(token);",
    "info" : "ExpressionStatement[67965-67998]:ExpressionStatement[68457-68490]"
  }, {
    "left" : "if (arg == null)",
    "right" : "if (arg == null)",
    "info" : "IfStatement[68014-68061]:IfStatement[68506-68553]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68031-68061]:Block[68523-68553]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[68041-68053]:ReturnStatement[68533-68545]"
  }, {
    "left" : "array.addChildToBack(arg);",
    "right" : "array.addChildToBack(arg);",
    "info" : "ExpressionStatement[68069-68095]:ExpressionStatement[68561-68587]"
  }, {
    "left" : "if (hasVarArgs)",
    "right" : "if (hasVarArgs)",
    "info" : "IfStatement[68102-68142]:IfStatement[68594-68634]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68118-68142]:Block[68610-68634]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[68128-68134]:BreakStatement[68620-68626]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[68149-68160]:ExpressionStatement[68641-68652]"
  }, {
    "left" : "if (!match(JsDocToken.RB))",
    "right" : "if (!match(JsDocToken.RB))",
    "info" : "IfStatement[68205-68301]:IfStatement[68697-68793]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68232-68301]:Block[68724-68793]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");",
    "info" : "ReturnStatement[68240-68295]:ReturnStatement[68732-68787]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[68306-68313]:ExpressionStatement[68798-68805]"
  }, {
    "left" : "return array;",
    "right" : "return array;",
    "info" : "ReturnStatement[68318-68331]:ReturnStatement[68810-68823]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[68392-68399]:Modifier[68884-68891]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[68400-68404]:SimpleType[68892-68896]"
  }, {
    "left" : "parseRecordType",
    "right" : "parseRecordType",
    "info" : "SimpleName[68405-68420]:SimpleName[68897-68912]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[68421-68437]:SingleVariableDeclaration[68913-68929]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68439-68825]:Block[68931-69317]"
  }, {
    "left" : "Node recordType = newNode(Token.LC);",
    "right" : "Node recordType = newNode(Token.LC);",
    "info" : "VariableDeclarationStatement[68445-68481]:VariableDeclarationStatement[68937-68973]"
  }, {
    "left" : "Node fieldTypeList = parseFieldTypeList(token);",
    "right" : "Node fieldTypeList = parseFieldTypeList(token);",
    "info" : "VariableDeclarationStatement[68486-68533]:VariableDeclarationStatement[68978-69025]"
  }, {
    "left" : "if (fieldTypeList == null)",
    "right" : "if (fieldTypeList == null)",
    "info" : "IfStatement[68539-68620]:IfStatement[69031-69112]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68566-68620]:Block[69058-69112]"
  }, {
    "left" : "return reportGenericTypeSyntaxWarning();",
    "right" : "return reportGenericTypeSyntaxWarning();",
    "info" : "ReturnStatement[68574-68614]:ReturnStatement[69066-69106]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[68626-68637]:ExpressionStatement[69118-69129]"
  }, {
    "left" : "if (!match(JsDocToken.RC))",
    "right" : "if (!match(JsDocToken.RC))",
    "info" : "IfStatement[68642-68738]:IfStatement[69134-69230]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68669-68738]:Block[69161-69230]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");",
    "info" : "ReturnStatement[68677-68732]:ReturnStatement[69169-69224]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[68744-68751]:ExpressionStatement[69236-69243]"
  }, {
    "left" : "recordType.addChildToBack(fieldTypeList);",
    "right" : "recordType.addChildToBack(fieldTypeList);",
    "info" : "ExpressionStatement[68757-68798]:ExpressionStatement[69249-69290]"
  }, {
    "left" : "return recordType;",
    "right" : "return recordType;",
    "info" : "ReturnStatement[68803-68821]:ReturnStatement[69295-69313]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[68903-68910]:Modifier[69395-69402]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[68911-68915]:SimpleType[69403-69407]"
  }, {
    "left" : "parseFieldTypeList",
    "right" : "parseFieldTypeList",
    "info" : "SimpleName[68916-68934]:SimpleName[69408-69426]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[68935-68951]:SingleVariableDeclaration[69427-69443]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68953-69429]:Block[69445-69921]"
  }, {
    "left" : "Node fieldTypeList = newNode(Token.LB);",
    "right" : "Node fieldTypeList = newNode(Token.LB);",
    "info" : "VariableDeclarationStatement[68959-68998]:VariableDeclarationStatement[69451-69490]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[69004-69398]:DoStatement[69496-69890]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69007-69384]:Block[69499-69876]"
  }, {
    "left" : "Node fieldType = parseFieldType(token);",
    "right" : "Node fieldType = parseFieldType(token);",
    "info" : "VariableDeclarationStatement[69015-69054]:VariableDeclarationStatement[69507-69546]"
  }, {
    "left" : "if (fieldType == null)",
    "right" : "if (fieldType == null)",
    "info" : "IfStatement[69062-69115]:IfStatement[69554-69607]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69085-69115]:Block[69577-69607]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[69095-69107]:ReturnStatement[69587-69599]"
  }, {
    "left" : "fieldTypeList.addChildToBack(fieldType);",
    "right" : "fieldTypeList.addChildToBack(fieldType);",
    "info" : "ExpressionStatement[69123-69163]:ExpressionStatement[69615-69655]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[69171-69182]:ExpressionStatement[69663-69674]"
  }, {
    "left" : "if (!match(JsDocToken.COMMA))",
    "right" : "if (!match(JsDocToken.COMMA))",
    "info" : "IfStatement[69189-69243]:IfStatement[69681-69735]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69219-69243]:Block[69711-69735]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[69229-69235]:BreakStatement[69721-69727]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[69285-69292]:ExpressionStatement[69777-69784]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[69345-69356]:ExpressionStatement[69837-69848]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[69363-69378]:ExpressionStatement[69855-69870]"
  }, {
    "left" : "return fieldTypeList;",
    "right" : "return fieldTypeList;",
    "info" : "ReturnStatement[69404-69425]:ReturnStatement[69896-69917]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[69504-69511]:Modifier[69996-70003]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[69512-69516]:SimpleType[70004-70008]"
  }, {
    "left" : "parseFieldType",
    "right" : "parseFieldType",
    "info" : "SimpleName[69517-69531]:SimpleName[70009-70023]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[69532-69548]:SingleVariableDeclaration[70024-70040]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69550-70140]:Block[70042-70632]"
  }, {
    "left" : "Node fieldName = parseFieldName(token);",
    "right" : "Node fieldName = parseFieldName(token);",
    "info" : "VariableDeclarationStatement[69556-69595]:VariableDeclarationStatement[70048-70087]"
  }, {
    "left" : "if (fieldName == null)",
    "right" : "if (fieldName == null)",
    "info" : "IfStatement[69601-69650]:IfStatement[70093-70142]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69624-69650]:Block[70116-70142]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[69632-69644]:ReturnStatement[70124-70136]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[69656-69667]:ExpressionStatement[70148-70159]"
  }, {
    "left" : "if (!match(JsDocToken.COLON))",
    "right" : "if (!match(JsDocToken.COLON))",
    "info" : "IfStatement[69672-69733]:IfStatement[70164-70225]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69702-69733]:Block[70194-70225]"
  }, {
    "left" : "return fieldName;",
    "right" : "return fieldName;",
    "info" : "ReturnStatement[69710-69727]:ReturnStatement[70202-70219]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[69765-69772]:ExpressionStatement[70257-70264]"
  }, {
    "left" : "skipEOLs();",
    "right" : "skipEOLs();",
    "info" : "ExpressionStatement[69857-69868]:ExpressionStatement[70349-70360]"
  }, {
    "left" : "Node typeExpression = parseTypeExpression(next());",
    "right" : "Node typeExpression = parseTypeExpression(next());",
    "info" : "VariableDeclarationStatement[69873-69923]:VariableDeclarationStatement[70365-70415]"
  }, {
    "left" : "if (typeExpression == null)",
    "right" : "if (typeExpression == null)",
    "info" : "IfStatement[69929-69983]:IfStatement[70421-70475]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69957-69983]:Block[70449-70475]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[69965-69977]:ReturnStatement[70457-70469]"
  }, {
    "left" : "Node fieldType = newNode(Token.COLON);",
    "right" : "Node fieldType = newNode(Token.COLON);",
    "info" : "VariableDeclarationStatement[69989-70027]:VariableDeclarationStatement[70481-70519]"
  }, {
    "left" : "fieldType.addChildToBack(fieldName);",
    "right" : "fieldType.addChildToBack(fieldName);",
    "info" : "ExpressionStatement[70032-70068]:ExpressionStatement[70524-70560]"
  }, {
    "left" : "fieldType.addChildToBack(typeExpression);",
    "right" : "fieldType.addChildToBack(typeExpression);",
    "info" : "ExpressionStatement[70073-70114]:ExpressionStatement[70565-70606]"
  }, {
    "left" : "return fieldType;",
    "right" : "return fieldType;",
    "info" : "ReturnStatement[70119-70136]:ReturnStatement[70611-70628]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[70247-70254]:Modifier[70739-70746]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[70255-70259]:SimpleType[70747-70751]"
  }, {
    "left" : "parseFieldName",
    "right" : "parseFieldName",
    "info" : "SimpleName[70260-70274]:SimpleName[70752-70766]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[70275-70291]:SingleVariableDeclaration[70767-70783]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70293-70463]:Block[70785-70955]"
  }, {
    "left" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
    "right" : "switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }",
    "info" : "SwitchStatement[70299-70459]:SwitchStatement[70791-70951]"
  }, {
    "left" : "case STRING:",
    "right" : "case STRING:",
    "info" : "SwitchCase[70322-70334]:SwitchCase[70814-70826]"
  }, {
    "left" : "String string = stream.getString();",
    "right" : "String string = stream.getString();",
    "info" : "VariableDeclarationStatement[70343-70378]:VariableDeclarationStatement[70835-70870]"
  }, {
    "left" : "return newStringNode(string);",
    "right" : "return newStringNode(string);",
    "info" : "ReturnStatement[70387-70416]:ReturnStatement[70879-70908]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[70424-70432]:SwitchCase[70916-70924]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[70441-70453]:ReturnStatement[70933-70945]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[70467-70474]:Modifier[70959-70966]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[70475-70479]:SimpleType[70967-70971]"
  }, {
    "left" : "wrapNode",
    "right" : "wrapNode",
    "info" : "SimpleName[70480-70488]:SimpleName[70972-70980]"
  }, {
    "left" : "int type",
    "right" : "int type",
    "info" : "SingleVariableDeclaration[70489-70497]:SingleVariableDeclaration[70981-70989]"
  }, {
    "left" : "Node n",
    "right" : "Node n",
    "info" : "SingleVariableDeclaration[70499-70505]:SingleVariableDeclaration[70991-70997]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70507-70650]:Block[70999-71142]"
  }, {
    "left" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);",
    "right" : "return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);",
    "info" : "ReturnStatement[70513-70646]:ReturnStatement[71005-71138]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[70654-70661]:Modifier[71146-71153]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[70662-70666]:SimpleType[71154-71158]"
  }, {
    "left" : "newNode",
    "right" : "newNode",
    "info" : "SimpleName[70667-70674]:SimpleName[71159-71166]"
  }, {
    "left" : "int type",
    "right" : "int type",
    "info" : "SingleVariableDeclaration[70675-70683]:SingleVariableDeclaration[71167-71175]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70685-70794]:Block[71177-71286]"
  }, {
    "left" : "return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
    "right" : "return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);",
    "info" : "ReturnStatement[70691-70790]:ReturnStatement[71183-71282]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[70798-70805]:Modifier[71290-71297]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[70806-70810]:SimpleType[71298-71302]"
  }, {
    "left" : "newStringNode",
    "right" : "newStringNode",
    "info" : "SimpleName[70811-70824]:SimpleName[71303-71316]"
  }, {
    "left" : "String s",
    "right" : "String s",
    "info" : "SingleVariableDeclaration[70825-70833]:SingleVariableDeclaration[71317-71325]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70835-70909]:Block[71327-71401]"
  }, {
    "left" : "return newStringNode(s, stream.getLineno(), stream.getCharno());",
    "right" : "return newStringNode(s, stream.getLineno(), stream.getCharno());",
    "info" : "ReturnStatement[70841-70905]:ReturnStatement[71333-71397]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[70913-70920]:Modifier[71405-71412]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[70921-70925]:SimpleType[71413-71417]"
  }, {
    "left" : "newStringNode",
    "right" : "newStringNode",
    "info" : "SimpleName[70926-70939]:SimpleName[71418-71431]"
  }, {
    "left" : "String s",
    "right" : "String s",
    "info" : "SingleVariableDeclaration[70940-70948]:SingleVariableDeclaration[71432-71440]"
  }, {
    "left" : "int lineno",
    "right" : "int lineno",
    "info" : "SingleVariableDeclaration[70950-70960]:SingleVariableDeclaration[71442-71452]"
  }, {
    "left" : "int charno",
    "right" : "int charno",
    "info" : "SingleVariableDeclaration[70962-70972]:SingleVariableDeclaration[71454-71464]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70974-71099]:Block[71466-71591]"
  }, {
    "left" : "Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);",
    "right" : "Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);",
    "info" : "VariableDeclarationStatement[70980-71052]:VariableDeclarationStatement[71472-71544]"
  }, {
    "left" : "n.setLength(s.length());",
    "right" : "n.setLength(s.length());",
    "info" : "ExpressionStatement[71057-71081]:ExpressionStatement[71549-71573]"
  }, {
    "left" : "return n;",
    "right" : "return n;",
    "info" : "ReturnStatement[71086-71095]:ReturnStatement[71578-71587]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[71221-71228]:Modifier[71713-71720]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[71229-71233]:SimpleType[71721-71725]"
  }, {
    "left" : "createTemplateNode",
    "right" : "createTemplateNode",
    "info" : "SimpleName[71234-71252]:SimpleName[71726-71744]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71255-71501]:Block[71747-71993]"
  }, {
    "left" : "Node templateNode = IR.script();",
    "right" : "Node templateNode = IR.script();",
    "info" : "VariableDeclarationStatement[71303-71335]:VariableDeclarationStatement[71795-71827]"
  }, {
    "left" : "templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);",
    "right" : "templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);",
    "info" : "ExpressionStatement[71340-71472]:ExpressionStatement[71832-71964]"
  }, {
    "left" : "return templateNode;",
    "right" : "return templateNode;",
    "info" : "ReturnStatement[71477-71497]:ReturnStatement[71969-71989]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[71505-71512]:Modifier[71997-72004]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[71513-71517]:SimpleType[72005-72009]"
  }, {
    "left" : "reportTypeSyntaxWarning",
    "right" : "reportTypeSyntaxWarning",
    "info" : "SimpleName[71518-71541]:SimpleName[72010-72033]"
  }, {
    "left" : "String warning",
    "right" : "String warning",
    "info" : "SingleVariableDeclaration[71542-71556]:SingleVariableDeclaration[72034-72048]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71558-71656]:Block[72050-72148]"
  }, {
    "left" : "parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());",
    "right" : "parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());",
    "info" : "ExpressionStatement[71564-71635]:ExpressionStatement[72056-72127]"
  }, {
    "left" : "return null;",
    "right" : "return null;",
    "info" : "ReturnStatement[71640-71652]:ReturnStatement[72132-72144]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[71660-71667]:Modifier[72152-72159]"
  }, {
    "left" : "Node",
    "right" : "Node",
    "info" : "SimpleType[71668-71672]:SimpleType[72160-72164]"
  }, {
    "left" : "reportGenericTypeSyntaxWarning",
    "right" : "reportGenericTypeSyntaxWarning",
    "info" : "SimpleName[71673-71703]:SimpleName[72165-72195]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71706-71772]:Block[72198-72264]"
  }, {
    "left" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
    "right" : "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");",
    "info" : "ReturnStatement[71712-71768]:ReturnStatement[72204-72260]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[71916-71923]:Modifier[72408-72415]"
  }, {
    "left" : "JsDocToken",
    "right" : "JsDocToken",
    "info" : "SimpleType[71924-71934]:SimpleType[72416-72426]"
  }, {
    "left" : "eatTokensUntilEOL",
    "right" : "eatTokensUntilEOL",
    "info" : "SimpleName[71935-71952]:SimpleName[72427-72444]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71955-71998]:Block[72447-72490]"
  }, {
    "left" : "return eatTokensUntilEOL(next());",
    "right" : "return eatTokensUntilEOL(next());",
    "info" : "ReturnStatement[71961-71994]:ReturnStatement[72453-72486]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[72142-72149]:Modifier[72634-72641]"
  }, {
    "left" : "JsDocToken",
    "right" : "JsDocToken",
    "info" : "SimpleType[72150-72160]:SimpleType[72642-72652]"
  }, {
    "left" : "eatTokensUntilEOL",
    "right" : "eatTokensUntilEOL",
    "info" : "SimpleName[72161-72178]:SimpleName[72653-72670]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[72179-72195]:SingleVariableDeclaration[72671-72687]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72197-72428]:Block[72689-72920]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[72203-72424]:DoStatement[72695-72916]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72206-72410]:Block[72698-72902]"
  }, {
    "left" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
    "right" : "if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF)",
    "info" : "IfStatement[72214-72382]:IfStatement[72706-72874]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72307-72382]:Block[72799-72874]"
  }, {
    "left" : "state = State.SEARCHING_ANNOTATION;",
    "right" : "state = State.SEARCHING_ANNOTATION;",
    "info" : "ExpressionStatement[72317-72352]:ExpressionStatement[72809-72844]"
  }, {
    "left" : "return token;",
    "right" : "return token;",
    "info" : "ReturnStatement[72361-72374]:ReturnStatement[72853-72866]"
  }, {
    "left" : "token = next();",
    "right" : "token = next();",
    "info" : "ExpressionStatement[72389-72404]:ExpressionStatement[72881-72896]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[72729-72736]:Modifier[73221-73228]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[72737-72741]:PrimitiveType[73229-73233]"
  }, {
    "left" : "restoreLookAhead",
    "right" : "restoreLookAhead",
    "info" : "SimpleName[72742-72758]:SimpleName[73234-73250]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[72759-72775]:SingleVariableDeclaration[73251-73267]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72777-72807]:Block[73269-73299]"
  }, {
    "left" : "unreadToken = token;",
    "right" : "unreadToken = token;",
    "info" : "ExpressionStatement[72783-72803]:ExpressionStatement[73275-73295]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[72911-72918]:Modifier[73403-73410]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[72919-72926]:PrimitiveType[73411-73418]"
  }, {
    "left" : "match",
    "right" : "match",
    "info" : "SimpleName[72927-72932]:SimpleName[73419-73424]"
  }, {
    "left" : "JsDocToken token",
    "right" : "JsDocToken token",
    "info" : "SingleVariableDeclaration[72933-72949]:SingleVariableDeclaration[73425-73441]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72951-73015]:Block[73443-73507]"
  }, {
    "left" : "unreadToken = next();",
    "right" : "unreadToken = next();",
    "info" : "ExpressionStatement[72957-72978]:ExpressionStatement[73449-73470]"
  }, {
    "left" : "return unreadToken == token;",
    "right" : "return unreadToken == token;",
    "info" : "ReturnStatement[72983-73011]:ReturnStatement[73475-73503]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[73125-73132]:Modifier[73617-73624]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[73133-73140]:PrimitiveType[73625-73632]"
  }, {
    "left" : "match",
    "right" : "match",
    "info" : "SimpleName[73141-73146]:SimpleName[73633-73638]"
  }, {
    "left" : "JsDocToken token1",
    "right" : "JsDocToken token1",
    "info" : "SingleVariableDeclaration[73147-73164]:SingleVariableDeclaration[73639-73656]"
  }, {
    "left" : "JsDocToken token2",
    "right" : "JsDocToken token2",
    "info" : "SingleVariableDeclaration[73166-73183]:SingleVariableDeclaration[73658-73675]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73185-73275]:Block[73677-73767]"
  }, {
    "left" : "unreadToken = next();",
    "right" : "unreadToken = next();",
    "info" : "ExpressionStatement[73191-73212]:ExpressionStatement[73683-73704]"
  }, {
    "left" : "return unreadToken == token1 || unreadToken == token2;",
    "right" : "return unreadToken == token1 || unreadToken == token2;",
    "info" : "ReturnStatement[73217-73271]:ReturnStatement[73709-73763]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[73398-73405]:Modifier[73890-73897]"
  }, {
    "left" : "JsDocToken",
    "right" : "JsDocToken",
    "info" : "SimpleType[73406-73416]:SimpleType[73898-73908]"
  }, {
    "left" : "next",
    "right" : "next",
    "info" : "SimpleName[73417-73421]:SimpleName[73909-73913]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73424-73551]:Block[73916-74043]"
  }, {
    "left" : "if (unreadToken == NO_UNREAD_TOKEN)",
    "right" : "if (unreadToken == NO_UNREAD_TOKEN)",
    "info" : "IfStatement[73430-73547]:IfStatement[73922-74039]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73466-73510]:Block[73958-74002]"
  }, {
    "left" : "return stream.getJsDocToken();",
    "right" : "return stream.getJsDocToken();",
    "info" : "ReturnStatement[73474-73504]:ReturnStatement[73966-73996]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73516-73547]:Block[74008-74039]"
  }, {
    "left" : "return current();",
    "right" : "return current();",
    "info" : "ReturnStatement[73524-73541]:ReturnStatement[74016-74033]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[73628-73635]:Modifier[74120-74127]"
  }, {
    "left" : "JsDocToken",
    "right" : "JsDocToken",
    "info" : "SimpleType[73636-73646]:SimpleType[74128-74138]"
  }, {
    "left" : "current",
    "right" : "current",
    "info" : "SimpleName[73647-73654]:SimpleName[74139-74146]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73657-73743]:Block[74149-74235]"
  }, {
    "left" : "JsDocToken t = unreadToken;",
    "right" : "JsDocToken t = unreadToken;",
    "info" : "VariableDeclarationStatement[73663-73690]:VariableDeclarationStatement[74155-74182]"
  }, {
    "left" : "unreadToken = NO_UNREAD_TOKEN;",
    "right" : "unreadToken = NO_UNREAD_TOKEN;",
    "info" : "ExpressionStatement[73695-73725]:ExpressionStatement[74187-74217]"
  }, {
    "left" : "return t;",
    "right" : "return t;",
    "info" : "ReturnStatement[73730-73739]:ReturnStatement[74222-74231]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[73887-73894]:Modifier[74379-74386]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[73895-73899]:PrimitiveType[74387-74391]"
  }, {
    "left" : "skipEOLs",
    "right" : "skipEOLs",
    "info" : "SimpleName[73900-73908]:SimpleName[74392-74400]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73911-74032]:Block[74403-74524]"
  }, {
    "left" : "while (match(JsDocToken.EOL))",
    "right" : "while (match(JsDocToken.EOL))",
    "info" : "WhileStatement[73917-74028]:WhileStatement[74409-74520]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73947-74028]:Block[74439-74520]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[73955-73962]:ExpressionStatement[74447-74454]"
  }, {
    "left" : "if (match(JsDocToken.STAR))",
    "right" : "if (match(JsDocToken.STAR))",
    "info" : "IfStatement[73969-74022]:IfStatement[74461-74514]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[73997-74022]:Block[74489-74514]"
  }, {
    "left" : "next();",
    "right" : "next();",
    "info" : "ExpressionStatement[74007-74014]:ExpressionStatement[74499-74506]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[74145-74152]:Modifier[74637-74644]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[74153-74160]:PrimitiveType[74645-74652]"
  }, {
    "left" : "hasParsedFileOverviewDocInfo",
    "right" : "hasParsedFileOverviewDocInfo",
    "info" : "SimpleName[74161-74189]:SimpleName[74653-74681]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74192-74252]:Block[74684-74744]"
  }, {
    "left" : "return jsdocBuilder.isPopulatedWithFileOverview();",
    "right" : "return jsdocBuilder.isPopulatedWithFileOverview();",
    "info" : "ReturnStatement[74198-74248]:ReturnStatement[74690-74740]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[74256-74263]:PrimitiveType[74748-74755]"
  }, {
    "left" : "hasParsedJSDocInfo",
    "right" : "hasParsedJSDocInfo",
    "info" : "SimpleName[74264-74282]:SimpleName[74756-74774]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74285-74329]:Block[74777-74821]"
  }, {
    "left" : "return jsdocBuilder.isPopulated();",
    "right" : "return jsdocBuilder.isPopulated();",
    "info" : "ReturnStatement[74291-74325]:ReturnStatement[74783-74817]"
  }, {
    "left" : "JSDocInfo",
    "right" : "JSDocInfo",
    "info" : "SimpleType[74333-74342]:SimpleType[74825-74834]"
  }, {
    "left" : "retrieveAndResetParsedJSDocInfo",
    "right" : "retrieveAndResetParsedJSDocInfo",
    "info" : "SimpleName[74343-74374]:SimpleName[74835-74866]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74377-74429]:Block[74869-74921]"
  }, {
    "left" : "return jsdocBuilder.build(associatedNode);",
    "right" : "return jsdocBuilder.build(associatedNode);",
    "info" : "ReturnStatement[74383-74425]:ReturnStatement[74875-74917]"
  }, {
    "left" : "JSDocInfo",
    "right" : "JSDocInfo",
    "info" : "SimpleType[74491-74500]:SimpleType[74983-74992]"
  }, {
    "left" : "getFileOverviewJSDocInfo",
    "right" : "getFileOverviewJSDocInfo",
    "info" : "SimpleName[74501-74525]:SimpleName[74993-75017]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74528-74567]:Block[75020-75059]"
  }, {
    "left" : "return fileOverviewJSDocInfo;",
    "right" : "return fileOverviewJSDocInfo;",
    "info" : "ReturnStatement[74534-74563]:ReturnStatement[75026-75055]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[74921-74928]:Modifier[75413-75420]"
  }, {
    "left" : "boolean",
    "right" : "boolean",
    "info" : "PrimitiveType[74929-74936]:PrimitiveType[75421-75428]"
  }, {
    "left" : "lookAheadForTypeAnnotation",
    "right" : "lookAheadForTypeAnnotation",
    "info" : "SimpleName[74937-74963]:SimpleName[75429-75455]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74966-75261]:Block[75458-75753]"
  }, {
    "left" : "boolean matchedLc = false;",
    "right" : "boolean matchedLc = false;",
    "info" : "VariableDeclarationStatement[74972-74998]:VariableDeclarationStatement[75464-75490]"
  }, {
    "left" : "int c;",
    "right" : "int c;",
    "info" : "VariableDeclarationStatement[75003-75009]:VariableDeclarationStatement[75495-75501]"
  }, {
    "left" : "while (true)",
    "right" : "while (true)",
    "info" : "WhileStatement[75014-75210]:WhileStatement[75506-75702]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75027-75210]:Block[75519-75702]"
  }, {
    "left" : "c = stream.getChar();",
    "right" : "c = stream.getChar();",
    "info" : "ExpressionStatement[75035-75056]:ExpressionStatement[75527-75548]"
  }, {
    "left" : "if (c == ' ')",
    "right" : "if (c == ' ')",
    "info" : "IfStatement[75063-75204]:IfStatement[75555-75696]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75077-75104]:Block[75569-75596]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[75087-75096]:ContinueStatement[75579-75588]"
  }, {
    "left" : "if (c == '{')",
    "right" : "if (c == '{')",
    "info" : "IfStatement[75110-75204]:IfStatement[75602-75696]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75124-75174]:Block[75616-75666]"
  }, {
    "left" : "matchedLc = true;",
    "right" : "matchedLc = true;",
    "info" : "ExpressionStatement[75134-75151]:ExpressionStatement[75626-75643]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[75160-75166]:BreakStatement[75652-75658]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75180-75204]:Block[75672-75696]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[75190-75196]:BreakStatement[75682-75688]"
  }, {
    "left" : "stream.ungetChar(c);",
    "right" : "stream.ungetChar(c);",
    "info" : "ExpressionStatement[75215-75235]:ExpressionStatement[75707-75727]"
  }, {
    "left" : "return matchedLc;",
    "right" : "return matchedLc;",
    "info" : "ReturnStatement[75240-75257]:ReturnStatement[75732-75749]"
  } ]
}