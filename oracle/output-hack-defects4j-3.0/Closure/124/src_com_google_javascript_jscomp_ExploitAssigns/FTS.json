{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "ExploitAssigns",
      "right" : "ExploitAssigns",
      "info" : "TypeDeclaration[781-7858]:TypeDeclaration[781-7895]"
    }, {
      "left" : "Node optimizeSubtree(Node subtree)",
      "right" : "Node optimizeSubtree(Node subtree)",
      "info" : "MethodDeclaration[988-1299]:MethodDeclaration[988-1299]"
    }, {
      "left" : "private void collapseAssign(Node assign, Node expr,\n      Node exprParent)",
      "right" : "private void collapseAssign(Node assign, Node expr,\n      Node exprParent)",
      "info" : "MethodDeclaration[1303-1975]:MethodDeclaration[1303-1975]"
    }, {
      "left" : "private static boolean isCollapsibleValue(Node value, boolean isLValue)",
      "right" : "private static boolean isCollapsibleValue(Node value, boolean isLValue)",
      "info" : "MethodDeclaration[1979-3023]:MethodDeclaration[1979-3023]"
    }, {
      "left" : "private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value)",
      "right" : "private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value)",
      "info" : "MethodDeclaration[3027-6796]:MethodDeclaration[3027-6796]"
    }, {
      "left" : "private boolean isSafeReplacement(Node node, Node replacement)",
      "right" : "private boolean isSafeReplacement(Node node, Node replacement)",
      "info" : "MethodDeclaration[6800-7321]:MethodDeclaration[6800-7358]"
    }, {
      "left" : "private boolean isNameAssignedTo(String name, Node node)",
      "right" : "private boolean isNameAssignedTo(String name, Node node)",
      "info" : "MethodDeclaration[7325-7856]:MethodDeclaration[7362-7893]"
    } ],
    "mappings" : [
 {
      "left" : "class",
      "right" : "class",
      "info" : "TYPE_DECLARATION_KIND[925-930]:TYPE_DECLARATION_KIND[925-930]"
    }, {
      "left" : "ExploitAssigns",
      "right" : "ExploitAssigns",
      "info" : "SimpleName[931-945]:SimpleName[931-945]"
    }, {
      "left" : "AbstractPeepholeOptimization",
      "right" : "AbstractPeepholeOptimization",
      "info" : "SimpleType[954-982]:SimpleType[954-982]"
    }, {
      "left" : "@Override",
      "right" : "@Override",
      "info" : "MarkerAnnotation[988-997]:MarkerAnnotation[988-997]"
    }, {
      "left" : "Node",
      "right" : "Node",
      "info" : "SimpleType[1000-1004]:SimpleType[1000-1004]"
    }, {
      "left" : "optimizeSubtree",
      "right" : "optimizeSubtree",
      "info" : "SimpleName[1005-1020]:SimpleName[1005-1020]"
    }, {
      "left" : "Node subtree",
      "right" : "Node subtree",
      "info" : "SingleVariableDeclaration[1021-1033]:SingleVariableDeclaration[1021-1033]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1035-1299]:Block[1035-1299]"
    }, {
      "left" : "for (Node child = subtree.getFirstChild(); child != null)",
      "right" : "for (Node child = subtree.getFirstChild(); child != null)",
      "info" : "ForStatement[1041-1275]:ForStatement[1041-1275]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1100-1275]:Block[1100-1275]"
    }, {
      "left" : "Node next = child.getNext();",
      "right" : "Node next = child.getNext();",
      "info" : "VariableDeclarationStatement[1108-1136]:VariableDeclarationStatement[1108-1136]"
    }, {
      "left" : "if (NodeUtil.isExprAssign(child))",
      "right" : "if (NodeUtil.isExprAssign(child))",
      "info" : "IfStatement[1143-1249]:IfStatement[1143-1249]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1177-1249]:Block[1177-1249]"
    }, {
      "left" : "collapseAssign(child.getFirstChild(), child, subtree);",
      "right" : "collapseAssign(child.getFirstChild(), child, subtree);",
      "info" : "ExpressionStatement[1187-1241]:ExpressionStatement[1187-1241]"
    }, {
      "left" : "child = next;",
      "right" : "child = next;",
      "info" : "ExpressionStatement[1256-1269]:ExpressionStatement[1256-1269]"
    }, {
      "left" : "return subtree;",
      "right" : "return subtree;",
      "info" : "ReturnStatement[1280-1295]:ReturnStatement[1280-1295]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[1382-1389]:Modifier[1382-1389]"
    }, {
      "left" : "void",
      "right" : "void",
      "info" : "PrimitiveType[1390-1394]:PrimitiveType[1390-1394]"
    }, {
      "left" : "collapseAssign",
      "right" : "collapseAssign",
      "info" : "SimpleName[1395-1409]:SimpleName[1395-1409]"
    }, {
      "left" : "Node assign",
      "right" : "Node assign",
      "info" : "SingleVariableDeclaration[1410-1421]:SingleVariableDeclaration[1410-1421]"
    }, {
      "left" : "Node expr",
      "right" : "Node expr",
      "info" : "SingleVariableDeclaration[1423-1432]:SingleVariableDeclaration[1423-1432]"
    }, {
      "left" : "Node exprParent",
      "right" : "Node exprParent",
      "info" : "SingleVariableDeclaration[1440-1455]:SingleVariableDeclaration[1440-1455]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1457-1975]:Block[1457-1975]"
    }, {
      "left" : "Node leftValue = assign.getFirstChild();",
      "right" : "Node leftValue = assign.getFirstChild();",
      "info" : "VariableDeclarationStatement[1463-1503]:VariableDeclarationStatement[1463-1503]"
    }, {
      "left" : "Node rightValue = leftValue.getNext();",
      "right" : "Node rightValue = leftValue.getNext();",
      "info" : "VariableDeclarationStatement[1508-1546]:VariableDeclarationStatement[1508-1546]"
    }, {
      "left" : "if (isCollapsibleValue(leftValue, true) &&\n        collapseAssignEqualTo(expr, exprParent, leftValue))",
      "right" : "if (isCollapsibleValue(leftValue, true) &&\n        collapseAssignEqualTo(expr, exprParent, leftValue))",
      "info" : "IfStatement[1551-1971]:IfStatement[1551-1971]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1654-1687]:Block[1654-1687]"
    }, {
      "left" : "reportCodeChange();",
      "right" : "reportCodeChange();",
      "info" : "ExpressionStatement[1662-1681]:ExpressionStatement[1662-1681]"
    }, {
      "left" : "if (isCollapsibleValue(rightValue, false) &&\n        collapseAssignEqualTo(expr, exprParent, rightValue))",
      "right" : "if (isCollapsibleValue(rightValue, false) &&\n        collapseAssignEqualTo(expr, exprParent, rightValue))",
      "info" : "IfStatement[1693-1971]:IfStatement[1693-1971]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1799-1832]:Block[1799-1832]"
    }, {
      "left" : "reportCodeChange();",
      "right" : "reportCodeChange();",
      "info" : "ExpressionStatement[1807-1826]:ExpressionStatement[1807-1826]"
    }, {
      "left" : "if (rightValue.isAssign())",
      "right" : "if (rightValue.isAssign())",
      "info" : "IfStatement[1838-1971]:IfStatement[1838-1971]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1865-1971]:Block[1865-1971]"
    }, {
      "left" : "collapseAssign(rightValue, expr, exprParent);",
      "right" : "collapseAssign(rightValue, expr, exprParent);",
      "info" : "ExpressionStatement[1920-1965]:ExpressionStatement[1920-1965]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[2441-2448]:Modifier[2441-2448]"
    }, {
      "left" : "static",
      "right" : "static",
      "info" : "Modifier[2449-2455]:Modifier[2449-2455]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[2456-2463]:PrimitiveType[2456-2463]"
    }, {
      "left" : "isCollapsibleValue",
      "right" : "isCollapsibleValue",
      "info" : "SimpleName[2464-2482]:SimpleName[2464-2482]"
    }, {
      "left" : "Node value",
      "right" : "Node value",
      "info" : "SingleVariableDeclaration[2483-2493]:SingleVariableDeclaration[2483-2493]"
    }, {
      "left" : "boolean isLValue",
      "right" : "boolean isLValue",
      "info" : "SingleVariableDeclaration[2495-2511]:SingleVariableDeclaration[2495-2511]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2513-3023]:Block[2513-3023]"
    }, {
      "left" : "switch (value.getType()) {\n      case Token.GETPROP:\n        // Do not collapse GETPROPs on arbitrary objects, because\n        // they may be implemented setter functions, and oftentimes\n        // setter functions fail on native objects. This is OK for \"THIS\"\n        // objects, because we assume that they are non-native.\n        return !isLValue || value.getFirstChild().isThis();\n\n      case Token.NAME:\n        return true;\n\n      default:\n        return NodeUtil.isImmutableValue(value);\n    }",
      "right" : "switch (value.getType()) {\n      case Token.GETPROP:\n        // Do not collapse GETPROPs on arbitrary objects, because\n        // they may be implemented setter functions, and oftentimes\n        // setter functions fail on native objects. This is OK for \"THIS\"\n        // objects, because we assume that they are non-native.\n        return !isLValue || value.getFirstChild().isThis();\n\n      case Token.NAME:\n        return true;\n\n      default:\n        return NodeUtil.isImmutableValue(value);\n    }",
      "info" : "SwitchStatement[2519-3019]:SwitchStatement[2519-3019]"
    }, {
      "left" : "case Token.GETPROP:",
      "right" : "case Token.GETPROP:",
      "info" : "SwitchCase[2552-2571]:SwitchCase[2552-2571]"
    }, {
      "left" : "return !isLValue || value.getFirstChild().isThis();",
      "right" : "return !isLValue || value.getFirstChild().isThis();",
      "info" : "ReturnStatement[2852-2903]:ReturnStatement[2852-2903]"
    }, {
      "left" : "case Token.NAME:",
      "right" : "case Token.NAME:",
      "info" : "SwitchCase[2911-2927]:SwitchCase[2911-2927]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[2936-2948]:ReturnStatement[2936-2948]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[2956-2964]:SwitchCase[2956-2964]"
    }, {
      "left" : "return NodeUtil.isImmutableValue(value);",
      "right" : "return NodeUtil.isImmutableValue(value);",
      "info" : "ReturnStatement[2973-3013]:ReturnStatement[2973-3013]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[3636-3643]:Modifier[3636-3643]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[3644-3651]:PrimitiveType[3644-3651]"
    }, {
      "left" : "collapseAssignEqualTo",
      "right" : "collapseAssignEqualTo",
      "info" : "SimpleName[3652-3673]:SimpleName[3652-3673]"
    }, {
      "left" : "Node expr",
      "right" : "Node expr",
      "info" : "SingleVariableDeclaration[3674-3683]:SingleVariableDeclaration[3674-3683]"
    }, {
      "left" : "Node exprParent",
      "right" : "Node exprParent",
      "info" : "SingleVariableDeclaration[3685-3700]:SingleVariableDeclaration[3685-3700]"
    }, {
      "left" : "Node value",
      "right" : "Node value",
      "info" : "SingleVariableDeclaration[3708-3718]:SingleVariableDeclaration[3708-3718]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3720-6796]:Block[3720-6796]"
    }, {
      "left" : "Node assign = expr.getFirstChild();",
      "right" : "Node assign = expr.getFirstChild();",
      "info" : "VariableDeclarationStatement[3726-3761]:VariableDeclarationStatement[3726-3761]"
    }, {
      "left" : "Node parent = exprParent;",
      "right" : "Node parent = exprParent;",
      "info" : "VariableDeclarationStatement[3766-3791]:VariableDeclarationStatement[3766-3791]"
    }, {
      "left" : "Node next = expr.getNext();",
      "right" : "Node next = expr.getNext();",
      "info" : "VariableDeclarationStatement[3796-3823]:VariableDeclarationStatement[3796-3823]"
    }, {
      "left" : "while (next != null)",
      "right" : "while (next != null)",
      "info" : "WhileStatement[3828-6773]:WhileStatement[3828-6773]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3849-6773]:Block[3849-6773]"
    }, {
      "left" : "switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }",
      "right" : "switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }",
      "info" : "SwitchStatement[3857-6767]:SwitchStatement[3857-6767]"
    }, {
      "left" : "case Token.AND:",
      "right" : "case Token.AND:",
      "info" : "SwitchCase[3891-3906]:SwitchCase[3891-3906]"
    }, {
      "left" : "case Token.OR:",
      "right" : "case Token.OR:",
      "info" : "SwitchCase[3915-3929]:SwitchCase[3915-3929]"
    }, {
      "left" : "case Token.HOOK:",
      "right" : "case Token.HOOK:",
      "info" : "SwitchCase[3938-3954]:SwitchCase[3938-3954]"
    }, {
      "left" : "case Token.IF:",
      "right" : "case Token.IF:",
      "info" : "SwitchCase[3963-3977]:SwitchCase[3963-3977]"
    }, {
      "left" : "case Token.RETURN:",
      "right" : "case Token.RETURN:",
      "info" : "SwitchCase[3986-4004]:SwitchCase[3986-4004]"
    }, {
      "left" : "case Token.EXPR_RESULT:",
      "right" : "case Token.EXPR_RESULT:",
      "info" : "SwitchCase[4013-4036]:SwitchCase[4013-4036]"
    }, {
      "left" : "parent = next;",
      "right" : "parent = next;",
      "info" : "ExpressionStatement[4084-4098]:ExpressionStatement[4084-4098]"
    }, {
      "left" : "next = next.getFirstChild();",
      "right" : "next = next.getFirstChild();",
      "info" : "ExpressionStatement[4109-4137]:ExpressionStatement[4109-4137]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4148-4154]:BreakStatement[4148-4154]"
    }, {
      "left" : "case Token.VAR:",
      "right" : "case Token.VAR:",
      "info" : "SwitchCase[4164-4179]:SwitchCase[4164-4179]"
    }, {
      "left" : "if (next.getFirstChild().hasChildren())",
      "right" : "if (next.getFirstChild().hasChildren())",
      "info" : "IfStatement[4190-4348]:IfStatement[4190-4348]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4230-4348]:Block[4230-4348]"
    }, {
      "left" : "parent = next.getFirstChild();",
      "right" : "parent = next.getFirstChild();",
      "info" : "ExpressionStatement[4244-4274]:ExpressionStatement[4244-4274]"
    }, {
      "left" : "next = parent.getFirstChild();",
      "right" : "next = parent.getFirstChild();",
      "info" : "ExpressionStatement[4287-4317]:ExpressionStatement[4287-4317]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[4330-4336]:BreakStatement[4330-4336]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[4359-4372]:ReturnStatement[4359-4372]"
    }, {
      "left" : "case Token.GETPROP:",
      "right" : "case Token.GETPROP:",
      "info" : "SwitchCase[4382-4401]:SwitchCase[4382-4401]"
    }, {
      "left" : "case Token.NAME:",
      "right" : "case Token.NAME:",
      "info" : "SwitchCase[4410-4426]:SwitchCase[4410-4426]"
    }, {
      "left" : "if (next.isQualifiedName())",
      "right" : "if (next.isQualifiedName())",
      "info" : "IfStatement[4437-5184]:IfStatement[4437-5184]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4465-5184]:Block[4465-5184]"
    }, {
      "left" : "String nextName = next.getQualifiedName();",
      "right" : "String nextName = next.getQualifiedName();",
      "info" : "VariableDeclarationStatement[4479-4521]:VariableDeclarationStatement[4479-4521]"
    }, {
      "left" : "if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName()))",
      "right" : "if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName()))",
      "info" : "IfStatement[4534-5172]:IfStatement[4534-5172]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4624-5172]:Block[4624-5172]"
    }, {
      "left" : "if (!isSafeReplacement(next, assign))",
      "right" : "if (!isSafeReplacement(next, assign))",
      "info" : "IfStatement[4912-4997]:IfStatement[4912-4997]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[4950-4997]:Block[4950-4997]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[4968-4981]:ReturnStatement[4968-4981]"
    }, {
      "left" : "exprParent.removeChild(expr);",
      "right" : "exprParent.removeChild(expr);",
      "info" : "ExpressionStatement[5013-5042]:ExpressionStatement[5013-5042]"
    }, {
      "left" : "expr.removeChild(assign);",
      "right" : "expr.removeChild(assign);",
      "info" : "ExpressionStatement[5057-5082]:ExpressionStatement[5057-5082]"
    }, {
      "left" : "parent.replaceChild(next, assign);",
      "right" : "parent.replaceChild(next, assign);",
      "info" : "ExpressionStatement[5097-5131]:ExpressionStatement[5097-5131]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[5146-5158]:ReturnStatement[5146-5158]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[5195-5208]:ReturnStatement[5195-5208]"
    }, {
      "left" : "case Token.ASSIGN:",
      "right" : "case Token.ASSIGN:",
      "info" : "SwitchCase[5218-5236]:SwitchCase[5218-5236]"
    }, {
      "left" : "Node leftSide = next.getFirstChild();",
      "right" : "Node leftSide = next.getFirstChild();",
      "info" : "VariableDeclarationStatement[5881-5918]:VariableDeclarationStatement[5881-5918]"
    }, {
      "left" : "if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis())",
      "right" : "if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis())",
      "info" : "IfStatement[5929-6239]:IfStatement[5929-6239]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6041-6194]:Block[6041-6194]"
    }, {
      "left" : "parent = next;",
      "right" : "parent = next;",
      "info" : "ExpressionStatement[6110-6124]:ExpressionStatement[6110-6124]"
    }, {
      "left" : "next = leftSide.getNext();",
      "right" : "next = leftSide.getNext();",
      "info" : "ExpressionStatement[6137-6163]:ExpressionStatement[6137-6163]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[6176-6182]:BreakStatement[6176-6182]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6200-6239]:Block[6200-6239]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[6214-6227]:ReturnStatement[6214-6227]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[6249-6257]:SwitchCase[6249-6257]"
    }, {
      "left" : "if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value))",
      "right" : "if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value))",
      "info" : "IfStatement[6268-6690]:IfStatement[6268-6690]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6349-6690]:Block[6349-6690]"
    }, {
      "left" : "exprParent.removeChild(expr);",
      "right" : "exprParent.removeChild(expr);",
      "info" : "ExpressionStatement[6539-6568]:ExpressionStatement[6539-6568]"
    }, {
      "left" : "expr.removeChild(assign);",
      "right" : "expr.removeChild(assign);",
      "info" : "ExpressionStatement[6581-6606]:ExpressionStatement[6581-6606]"
    }, {
      "left" : "parent.replaceChild(next, assign);",
      "right" : "parent.replaceChild(next, assign);",
      "info" : "ExpressionStatement[6619-6653]:ExpressionStatement[6619-6653]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[6666-6678]:ReturnStatement[6666-6678]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[6746-6759]:ReturnStatement[6746-6759]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[6779-6792]:ReturnStatement[6779-6792]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[6942-6949]:Modifier[6942-6949]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[6950-6957]:PrimitiveType[6950-6957]"
    }, {
      "left" : "isSafeReplacement",
      "right" : "isSafeReplacement",
      "info" : "SimpleName[6958-6975]:SimpleName[6958-6975]"
    }, {
      "left" : "Node node",
      "right" : "Node node",
      "info" : "SingleVariableDeclaration[6976-6985]:SingleVariableDeclaration[6976-6985]"
    }, {
      "left" : "Node replacement",
      "right" : "Node replacement",
      "info" : "SingleVariableDeclaration[6987-7003]:SingleVariableDeclaration[6987-7003]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7005-7321]:Block[7005-7358]"
    }, {
      "left" : "if (node.isName())",
      "right" : "if (node.isName())",
      "info" : "IfStatement[7057-7102]:IfStatement[7057-7102]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7076-7102]:Block[7076-7102]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[7084-7096]:ReturnStatement[7084-7096]"
    }, {
      "left" : "Preconditions.checkArgument(node.isGetProp());",
      "right" : "Preconditions.checkArgument(node.isGetProp());",
      "info" : "ExpressionStatement[7107-7153]:ExpressionStatement[7107-7153]"
    }, {
      "left" : "node = node.getFirstChild();",
      "right" : "node = node.getFirstChild();",
      "info" : "ExpressionStatement[7161-7189]:ExpressionStatement[7192-7220]"
    }, {
      "left" : "if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement))",
      "right" : "if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement))",
      "info" : "IfStatement[7194-7299]:IfStatement[7231-7336]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7272-7299]:Block[7309-7336]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[7280-7293]:ReturnStatement[7317-7330]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[7305-7317]:ReturnStatement[7342-7354]"
    }, {
      "left" : "private",
      "right" : "private",
      "info" : "Modifier[7410-7417]:Modifier[7447-7454]"
    }, {
      "left" : "boolean",
      "right" : "boolean",
      "info" : "PrimitiveType[7418-7425]:PrimitiveType[7455-7462]"
    }, {
      "left" : "isNameAssignedTo",
      "right" : "isNameAssignedTo",
      "info" : "SimpleName[7426-7442]:SimpleName[7463-7479]"
    }, {
      "left" : "String name",
      "right" : "String name",
      "info" : "SingleVariableDeclaration[7443-7454]:SingleVariableDeclaration[7480-7491]"
    }, {
      "left" : "Node node",
      "right" : "Node node",
      "info" : "SingleVariableDeclaration[7456-7465]:SingleVariableDeclaration[7493-7502]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7467-7856]:Block[7504-7893]"
    }, {
      "left" : "for (Node c = node.getFirstChild(); c != null; c = c.getNext())",
      "right" : "for (Node c = node.getFirstChild(); c != null; c = c.getNext())",
      "info" : "ForStatement[7473-7612]:ForStatement[7510-7649]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7537-7612]:Block[7574-7649]"
    }, {
      "left" : "if (isNameAssignedTo(name, c))",
      "right" : "if (isNameAssignedTo(name, c))",
      "info" : "IfStatement[7545-7606]:IfStatement[7582-7643]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7576-7606]:Block[7613-7643]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[7586-7598]:ReturnStatement[7623-7635]"
    }, {
      "left" : "if (node.isName())",
      "right" : "if (node.isName())",
      "info" : "IfStatement[7618-7833]:IfStatement[7655-7870]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7637-7833]:Block[7674-7870]"
    }, {
      "left" : "Node parent = node.getParent();",
      "right" : "Node parent = node.getParent();",
      "info" : "VariableDeclarationStatement[7645-7676]:VariableDeclarationStatement[7682-7713]"
    }, {
      "left" : "if (parent.isAssign() && parent.getFirstChild() == node)",
      "right" : "if (parent.isAssign() && parent.getFirstChild() == node)",
      "info" : "IfStatement[7683-7827]:IfStatement[7720-7864]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7740-7827]:Block[7777-7864]"
    }, {
      "left" : "if (name.equals(node.getString()))",
      "right" : "if (name.equals(node.getString()))",
      "info" : "IfStatement[7750-7819]:IfStatement[7787-7856]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7785-7819]:Block[7822-7856]"
    }, {
      "left" : "return true;",
      "right" : "return true;",
      "info" : "ReturnStatement[7797-7809]:ReturnStatement[7834-7846]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[7839-7852]:ReturnStatement[7876-7889]"
    } ]
  },
  "interFileMappings" : { }
}