{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "JsdocToEs6TypedConverter",
      "right" : "JsdocToEs6TypedConverter",
      "info" : "TypeDeclaration[1061-3414]:TypeDeclaration[2156-11302]"
    }, {
      "left" : "private final AbstractCompiler compiler;",
      "right" : "private final AbstractCompiler compiler;",
      "info" : "FieldDeclaration[1416-1456]:FieldDeclaration[2511-2551]"
    }, {
      "left" : "public JsdocToEs6TypedConverter(AbstractCompiler compiler)",
      "right" : "public JsdocToEs6TypedConverter(AbstractCompiler compiler)",
      "info" : "MethodDeclaration[1460-1554]:MethodDeclaration[2555-2649]"
    }, {
      "left" : "public void process(Node externs, Node root)",
      "right" : "public void process(Node externs, Node root)",
      "info" : "MethodDeclaration[1558-1670]:MethodDeclaration[2653-2765]"
    }, {
      "left" : "public void visit(NodeTraversal t, Node n, Node parent)",
      "right" : "public void visit(NodeTraversal t, Node n, Node parent)",
      "info" : "MethodDeclaration[1674-3189]:MethodDeclaration[2769-4284]"
    }, {
      "left" : "private void setTypeExpression(Node n, JSTypeExpression type)",
      "right" : "private void setTypeExpression(Node n, JSTypeExpression type)",
      "info" : "MethodDeclaration[3193-3412]:MethodDeclaration[4288-4533]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1519-1554]:Block[2614-2649]"
    }, {
      "left" : "this.compiler = compiler;",
      "right" : "this.compiler = compiler;",
      "info" : "ExpressionStatement[1525-1550]:ExpressionStatement[2620-2645]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1615-1670]:Block[2710-2765]"
    }, {
      "left" : "NodeTraversal.traverse(compiler, root, this);",
      "right" : "NodeTraversal.traverse(compiler, root, this);",
      "info" : "ExpressionStatement[1621-1666]:ExpressionStatement[2716-2761]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1742-3189]:Block[2837-4284]"
    }, {
      "left" : "JSDocInfo bestJSDocInfo = NodeUtil.getBestJSDocInfo(n);",
      "right" : "JSDocInfo bestJSDocInfo = NodeUtil.getBestJSDocInfo(n);",
      "info" : "VariableDeclarationStatement[1748-1803]:VariableDeclarationStatement[2843-2898]"
    }, {
      "left" : "switch (n.getType()) {\n      case Token.FUNCTION:\n        if (bestJSDocInfo != null) {\n          setTypeExpression(n, bestJSDocInfo.getReturnType());\n        }\n        break;\n      case Token.NAME:\n      case Token.GETPROP:\n        if (parent == null) {\n          break;\n        }\n        if (parent.isVar() || parent.isAssign() || parent.isExprResult()) {\n          if (bestJSDocInfo != null) {\n            setTypeExpression(n, bestJSDocInfo.getType());\n          }\n        } else if (parent.isParamList()) {\n          JSDocInfo parentDocInfo = NodeUtil.getBestJSDocInfo(parent);\n          if (parentDocInfo == null) {\n            break;\n          }\n          JSTypeExpression parameterType =\n              parentDocInfo.getParameterType(n.getString());\n          if (parameterType != null) {\n            Node attachTypeExpr = n;\n            // Modify the primary AST to represent a function parameter as a\n            // REST node, if the type indicates it is a rest parameter.\n            if (parameterType.getRoot().getType() == Token.ELLIPSIS) {\n              attachTypeExpr = Node.newString(Token.REST, n.getString());\n              n.getParent().replaceChild(n, attachTypeExpr);\n              compiler.reportCodeChange();\n            }\n            setTypeExpression(attachTypeExpr, parameterType);\n          }\n        }\n        break;\n      default:\n        break;\n    }",
      "right" : "switch (n.getType()) {\n      case Token.FUNCTION:\n        if (bestJSDocInfo != null) {\n          setTypeExpression(n, bestJSDocInfo.getReturnType());\n        }\n        break;\n      case Token.NAME:\n      case Token.GETPROP:\n        if (parent == null) {\n          break;\n        }\n        if (parent.isVar() || parent.isAssign() || parent.isExprResult()) {\n          if (bestJSDocInfo != null) {\n            setTypeExpression(n, bestJSDocInfo.getType());\n          }\n        } else if (parent.isParamList()) {\n          JSDocInfo parentDocInfo = NodeUtil.getBestJSDocInfo(parent);\n          if (parentDocInfo == null) {\n            break;\n          }\n          JSTypeExpression parameterType =\n              parentDocInfo.getParameterType(n.getString());\n          if (parameterType != null) {\n            Node attachTypeExpr = n;\n            // Modify the primary AST to represent a function parameter as a\n            // REST node, if the type indicates it is a rest parameter.\n            if (parameterType.getRoot().getType() == Token.ELLIPSIS) {\n              attachTypeExpr = Node.newString(Token.REST, n.getString());\n              n.getParent().replaceChild(n, attachTypeExpr);\n              compiler.reportCodeChange();\n            }\n            setTypeExpression(attachTypeExpr, parameterType);\n          }\n        }\n        break;\n      default:\n        break;\n    }",
      "info" : "SwitchStatement[1808-3185]:SwitchStatement[2903-4280]"
    }, {
      "left" : "case Token.FUNCTION:",
      "right" : "case Token.FUNCTION:",
      "info" : "SwitchCase[1837-1857]:SwitchCase[2932-2952]"
    }, {
      "left" : "if (bestJSDocInfo != null)",
      "right" : "if (bestJSDocInfo != null)",
      "info" : "IfStatement[1866-1967]:IfStatement[2961-3062]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[1893-1967]:Block[2988-3062]"
    }, {
      "left" : "setTypeExpression(n, bestJSDocInfo.getReturnType());",
      "right" : "setTypeExpression(n, bestJSDocInfo.getReturnType());",
      "info" : "ExpressionStatement[1905-1957]:ExpressionStatement[3000-3052]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[1976-1982]:BreakStatement[3071-3077]"
    }, {
      "left" : "case Token.NAME:",
      "right" : "case Token.NAME:",
      "info" : "SwitchCase[1989-2005]:SwitchCase[3084-3100]"
    }, {
      "left" : "case Token.GETPROP:",
      "right" : "case Token.GETPROP:",
      "info" : "SwitchCase[2012-2031]:SwitchCase[3107-3126]"
    }, {
      "left" : "if (parent == null)",
      "right" : "if (parent == null)",
      "info" : "IfStatement[2040-2088]:IfStatement[3135-3183]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2060-2088]:Block[3155-3183]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[2072-2078]:BreakStatement[3167-3173]"
    }, {
      "left" : "if (parent.isVar() || parent.isAssign() || parent.isExprResult())",
      "right" : "if (parent.isVar() || parent.isAssign() || parent.isExprResult())",
      "info" : "IfStatement[2097-3134]:IfStatement[3192-4229]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2163-2284]:Block[3258-3379]"
    }, {
      "left" : "if (bestJSDocInfo != null)",
      "right" : "if (bestJSDocInfo != null)",
      "info" : "IfStatement[2175-2274]:IfStatement[3270-3369]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2202-2274]:Block[3297-3369]"
    }, {
      "left" : "setTypeExpression(n, bestJSDocInfo.getType());",
      "right" : "setTypeExpression(n, bestJSDocInfo.getType());",
      "info" : "ExpressionStatement[2216-2262]:ExpressionStatement[3311-3357]"
    }, {
      "left" : "if (parent.isParamList())",
      "right" : "if (parent.isParamList())",
      "info" : "IfStatement[2290-3134]:IfStatement[3385-4229]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2316-3134]:Block[3411-4229]"
    }, {
      "left" : "JSDocInfo parentDocInfo = NodeUtil.getBestJSDocInfo(parent);",
      "right" : "JSDocInfo parentDocInfo = NodeUtil.getBestJSDocInfo(parent);",
      "info" : "VariableDeclarationStatement[2328-2388]:VariableDeclarationStatement[3423-3483]"
    }, {
      "left" : "if (parentDocInfo == null)",
      "right" : "if (parentDocInfo == null)",
      "info" : "IfStatement[2399-2458]:IfStatement[3494-3553]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2426-2458]:Block[3521-3553]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[2440-2446]:BreakStatement[3535-3541]"
    }, {
      "left" : "JSTypeExpression parameterType =\n              parentDocInfo.getParameterType(n.getString());",
      "right" : "JSTypeExpression parameterType =\n              parentDocInfo.getParameterType(n.getString());",
      "info" : "VariableDeclarationStatement[2469-2562]:VariableDeclarationStatement[3564-3657]"
    }, {
      "left" : "if (parameterType != null)",
      "right" : "if (parameterType != null)",
      "info" : "IfStatement[2573-3124]:IfStatement[3668-4219]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2600-3124]:Block[3695-4219]"
    }, {
      "left" : "Node attachTypeExpr = n;",
      "right" : "Node attachTypeExpr = n;",
      "info" : "VariableDeclarationStatement[2614-2638]:VariableDeclarationStatement[3709-3733]"
    }, {
      "left" : "if (parameterType.getRoot().getType() == Token.ELLIPSIS)",
      "right" : "if (parameterType.getRoot().getType() == Token.ELLIPSIS)",
      "info" : "IfStatement[2800-3050]:IfStatement[3895-4145]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[2857-3050]:Block[3952-4145]"
    }, {
      "left" : "attachTypeExpr = Node.newString(Token.REST, n.getString());",
      "right" : "attachTypeExpr = Node.newString(Token.REST, n.getString());",
      "info" : "ExpressionStatement[2873-2932]:ExpressionStatement[3968-4027]"
    }, {
      "left" : "n.getParent().replaceChild(n, attachTypeExpr);",
      "right" : "n.getParent().replaceChild(n, attachTypeExpr);",
      "info" : "ExpressionStatement[2947-2993]:ExpressionStatement[4042-4088]"
    }, {
      "left" : "compiler.reportCodeChange();",
      "right" : "compiler.reportCodeChange();",
      "info" : "ExpressionStatement[3008-3036]:ExpressionStatement[4103-4131]"
    }, {
      "left" : "setTypeExpression(attachTypeExpr, parameterType);",
      "right" : "setTypeExpression(attachTypeExpr, parameterType);",
      "info" : "ExpressionStatement[3063-3112]:ExpressionStatement[4158-4207]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[3143-3149]:BreakStatement[4238-4244]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[3156-3164]:SwitchCase[4251-4259]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[3173-3179]:BreakStatement[4268-4274]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3255-3412]:Block[4350-4533]"
    }, {
      "left" : "TypeDeclarationNode node = convert(type);",
      "right" : "TypeDeclarationNode node = TypeDeclarationsIRFactory.convert(type);",
      "info" : "VariableDeclarationStatement[3261-3302]:VariableDeclarationStatement[4356-4423]"
    }, {
      "left" : "if (node != null)",
      "right" : "if (node != null)",
      "info" : "IfStatement[3307-3408]:IfStatement[4428-4529]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[3325-3408]:Block[4446-4529]"
    }, {
      "left" : "n.setDeclaredTypeExpression(node);",
      "right" : "n.setDeclaredTypeExpression(node);",
      "info" : "ExpressionStatement[3333-3367]:ExpressionStatement[4454-4488]"
    }, {
      "left" : "compiler.reportCodeChange();",
      "right" : "compiler.reportCodeChange();",
      "info" : "ExpressionStatement[3374-3402]:ExpressionStatement[4495-4523]"
    } ]
  },
  "interFileMappings" : {
    "Moved from File: src/com/google/javascript/jscomp/parsing/TypeDeclarationsIRFactory.java" : {
      "matchedElements" : [
 {
        "left" : "TypeDeclarationsIRFactory",
        "right" : "TypeDeclarationsIRFactory",
        "info" : "TypeDeclaration[2042-8492]:TypeDeclaration[4537-11300]"
      }, {
        "left" : "private static final Function<Node, TypeDeclarationNode> CONVERT_TYPE_NODE =\n      new Function<Node, TypeDeclarationNode>() {\n        @Override\n        public TypeDeclarationNode apply(Node node) {\n          return convertTypeNodeAST(node);\n        }\n      };",
        "right" : "private static final Function<Node, TypeDeclarationNode> CONVERT_TYPE_NODE =\n        new Function<Node, TypeDeclarationNode>() {\n          @Override\n          public TypeDeclarationNode apply(Node node) {\n            return convertTypeNodeAST(node);\n          }\n        };",
        "info" : "FieldDeclaration[2294-2554]:FieldDeclaration[4810-5082]"
      }, {
        "left" : "public TypeDeclarationNode apply(Node node)",
        "right" : "public TypeDeclarationNode apply(Node node)",
        "info" : "MethodDeclaration[2429-2545]:MethodDeclaration[4949-5071]"
      }, {
        "left" : "public static TypeDeclarationNode convert(@Nullable JSTypeExpression typeExpr)",
        "right" : "public static TypeDeclarationNode convert(@Nullable JSTypeExpression typeExpr)",
        "info" : "MethodDeclaration[2558-2758]:MethodDeclaration[5088-5300]"
      }, {
        "left" : "public static TypeDeclarationNode convertTypeNodeAST(Node n)",
        "right" : "public static TypeDeclarationNode convertTypeNodeAST(Node n)",
        "info" : "MethodDeclaration[2762-8490]:MethodDeclaration[5306-11296]"
      } ],
      "mappings" : [
 {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[2491-2545]:Block[5013-5071]"
      }, {
        "left" : "return convertTypeNodeAST(node);",
        "right" : "return convertTypeNodeAST(node);",
        "info" : "ReturnStatement[2503-2535]:ReturnStatement[5027-5059]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[2649-2758]:Block[5181-5300]"
      }, {
        "left" : "if (typeExpr == null)",
        "right" : "if (typeExpr == null)",
        "info" : "IfStatement[2655-2703]:IfStatement[5189-5241]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[2677-2703]:Block[5211-5241]"
      }, {
        "left" : "return null;",
        "right" : "return null;",
        "info" : "ReturnStatement[2685-2697]:ReturnStatement[5221-5233]"
      }, {
        "left" : "return convertTypeNodeAST(typeExpr.getRoot());",
        "right" : "return convertTypeNodeAST(typeExpr.getRoot());",
        "info" : "ReturnStatement[2708-2754]:ReturnStatement[5248-5294]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[3366-8490]:Block[5934-11296]"
      }, {
        "left" : "int token = n.getType();",
        "right" : "int token = n.getType();",
        "info" : "VariableDeclarationStatement[3372-3396]:VariableDeclarationStatement[5942-5966]"
      }, {
        "left" : "switch (token) {\n      case Token.STAR:\n      case Token.EMPTY: // for function types that don't declare a return type\n        return anyType();\n      case Token.VOID:\n        return undefinedType();\n      case Token.BANG:\n        // TODO(alexeagle): non-nullable is assumed to be the default\n        return convertTypeNodeAST(n.getFirstChild());\n      case Token.STRING:\n        String typeName = n.getString();\n        switch (typeName) {\n          case \"boolean\":\n            return booleanType();\n          case \"number\":\n            return numberType();\n          case \"string\":\n            return stringType();\n          case \"null\":\n          case \"undefined\":\n          case \"void\":\n            return null;\n          default:\n            TypeDeclarationNode root = namedType(typeName);\n            if (n.getChildCount() > 0 && n.getFirstChild().isBlock()) {\n              Node block = n.getFirstChild();\n              if (\"Array\".equals(typeName)) {\n                return arrayType(convertTypeNodeAST(block.getFirstChild()));\n              }\n              return parameterizedType(root,\n                  Iterables.filter(\n                      Iterables.transform(block.children(), CONVERT_TYPE_NODE),\n                      Predicates.notNull()));\n            }\n            return root;\n        }\n      case Token.QMARK:\n        Node child = n.getFirstChild();\n        return child == null\n            ? anyType()\n            // For now, our ES6_TYPED language doesn't support nullable\n            // so we drop it before building the tree.\n            // : nullable(convertTypeNodeAST(child));\n            : convertTypeNodeAST(child);\n      case Token.LC:\n        LinkedHashMap<String, TypeDeclarationNode> properties = new LinkedHashMap<>();\n        for (Node field : n.getFirstChild().children()) {\n          boolean isFieldTypeDeclared = field.getType() == Token.COLON;\n          Node fieldNameNode = isFieldTypeDeclared ? field.getFirstChild() : field;\n          String fieldName = fieldNameNode.getString();\n          if (fieldName.startsWith(\"'\") || fieldName.startsWith(\"\\\"\")) {\n            fieldName = fieldName.substring(1, fieldName.length() - 1);\n          }\n          TypeDeclarationNode fieldType = isFieldTypeDeclared\n              ? convertTypeNodeAST(field.getLastChild()) : null;\n          properties.put(fieldName, fieldType);\n        }\n        return recordType(properties);\n      case Token.ELLIPSIS:\n        return arrayType(convertTypeNodeAST(n.getFirstChild()));\n      case Token.PIPE:\n        ImmutableList<TypeDeclarationNode> types = FluentIterable\n            .from(n.children()).transform(CONVERT_TYPE_NODE)\n            .filter(Predicates.notNull()).toList();\n        switch (types.size()) {\n          case 0:\n            return null;\n          case 1:\n            return types.get(0);\n          default:\n            return unionType(types);\n        }\n      case Token.FUNCTION:\n        Node returnType = anyType();\n        LinkedHashMap<String, TypeDeclarationNode> requiredParams = new LinkedHashMap<>();\n        LinkedHashMap<String, TypeDeclarationNode> optionalParams = new LinkedHashMap<>();\n        String restName = null;\n        TypeDeclarationNode restType = null;\n        for (Node child2 : n.children()) {\n          if (child2.isParamList()) {\n            int paramIdx = 1;\n            for (Node param : child2.children()) {\n              String paramName = \"p\" + paramIdx++;\n              if (param.getType() == Token.ELLIPSIS) {\n                if (param.getFirstChild() != null) {\n                  restType = arrayType(convertTypeNodeAST(param.getFirstChild()));\n                }\n                restName = paramName;\n              } else {\n                TypeDeclarationNode paramNode = convertTypeNodeAST(param);\n                if (paramNode.getType() == Token.OPTIONAL_PARAMETER) {\n                  optionalParams.put(paramName,\n                      (TypeDeclarationNode) paramNode.removeFirstChild());\n                } else {\n                  requiredParams.put(paramName, convertTypeNodeAST(param));\n                }\n              }\n            }\n          } else if (child2.isNew()) {\n            // TODO(alexeagle): keep the constructor signatures on the tree, and emit them following\n            // the syntax in TypeScript 1.4 spec, section 3.7.8 Constructor Type Literals\n          } else if (child2.isThis()) {\n            // Not expressible in TypeScript syntax, so we omit them from the tree.\n            // They could be added as properties on the result node.\n          } else {\n            returnType = convertTypeNodeAST(child2);\n          }\n        }\n        return functionType(returnType, requiredParams, optionalParams, restName, restType);\n      case Token.EQUALS:\n        TypeDeclarationNode optionalParam = convertTypeNodeAST(n.getFirstChild());\n        return optionalParam == null ? null : optionalParameter(optionalParam);\n      default:\n        throw new IllegalArgumentException(\n            \"Unsupported node type: \" + Token.name(n.getType())\n                + \" \" + n.toStringTree());\n    }",
        "right" : "switch (token) {\n        case Token.STAR:\n        case Token.EMPTY: // for function types that don't declare a return type\n          return anyType();\n        case Token.VOID:\n          return undefinedType();\n        case Token.BANG:\n          // TODO(alexeagle): non-nullable is assumed to be the default\n          return convertTypeNodeAST(n.getFirstChild());\n        case Token.STRING:\n          String typeName = n.getString();\n          switch (typeName) {\n            case \"boolean\":\n              return booleanType();\n            case \"number\":\n              return numberType();\n            case \"string\":\n              return stringType();\n            case \"null\":\n            case \"undefined\":\n            case \"void\":\n              return null;\n            default:\n              TypeDeclarationNode root = namedType(typeName);\n              if (n.getChildCount() > 0 && n.getFirstChild().isBlock()) {\n                Node block = n.getFirstChild();\n                if (\"Array\".equals(typeName)) {\n                  return arrayType(convertTypeNodeAST(block.getFirstChild()));\n                }\n                return parameterizedType(root,\n                    Iterables.filter(\n                        Iterables.transform(block.children(), CONVERT_TYPE_NODE),\n                        Predicates.notNull()));\n              }\n              return root;\n          }\n        case Token.QMARK:\n          Node child = n.getFirstChild();\n          return child == null\n              ? anyType()\n              // For now, our ES6_TYPED language doesn't support nullable\n              // so we drop it before building the tree.\n              // : nullable(convertTypeNodeAST(child));\n              : convertTypeNodeAST(child);\n        case Token.LC:\n          LinkedHashMap<String, TypeDeclarationNode> properties = new LinkedHashMap<>();\n          for (Node field : n.getFirstChild().children()) {\n            boolean isFieldTypeDeclared = field.getType() == Token.COLON;\n            Node fieldNameNode = isFieldTypeDeclared ? field.getFirstChild() : field;\n            String fieldName = fieldNameNode.getString();\n            if (fieldName.startsWith(\"'\") || fieldName.startsWith(\"\\\"\")) {\n              fieldName = fieldName.substring(1, fieldName.length() - 1);\n            }\n            TypeDeclarationNode fieldType = isFieldTypeDeclared\n                ? convertTypeNodeAST(field.getLastChild()) : null;\n            properties.put(fieldName, fieldType);\n          }\n          return recordType(properties);\n        case Token.ELLIPSIS:\n          return arrayType(convertTypeNodeAST(n.getFirstChild()));\n        case Token.PIPE:\n          ImmutableList<TypeDeclarationNode> types = FluentIterable\n              .from(n.children()).transform(CONVERT_TYPE_NODE)\n              .filter(Predicates.notNull()).toList();\n          switch (types.size()) {\n            case 0:\n              return null;\n            case 1:\n              return types.get(0);\n            default:\n              return unionType(types);\n          }\n        case Token.FUNCTION:\n          Node returnType = anyType();\n          LinkedHashMap<String, TypeDeclarationNode> requiredParams = new LinkedHashMap<>();\n          LinkedHashMap<String, TypeDeclarationNode> optionalParams = new LinkedHashMap<>();\n          String restName = null;\n          TypeDeclarationNode restType = null;\n          for (Node child2 : n.children()) {\n            if (child2.isParamList()) {\n              int paramIdx = 1;\n              for (Node param : child2.children()) {\n                String paramName = \"p\" + paramIdx++;\n                if (param.getType() == Token.ELLIPSIS) {\n                  if (param.getFirstChild() != null) {\n                    restType = arrayType(convertTypeNodeAST(param.getFirstChild()));\n                  }\n                  restName = paramName;\n                } else {\n                  TypeDeclarationNode paramNode = convertTypeNodeAST(param);\n                  if (paramNode.getType() == Token.OPTIONAL_PARAMETER) {\n                    optionalParams.put(paramName,\n                        (TypeDeclarationNode) paramNode.removeFirstChild());\n                  } else {\n                    requiredParams.put(paramName, convertTypeNodeAST(param));\n                  }\n                }\n              }\n            } else if (child2.isNew()) {\n              // TODO(alexeagle): keep the constructor signatures on the tree, and emit them following\n              // the syntax in TypeScript 1.4 spec, section 3.7.8 Constructor Type Literals\n            } else if (child2.isThis()) {\n              // Not expressible in TypeScript syntax, so we omit them from the tree.\n              // They could be added as properties on the result node.\n            } else {\n              returnType = convertTypeNodeAST(child2);\n            }\n          }\n          return functionType(returnType, requiredParams, optionalParams, restName, restType);\n        case Token.EQUALS:\n          TypeDeclarationNode optionalParam = convertTypeNodeAST(n.getFirstChild());\n          return optionalParam == null ? null : optionalParameter(optionalParam);\n        default:\n          throw new IllegalArgumentException(\n              \"Unsupported node type: \" + Token.name(n.getType())\n                  + \" \" + n.toStringTree());\n      }",
        "info" : "SwitchStatement[3401-8486]:SwitchStatement[5973-11290]"
      }, {
        "left" : "case Token.STAR:",
        "right" : "case Token.STAR:",
        "info" : "SwitchCase[3424-3440]:SwitchCase[5998-6014]"
      }, {
        "left" : "case Token.EMPTY:",
        "right" : "case Token.EMPTY:",
        "info" : "SwitchCase[3447-3464]:SwitchCase[6023-6040]"
      }, {
        "left" : "return anyType();",
        "right" : "return anyType();",
        "info" : "ReturnStatement[3528-3545]:ReturnStatement[6106-6123]"
      }, {
        "left" : "case Token.VOID:",
        "right" : "case Token.VOID:",
        "info" : "SwitchCase[3552-3568]:SwitchCase[6132-6148]"
      }, {
        "left" : "return undefinedType();",
        "right" : "return undefinedType();",
        "info" : "ReturnStatement[3577-3600]:ReturnStatement[6159-6182]"
      }, {
        "left" : "case Token.BANG:",
        "right" : "case Token.BANG:",
        "info" : "SwitchCase[3607-3623]:SwitchCase[6191-6207]"
      }, {
        "left" : "return convertTypeNodeAST(n.getFirstChild());",
        "right" : "return convertTypeNodeAST(n.getFirstChild());",
        "info" : "ReturnStatement[3702-3747]:ReturnStatement[6290-6335]"
      }, {
        "left" : "case Token.STRING:",
        "right" : "case Token.STRING:",
        "info" : "SwitchCase[3754-3772]:SwitchCase[6344-6362]"
      }, {
        "left" : "String typeName = n.getString();",
        "right" : "String typeName = n.getString();",
        "info" : "VariableDeclarationStatement[3781-3813]:VariableDeclarationStatement[6373-6405]"
      }, {
        "left" : "switch (typeName) {\n          case \"boolean\":\n            return booleanType();\n          case \"number\":\n            return numberType();\n          case \"string\":\n            return stringType();\n          case \"null\":\n          case \"undefined\":\n          case \"void\":\n            return null;\n          default:\n            TypeDeclarationNode root = namedType(typeName);\n            if (n.getChildCount() > 0 && n.getFirstChild().isBlock()) {\n              Node block = n.getFirstChild();\n              if (\"Array\".equals(typeName)) {\n                return arrayType(convertTypeNodeAST(block.getFirstChild()));\n              }\n              return parameterizedType(root,\n                  Iterables.filter(\n                      Iterables.transform(block.children(), CONVERT_TYPE_NODE),\n                      Predicates.notNull()));\n            }\n            return root;\n        }",
        "right" : "switch (typeName) {\n            case \"boolean\":\n              return booleanType();\n            case \"number\":\n              return numberType();\n            case \"string\":\n              return stringType();\n            case \"null\":\n            case \"undefined\":\n            case \"void\":\n              return null;\n            default:\n              TypeDeclarationNode root = namedType(typeName);\n              if (n.getChildCount() > 0 && n.getFirstChild().isBlock()) {\n                Node block = n.getFirstChild();\n                if (\"Array\".equals(typeName)) {\n                  return arrayType(convertTypeNodeAST(block.getFirstChild()));\n                }\n                return parameterizedType(root,\n                    Iterables.filter(\n                        Iterables.transform(block.children(), CONVERT_TYPE_NODE),\n                        Predicates.notNull()));\n              }\n              return root;\n          }",
        "info" : "SwitchStatement[3822-4708]:SwitchStatement[6416-7350]"
      }, {
        "left" : "case \"boolean\":",
        "right" : "case \"boolean\":",
        "info" : "SwitchCase[3852-3867]:SwitchCase[6448-6463]"
      }, {
        "left" : "return booleanType();",
        "right" : "return booleanType();",
        "info" : "ReturnStatement[3880-3901]:ReturnStatement[6478-6499]"
      }, {
        "left" : "case \"number\":",
        "right" : "case \"number\":",
        "info" : "SwitchCase[3912-3926]:SwitchCase[6512-6526]"
      }, {
        "left" : "return numberType();",
        "right" : "return numberType();",
        "info" : "ReturnStatement[3939-3959]:ReturnStatement[6541-6561]"
      }, {
        "left" : "case \"string\":",
        "right" : "case \"string\":",
        "info" : "SwitchCase[3970-3984]:SwitchCase[6574-6588]"
      }, {
        "left" : "return stringType();",
        "right" : "return stringType();",
        "info" : "ReturnStatement[3997-4017]:ReturnStatement[6603-6623]"
      }, {
        "left" : "case \"null\":",
        "right" : "case \"null\":",
        "info" : "SwitchCase[4028-4040]:SwitchCase[6636-6648]"
      }, {
        "left" : "case \"undefined\":",
        "right" : "case \"undefined\":",
        "info" : "SwitchCase[4051-4068]:SwitchCase[6661-6678]"
      }, {
        "left" : "case \"void\":",
        "right" : "case \"void\":",
        "info" : "SwitchCase[4079-4091]:SwitchCase[6691-6703]"
      }, {
        "left" : "return null;",
        "right" : "return null;",
        "info" : "ReturnStatement[4104-4116]:ReturnStatement[6718-6730]"
      }, {
        "left" : "default:",
        "right" : "default:",
        "info" : "SwitchCase[4127-4135]:SwitchCase[6743-6751]"
      }, {
        "left" : "TypeDeclarationNode root = namedType(typeName);",
        "right" : "TypeDeclarationNode root = namedType(typeName);",
        "info" : "VariableDeclarationStatement[4148-4195]:VariableDeclarationStatement[6766-6813]"
      }, {
        "left" : "if (n.getChildCount() > 0 && n.getFirstChild().isBlock())",
        "right" : "if (n.getChildCount() > 0 && n.getFirstChild().isBlock())",
        "info" : "IfStatement[4208-4673]:IfStatement[6828-7311]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[4266-4673]:Block[6886-7311]"
      }, {
        "left" : "Node block = n.getFirstChild();",
        "right" : "Node block = n.getFirstChild();",
        "info" : "VariableDeclarationStatement[4282-4313]:VariableDeclarationStatement[6904-6935]"
      }, {
        "left" : "if (\"Array\".equals(typeName))",
        "right" : "if (\"Array\".equals(typeName))",
        "info" : "IfStatement[4328-4452]:IfStatement[6952-7080]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[4358-4452]:Block[6982-7080]"
      }, {
        "left" : "return arrayType(convertTypeNodeAST(block.getFirstChild()));",
        "right" : "return arrayType(convertTypeNodeAST(block.getFirstChild()));",
        "info" : "ReturnStatement[4376-4436]:ReturnStatement[7002-7062]"
      }, {
        "left" : "return parameterizedType(root,\n                  Iterables.filter(\n                      Iterables.transform(block.children(), CONVERT_TYPE_NODE),\n                      Predicates.notNull()));",
        "right" : "return parameterizedType(root,\n                    Iterables.filter(\n                        Iterables.transform(block.children(), CONVERT_TYPE_NODE),\n                        Predicates.notNull()));",
        "info" : "ReturnStatement[4467-4659]:ReturnStatement[7097-7295]"
      }, {
        "left" : "return root;",
        "right" : "return root;",
        "info" : "ReturnStatement[4686-4698]:ReturnStatement[7326-7338]"
      }, {
        "left" : "case Token.QMARK:",
        "right" : "case Token.QMARK:",
        "info" : "SwitchCase[4715-4732]:SwitchCase[7359-7376]"
      }, {
        "left" : "Node child = n.getFirstChild();",
        "right" : "Node child = n.getFirstChild();",
        "info" : "VariableDeclarationStatement[4741-4772]:VariableDeclarationStatement[7387-7418]"
      }, {
        "left" : "return child == null\n            ? anyType()\n            // For now, our ES6_TYPED language doesn't support nullable\n            // so we drop it before building the tree.\n            // : nullable(convertTypeNodeAST(child));\n            : convertTypeNodeAST(child);",
        "right" : "return child == null\n              ? anyType()\n              // For now, our ES6_TYPED language doesn't support nullable\n              // so we drop it before building the tree.\n              // : nullable(convertTypeNodeAST(child));\n              : convertTypeNodeAST(child);",
        "info" : "ReturnStatement[4781-5047]:ReturnStatement[7429-7705]"
      }, {
        "left" : "case Token.LC:",
        "right" : "case Token.LC:",
        "info" : "SwitchCase[5054-5068]:SwitchCase[7714-7728]"
      }, {
        "left" : "LinkedHashMap<String, TypeDeclarationNode> properties = new LinkedHashMap<>();",
        "right" : "LinkedHashMap<String, TypeDeclarationNode> properties = new LinkedHashMap<>();",
        "info" : "VariableDeclarationStatement[5077-5155]:VariableDeclarationStatement[7739-7817]"
      }, {
        "left" : "for (Node field : n.getFirstChild().children())",
        "right" : "for (Node field : n.getFirstChild().children())",
        "info" : "EnhancedForStatement[5164-5767]:EnhancedForStatement[7828-8451]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[5212-5767]:Block[7876-8451]"
      }, {
        "left" : "boolean isFieldTypeDeclared = field.getType() == Token.COLON;",
        "right" : "boolean isFieldTypeDeclared = field.getType() == Token.COLON;",
        "info" : "VariableDeclarationStatement[5224-5285]:VariableDeclarationStatement[7890-7951]"
      }, {
        "left" : "Node fieldNameNode = isFieldTypeDeclared ? field.getFirstChild() : field;",
        "right" : "Node fieldNameNode = isFieldTypeDeclared ? field.getFirstChild() : field;",
        "info" : "VariableDeclarationStatement[5296-5369]:VariableDeclarationStatement[7964-8037]"
      }, {
        "left" : "String fieldName = fieldNameNode.getString();",
        "right" : "String fieldName = fieldNameNode.getString();",
        "info" : "VariableDeclarationStatement[5380-5425]:VariableDeclarationStatement[8050-8095]"
      }, {
        "left" : "if (fieldName.startsWith(\"'\") || fieldName.startsWith(\"\\\"\"))",
        "right" : "if (fieldName.startsWith(\"'\") || fieldName.startsWith(\"\\\"\"))",
        "info" : "IfStatement[5436-5582]:IfStatement[8108-8258]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[5497-5582]:Block[8169-8258]"
      }, {
        "left" : "fieldName = fieldName.substring(1, fieldName.length() - 1);",
        "right" : "fieldName = fieldName.substring(1, fieldName.length() - 1);",
        "info" : "ExpressionStatement[5511-5570]:ExpressionStatement[8185-8244]"
      }, {
        "left" : "TypeDeclarationNode fieldType = isFieldTypeDeclared\n              ? convertTypeNodeAST(field.getLastChild()) : null;",
        "right" : "TypeDeclarationNode fieldType = isFieldTypeDeclared\n                ? convertTypeNodeAST(field.getLastChild()) : null;",
        "info" : "VariableDeclarationStatement[5593-5709]:VariableDeclarationStatement[8271-8389]"
      }, {
        "left" : "properties.put(fieldName, fieldType);",
        "right" : "properties.put(fieldName, fieldType);",
        "info" : "ExpressionStatement[5720-5757]:ExpressionStatement[8402-8439]"
      }, {
        "left" : "return recordType(properties);",
        "right" : "return recordType(properties);",
        "info" : "ReturnStatement[5776-5806]:ReturnStatement[8462-8492]"
      }, {
        "left" : "case Token.ELLIPSIS:",
        "right" : "case Token.ELLIPSIS:",
        "info" : "SwitchCase[5813-5833]:SwitchCase[8501-8521]"
      }, {
        "left" : "return arrayType(convertTypeNodeAST(n.getFirstChild()));",
        "right" : "return arrayType(convertTypeNodeAST(n.getFirstChild()));",
        "info" : "ReturnStatement[5842-5898]:ReturnStatement[8532-8588]"
      }, {
        "left" : "case Token.PIPE:",
        "right" : "case Token.PIPE:",
        "info" : "SwitchCase[5905-5921]:SwitchCase[8597-8613]"
      }, {
        "left" : "ImmutableList<TypeDeclarationNode> types = FluentIterable\n            .from(n.children()).transform(CONVERT_TYPE_NODE)\n            .filter(Predicates.notNull()).toList();",
        "right" : "ImmutableList<TypeDeclarationNode> types = FluentIterable\n              .from(n.children()).transform(CONVERT_TYPE_NODE)\n              .filter(Predicates.notNull()).toList();",
        "info" : "VariableDeclarationStatement[5930-6100]:VariableDeclarationStatement[8624-8798]"
      }, {
        "left" : "switch (types.size()) {\n          case 0:\n            return null;\n          case 1:\n            return types.get(0);\n          default:\n            return unionType(types);\n        }",
        "right" : "switch (types.size()) {\n            case 0:\n              return null;\n            case 1:\n              return types.get(0);\n            default:\n              return unionType(types);\n          }",
        "info" : "SwitchStatement[6109-6292]:SwitchStatement[8809-9006]"
      }, {
        "left" : "case 0:",
        "right" : "case 0:",
        "info" : "SwitchCase[6143-6150]:SwitchCase[8845-8852]"
      }, {
        "left" : "return null;",
        "right" : "return null;",
        "info" : "ReturnStatement[6163-6175]:ReturnStatement[8867-8879]"
      }, {
        "left" : "case 1:",
        "right" : "case 1:",
        "info" : "SwitchCase[6186-6193]:SwitchCase[8892-8899]"
      }, {
        "left" : "return types.get(0);",
        "right" : "return types.get(0);",
        "info" : "ReturnStatement[6206-6226]:ReturnStatement[8914-8934]"
      }, {
        "left" : "default:",
        "right" : "default:",
        "info" : "SwitchCase[6237-6245]:SwitchCase[8947-8955]"
      }, {
        "left" : "return unionType(types);",
        "right" : "return unionType(types);",
        "info" : "ReturnStatement[6258-6282]:ReturnStatement[8970-8994]"
      }, {
        "left" : "case Token.FUNCTION:",
        "right" : "case Token.FUNCTION:",
        "info" : "SwitchCase[6299-6319]:SwitchCase[9015-9035]"
      }, {
        "left" : "Node returnType = anyType();",
        "right" : "Node returnType = anyType();",
        "info" : "VariableDeclarationStatement[6328-6356]:VariableDeclarationStatement[9046-9074]"
      }, {
        "left" : "LinkedHashMap<String, TypeDeclarationNode> requiredParams = new LinkedHashMap<>();",
        "right" : "LinkedHashMap<String, TypeDeclarationNode> requiredParams = new LinkedHashMap<>();",
        "info" : "VariableDeclarationStatement[6365-6447]:VariableDeclarationStatement[9085-9167]"
      }, {
        "left" : "LinkedHashMap<String, TypeDeclarationNode> optionalParams = new LinkedHashMap<>();",
        "right" : "LinkedHashMap<String, TypeDeclarationNode> optionalParams = new LinkedHashMap<>();",
        "info" : "VariableDeclarationStatement[6456-6538]:VariableDeclarationStatement[9178-9260]"
      }, {
        "left" : "String restName = null;",
        "right" : "String restName = null;",
        "info" : "VariableDeclarationStatement[6547-6570]:VariableDeclarationStatement[9271-9294]"
      }, {
        "left" : "TypeDeclarationNode restType = null;",
        "right" : "TypeDeclarationNode restType = null;",
        "info" : "VariableDeclarationStatement[6579-6615]:VariableDeclarationStatement[9305-9341]"
      }, {
        "left" : "for (Node child2 : n.children())",
        "right" : "for (Node child2 : n.children())",
        "info" : "EnhancedForStatement[6624-8033]:EnhancedForStatement[9352-10819]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[6657-8033]:Block[9385-10819]"
      }, {
        "left" : "if (child2.isParamList())",
        "right" : "if (child2.isParamList())",
        "info" : "IfStatement[6669-8023]:IfStatement[9399-10807]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[6695-7528]:Block[9425-10296]"
      }, {
        "left" : "int paramIdx = 1;",
        "right" : "int paramIdx = 1;",
        "info" : "VariableDeclarationStatement[6709-6726]:VariableDeclarationStatement[9441-9458]"
      }, {
        "left" : "for (Node param : child2.children())",
        "right" : "for (Node param : child2.children())",
        "info" : "EnhancedForStatement[6739-7516]:EnhancedForStatement[9473-10282]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[6776-7516]:Block[9510-10282]"
      }, {
        "left" : "String paramName = \"p\" + paramIdx++;",
        "right" : "String paramName = \"p\" + paramIdx++;",
        "info" : "VariableDeclarationStatement[6792-6828]:VariableDeclarationStatement[9528-9564]"
      }, {
        "left" : "if (param.getType() == Token.ELLIPSIS)",
        "right" : "if (param.getType() == Token.ELLIPSIS)",
        "info" : "IfStatement[6843-7502]:IfStatement[9581-10266]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[6882-7091]:Block[9620-9839]"
      }, {
        "left" : "if (param.getFirstChild() != null)",
        "right" : "if (param.getFirstChild() != null)",
        "info" : "IfStatement[6900-7037]:IfStatement[9640-9781]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[6935-7037]:Block[9675-9781]"
      }, {
        "left" : "restType = arrayType(convertTypeNodeAST(param.getFirstChild()));",
        "right" : "restType = arrayType(convertTypeNodeAST(param.getFirstChild()));",
        "info" : "ExpressionStatement[6955-7019]:ExpressionStatement[9697-9761]"
      }, {
        "left" : "restName = paramName;",
        "right" : "restName = paramName;",
        "info" : "ExpressionStatement[7054-7075]:ExpressionStatement[9800-9821]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[7097-7502]:Block[9845-10266]"
      }, {
        "left" : "TypeDeclarationNode paramNode = convertTypeNodeAST(param);",
        "right" : "TypeDeclarationNode paramNode = convertTypeNodeAST(param);",
        "info" : "VariableDeclarationStatement[7115-7173]:VariableDeclarationStatement[9865-9923]"
      }, {
        "left" : "if (paramNode.getType() == Token.OPTIONAL_PARAMETER)",
        "right" : "if (paramNode.getType() == Token.OPTIONAL_PARAMETER)",
        "info" : "IfStatement[7190-7486]:IfStatement[9942-10248]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[7243-7385]:Block[9995-10143]"
      }, {
        "left" : "optionalParams.put(paramName,\n                      (TypeDeclarationNode) paramNode.removeFirstChild());",
        "right" : "optionalParams.put(paramName,\n                        (TypeDeclarationNode) paramNode.removeFirstChild());",
        "info" : "ExpressionStatement[7263-7367]:ExpressionStatement[10017-10123]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[7391-7486]:Block[10149-10248]"
      }, {
        "left" : "requiredParams.put(paramName, convertTypeNodeAST(param));",
        "right" : "requiredParams.put(paramName, convertTypeNodeAST(param));",
        "info" : "ExpressionStatement[7411-7468]:ExpressionStatement[10171-10228]"
      }, {
        "left" : "if (child2.isNew())",
        "right" : "if (child2.isNew())",
        "info" : "IfStatement[7534-8023]:IfStatement[10302-10807]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[7554-7758]:Block[10322-10532]"
      }, {
        "left" : "if (child2.isThis())",
        "right" : "if (child2.isThis())",
        "info" : "IfStatement[7764-8023]:IfStatement[10538-10807]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[7785-7951]:Block[10559-10731]"
      }, {
        "left" : "{}",
        "right" : "{}",
        "info" : "Block[7957-8023]:Block[10737-10807]"
      }, {
        "left" : "returnType = convertTypeNodeAST(child2);",
        "right" : "returnType = convertTypeNodeAST(child2);",
        "info" : "ExpressionStatement[7971-8011]:ExpressionStatement[10753-10793]"
      }, {
        "left" : "return functionType(returnType, requiredParams, optionalParams, restName, restType);",
        "right" : "return functionType(returnType, requiredParams, optionalParams, restName, restType);",
        "info" : "ReturnStatement[8042-8126]:ReturnStatement[10830-10914]"
      }, {
        "left" : "case Token.EQUALS:",
        "right" : "case Token.EQUALS:",
        "info" : "SwitchCase[8133-8151]:SwitchCase[10923-10941]"
      }, {
        "left" : "TypeDeclarationNode optionalParam = convertTypeNodeAST(n.getFirstChild());",
        "right" : "TypeDeclarationNode optionalParam = convertTypeNodeAST(n.getFirstChild());",
        "info" : "VariableDeclarationStatement[8160-8234]:VariableDeclarationStatement[10952-11026]"
      }, {
        "left" : "return optionalParam == null ? null : optionalParameter(optionalParam);",
        "right" : "return optionalParam == null ? null : optionalParameter(optionalParam);",
        "info" : "ReturnStatement[8243-8314]:ReturnStatement[11037-11108]"
      }, {
        "left" : "default:",
        "right" : "default:",
        "info" : "SwitchCase[8321-8329]:SwitchCase[11117-11125]"
      }, {
        "left" : "throw new IllegalArgumentException(\n            \"Unsupported node type: \" + Token.name(n.getType())\n                + \" \" + n.toStringTree());",
        "right" : "throw new IllegalArgumentException(\n              \"Unsupported node type: \" + Token.name(n.getType())\n                  + \" \" + n.toStringTree());",
        "info" : "ThrowStatement[8338-8480]:ThrowStatement[11136-11282]"
      } ]
    }
  }
}