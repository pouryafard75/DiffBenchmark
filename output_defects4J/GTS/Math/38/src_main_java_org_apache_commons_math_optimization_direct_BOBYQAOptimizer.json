{
  "matchedElements" : [
 {
    "left" : "class : BOBYQAOptimizer",
    "right" : "class : BOBYQAOptimizer",
    "info" : "TypeDeclaration[1559-113825]:TypeDeclaration[1559-113839]"
  }, {
    "left" : "MINIMUM_PROBLEM_DIMENSION",
    "right" : "MINIMUM_PROBLEM_DIMENSION",
    "info" : "FieldDeclaration[2513-2621]:FieldDeclaration[2513-2621]"
  }, {
    "left" : "DEFAULT_INITIAL_RADIUS",
    "right" : "DEFAULT_INITIAL_RADIUS",
    "info" : "FieldDeclaration[2626-2758]:FieldDeclaration[2626-2758]"
  }, {
    "left" : "DEFAULT_STOPPING_RADIUS",
    "right" : "DEFAULT_STOPPING_RADIUS",
    "info" : "FieldDeclaration[2763-2897]:FieldDeclaration[2763-2897]"
  }, {
    "left" : "ZERO",
    "right" : "ZERO",
    "info" : "FieldDeclaration[2903-2941]:FieldDeclaration[2903-2941]"
  }, {
    "left" : "ONE",
    "right" : "ONE",
    "info" : "FieldDeclaration[2946-2983]:FieldDeclaration[2946-2983]"
  }, {
    "left" : "TWO",
    "right" : "TWO",
    "info" : "FieldDeclaration[2988-3025]:FieldDeclaration[2988-3025]"
  }, {
    "left" : "TEN",
    "right" : "TEN",
    "info" : "FieldDeclaration[3030-3068]:FieldDeclaration[3030-3068]"
  }, {
    "left" : "SIXTEEN",
    "right" : "SIXTEEN",
    "info" : "FieldDeclaration[3073-3115]:FieldDeclaration[3073-3115]"
  }, {
    "left" : "TWO_HUNDRED_FIFTY",
    "right" : "TWO_HUNDRED_FIFTY",
    "info" : "FieldDeclaration[3120-3173]:FieldDeclaration[3120-3173]"
  }, {
    "left" : "MINUS_ONE",
    "right" : "MINUS_ONE",
    "info" : "FieldDeclaration[3178-3223]:FieldDeclaration[3178-3223]"
  }, {
    "left" : "HALF",
    "right" : "HALF",
    "info" : "FieldDeclaration[3228-3271]:FieldDeclaration[3228-3271]"
  }, {
    "left" : "ONE_OVER_FOUR",
    "right" : "ONE_OVER_FOUR",
    "info" : "FieldDeclaration[3276-3328]:FieldDeclaration[3276-3328]"
  }, {
    "left" : "ONE_OVER_EIGHT",
    "right" : "ONE_OVER_EIGHT",
    "info" : "FieldDeclaration[3333-3386]:FieldDeclaration[3333-3386]"
  }, {
    "left" : "ONE_OVER_TEN",
    "right" : "ONE_OVER_TEN",
    "info" : "FieldDeclaration[3391-3443]:FieldDeclaration[3391-3443]"
  }, {
    "left" : "ONE_OVER_A_THOUSAND",
    "right" : "ONE_OVER_A_THOUSAND",
    "info" : "FieldDeclaration[3448-3509]:FieldDeclaration[3448-3509]"
  }, {
    "left" : "numberOfInterpolationPoints",
    "right" : "numberOfInterpolationPoints",
    "info" : "FieldDeclaration[3515-3616]:FieldDeclaration[3515-3616]"
  }, {
    "left" : "initialTrustRegionRadius",
    "right" : "initialTrustRegionRadius",
    "info" : "FieldDeclaration[3621-3713]:FieldDeclaration[3621-3713]"
  }, {
    "left" : "stoppingTrustRegionRadius",
    "right" : "stoppingTrustRegionRadius",
    "info" : "FieldDeclaration[3718-3818]:FieldDeclaration[3718-3818]"
  }, {
    "left" : "isMinimize",
    "right" : "isMinimize",
    "info" : "FieldDeclaration[3823-3895]:FieldDeclaration[3823-3895]"
  }, {
    "left" : "currentBest",
    "right" : "currentBest",
    "info" : "FieldDeclaration[3900-4137]:FieldDeclaration[3900-4137]"
  }, {
    "left" : "boundDifference",
    "right" : "boundDifference",
    "info" : "FieldDeclaration[4142-4234]:FieldDeclaration[4142-4234]"
  }, {
    "left" : "trustRegionCenterInterpolationPointIndex",
    "right" : "trustRegionCenterInterpolationPointIndex",
    "info" : "FieldDeclaration[4239-4376]:FieldDeclaration[4239-4376]"
  }, {
    "left" : "bMatrix",
    "right" : "bMatrix",
    "info" : "FieldDeclaration[4381-4576]:FieldDeclaration[4381-4576]"
  }, {
    "left" : "zMatrix",
    "right" : "zMatrix",
    "info" : "FieldDeclaration[4581-4871]:FieldDeclaration[4581-4871]"
  }, {
    "left" : "interpolationPoints",
    "right" : "interpolationPoints",
    "info" : "FieldDeclaration[4876-5061]:FieldDeclaration[4876-5061]"
  }, {
    "left" : "originShift",
    "right" : "originShift",
    "info" : "FieldDeclaration[5066-5294]:FieldDeclaration[5066-5294]"
  }, {
    "left" : "fAtInterpolationPoints",
    "right" : "fAtInterpolationPoints",
    "info" : "FieldDeclaration[5299-5471]:FieldDeclaration[5299-5471]"
  }, {
    "left" : "trustRegionCenterOffset",
    "right" : "trustRegionCenterOffset",
    "info" : "FieldDeclaration[5476-5654]:FieldDeclaration[5476-5654]"
  }, {
    "left" : "gradientAtTrustRegionCenter",
    "right" : "gradientAtTrustRegionCenter",
    "info" : "FieldDeclaration[5659-5873]:FieldDeclaration[5659-5873]"
  }, {
    "left" : "lowerDifference",
    "right" : "lowerDifference",
    "info" : "FieldDeclaration[5878-6379]:FieldDeclaration[5878-6379]"
  }, {
    "left" : "upperDifference",
    "right" : "upperDifference",
    "info" : "FieldDeclaration[6384-6886]:FieldDeclaration[6384-6886]"
  }, {
    "left" : "modelSecondDerivativesParameters",
    "right" : "modelSecondDerivativesParameters",
    "info" : "FieldDeclaration[6891-7080]:FieldDeclaration[6891-7080]"
  }, {
    "left" : "newPoint",
    "right" : "newPoint",
    "info" : "FieldDeclaration[7085-7629]:FieldDeclaration[7085-7629]"
  }, {
    "left" : "alternativeNewPoint",
    "right" : "alternativeNewPoint",
    "info" : "FieldDeclaration[7634-7957]:FieldDeclaration[7634-7957]"
  }, {
    "left" : "trialStepPoint",
    "right" : "trialStepPoint",
    "info" : "FieldDeclaration[7962-8190]:FieldDeclaration[7962-8190]"
  }, {
    "left" : "lagrangeValuesAtNewPoint",
    "right" : "lagrangeValuesAtNewPoint",
    "info" : "FieldDeclaration[8195-8356]:FieldDeclaration[8195-8356]"
  }, {
    "left" : "modelSecondDerivativesValues",
    "right" : "modelSecondDerivativesValues",
    "info" : "FieldDeclaration[8361-8527]:FieldDeclaration[8361-8527]"
  }, {
    "left" : "public BOBYQAOptimizer(numberOfInterpolationPoints int)",
    "right" : "public BOBYQAOptimizer(numberOfInterpolationPoints int)",
    "info" : "MethodDeclaration[8533-8984]:MethodDeclaration[8533-8984]"
  }, {
    "left" : "public BOBYQAOptimizer(numberOfInterpolationPoints int, initialTrustRegionRadius double, stoppingTrustRegionRadius double...)",
    "right" : "public BOBYQAOptimizer(numberOfInterpolationPoints int, initialTrustRegionRadius double, stoppingTrustRegionRadius double...)",
    "info" : "MethodDeclaration[8990-9788]:MethodDeclaration[8990-9788]"
  }, {
    "left" : "protected doOptimize() : ",
    "right" : "protected doOptimize() : ",
    "info" : "MethodDeclaration[9794-10371]:MethodDeclaration[9794-10371]"
  }, {
    "left" : "private bobyqa(lowerBound , upperBound ) : double",
    "right" : "private bobyqa(lowerBound , upperBound ) : double",
    "info" : "MethodDeclaration[10377-15195]:MethodDeclaration[10377-15195]"
  }, {
    "left" : "private bobyqb(lowerBound , upperBound ) : double",
    "right" : "private bobyqb(lowerBound , upperBound ) : double",
    "info" : "MethodDeclaration[15308-57585]:MethodDeclaration[15308-57585]"
  }, {
    "left" : "private altmov(knew int, adelt double) : ",
    "right" : "private altmov(knew int, adelt double) : ",
    "info" : "MethodDeclaration[57698-72997]:MethodDeclaration[57698-72997]"
  }, {
    "left" : "private prelim(lowerBound , upperBound ) : void",
    "right" : "private prelim(lowerBound , upperBound ) : void",
    "info" : "MethodDeclaration[73110-83137]:MethodDeclaration[73110-83151]"
  }, {
    "left" : "private trsbox(delta double, gnew , xbdi , s , hs , hred ) : ",
    "right" : "private trsbox(delta double, gnew , xbdi , s , hs , hred ) : ",
    "info" : "MethodDeclaration[83251-104964]:MethodDeclaration[83265-104978]"
  }, {
    "left" : "private update(beta double, denom double, knew int) : void",
    "right" : "private update(beta double, denom double, knew int) : void",
    "info" : "MethodDeclaration[105077-109102]:MethodDeclaration[105091-109116]"
  }, {
    "left" : "private setup(lowerBound , upperBound ) : void",
    "right" : "private setup(lowerBound , upperBound ) : void",
    "info" : "MethodDeclaration[109118-112162]:MethodDeclaration[109132-112176]"
  }, {
    "left" : "private fillNewArray(n int, value double) : ",
    "right" : "private fillNewArray(n int, value double) : ",
    "info" : "MethodDeclaration[112168-112599]:MethodDeclaration[112182-112613]"
  }, {
    "left" : "private caller(n int) : ",
    "right" : "private caller(n int) : ",
    "info" : "MethodDeclaration[112656-112932]:MethodDeclaration[112670-112946]"
  }, {
    "left" : "private printState(s int) : void",
    "right" : "private printState(s int) : void",
    "info" : "MethodDeclaration[112988-113099]:MethodDeclaration[113002-113113]"
  }, {
    "left" : "private printMethod() : void",
    "right" : "private printMethod() : void",
    "info" : "MethodDeclaration[113155-113245]:MethodDeclaration[113169-113259]"
  }, {
    "left" : "class : PathIsExploredException",
    "right" : "class : PathIsExploredException",
    "info" : "TypeDeclaration[113251-113823]:TypeDeclaration[113265-113837]"
  }, {
    "left" : "serialVersionUID",
    "right" : "serialVersionUID",
    "info" : "FieldDeclaration[113505-113570]:FieldDeclaration[113519-113584]"
  }, {
    "left" : "PATH_IS_EXPLORED",
    "right" : "PATH_IS_EXPLORED",
    "info" : "FieldDeclaration[113580-113699]:FieldDeclaration[113594-113713]"
  }, {
    "left" : "package PathIsExploredException()",
    "right" : "package PathIsExploredException()",
    "info" : "MethodDeclaration[113709-113817]:MethodDeclaration[113723-113831]"
  } ],
  "mappings" : [
 {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[2361-2367]:Modifier[2361-2367]"
  }, {
    "left" : "class",
    "right" : "class",
    "info" : "TYPE_DECLARATION_KIND[2368-2373]:TYPE_DECLARATION_KIND[2368-2373]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[8803-8809]:Modifier[8803-8809]"
  }, {
    "left" : "BOBYQAOptimizer",
    "right" : "BOBYQAOptimizer",
    "info" : "SimpleName[8810-8825]:SimpleName[8810-8825]"
  }, {
    "left" : "int numberOfInterpolationPoints",
    "right" : "int numberOfInterpolationPoints",
    "info" : "SingleVariableDeclaration[8826-8857]:SingleVariableDeclaration[8826-8857]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[8859-8984]:Block[8859-8984]"
  }, {
    "left" : "this(numberOfInterpolationPoints,\n             DEFAULT_INITIAL_RADIUS,\n             DEFAULT_STOPPING_RADIUS);",
    "right" : "this(numberOfInterpolationPoints,\n             DEFAULT_INITIAL_RADIUS,\n             DEFAULT_STOPPING_RADIUS);",
    "info" : "ConstructorInvocation[8869-8978]:ConstructorInvocation[8869-8978]"
  }, {
    "left" : "public",
    "right" : "public",
    "info" : "Modifier[9398-9404]:Modifier[9398-9404]"
  }, {
    "left" : "BOBYQAOptimizer",
    "right" : "BOBYQAOptimizer",
    "info" : "SimpleName[9405-9420]:SimpleName[9405-9420]"
  }, {
    "left" : "int numberOfInterpolationPoints",
    "right" : "int numberOfInterpolationPoints",
    "info" : "SingleVariableDeclaration[9421-9452]:SingleVariableDeclaration[9421-9452]"
  }, {
    "left" : "double initialTrustRegionRadius",
    "right" : "double initialTrustRegionRadius",
    "info" : "SingleVariableDeclaration[9481-9512]:SingleVariableDeclaration[9481-9512]"
  }, {
    "left" : "double stoppingTrustRegionRadius",
    "right" : "double stoppingTrustRegionRadius",
    "info" : "SingleVariableDeclaration[9541-9573]:SingleVariableDeclaration[9541-9573]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[9575-9788]:Block[9575-9788]"
  }, {
    "left" : "this.numberOfInterpolationPoints = numberOfInterpolationPoints;",
    "right" : "this.numberOfInterpolationPoints = numberOfInterpolationPoints;",
    "info" : "ExpressionStatement[9585-9648]:ExpressionStatement[9585-9648]"
  }, {
    "left" : "this.initialTrustRegionRadius = initialTrustRegionRadius;",
    "right" : "this.initialTrustRegionRadius = initialTrustRegionRadius;",
    "info" : "ExpressionStatement[9657-9714]:ExpressionStatement[9657-9714]"
  }, {
    "left" : "this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;",
    "right" : "this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;",
    "info" : "ExpressionStatement[9723-9782]:ExpressionStatement[9723-9782]"
  }, {
    "left" : "@Override",
    "right" : "@Override",
    "info" : "MarkerAnnotation[9819-9828]:MarkerAnnotation[9819-9828]"
  }, {
    "left" : "protected",
    "right" : "protected",
    "info" : "Modifier[9833-9842]:Modifier[9833-9842]"
  }, {
    "left" : "RealPointValuePair",
    "right" : "RealPointValuePair",
    "info" : "SimpleType[9843-9861]:SimpleType[9843-9861]"
  }, {
    "left" : "doOptimize",
    "right" : "doOptimize",
    "info" : "SimpleName[9862-9872]:SimpleName[9862-9872]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[9875-10371]:Block[9875-10371]"
  }, {
    "left" : "final double[] lowerBound = getLowerBound();",
    "right" : "final double[] lowerBound = getLowerBound();",
    "info" : "VariableDeclarationStatement[9885-9929]:VariableDeclarationStatement[9885-9929]"
  }, {
    "left" : "final double[] upperBound = getUpperBound();",
    "right" : "final double[] upperBound = getUpperBound();",
    "info" : "VariableDeclarationStatement[9938-9982]:VariableDeclarationStatement[9938-9982]"
  }, {
    "left" : "setup(lowerBound, upperBound);",
    "right" : "setup(lowerBound, upperBound);",
    "info" : "ExpressionStatement[10020-10050]:ExpressionStatement[10020-10050]"
  }, {
    "left" : "isMinimize = (getGoalType() == GoalType.MINIMIZE);",
    "right" : "isMinimize = (getGoalType() == GoalType.MINIMIZE);",
    "info" : "ExpressionStatement[10060-10110]:ExpressionStatement[10060-10110]"
  }, {
    "left" : "currentBest = new ArrayRealVector(getStartPoint());",
    "right" : "currentBest = new ArrayRealVector(getStartPoint());",
    "info" : "ExpressionStatement[10119-10170]:ExpressionStatement[10119-10170]"
  }, {
    "left" : "final double value = bobyqa(lowerBound, upperBound);",
    "right" : "final double value = bobyqa(lowerBound, upperBound);",
    "info" : "VariableDeclarationStatement[10180-10232]:VariableDeclarationStatement[10180-10232]"
  }, {
    "left" : "return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);",
    "right" : "return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);",
    "info" : "ReturnStatement[10242-10365]:ReturnStatement[10242-10365]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[12635-12642]:Modifier[12635-12642]"
  }, {
    "left" : "double",
    "right" : "double",
    "info" : "PrimitiveType[12643-12649]:PrimitiveType[12643-12649]"
  }, {
    "left" : "bobyqa",
    "right" : "bobyqa",
    "info" : "SimpleName[12650-12656]:SimpleName[12650-12656]"
  }, {
    "left" : "double[] lowerBound",
    "right" : "double[] lowerBound",
    "info" : "SingleVariableDeclaration[12657-12676]:SingleVariableDeclaration[12657-12676]"
  }, {
    "left" : "double[] upperBound",
    "right" : "double[] upperBound",
    "info" : "SingleVariableDeclaration[12704-12723]:SingleVariableDeclaration[12704-12723]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[12725-15195]:Block[12725-15195]"
  }, {
    "left" : "printMethod();",
    "right" : "printMethod();",
    "info" : "ExpressionStatement[12735-12749]:ExpressionStatement[12735-12749]"
  }, {
    "left" : "final int n = currentBest.getDimension();",
    "right" : "final int n = currentBest.getDimension();",
    "info" : "VariableDeclarationStatement[12766-12807]:VariableDeclarationStatement[12766-12807]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[13303-15104]:ForStatement[13303-15104]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13331-15104]:Block[13331-15104]"
  }, {
    "left" : "final double boundDiff = boundDifference[j];",
    "right" : "final double boundDiff = boundDifference[j];",
    "info" : "VariableDeclarationStatement[13345-13389]:VariableDeclarationStatement[13345-13389]"
  }, {
    "left" : "lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));",
    "right" : "lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));",
    "info" : "ExpressionStatement[13402-13471]:ExpressionStatement[13402-13471]"
  }, {
    "left" : "upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));",
    "right" : "upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));",
    "info" : "ExpressionStatement[13484-13553]:ExpressionStatement[13484-13553]"
  }, {
    "left" : "if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius)",
    "right" : "if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius)",
    "info" : "IfStatement[13566-15094]:IfStatement[13566-15094]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13628-14300]:Block[13628-14300]"
  }, {
    "left" : "if (lowerDifference.getEntry(j) >= ZERO)",
    "right" : "if (lowerDifference.getEntry(j) >= ZERO)",
    "info" : "IfStatement[13646-14286]:IfStatement[13646-14286]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13687-13881]:Block[13687-13881]"
  }, {
    "left" : "currentBest.setEntry(j, lowerBound[j]);",
    "right" : "currentBest.setEntry(j, lowerBound[j]);",
    "info" : "ExpressionStatement[13709-13748]:ExpressionStatement[13709-13748]"
  }, {
    "left" : "lowerDifference.setEntry(j, ZERO);",
    "right" : "lowerDifference.setEntry(j, ZERO);",
    "info" : "ExpressionStatement[13769-13803]:ExpressionStatement[13769-13803]"
  }, {
    "left" : "upperDifference.setEntry(j, boundDiff);",
    "right" : "upperDifference.setEntry(j, boundDiff);",
    "info" : "ExpressionStatement[13824-13863]:ExpressionStatement[13824-13863]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[13887-14286]:Block[13887-14286]"
  }, {
    "left" : "currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);",
    "right" : "currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);",
    "info" : "ExpressionStatement[13909-13975]:ExpressionStatement[13909-13975]"
  }, {
    "left" : "lowerDifference.setEntry(j, -initialTrustRegionRadius);",
    "right" : "lowerDifference.setEntry(j, -initialTrustRegionRadius);",
    "info" : "ExpressionStatement[13996-14051]:ExpressionStatement[13996-14051]"
  }, {
    "left" : "final double deltaOne = upperBound[j] - currentBest.getEntry(j);",
    "right" : "final double deltaOne = upperBound[j] - currentBest.getEntry(j);",
    "info" : "VariableDeclarationStatement[14109-14173]:VariableDeclarationStatement[14109-14173]"
  }, {
    "left" : "upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));",
    "right" : "upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));",
    "info" : "ExpressionStatement[14194-14268]:ExpressionStatement[14194-14268]"
  }, {
    "left" : "if (upperDifference.getEntry(j) <= initialTrustRegionRadius)",
    "right" : "if (upperDifference.getEntry(j) <= initialTrustRegionRadius)",
    "info" : "IfStatement[14306-15094]:IfStatement[14306-15094]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14367-15094]:Block[14367-15094]"
  }, {
    "left" : "if (upperDifference.getEntry(j) <= ZERO)",
    "right" : "if (upperDifference.getEntry(j) <= ZERO)",
    "info" : "IfStatement[14385-15080]:IfStatement[14385-15080]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14426-14621]:Block[14426-14621]"
  }, {
    "left" : "currentBest.setEntry(j, upperBound[j]);",
    "right" : "currentBest.setEntry(j, upperBound[j]);",
    "info" : "ExpressionStatement[14448-14487]:ExpressionStatement[14448-14487]"
  }, {
    "left" : "lowerDifference.setEntry(j, -boundDiff);",
    "right" : "lowerDifference.setEntry(j, -boundDiff);",
    "info" : "ExpressionStatement[14508-14548]:ExpressionStatement[14508-14548]"
  }, {
    "left" : "upperDifference.setEntry(j, ZERO);",
    "right" : "upperDifference.setEntry(j, ZERO);",
    "info" : "ExpressionStatement[14569-14603]:ExpressionStatement[14569-14603]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[14627-15080]:Block[14627-15080]"
  }, {
    "left" : "currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);",
    "right" : "currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);",
    "info" : "ExpressionStatement[14649-14715]:ExpressionStatement[14649-14715]"
  }, {
    "left" : "final double deltaOne = lowerBound[j] - currentBest.getEntry(j);",
    "right" : "final double deltaOne = lowerBound[j] - currentBest.getEntry(j);",
    "info" : "VariableDeclarationStatement[14773-14837]:VariableDeclarationStatement[14773-14837]"
  }, {
    "left" : "final double deltaTwo = -initialTrustRegionRadius;",
    "right" : "final double deltaTwo = -initialTrustRegionRadius;",
    "info" : "VariableDeclarationStatement[14858-14908]:VariableDeclarationStatement[14858-14908]"
  }, {
    "left" : "lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));",
    "right" : "lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));",
    "info" : "ExpressionStatement[14929-14987]:ExpressionStatement[14929-14987]"
  }, {
    "left" : "upperDifference.setEntry(j, initialTrustRegionRadius);",
    "right" : "upperDifference.setEntry(j, initialTrustRegionRadius);",
    "info" : "ExpressionStatement[15008-15062]:ExpressionStatement[15008-15062]"
  }, {
    "left" : "return bobyqb(lowerBound, upperBound);",
    "right" : "return bobyqb(lowerBound, upperBound);",
    "info" : "ReturnStatement[15151-15189]:ReturnStatement[15151-15189]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[17725-17732]:Modifier[17725-17732]"
  }, {
    "left" : "double",
    "right" : "double",
    "info" : "PrimitiveType[17733-17739]:PrimitiveType[17733-17739]"
  }, {
    "left" : "bobyqb",
    "right" : "bobyqb",
    "info" : "SimpleName[17740-17746]:SimpleName[17740-17746]"
  }, {
    "left" : "double[] lowerBound",
    "right" : "double[] lowerBound",
    "info" : "SingleVariableDeclaration[17747-17766]:SingleVariableDeclaration[17747-17766]"
  }, {
    "left" : "double[] upperBound",
    "right" : "double[] upperBound",
    "info" : "SingleVariableDeclaration[17794-17813]:SingleVariableDeclaration[17794-17813]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[17815-57585]:Block[17815-57585]"
  }, {
    "left" : "printMethod();",
    "right" : "printMethod();",
    "info" : "ExpressionStatement[17825-17839]:ExpressionStatement[17825-17839]"
  }, {
    "left" : "final int n = currentBest.getDimension();",
    "right" : "final int n = currentBest.getDimension();",
    "info" : "VariableDeclarationStatement[17856-17897]:VariableDeclarationStatement[17856-17897]"
  }, {
    "left" : "final int npt = numberOfInterpolationPoints;",
    "right" : "final int npt = numberOfInterpolationPoints;",
    "info" : "VariableDeclarationStatement[17906-17950]:VariableDeclarationStatement[17906-17950]"
  }, {
    "left" : "final int np = n + 1;",
    "right" : "final int np = n + 1;",
    "info" : "VariableDeclarationStatement[17959-17980]:VariableDeclarationStatement[17959-17980]"
  }, {
    "left" : "final int nptm = npt - np;",
    "right" : "final int nptm = npt - np;",
    "info" : "VariableDeclarationStatement[17989-18015]:VariableDeclarationStatement[17989-18015]"
  }, {
    "left" : "final int nh = n * np / 2;",
    "right" : "final int nh = n * np / 2;",
    "info" : "VariableDeclarationStatement[18024-18050]:VariableDeclarationStatement[18024-18050]"
  }, {
    "left" : "final ArrayRealVector work1 = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector work1 = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[18060-18113]:VariableDeclarationStatement[18060-18113]"
  }, {
    "left" : "final ArrayRealVector work2 = new ArrayRealVector(npt);",
    "right" : "final ArrayRealVector work2 = new ArrayRealVector(npt);",
    "info" : "VariableDeclarationStatement[18122-18177]:VariableDeclarationStatement[18122-18177]"
  }, {
    "left" : "final ArrayRealVector work3 = new ArrayRealVector(npt);",
    "right" : "final ArrayRealVector work3 = new ArrayRealVector(npt);",
    "info" : "VariableDeclarationStatement[18186-18241]:VariableDeclarationStatement[18186-18241]"
  }, {
    "left" : "double cauchy = Double.NaN;",
    "right" : "double cauchy = Double.NaN;",
    "info" : "VariableDeclarationStatement[18251-18278]:VariableDeclarationStatement[18251-18278]"
  }, {
    "left" : "double alpha = Double.NaN;",
    "right" : "double alpha = Double.NaN;",
    "info" : "VariableDeclarationStatement[18287-18313]:VariableDeclarationStatement[18287-18313]"
  }, {
    "left" : "double dsq = Double.NaN;",
    "right" : "double dsq = Double.NaN;",
    "info" : "VariableDeclarationStatement[18322-18346]:VariableDeclarationStatement[18322-18346]"
  }, {
    "left" : "double crvmin = Double.NaN;",
    "right" : "double crvmin = Double.NaN;",
    "info" : "VariableDeclarationStatement[18355-18382]:VariableDeclarationStatement[18355-18382]"
  }, {
    "left" : "trustRegionCenterInterpolationPointIndex = 0;",
    "right" : "trustRegionCenterInterpolationPointIndex = 0;",
    "info" : "ExpressionStatement[18973-19018]:ExpressionStatement[18973-19018]"
  }, {
    "left" : "prelim(lowerBound, upperBound);",
    "right" : "prelim(lowerBound, upperBound);",
    "info" : "ExpressionStatement[19028-19059]:ExpressionStatement[19028-19059]"
  }, {
    "left" : "double xoptsq = ZERO;",
    "right" : "double xoptsq = ZERO;",
    "info" : "VariableDeclarationStatement[19068-19089]:VariableDeclarationStatement[19068-19089]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[19098-19412]:ForStatement[19098-19412]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[19126-19412]:Block[19126-19412]"
  }, {
    "left" : "trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));",
    "right" : "trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));",
    "info" : "ExpressionStatement[19140-19251]:ExpressionStatement[19140-19251]"
  }, {
    "left" : "final double deltaOne = trustRegionCenterOffset.getEntry(i);",
    "right" : "final double deltaOne = trustRegionCenterOffset.getEntry(i);",
    "info" : "VariableDeclarationStatement[19299-19359]:VariableDeclarationStatement[19299-19359]"
  }, {
    "left" : "xoptsq += deltaOne * deltaOne;",
    "right" : "xoptsq += deltaOne * deltaOne;",
    "info" : "ExpressionStatement[19372-19402]:ExpressionStatement[19372-19402]"
  }, {
    "left" : "double fsave = fAtInterpolationPoints.getEntry(0);",
    "right" : "double fsave = fAtInterpolationPoints.getEntry(0);",
    "info" : "VariableDeclarationStatement[19421-19471]:VariableDeclarationStatement[19421-19471]"
  }, {
    "left" : "final int kbase = 0;",
    "right" : "final int kbase = 0;",
    "info" : "VariableDeclarationStatement[19480-19500]:VariableDeclarationStatement[19480-19500]"
  }, {
    "left" : "int ntrits = 0;",
    "right" : "int ntrits = 0;",
    "info" : "VariableDeclarationStatement[19591-19606]:VariableDeclarationStatement[19591-19606]"
  }, {
    "left" : "int itest = 0;",
    "right" : "int itest = 0;",
    "info" : "VariableDeclarationStatement[19615-19629]:VariableDeclarationStatement[19615-19629]"
  }, {
    "left" : "int knew = 0;",
    "right" : "int knew = 0;",
    "info" : "VariableDeclarationStatement[19638-19651]:VariableDeclarationStatement[19638-19651]"
  }, {
    "left" : "int nfsav = getEvaluations();",
    "right" : "int nfsav = getEvaluations();",
    "info" : "VariableDeclarationStatement[19660-19689]:VariableDeclarationStatement[19660-19689]"
  }, {
    "left" : "double rho = initialTrustRegionRadius;",
    "right" : "double rho = initialTrustRegionRadius;",
    "info" : "VariableDeclarationStatement[19698-19736]:VariableDeclarationStatement[19698-19736]"
  }, {
    "left" : "double delta = rho;",
    "right" : "double delta = rho;",
    "info" : "VariableDeclarationStatement[19745-19764]:VariableDeclarationStatement[19745-19764]"
  }, {
    "left" : "double diffa = ZERO;",
    "right" : "double diffa = ZERO;",
    "info" : "VariableDeclarationStatement[19773-19793]:VariableDeclarationStatement[19773-19793]"
  }, {
    "left" : "double diffb = ZERO;",
    "right" : "double diffb = ZERO;",
    "info" : "VariableDeclarationStatement[19802-19822]:VariableDeclarationStatement[19802-19822]"
  }, {
    "left" : "double diffc = ZERO;",
    "right" : "double diffc = ZERO;",
    "info" : "VariableDeclarationStatement[19831-19851]:VariableDeclarationStatement[19831-19851]"
  }, {
    "left" : "double f = ZERO;",
    "right" : "double f = ZERO;",
    "info" : "VariableDeclarationStatement[19860-19876]:VariableDeclarationStatement[19860-19876]"
  }, {
    "left" : "double beta = ZERO;",
    "right" : "double beta = ZERO;",
    "info" : "VariableDeclarationStatement[19885-19904]:VariableDeclarationStatement[19885-19904]"
  }, {
    "left" : "double adelt = ZERO;",
    "right" : "double adelt = ZERO;",
    "info" : "VariableDeclarationStatement[19913-19933]:VariableDeclarationStatement[19913-19933]"
  }, {
    "left" : "double denom = ZERO;",
    "right" : "double denom = ZERO;",
    "info" : "VariableDeclarationStatement[19942-19962]:VariableDeclarationStatement[19942-19962]"
  }, {
    "left" : "double ratio = ZERO;",
    "right" : "double ratio = ZERO;",
    "info" : "VariableDeclarationStatement[19971-19991]:VariableDeclarationStatement[19971-19991]"
  }, {
    "left" : "double dnorm = ZERO;",
    "right" : "double dnorm = ZERO;",
    "info" : "VariableDeclarationStatement[20000-20020]:VariableDeclarationStatement[20000-20020]"
  }, {
    "left" : "double scaden = ZERO;",
    "right" : "double scaden = ZERO;",
    "info" : "VariableDeclarationStatement[20029-20050]:VariableDeclarationStatement[20029-20050]"
  }, {
    "left" : "double biglsq = ZERO;",
    "right" : "double biglsq = ZERO;",
    "info" : "VariableDeclarationStatement[20059-20080]:VariableDeclarationStatement[20059-20080]"
  }, {
    "left" : "double distsq = ZERO;",
    "right" : "double distsq = ZERO;",
    "info" : "VariableDeclarationStatement[20089-20110]:VariableDeclarationStatement[20089-20110]"
  }, {
    "left" : "int state = 20;",
    "right" : "int state = 20;",
    "info" : "VariableDeclarationStatement[20254-20269]:VariableDeclarationStatement[20254-20269]"
  }, {
    "left" : "for(;;) switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}",
    "right" : "for(;;) switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}",
    "info" : "ForStatement[20278-57579]:ForStatement[20278-57579]"
  }, {
    "left" : "switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}",
    "right" : "switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}",
    "info" : "SwitchStatement[20286-57579]:SwitchStatement[20286-57579]"
  }, {
    "left" : "case 20:",
    "right" : "case 20:",
    "info" : "SwitchCase[20311-20319]:SwitchCase[20311-20319]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20320-22342]:Block[20320-22342]"
  }, {
    "left" : "printState(20);",
    "right" : "printState(20);",
    "info" : "ExpressionStatement[20334-20349]:ExpressionStatement[20334-20349]"
  }, {
    "left" : "if (trustRegionCenterInterpolationPointIndex != kbase)",
    "right" : "if (trustRegionCenterInterpolationPointIndex != kbase)",
    "info" : "IfStatement[20369-21827]:IfStatement[20369-21827]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20424-21827]:Block[20424-21827]"
  }, {
    "left" : "int ih = 0;",
    "right" : "int ih = 0;",
    "info" : "VariableDeclarationStatement[20442-20453]:VariableDeclarationStatement[20442-20453]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[20470-21065]:ForStatement[20470-21065]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20498-21065]:Block[20498-21065]"
  }, {
    "left" : "for (int i = 0; i <= j; i++)",
    "right" : "for (int i = 0; i <= j; i++)",
    "info" : "ForStatement[20520-21047]:ForStatement[20520-21047]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20549-21047]:Block[20549-21047]"
  }, {
    "left" : "if (i < j)",
    "right" : "if (i < j)",
    "info" : "IfStatement[20575-20806]:IfStatement[20575-20806]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[20586-20806]:Block[20586-20806]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));",
    "right" : "gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[20616-20780]:ExpressionStatement[20616-20780]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));",
    "right" : "gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));",
    "info" : "ExpressionStatement[20831-20995]:ExpressionStatement[20831-20995]"
  }, {
    "left" : "ih++;",
    "right" : "ih++;",
    "info" : "ExpressionStatement[21020-21025]:ExpressionStatement[21020-21025]"
  }, {
    "left" : "if (getEvaluations() > npt)",
    "right" : "if (getEvaluations() > npt)",
    "info" : "IfStatement[21082-21813]:IfStatement[21082-21813]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21110-21813]:Block[21110-21813]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[21132-21731]:ForStatement[21132-21731]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21162-21731]:Block[21162-21731]"
  }, {
    "left" : "double temp = ZERO;",
    "right" : "double temp = ZERO;",
    "info" : "VariableDeclarationStatement[21188-21207]:VariableDeclarationStatement[21188-21207]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[21232-21397]:ForStatement[21232-21397]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21260-21397]:Block[21260-21397]"
  }, {
    "left" : "temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "right" : "temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "info" : "ExpressionStatement[21290-21371]:ExpressionStatement[21290-21371]"
  }, {
    "left" : "temp *= modelSecondDerivativesParameters.getEntry(k);",
    "right" : "temp *= modelSecondDerivativesParameters.getEntry(k);",
    "info" : "ExpressionStatement[21422-21475]:ExpressionStatement[21422-21475]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[21500-21709]:ForStatement[21500-21709]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[21528-21709]:Block[21528-21709]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));",
    "right" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));",
    "info" : "ExpressionStatement[21558-21683]:ExpressionStatement[21558-21683]"
  }, {
    "left" : "throw new PathIsExploredException();",
    "right" : "throw new PathIsExploredException();",
    "info" : "ThrowStatement[21752-21788]:ThrowStatement[21752-21788]"
  }, {
    "left" : "case 60:",
    "right" : "case 60:",
    "info" : "SwitchCase[22351-22359]:SwitchCase[22351-22359]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[22360-25862]:Block[22360-25862]"
  }, {
    "left" : "printState(60);",
    "right" : "printState(60);",
    "info" : "ExpressionStatement[22374-22389]:ExpressionStatement[22374-22389]"
  }, {
    "left" : "final ArrayRealVector gnew = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector gnew = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[22409-22461]:VariableDeclarationStatement[22409-22461]"
  }, {
    "left" : "final ArrayRealVector xbdi = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector xbdi = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[22474-22526]:VariableDeclarationStatement[22474-22526]"
  }, {
    "left" : "final ArrayRealVector s = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector s = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[22539-22588]:VariableDeclarationStatement[22539-22588]"
  }, {
    "left" : "final ArrayRealVector hs = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector hs = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[22601-22651]:VariableDeclarationStatement[22601-22651]"
  }, {
    "left" : "final ArrayRealVector hred = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector hred = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[22664-22716]:VariableDeclarationStatement[22664-22716]"
  }, {
    "left" : "final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);",
    "right" : "final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);",
    "info" : "VariableDeclarationStatement[22730-22842]:VariableDeclarationStatement[22730-22842]"
  }, {
    "left" : "dsq = dsqCrvmin[0];",
    "right" : "dsq = dsqCrvmin[0];",
    "info" : "ExpressionStatement[22855-22874]:ExpressionStatement[22855-22874]"
  }, {
    "left" : "crvmin = dsqCrvmin[1];",
    "right" : "crvmin = dsqCrvmin[1];",
    "info" : "ExpressionStatement[22887-22909]:ExpressionStatement[22887-22909]"
  }, {
    "left" : "double deltaOne = delta;",
    "right" : "double deltaOne = delta;",
    "info" : "VariableDeclarationStatement[22952-22976]:VariableDeclarationStatement[22952-22976]"
  }, {
    "left" : "double deltaTwo = Math.sqrt(dsq);",
    "right" : "double deltaTwo = Math.sqrt(dsq);",
    "info" : "VariableDeclarationStatement[22989-23022]:VariableDeclarationStatement[22989-23022]"
  }, {
    "left" : "dnorm = Math.min(deltaOne, deltaTwo);",
    "right" : "dnorm = Math.min(deltaOne, deltaTwo);",
    "info" : "ExpressionStatement[23035-23072]:ExpressionStatement[23035-23072]"
  }, {
    "left" : "if (dnorm < HALF * rho)",
    "right" : "if (dnorm < HALF * rho)",
    "info" : "IfStatement[23085-25405]:IfStatement[23085-25405]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23109-25405]:Block[23109-25405]"
  }, {
    "left" : "ntrits = -1;",
    "right" : "ntrits = -1;",
    "info" : "ExpressionStatement[23127-23139]:ExpressionStatement[23127-23139]"
  }, {
    "left" : "deltaOne = TEN * rho;",
    "right" : "deltaOne = TEN * rho;",
    "info" : "ExpressionStatement[23195-23216]:ExpressionStatement[23195-23216]"
  }, {
    "left" : "distsq = deltaOne * deltaOne;",
    "right" : "distsq = deltaOne * deltaOne;",
    "info" : "ExpressionStatement[23233-23262]:ExpressionStatement[23233-23262]"
  }, {
    "left" : "if (getEvaluations() <= nfsav + 2)",
    "right" : "if (getEvaluations() <= nfsav + 2)",
    "info" : "IfStatement[23279-23373]:IfStatement[23279-23373]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[23314-23373]:Block[23314-23373]"
  }, {
    "left" : "state = 650;",
    "right" : "state = 650;",
    "info" : "ExpressionStatement[23336-23348]:ExpressionStatement[23336-23348]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[23349-23355]:BreakStatement[23349-23355]"
  }, {
    "left" : "deltaOne = Math.max(diffa, diffb);",
    "right" : "deltaOne = Math.max(diffa, diffb);",
    "info" : "ExpressionStatement[23874-23908]:ExpressionStatement[23874-23908]"
  }, {
    "left" : "final double errbig = Math.max(deltaOne, diffc);",
    "right" : "final double errbig = Math.max(deltaOne, diffc);",
    "info" : "VariableDeclarationStatement[23925-23973]:VariableDeclarationStatement[23925-23973]"
  }, {
    "left" : "final double frhosq = rho * ONE_OVER_EIGHT * rho;",
    "right" : "final double frhosq = rho * ONE_OVER_EIGHT * rho;",
    "info" : "VariableDeclarationStatement[23990-24039]:VariableDeclarationStatement[23990-24039]"
  }, {
    "left" : "if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin)",
    "right" : "if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin)",
    "info" : "IfStatement[24056-24182]:IfStatement[24056-24182]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24123-24182]:Block[24123-24182]"
  }, {
    "left" : "state = 650;",
    "right" : "state = 650;",
    "info" : "ExpressionStatement[24145-24157]:ExpressionStatement[24145-24157]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[24158-24164]:BreakStatement[24158-24164]"
  }, {
    "left" : "final double bdtol = errbig / rho;",
    "right" : "final double bdtol = errbig / rho;",
    "info" : "VariableDeclarationStatement[24199-24233]:VariableDeclarationStatement[24199-24233]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[24250-25355]:ForStatement[24250-25355]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24278-25355]:Block[24278-25355]"
  }, {
    "left" : "double bdtest = bdtol;",
    "right" : "double bdtest = bdtol;",
    "info" : "VariableDeclarationStatement[24300-24322]:VariableDeclarationStatement[24300-24322]"
  }, {
    "left" : "if (newPoint.getEntry(j) == lowerDifference.getEntry(j))",
    "right" : "if (newPoint.getEntry(j) == lowerDifference.getEntry(j))",
    "info" : "IfStatement[24343-24475]:IfStatement[24343-24475]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24400-24475]:Block[24400-24475]"
  }, {
    "left" : "bdtest = work1.getEntry(j);",
    "right" : "bdtest = work1.getEntry(j);",
    "info" : "ExpressionStatement[24426-24453]:ExpressionStatement[24426-24453]"
  }, {
    "left" : "if (newPoint.getEntry(j) == upperDifference.getEntry(j))",
    "right" : "if (newPoint.getEntry(j) == upperDifference.getEntry(j))",
    "info" : "IfStatement[24496-24629]:IfStatement[24496-24629]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24553-24629]:Block[24553-24629]"
  }, {
    "left" : "bdtest = -work1.getEntry(j);",
    "right" : "bdtest = -work1.getEntry(j);",
    "info" : "ExpressionStatement[24579-24607]:ExpressionStatement[24579-24607]"
  }, {
    "left" : "if (bdtest < bdtol)",
    "right" : "if (bdtest < bdtol)",
    "info" : "IfStatement[24650-25337]:IfStatement[24650-25337]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24670-25337]:Block[24670-25337]"
  }, {
    "left" : "double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);",
    "right" : "double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);",
    "info" : "VariableDeclarationStatement[24696-24765]:VariableDeclarationStatement[24696-24765]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[24790-25074]:ForStatement[24790-25074]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[24820-25074]:Block[24820-25074]"
  }, {
    "left" : "final double d1 = interpolationPoints.getEntry(k, j);",
    "right" : "final double d1 = interpolationPoints.getEntry(k, j);",
    "info" : "VariableDeclarationStatement[24901-24954]:VariableDeclarationStatement[24901-24954]"
  }, {
    "left" : "curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);",
    "right" : "curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);",
    "info" : "ExpressionStatement[24983-25048]:ExpressionStatement[24983-25048]"
  }, {
    "left" : "bdtest += HALF * curv * rho;",
    "right" : "bdtest += HALF * curv * rho;",
    "info" : "ExpressionStatement[25099-25127]:ExpressionStatement[25099-25127]"
  }, {
    "left" : "if (bdtest < bdtol)",
    "right" : "if (bdtest < bdtol)",
    "info" : "IfStatement[25152-25247]:IfStatement[25152-25247]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25172-25247]:Block[25172-25247]"
  }, {
    "left" : "state = 650;",
    "right" : "state = 650;",
    "info" : "ExpressionStatement[25202-25214]:ExpressionStatement[25202-25214]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[25215-25221]:BreakStatement[25215-25221]"
  }, {
    "left" : "throw new PathIsExploredException();",
    "right" : "throw new PathIsExploredException();",
    "info" : "ThrowStatement[25272-25308]:ThrowStatement[25272-25308]"
  }, {
    "left" : "state = 680;",
    "right" : "state = 680;",
    "info" : "ExpressionStatement[25372-25384]:ExpressionStatement[25372-25384]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[25385-25391]:BreakStatement[25385-25391]"
  }, {
    "left" : "++ntrits;",
    "right" : "++ntrits;",
    "info" : "ExpressionStatement[25418-25427]:ExpressionStatement[25418-25427]"
  }, {
    "left" : "case 90:",
    "right" : "case 90:",
    "info" : "SwitchCase[25871-25879]:SwitchCase[25871-25879]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25880-31865]:Block[25880-31865]"
  }, {
    "left" : "printState(90);",
    "right" : "printState(90);",
    "info" : "ExpressionStatement[25894-25909]:ExpressionStatement[25894-25909]"
  }, {
    "left" : "if (dsq <= xoptsq * ONE_OVER_A_THOUSAND)",
    "right" : "if (dsq <= xoptsq * ONE_OVER_A_THOUSAND)",
    "info" : "IfStatement[25929-31066]:IfStatement[25929-31066]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[25970-31066]:Block[25970-31066]"
  }, {
    "left" : "final double fracsq = xoptsq * ONE_OVER_FOUR;",
    "right" : "final double fracsq = xoptsq * ONE_OVER_FOUR;",
    "info" : "VariableDeclarationStatement[25988-26033]:VariableDeclarationStatement[25988-26033]"
  }, {
    "left" : "double sumpq = ZERO;",
    "right" : "double sumpq = ZERO;",
    "info" : "VariableDeclarationStatement[26050-26070]:VariableDeclarationStatement[26050-26070]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[26252-27542]:ForStatement[26252-27542]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26282-27542]:Block[26282-27542]"
  }, {
    "left" : "sumpq += modelSecondDerivativesParameters.getEntry(k);",
    "right" : "sumpq += modelSecondDerivativesParameters.getEntry(k);",
    "info" : "ExpressionStatement[26304-26358]:ExpressionStatement[26304-26358]"
  }, {
    "left" : "double sum = -HALF * xoptsq;",
    "right" : "double sum = -HALF * xoptsq;",
    "info" : "VariableDeclarationStatement[26379-26407]:VariableDeclarationStatement[26379-26407]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[26428-26584]:ForStatement[26428-26584]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26456-26584]:Block[26456-26584]"
  }, {
    "left" : "sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);",
    "right" : "sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);",
    "info" : "ExpressionStatement[26482-26562]:ExpressionStatement[26482-26562]"
  }, {
    "left" : "work2.setEntry(k, sum);",
    "right" : "work2.setEntry(k, sum);",
    "info" : "ExpressionStatement[26701-26724]:ExpressionStatement[26701-26724]"
  }, {
    "left" : "final double temp = fracsq - HALF * sum;",
    "right" : "final double temp = fracsq - HALF * sum;",
    "info" : "VariableDeclarationStatement[26745-26785]:VariableDeclarationStatement[26745-26785]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[26806-27524]:ForStatement[26806-27524]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[26834-27524]:Block[26834-27524]"
  }, {
    "left" : "work1.setEntry(i, bMatrix.getEntry(k, i));",
    "right" : "work1.setEntry(i, bMatrix.getEntry(k, i));",
    "info" : "ExpressionStatement[26860-26902]:ExpressionStatement[26860-26902]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));",
    "right" : "lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[26927-27051]:ExpressionStatement[26927-27051]"
  }, {
    "left" : "final int ip = npt + i;",
    "right" : "final int ip = npt + i;",
    "info" : "VariableDeclarationStatement[27076-27099]:VariableDeclarationStatement[27076-27099]"
  }, {
    "left" : "for (int j = 0; j <= i; j++)",
    "right" : "for (int j = 0; j <= i; j++)",
    "info" : "ForStatement[27124-27502]:ForStatement[27124-27502]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27153-27502]:Block[27153-27502]"
  }, {
    "left" : "bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));",
    "right" : "bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));",
    "info" : "ExpressionStatement[27183-27476]:ExpressionStatement[27183-27476]"
  }, {
    "left" : "for (int m = 0; m < nptm; m++)",
    "right" : "for (int m = 0; m < nptm; m++)",
    "info" : "ForStatement[27643-29223]:ForStatement[27643-29223]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27674-29223]:Block[27674-29223]"
  }, {
    "left" : "double sumz = ZERO;",
    "right" : "double sumz = ZERO;",
    "info" : "VariableDeclarationStatement[27696-27715]:VariableDeclarationStatement[27696-27715]"
  }, {
    "left" : "double sumw = ZERO;",
    "right" : "double sumw = ZERO;",
    "info" : "VariableDeclarationStatement[27736-27755]:VariableDeclarationStatement[27736-27755]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[27776-28061]:ForStatement[27776-28061]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[27806-28061]:Block[27806-28061]"
  }, {
    "left" : "sumz += zMatrix.getEntry(k, m);",
    "right" : "sumz += zMatrix.getEntry(k, m);",
    "info" : "ExpressionStatement[27832-27863]:ExpressionStatement[27832-27863]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));",
    "right" : "lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));",
    "info" : "ExpressionStatement[27888-27969]:ExpressionStatement[27888-27969]"
  }, {
    "left" : "sumw += lagrangeValuesAtNewPoint.getEntry(k);",
    "right" : "sumw += lagrangeValuesAtNewPoint.getEntry(k);",
    "info" : "ExpressionStatement[27994-28039]:ExpressionStatement[27994-28039]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[28082-28752]:ForStatement[28082-28752]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28110-28752]:Block[28110-28752]"
  }, {
    "left" : "double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);",
    "right" : "double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);",
    "info" : "VariableDeclarationStatement[28136-28217]:VariableDeclarationStatement[28136-28217]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[28242-28409]:ForStatement[28242-28409]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28272-28409]:Block[28272-28409]"
  }, {
    "left" : "sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);",
    "right" : "sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);",
    "info" : "ExpressionStatement[28302-28383]:ExpressionStatement[28302-28383]"
  }, {
    "left" : "work1.setEntry(j, sum);",
    "right" : "work1.setEntry(j, sum);",
    "info" : "ExpressionStatement[28434-28457]:ExpressionStatement[28434-28457]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[28482-28730]:ForStatement[28482-28730]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28512-28730]:Block[28512-28730]"
  }, {
    "left" : "bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));",
    "right" : "bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));",
    "info" : "ExpressionStatement[28542-28704]:ExpressionStatement[28542-28704]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[28773-29205]:ForStatement[28773-29205]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28801-29205]:Block[28801-29205]"
  }, {
    "left" : "final int ip = i + npt;",
    "right" : "final int ip = i + npt;",
    "info" : "VariableDeclarationStatement[28827-28850]:VariableDeclarationStatement[28827-28850]"
  }, {
    "left" : "final double temp = work1.getEntry(i);",
    "right" : "final double temp = work1.getEntry(i);",
    "info" : "VariableDeclarationStatement[28875-28913]:VariableDeclarationStatement[28875-28913]"
  }, {
    "left" : "for (int j = 0; j <= i; j++)",
    "right" : "for (int j = 0; j <= i; j++)",
    "info" : "ForStatement[28938-29183]:ForStatement[28938-29183]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[28967-29183]:Block[28967-29183]"
  }, {
    "left" : "bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));",
    "right" : "bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));",
    "info" : "ExpressionStatement[28997-29157]:ExpressionStatement[28997-29157]"
  }, {
    "left" : "int ih = 0;",
    "right" : "int ih = 0;",
    "info" : "VariableDeclarationStatement[29409-29420]:VariableDeclarationStatement[29409-29420]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[29437-30452]:ForStatement[29437-30452]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29465-30452]:Block[29465-30452]"
  }, {
    "left" : "work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));",
    "right" : "work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));",
    "info" : "ExpressionStatement[29487-29558]:ExpressionStatement[29487-29558]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[29579-29912]:ForStatement[29579-29912]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29609-29912]:Block[29609-29912]"
  }, {
    "left" : "work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));",
    "right" : "work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));",
    "info" : "ExpressionStatement[29635-29756]:ExpressionStatement[29635-29756]"
  }, {
    "left" : "interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));",
    "right" : "interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));",
    "info" : "ExpressionStatement[29781-29890]:ExpressionStatement[29781-29890]"
  }, {
    "left" : "for (int i = 0; i <= j; i++)",
    "right" : "for (int i = 0; i <= j; i++)",
    "info" : "ForStatement[29933-30434]:ForStatement[29933-30434]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[29962-30434]:Block[29962-30434]"
  }, {
    "left" : "modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));",
    "right" : "modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));",
    "info" : "ExpressionStatement[29989-30298]:ExpressionStatement[29989-30298]"
  }, {
    "left" : "bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));",
    "right" : "bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));",
    "info" : "ExpressionStatement[30323-30382]:ExpressionStatement[30323-30382]"
  }, {
    "left" : "ih++;",
    "right" : "ih++;",
    "info" : "ExpressionStatement[30407-30412]:ExpressionStatement[30407-30412]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[30469-31021]:ForStatement[30469-31021]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[30497-31021]:Block[30497-31021]"
  }, {
    "left" : "originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));",
    "right" : "originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[30519-30606]:ExpressionStatement[30519-30606]"
  }, {
    "left" : "newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[30627-30708]:ExpressionStatement[30627-30708]"
  }, {
    "left" : "lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[30729-30824]:ExpressionStatement[30729-30824]"
  }, {
    "left" : "upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[30845-30940]:ExpressionStatement[30845-30940]"
  }, {
    "left" : "trustRegionCenterOffset.setEntry(i, ZERO);",
    "right" : "trustRegionCenterOffset.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[30961-31003]:ExpressionStatement[30961-31003]"
  }, {
    "left" : "xoptsq = ZERO;",
    "right" : "xoptsq = ZERO;",
    "info" : "ExpressionStatement[31038-31052]:ExpressionStatement[31038-31052]"
  }, {
    "left" : "if (ntrits == 0)",
    "right" : "if (ntrits == 0)",
    "info" : "IfStatement[31079-31147]:IfStatement[31079-31147]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31096-31147]:Block[31096-31147]"
  }, {
    "left" : "state = 210;",
    "right" : "state = 210;",
    "info" : "ExpressionStatement[31114-31126]:ExpressionStatement[31114-31126]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[31127-31133]:BreakStatement[31127-31133]"
  }, {
    "left" : "state = 230;",
    "right" : "state = 230;",
    "info" : "ExpressionStatement[31160-31172]:ExpressionStatement[31160-31172]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[31173-31179]:BreakStatement[31173-31179]"
  }, {
    "left" : "case 210:",
    "right" : "case 210:",
    "info" : "SwitchCase[31874-31883]:SwitchCase[31874-31883]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[31884-33234]:Block[31884-33234]"
  }, {
    "left" : "printState(210);",
    "right" : "printState(210);",
    "info" : "ExpressionStatement[31898-31914]:ExpressionStatement[31898-31914]"
  }, {
    "left" : "final double[] alphaCauchy = altmov(knew, adelt);",
    "right" : "final double[] alphaCauchy = altmov(knew, adelt);",
    "info" : "VariableDeclarationStatement[32737-32786]:VariableDeclarationStatement[32737-32786]"
  }, {
    "left" : "alpha = alphaCauchy[0];",
    "right" : "alpha = alphaCauchy[0];",
    "info" : "ExpressionStatement[32799-32822]:ExpressionStatement[32799-32822]"
  }, {
    "left" : "cauchy = alphaCauchy[1];",
    "right" : "cauchy = alphaCauchy[1];",
    "info" : "ExpressionStatement[32835-32859]:ExpressionStatement[32835-32859]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[32873-33020]:ForStatement[32873-33020]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[32901-33020]:Block[32901-33020]"
  }, {
    "left" : "trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[32919-33006]:ExpressionStatement[32919-33006]"
  }, {
    "left" : "case 230:",
    "right" : "case 230:",
    "info" : "SwitchCase[33243-33252]:SwitchCase[33243-33252]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33253-39232]:Block[33253-39232]"
  }, {
    "left" : "printState(230);",
    "right" : "printState(230);",
    "info" : "ExpressionStatement[33267-33283]:ExpressionStatement[33267-33283]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[33303-33958]:ForStatement[33303-33958]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33333-33958]:Block[33333-33958]"
  }, {
    "left" : "double suma = ZERO;",
    "right" : "double suma = ZERO;",
    "info" : "VariableDeclarationStatement[33351-33370]:VariableDeclarationStatement[33351-33370]"
  }, {
    "left" : "double sumb = ZERO;",
    "right" : "double sumb = ZERO;",
    "info" : "VariableDeclarationStatement[33387-33406]:VariableDeclarationStatement[33387-33406]"
  }, {
    "left" : "double sum = ZERO;",
    "right" : "double sum = ZERO;",
    "info" : "VariableDeclarationStatement[33423-33441]:VariableDeclarationStatement[33423-33441]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[33458-33780]:ForStatement[33458-33780]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[33486-33780]:Block[33486-33780]"
  }, {
    "left" : "suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);",
    "right" : "suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);",
    "info" : "ExpressionStatement[33508-33580]:ExpressionStatement[33508-33580]"
  }, {
    "left" : "sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "right" : "sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "info" : "ExpressionStatement[33601-33682]:ExpressionStatement[33601-33682]"
  }, {
    "left" : "sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);",
    "right" : "sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);",
    "info" : "ExpressionStatement[33703-33762]:ExpressionStatement[33703-33762]"
  }, {
    "left" : "work3.setEntry(k, suma * (HALF * suma + sumb));",
    "right" : "work3.setEntry(k, suma * (HALF * suma + sumb));",
    "info" : "ExpressionStatement[33797-33844]:ExpressionStatement[33797-33844]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(k, sum);",
    "right" : "lagrangeValuesAtNewPoint.setEntry(k, sum);",
    "info" : "ExpressionStatement[33861-33903]:ExpressionStatement[33861-33903]"
  }, {
    "left" : "work2.setEntry(k, suma);",
    "right" : "work2.setEntry(k, suma);",
    "info" : "ExpressionStatement[33920-33944]:ExpressionStatement[33920-33944]"
  }, {
    "left" : "beta = ZERO;",
    "right" : "beta = ZERO;",
    "info" : "ExpressionStatement[33971-33983]:ExpressionStatement[33971-33983]"
  }, {
    "left" : "for (int m = 0; m < nptm; m++)",
    "right" : "for (int m = 0; m < nptm; m++)",
    "info" : "ForStatement[33996-34442]:ForStatement[33996-34442]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34027-34442]:Block[34027-34442]"
  }, {
    "left" : "double sum = ZERO;",
    "right" : "double sum = ZERO;",
    "info" : "VariableDeclarationStatement[34045-34063]:VariableDeclarationStatement[34045-34063]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[34080-34200]:ForStatement[34080-34200]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34110-34200]:Block[34110-34200]"
  }, {
    "left" : "sum += zMatrix.getEntry(k, m) * work3.getEntry(k);",
    "right" : "sum += zMatrix.getEntry(k, m) * work3.getEntry(k);",
    "info" : "ExpressionStatement[34132-34182]:ExpressionStatement[34132-34182]"
  }, {
    "left" : "beta -= sum * sum;",
    "right" : "beta -= sum * sum;",
    "info" : "ExpressionStatement[34217-34235]:ExpressionStatement[34217-34235]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[34252-34428]:ForStatement[34252-34428]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34282-34428]:Block[34282-34428]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));",
    "right" : "lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));",
    "info" : "ExpressionStatement[34304-34410]:ExpressionStatement[34304-34410]"
  }, {
    "left" : "dsq = ZERO;",
    "right" : "dsq = ZERO;",
    "info" : "ExpressionStatement[34455-34466]:ExpressionStatement[34455-34466]"
  }, {
    "left" : "double bsum = ZERO;",
    "right" : "double bsum = ZERO;",
    "info" : "VariableDeclarationStatement[34479-34498]:VariableDeclarationStatement[34479-34498]"
  }, {
    "left" : "double dx = ZERO;",
    "right" : "double dx = ZERO;",
    "info" : "VariableDeclarationStatement[34511-34528]:VariableDeclarationStatement[34511-34528]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[34541-35338]:ForStatement[34541-35338]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34569-35338]:Block[34569-35338]"
  }, {
    "left" : "final double d1 = trialStepPoint.getEntry(j);",
    "right" : "final double d1 = trialStepPoint.getEntry(j);",
    "info" : "VariableDeclarationStatement[34626-34671]:VariableDeclarationStatement[34626-34671]"
  }, {
    "left" : "dsq += d1 * d1;",
    "right" : "dsq += d1 * d1;",
    "info" : "ExpressionStatement[34688-34703]:ExpressionStatement[34688-34703]"
  }, {
    "left" : "double sum = ZERO;",
    "right" : "double sum = ZERO;",
    "info" : "VariableDeclarationStatement[34720-34738]:VariableDeclarationStatement[34720-34738]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[34755-34875]:ForStatement[34755-34875]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[34785-34875]:Block[34785-34875]"
  }, {
    "left" : "sum += work3.getEntry(k) * bMatrix.getEntry(k, j);",
    "right" : "sum += work3.getEntry(k) * bMatrix.getEntry(k, j);",
    "info" : "ExpressionStatement[34807-34857]:ExpressionStatement[34807-34857]"
  }, {
    "left" : "bsum += sum * trialStepPoint.getEntry(j);",
    "right" : "bsum += sum * trialStepPoint.getEntry(j);",
    "info" : "ExpressionStatement[34892-34933]:ExpressionStatement[34892-34933]"
  }, {
    "left" : "final int jp = npt + j;",
    "right" : "final int jp = npt + j;",
    "info" : "VariableDeclarationStatement[34950-34973]:VariableDeclarationStatement[34950-34973]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[34990-35118]:ForStatement[34990-35118]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[35018-35118]:Block[35018-35118]"
  }, {
    "left" : "sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);",
    "right" : "sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);",
    "info" : "ExpressionStatement[35040-35100]:ExpressionStatement[35040-35100]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(jp, sum);",
    "right" : "lagrangeValuesAtNewPoint.setEntry(jp, sum);",
    "info" : "ExpressionStatement[35135-35178]:ExpressionStatement[35135-35178]"
  }, {
    "left" : "bsum += sum * trialStepPoint.getEntry(j);",
    "right" : "bsum += sum * trialStepPoint.getEntry(j);",
    "info" : "ExpressionStatement[35195-35236]:ExpressionStatement[35195-35236]"
  }, {
    "left" : "dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);",
    "right" : "dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);",
    "info" : "ExpressionStatement[35253-35324]:ExpressionStatement[35253-35324]"
  }, {
    "left" : "beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum;",
    "right" : "beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum;",
    "info" : "ExpressionStatement[35352-35421]:ExpressionStatement[35352-35421]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);",
    "right" : "lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);",
    "info" : "ExpressionStatement[35682-35867]:ExpressionStatement[35682-35867]"
  }, {
    "left" : "if (ntrits == 0)",
    "right" : "if (ntrits == 0)",
    "info" : "IfStatement[36113-38909]:IfStatement[36113-38909]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36130-37183]:Block[36130-37183]"
  }, {
    "left" : "final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);",
    "right" : "final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);",
    "info" : "VariableDeclarationStatement[36187-36245]:VariableDeclarationStatement[36187-36245]"
  }, {
    "left" : "denom = d1 * d1 + alpha * beta;",
    "right" : "denom = d1 * d1 + alpha * beta;",
    "info" : "ExpressionStatement[36262-36293]:ExpressionStatement[36262-36293]"
  }, {
    "left" : "if (denom < cauchy && cauchy > ZERO)",
    "right" : "if (denom < cauchy && cauchy > ZERO)",
    "info" : "IfStatement[36310-36729]:IfStatement[36310-36729]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36347-36729]:Block[36347-36729]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[36369-36611]:ForStatement[36369-36611]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[36397-36611]:Block[36397-36611]"
  }, {
    "left" : "newPoint.setEntry(i, alternativeNewPoint.getEntry(i));",
    "right" : "newPoint.setEntry(i, alternativeNewPoint.getEntry(i));",
    "info" : "ExpressionStatement[36423-36477]:ExpressionStatement[36423-36477]"
  }, {
    "left" : "trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[36502-36589]:ExpressionStatement[36502-36589]"
  }, {
    "left" : "cauchy = ZERO;",
    "right" : "cauchy = ZERO;",
    "info" : "ExpressionStatement[36632-36646]:ExpressionStatement[36632-36646]"
  }, {
    "left" : "state = 230;",
    "right" : "state = 230;",
    "info" : "ExpressionStatement[36692-36704]:ExpressionStatement[36692-36704]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[36705-36711]:BreakStatement[36705-36711]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37189-38909]:Block[37189-38909]"
  }, {
    "left" : "final double delsq = delta * delta;",
    "right" : "final double delsq = delta * delta;",
    "info" : "VariableDeclarationStatement[37207-37242]:VariableDeclarationStatement[37207-37242]"
  }, {
    "left" : "scaden = ZERO;",
    "right" : "scaden = ZERO;",
    "info" : "ExpressionStatement[37259-37273]:ExpressionStatement[37259-37273]"
  }, {
    "left" : "biglsq = ZERO;",
    "right" : "biglsq = ZERO;",
    "info" : "ExpressionStatement[37290-37304]:ExpressionStatement[37290-37304]"
  }, {
    "left" : "knew = 0;",
    "right" : "knew = 0;",
    "info" : "ExpressionStatement[37321-37330]:ExpressionStatement[37321-37330]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[37347-38895]:ForStatement[37347-38895]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37377-38895]:Block[37377-38895]"
  }, {
    "left" : "if (k == trustRegionCenterInterpolationPointIndex)",
    "right" : "if (k == trustRegionCenterInterpolationPointIndex)",
    "info" : "IfStatement[37399-37507]:IfStatement[37399-37507]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37450-37507]:Block[37450-37507]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[37476-37485]:ContinueStatement[37476-37485]"
  }, {
    "left" : "double hdiag = ZERO;",
    "right" : "double hdiag = ZERO;",
    "info" : "VariableDeclarationStatement[37528-37548]:VariableDeclarationStatement[37528-37548]"
  }, {
    "left" : "for (int m = 0; m < nptm; m++)",
    "right" : "for (int m = 0; m < nptm; m++)",
    "info" : "ForStatement[37569-37778]:ForStatement[37569-37778]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[37600-37778]:Block[37600-37778]"
  }, {
    "left" : "final double d1 = zMatrix.getEntry(k, m);",
    "right" : "final double d1 = zMatrix.getEntry(k, m);",
    "info" : "VariableDeclarationStatement[37673-37714]:VariableDeclarationStatement[37673-37714]"
  }, {
    "left" : "hdiag += d1 * d1;",
    "right" : "hdiag += d1 * d1;",
    "info" : "ExpressionStatement[37739-37756]:ExpressionStatement[37739-37756]"
  }, {
    "left" : "final double d2 = lagrangeValuesAtNewPoint.getEntry(k);",
    "right" : "final double d2 = lagrangeValuesAtNewPoint.getEntry(k);",
    "info" : "VariableDeclarationStatement[37842-37897]:VariableDeclarationStatement[37842-37897]"
  }, {
    "left" : "final double den = beta * hdiag + d2 * d2;",
    "right" : "final double den = beta * hdiag + d2 * d2;",
    "info" : "VariableDeclarationStatement[37918-37960]:VariableDeclarationStatement[37918-37960]"
  }, {
    "left" : "distsq = ZERO;",
    "right" : "distsq = ZERO;",
    "info" : "ExpressionStatement[37981-37995]:ExpressionStatement[37981-37995]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[38016-38273]:ForStatement[38016-38273]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38044-38273]:Block[38044-38273]"
  }, {
    "left" : "final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);",
    "right" : "final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);",
    "info" : "VariableDeclarationStatement[38117-38208]:VariableDeclarationStatement[38117-38208]"
  }, {
    "left" : "distsq += d3 * d3;",
    "right" : "distsq += d3 * d3;",
    "info" : "ExpressionStatement[38233-38251]:ExpressionStatement[38233-38251]"
  }, {
    "left" : "final double d4 = distsq / delsq;",
    "right" : "final double d4 = distsq / delsq;",
    "info" : "VariableDeclarationStatement[38374-38407]:VariableDeclarationStatement[38374-38407]"
  }, {
    "left" : "final double temp = Math.max(ONE, d4 * d4);",
    "right" : "final double temp = Math.max(ONE, d4 * d4);",
    "info" : "VariableDeclarationStatement[38428-38471]:VariableDeclarationStatement[38428-38471]"
  }, {
    "left" : "if (temp * den > scaden)",
    "right" : "if (temp * den > scaden)",
    "info" : "IfStatement[38492-38656]:IfStatement[38492-38656]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[38517-38656]:Block[38517-38656]"
  }, {
    "left" : "scaden = temp * den;",
    "right" : "scaden = temp * den;",
    "info" : "ExpressionStatement[38543-38563]:ExpressionStatement[38543-38563]"
  }, {
    "left" : "knew = k;",
    "right" : "knew = k;",
    "info" : "ExpressionStatement[38588-38597]:ExpressionStatement[38588-38597]"
  }, {
    "left" : "denom = den;",
    "right" : "denom = den;",
    "info" : "ExpressionStatement[38622-38634]:ExpressionStatement[38622-38634]"
  }, {
    "left" : "final double d5 = lagrangeValuesAtNewPoint.getEntry(k);",
    "right" : "final double d5 = lagrangeValuesAtNewPoint.getEntry(k);",
    "info" : "VariableDeclarationStatement[38757-38812]:VariableDeclarationStatement[38757-38812]"
  }, {
    "left" : "biglsq = Math.max(biglsq, temp * (d5 * d5));",
    "right" : "biglsq = Math.max(biglsq, temp * (d5 * d5));",
    "info" : "ExpressionStatement[38833-38877]:ExpressionStatement[38833-38877]"
  }, {
    "left" : "case 360:",
    "right" : "case 360:",
    "info" : "SwitchCase[39241-39250]:SwitchCase[39241-39250]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39251-53458]:Block[39251-53458]"
  }, {
    "left" : "printState(360);",
    "right" : "printState(360);",
    "info" : "ExpressionStatement[39265-39281]:ExpressionStatement[39265-39281]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[39301-40007]:ForStatement[39301-40007]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39329-40007]:Block[39329-40007]"
  }, {
    "left" : "final double d3 = lowerBound[i];",
    "right" : "final double d3 = lowerBound[i];",
    "info" : "VariableDeclarationStatement[39413-39445]:VariableDeclarationStatement[39413-39445]"
  }, {
    "left" : "final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);",
    "right" : "final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);",
    "info" : "VariableDeclarationStatement[39462-39527]:VariableDeclarationStatement[39462-39527]"
  }, {
    "left" : "final double d1 = Math.max(d3, d4);",
    "right" : "final double d1 = Math.max(d3, d4);",
    "info" : "VariableDeclarationStatement[39544-39579]:VariableDeclarationStatement[39544-39579]"
  }, {
    "left" : "final double d2 = upperBound[i];",
    "right" : "final double d2 = upperBound[i];",
    "info" : "VariableDeclarationStatement[39596-39628]:VariableDeclarationStatement[39596-39628]"
  }, {
    "left" : "currentBest.setEntry(i, Math.min(d1, d2));",
    "right" : "currentBest.setEntry(i, Math.min(d1, d2));",
    "info" : "ExpressionStatement[39645-39687]:ExpressionStatement[39645-39687]"
  }, {
    "left" : "if (newPoint.getEntry(i) == lowerDifference.getEntry(i))",
    "right" : "if (newPoint.getEntry(i) == lowerDifference.getEntry(i))",
    "info" : "IfStatement[39704-39840]:IfStatement[39704-39840]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39761-39840]:Block[39761-39840]"
  }, {
    "left" : "currentBest.setEntry(i, lowerBound[i]);",
    "right" : "currentBest.setEntry(i, lowerBound[i]);",
    "info" : "ExpressionStatement[39783-39822]:ExpressionStatement[39783-39822]"
  }, {
    "left" : "if (newPoint.getEntry(i) == upperDifference.getEntry(i))",
    "right" : "if (newPoint.getEntry(i) == upperDifference.getEntry(i))",
    "info" : "IfStatement[39857-39993]:IfStatement[39857-39993]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[39914-39993]:Block[39914-39993]"
  }, {
    "left" : "currentBest.setEntry(i, upperBound[i]);",
    "right" : "currentBest.setEntry(i, upperBound[i]);",
    "info" : "ExpressionStatement[39936-39975]:ExpressionStatement[39936-39975]"
  }, {
    "left" : "f = computeObjectiveValue(currentBest.toArray());",
    "right" : "f = computeObjectiveValue(currentBest.toArray());",
    "info" : "ExpressionStatement[40021-40070]:ExpressionStatement[40021-40070]"
  }, {
    "left" : "if (!isMinimize)",
    "right" : "if (!isMinimize)",
    "info" : "IfStatement[40084-40124]:IfStatement[40084-40124]"
  }, {
    "left" : "f = -f;",
    "right" : "f = -f;",
    "info" : "ExpressionStatement[40117-40124]:ExpressionStatement[40117-40124]"
  }, {
    "left" : "if (ntrits == -1)",
    "right" : "if (ntrits == -1)",
    "info" : "IfStatement[40137-40233]:IfStatement[40137-40233]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[40155-40233]:Block[40155-40233]"
  }, {
    "left" : "fsave = f;",
    "right" : "fsave = f;",
    "info" : "ExpressionStatement[40173-40183]:ExpressionStatement[40173-40183]"
  }, {
    "left" : "state = 720;",
    "right" : "state = 720;",
    "info" : "ExpressionStatement[40200-40212]:ExpressionStatement[40200-40212]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[40213-40219]:BreakStatement[40213-40219]"
  }, {
    "left" : "final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);",
    "right" : "final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);",
    "info" : "VariableDeclarationStatement[40396-40490]:VariableDeclarationStatement[40396-40490]"
  }, {
    "left" : "double vquad = ZERO;",
    "right" : "double vquad = ZERO;",
    "info" : "VariableDeclarationStatement[40503-40523]:VariableDeclarationStatement[40503-40523]"
  }, {
    "left" : "int ih = 0;",
    "right" : "int ih = 0;",
    "info" : "VariableDeclarationStatement[40536-40547]:VariableDeclarationStatement[40536-40547]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[40560-41052]:ForStatement[40560-41052]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[40588-41052]:Block[40588-41052]"
  }, {
    "left" : "vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);",
    "right" : "vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);",
    "info" : "ExpressionStatement[40606-40684]:ExpressionStatement[40606-40684]"
  }, {
    "left" : "for (int i = 0; i <= j; i++)",
    "right" : "for (int i = 0; i <= j; i++)",
    "info" : "ForStatement[40701-41038]:ForStatement[40701-41038]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[40730-41038]:Block[40730-41038]"
  }, {
    "left" : "double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);",
    "right" : "double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);",
    "info" : "VariableDeclarationStatement[40752-40822]:VariableDeclarationStatement[40752-40822]"
  }, {
    "left" : "if (i == j)",
    "right" : "if (i == j)",
    "info" : "IfStatement[40843-40916]:IfStatement[40843-40916]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[40855-40916]:Block[40855-40916]"
  }, {
    "left" : "temp *= HALF;",
    "right" : "temp *= HALF;",
    "info" : "ExpressionStatement[40881-40894]:ExpressionStatement[40881-40894]"
  }, {
    "left" : "vquad += modelSecondDerivativesValues.getEntry(ih) * temp;",
    "right" : "vquad += modelSecondDerivativesValues.getEntry(ih) * temp;",
    "info" : "ExpressionStatement[40937-40995]:ExpressionStatement[40937-40995]"
  }, {
    "left" : "ih++;",
    "right" : "ih++;",
    "info" : "ExpressionStatement[41016-41021]:ExpressionStatement[41016-41021]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[41065-41384]:ForStatement[41065-41384]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41095-41384]:Block[41095-41384]"
  }, {
    "left" : "final double d1 = work2.getEntry(k);",
    "right" : "final double d1 = work2.getEntry(k);",
    "info" : "VariableDeclarationStatement[41152-41188]:VariableDeclarationStatement[41152-41188]"
  }, {
    "left" : "final double d2 = d1 * d1;",
    "right" : "final double d2 = d1 * d1;",
    "info" : "VariableDeclarationStatement[41205-41231]:VariableDeclarationStatement[41205-41231]"
  }, {
    "left" : "vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;",
    "right" : "vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;",
    "info" : "ExpressionStatement[41304-41370]:ExpressionStatement[41304-41370]"
  }, {
    "left" : "final double diff = f - fopt - vquad;",
    "right" : "final double diff = f - fopt - vquad;",
    "info" : "VariableDeclarationStatement[41397-41434]:VariableDeclarationStatement[41397-41434]"
  }, {
    "left" : "diffc = diffb;",
    "right" : "diffc = diffb;",
    "info" : "ExpressionStatement[41447-41461]:ExpressionStatement[41447-41461]"
  }, {
    "left" : "diffb = diffa;",
    "right" : "diffb = diffa;",
    "info" : "ExpressionStatement[41474-41488]:ExpressionStatement[41474-41488]"
  }, {
    "left" : "diffa = Math.abs(diff);",
    "right" : "diffa = Math.abs(diff);",
    "info" : "ExpressionStatement[41501-41524]:ExpressionStatement[41501-41524]"
  }, {
    "left" : "if (dnorm > rho)",
    "right" : "if (dnorm > rho)",
    "info" : "IfStatement[41537-41611]:IfStatement[41537-41611]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41554-41611]:Block[41554-41611]"
  }, {
    "left" : "nfsav = getEvaluations();",
    "right" : "nfsav = getEvaluations();",
    "info" : "ExpressionStatement[41572-41597]:ExpressionStatement[41572-41597]"
  }, {
    "left" : "if (ntrits > 0)",
    "right" : "if (ntrits > 0)",
    "info" : "IfStatement[41697-44598]:IfStatement[41697-44598]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41713-44598]:Block[41713-44598]"
  }, {
    "left" : "if (vquad >= ZERO)",
    "right" : "if (vquad >= ZERO)",
    "info" : "IfStatement[41731-41876]:IfStatement[41731-41876]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[41750-41876]:Block[41750-41876]"
  }, {
    "left" : "throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);",
    "right" : "throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);",
    "info" : "ThrowStatement[41772-41858]:ThrowStatement[41772-41858]"
  }, {
    "left" : "ratio = (f - fopt) / vquad;",
    "right" : "ratio = (f - fopt) / vquad;",
    "info" : "ExpressionStatement[41893-41920]:ExpressionStatement[41893-41920]"
  }, {
    "left" : "final double hDelta = HALF * delta;",
    "right" : "final double hDelta = HALF * delta;",
    "info" : "VariableDeclarationStatement[41937-41972]:VariableDeclarationStatement[41937-41972]"
  }, {
    "left" : "if (ratio <= ONE_OVER_TEN)",
    "right" : "if (ratio <= ONE_OVER_TEN)",
    "info" : "IfStatement[41989-42376]:IfStatement[41989-42376]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42016-42125]:Block[42016-42125]"
  }, {
    "left" : "delta = Math.min(hDelta, dnorm);",
    "right" : "delta = Math.min(hDelta, dnorm);",
    "info" : "ExpressionStatement[42075-42107]:ExpressionStatement[42075-42107]"
  }, {
    "left" : "if (ratio <= .7)",
    "right" : "if (ratio <= .7)",
    "info" : "IfStatement[42131-42376]:IfStatement[42131-42376]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42148-42257]:Block[42148-42257]"
  }, {
    "left" : "delta = Math.max(hDelta, dnorm);",
    "right" : "delta = Math.max(hDelta, dnorm);",
    "info" : "ExpressionStatement[42207-42239]:ExpressionStatement[42207-42239]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42263-42376]:Block[42263-42376]"
  }, {
    "left" : "delta = Math.max(hDelta, 2 * dnorm);",
    "right" : "delta = Math.max(hDelta, 2 * dnorm);",
    "info" : "ExpressionStatement[42322-42358]:ExpressionStatement[42322-42358]"
  }, {
    "left" : "if (delta <= rho * 1.5)",
    "right" : "if (delta <= rho * 1.5)",
    "info" : "IfStatement[42393-42469]:IfStatement[42393-42469]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42417-42469]:Block[42417-42469]"
  }, {
    "left" : "delta = rho;",
    "right" : "delta = rho;",
    "info" : "ExpressionStatement[42439-42451]:ExpressionStatement[42439-42451]"
  }, {
    "left" : "if (f < fopt)",
    "right" : "if (f < fopt)",
    "info" : "IfStatement[42566-44584]:IfStatement[42566-44584]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42580-44584]:Block[42580-44584]"
  }, {
    "left" : "final int ksav = knew;",
    "right" : "final int ksav = knew;",
    "info" : "VariableDeclarationStatement[42602-42624]:VariableDeclarationStatement[42602-42624]"
  }, {
    "left" : "final double densav = denom;",
    "right" : "final double densav = denom;",
    "info" : "VariableDeclarationStatement[42645-42673]:VariableDeclarationStatement[42645-42673]"
  }, {
    "left" : "final double delsq = delta * delta;",
    "right" : "final double delsq = delta * delta;",
    "info" : "VariableDeclarationStatement[42694-42729]:VariableDeclarationStatement[42694-42729]"
  }, {
    "left" : "scaden = ZERO;",
    "right" : "scaden = ZERO;",
    "info" : "ExpressionStatement[42750-42764]:ExpressionStatement[42750-42764]"
  }, {
    "left" : "biglsq = ZERO;",
    "right" : "biglsq = ZERO;",
    "info" : "ExpressionStatement[42785-42799]:ExpressionStatement[42785-42799]"
  }, {
    "left" : "knew = 0;",
    "right" : "knew = 0;",
    "info" : "ExpressionStatement[42820-42829]:ExpressionStatement[42820-42829]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[42850-44416]:ForStatement[42850-44416]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42880-44416]:Block[42880-44416]"
  }, {
    "left" : "double hdiag = ZERO;",
    "right" : "double hdiag = ZERO;",
    "info" : "VariableDeclarationStatement[42906-42926]:VariableDeclarationStatement[42906-42926]"
  }, {
    "left" : "for (int m = 0; m < nptm; m++)",
    "right" : "for (int m = 0; m < nptm; m++)",
    "info" : "ForStatement[42951-43176]:ForStatement[42951-43176]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[42982-43176]:Block[42982-43176]"
  }, {
    "left" : "final double d1 = zMatrix.getEntry(k, m);",
    "right" : "final double d1 = zMatrix.getEntry(k, m);",
    "info" : "VariableDeclarationStatement[43063-43104]:VariableDeclarationStatement[43063-43104]"
  }, {
    "left" : "hdiag += d1 * d1;",
    "right" : "hdiag += d1 * d1;",
    "info" : "ExpressionStatement[43133-43150]:ExpressionStatement[43133-43150]"
  }, {
    "left" : "final double d1 = lagrangeValuesAtNewPoint.getEntry(k);",
    "right" : "final double d1 = lagrangeValuesAtNewPoint.getEntry(k);",
    "info" : "VariableDeclarationStatement[43248-43303]:VariableDeclarationStatement[43248-43303]"
  }, {
    "left" : "final double den = beta * hdiag + d1 * d1;",
    "right" : "final double den = beta * hdiag + d1 * d1;",
    "info" : "VariableDeclarationStatement[43328-43370]:VariableDeclarationStatement[43328-43370]"
  }, {
    "left" : "distsq = ZERO;",
    "right" : "distsq = ZERO;",
    "info" : "ExpressionStatement[43395-43409]:ExpressionStatement[43395-43409]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[43434-43692]:ForStatement[43434-43692]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43462-43692]:Block[43462-43692]"
  }, {
    "left" : "final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);",
    "right" : "final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);",
    "info" : "VariableDeclarationStatement[43543-43619]:VariableDeclarationStatement[43543-43619]"
  }, {
    "left" : "distsq += d2 * d2;",
    "right" : "distsq += d2 * d2;",
    "info" : "ExpressionStatement[43648-43666]:ExpressionStatement[43648-43666]"
  }, {
    "left" : "final double d3 = distsq / delsq;",
    "right" : "final double d3 = distsq / delsq;",
    "info" : "VariableDeclarationStatement[43805-43838]:VariableDeclarationStatement[43805-43838]"
  }, {
    "left" : "final double temp = Math.max(ONE, d3 * d3);",
    "right" : "final double temp = Math.max(ONE, d3 * d3);",
    "info" : "VariableDeclarationStatement[43863-43906]:VariableDeclarationStatement[43863-43906]"
  }, {
    "left" : "if (temp * den > scaden)",
    "right" : "if (temp * den > scaden)",
    "info" : "IfStatement[43931-44111]:IfStatement[43931-44111]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[43956-44111]:Block[43956-44111]"
  }, {
    "left" : "scaden = temp * den;",
    "right" : "scaden = temp * den;",
    "info" : "ExpressionStatement[43986-44006]:ExpressionStatement[43986-44006]"
  }, {
    "left" : "knew = k;",
    "right" : "knew = k;",
    "info" : "ExpressionStatement[44035-44044]:ExpressionStatement[44035-44044]"
  }, {
    "left" : "denom = den;",
    "right" : "denom = den;",
    "info" : "ExpressionStatement[44073-44085]:ExpressionStatement[44073-44085]"
  }, {
    "left" : "final double d4 = lagrangeValuesAtNewPoint.getEntry(k);",
    "right" : "final double d4 = lagrangeValuesAtNewPoint.getEntry(k);",
    "info" : "VariableDeclarationStatement[44224-44279]:VariableDeclarationStatement[44224-44279]"
  }, {
    "left" : "final double d5 = temp * (d4 * d4);",
    "right" : "final double d5 = temp * (d4 * d4);",
    "info" : "VariableDeclarationStatement[44304-44339]:VariableDeclarationStatement[44304-44339]"
  }, {
    "left" : "biglsq = Math.max(biglsq, d5);",
    "right" : "biglsq = Math.max(biglsq, d5);",
    "info" : "ExpressionStatement[44364-44394]:ExpressionStatement[44364-44394]"
  }, {
    "left" : "if (scaden <= HALF * biglsq)",
    "right" : "if (scaden <= HALF * biglsq)",
    "info" : "IfStatement[44437-44566]:IfStatement[44437-44566]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[44466-44566]:Block[44466-44566]"
  }, {
    "left" : "knew = ksav;",
    "right" : "knew = ksav;",
    "info" : "ExpressionStatement[44492-44504]:ExpressionStatement[44492-44504]"
  }, {
    "left" : "denom = densav;",
    "right" : "denom = densav;",
    "info" : "ExpressionStatement[44529-44544]:ExpressionStatement[44529-44544]"
  }, {
    "left" : "update(beta, denom, knew);",
    "right" : "update(beta, denom, knew);",
    "info" : "ExpressionStatement[44773-44799]:ExpressionStatement[44773-44799]"
  }, {
    "left" : "ih = 0;",
    "right" : "ih = 0;",
    "info" : "ExpressionStatement[44813-44820]:ExpressionStatement[44813-44820]"
  }, {
    "left" : "final double pqold = modelSecondDerivativesParameters.getEntry(knew);",
    "right" : "final double pqold = modelSecondDerivativesParameters.getEntry(knew);",
    "info" : "VariableDeclarationStatement[44833-44902]:VariableDeclarationStatement[44833-44902]"
  }, {
    "left" : "modelSecondDerivativesParameters.setEntry(knew, ZERO);",
    "right" : "modelSecondDerivativesParameters.setEntry(knew, ZERO);",
    "info" : "ExpressionStatement[44915-44969]:ExpressionStatement[44915-44969]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[44982-45352]:ForStatement[44982-45352]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45010-45352]:Block[45010-45352]"
  }, {
    "left" : "final double temp = pqold * interpolationPoints.getEntry(knew, i);",
    "right" : "final double temp = pqold * interpolationPoints.getEntry(knew, i);",
    "info" : "VariableDeclarationStatement[45028-45094]:VariableDeclarationStatement[45028-45094]"
  }, {
    "left" : "for (int j = 0; j <= i; j++)",
    "right" : "for (int j = 0; j <= i; j++)",
    "info" : "ForStatement[45111-45338]:ForStatement[45111-45338]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45140-45338]:Block[45140-45338]"
  }, {
    "left" : "modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));",
    "right" : "modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));",
    "info" : "ExpressionStatement[45162-45294]:ExpressionStatement[45162-45294]"
  }, {
    "left" : "ih++;",
    "right" : "ih++;",
    "info" : "ExpressionStatement[45315-45320]:ExpressionStatement[45315-45320]"
  }, {
    "left" : "for (int m = 0; m < nptm; m++)",
    "right" : "for (int m = 0; m < nptm; m++)",
    "info" : "ForStatement[45365-45691]:ForStatement[45365-45691]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45396-45691]:Block[45396-45691]"
  }, {
    "left" : "final double temp = diff * zMatrix.getEntry(knew, m);",
    "right" : "final double temp = diff * zMatrix.getEntry(knew, m);",
    "info" : "VariableDeclarationStatement[45414-45467]:VariableDeclarationStatement[45414-45467]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[45484-45677]:ForStatement[45484-45677]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45514-45677]:Block[45514-45677]"
  }, {
    "left" : "modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));",
    "right" : "modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));",
    "info" : "ExpressionStatement[45536-45659]:ExpressionStatement[45536-45659]"
  }, {
    "left" : "fAtInterpolationPoints.setEntry(knew,  f);",
    "right" : "fAtInterpolationPoints.setEntry(knew,  f);",
    "info" : "ExpressionStatement[45874-45916]:ExpressionStatement[45874-45916]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[45929-46111]:ForStatement[45929-46111]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[45957-46111]:Block[45957-46111]"
  }, {
    "left" : "interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));",
    "right" : "interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));",
    "info" : "ExpressionStatement[45975-46035]:ExpressionStatement[45975-46035]"
  }, {
    "left" : "work1.setEntry(i, bMatrix.getEntry(knew, i));",
    "right" : "work1.setEntry(i, bMatrix.getEntry(knew, i));",
    "info" : "ExpressionStatement[46052-46097]:ExpressionStatement[46052-46097]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[46124-46769]:ForStatement[46124-46769]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46154-46769]:Block[46154-46769]"
  }, {
    "left" : "double suma = ZERO;",
    "right" : "double suma = ZERO;",
    "info" : "VariableDeclarationStatement[46172-46191]:VariableDeclarationStatement[46172-46191]"
  }, {
    "left" : "for (int m = 0; m < nptm; m++)",
    "right" : "for (int m = 0; m < nptm; m++)",
    "info" : "ForStatement[46208-46338]:ForStatement[46208-46338]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46239-46338]:Block[46239-46338]"
  }, {
    "left" : "suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);",
    "right" : "suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);",
    "info" : "ExpressionStatement[46261-46320]:ExpressionStatement[46261-46320]"
  }, {
    "left" : "double sumb = ZERO;",
    "right" : "double sumb = ZERO;",
    "info" : "VariableDeclarationStatement[46355-46374]:VariableDeclarationStatement[46355-46374]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[46391-46540]:ForStatement[46391-46540]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46419-46540]:Block[46419-46540]"
  }, {
    "left" : "sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "right" : "sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "info" : "ExpressionStatement[46441-46522]:ExpressionStatement[46441-46522]"
  }, {
    "left" : "final double temp = suma * sumb;",
    "right" : "final double temp = suma * sumb;",
    "info" : "VariableDeclarationStatement[46557-46589]:VariableDeclarationStatement[46557-46589]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[46606-46755]:ForStatement[46606-46755]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46634-46755]:Block[46634-46755]"
  }, {
    "left" : "work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));",
    "right" : "work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));",
    "info" : "ExpressionStatement[46656-46737]:ExpressionStatement[46656-46737]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[46782-46950]:ForStatement[46782-46950]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[46810-46950]:Block[46810-46950]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));",
    "right" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));",
    "info" : "ExpressionStatement[46828-46936]:ExpressionStatement[46828-46936]"
  }, {
    "left" : "if (f < fopt)",
    "right" : "if (f < fopt)",
    "info" : "IfStatement[47050-48598]:IfStatement[47050-48598]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[47064-48598]:Block[47064-48598]"
  }, {
    "left" : "trustRegionCenterInterpolationPointIndex = knew;",
    "right" : "trustRegionCenterInterpolationPointIndex = knew;",
    "info" : "ExpressionStatement[47082-47130]:ExpressionStatement[47082-47130]"
  }, {
    "left" : "xoptsq = ZERO;",
    "right" : "xoptsq = ZERO;",
    "info" : "ExpressionStatement[47147-47161]:ExpressionStatement[47147-47161]"
  }, {
    "left" : "ih = 0;",
    "right" : "ih = 0;",
    "info" : "ExpressionStatement[47178-47185]:ExpressionStatement[47178-47185]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[47202-48013]:ForStatement[47202-48013]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[47230-48013]:Block[47230-48013]"
  }, {
    "left" : "trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));",
    "right" : "trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));",
    "info" : "ExpressionStatement[47252-47310]:ExpressionStatement[47252-47310]"
  }, {
    "left" : "final double d1 = trustRegionCenterOffset.getEntry(j);",
    "right" : "final double d1 = trustRegionCenterOffset.getEntry(j);",
    "info" : "VariableDeclarationStatement[47374-47428]:VariableDeclarationStatement[47374-47428]"
  }, {
    "left" : "xoptsq += d1 * d1;",
    "right" : "xoptsq += d1 * d1;",
    "info" : "ExpressionStatement[47449-47467]:ExpressionStatement[47449-47467]"
  }, {
    "left" : "for (int i = 0; i <= j; i++)",
    "right" : "for (int i = 0; i <= j; i++)",
    "info" : "ForStatement[47488-47995]:ForStatement[47488-47995]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[47517-47995]:Block[47517-47995]"
  }, {
    "left" : "if (i < j)",
    "right" : "if (i < j)",
    "info" : "IfStatement[47543-47764]:IfStatement[47543-47764]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[47554-47764]:Block[47554-47764]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));",
    "right" : "gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));",
    "info" : "ExpressionStatement[47584-47738]:ExpressionStatement[47584-47738]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));",
    "right" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));",
    "info" : "ExpressionStatement[47789-47943]:ExpressionStatement[47789-47943]"
  }, {
    "left" : "ih++;",
    "right" : "ih++;",
    "info" : "ExpressionStatement[47968-47973]:ExpressionStatement[47968-47973]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[48030-48584]:ForStatement[48030-48584]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48060-48584]:Block[48060-48584]"
  }, {
    "left" : "double temp = ZERO;",
    "right" : "double temp = ZERO;",
    "info" : "VariableDeclarationStatement[48082-48101]:VariableDeclarationStatement[48082-48101]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[48122-48270]:ForStatement[48122-48270]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48150-48270]:Block[48150-48270]"
  }, {
    "left" : "temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);",
    "right" : "temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);",
    "info" : "ExpressionStatement[48176-48248]:ExpressionStatement[48176-48248]"
  }, {
    "left" : "temp *= modelSecondDerivativesParameters.getEntry(k);",
    "right" : "temp *= modelSecondDerivativesParameters.getEntry(k);",
    "info" : "ExpressionStatement[48291-48344]:ExpressionStatement[48291-48344]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[48365-48566]:ForStatement[48365-48566]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48393-48566]:Block[48393-48566]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));",
    "right" : "gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));",
    "info" : "ExpressionStatement[48419-48544]:ExpressionStatement[48419-48544]"
  }, {
    "left" : "if (ntrits > 0)",
    "right" : "if (ntrits > 0)",
    "info" : "IfStatement[48826-52651]:IfStatement[48826-52651]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48842-52651]:Block[48842-52651]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[48860-49124]:ForStatement[48860-49124]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[48890-49124]:Block[48890-49124]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));",
    "right" : "lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));",
    "info" : "ExpressionStatement[48912-49061]:ExpressionStatement[48912-49061]"
  }, {
    "left" : "work3.setEntry(k, ZERO);",
    "right" : "work3.setEntry(k, ZERO);",
    "info" : "ExpressionStatement[49082-49106]:ExpressionStatement[49082-49106]"
  }, {
    "left" : "for (int j = 0; j < nptm; j++)",
    "right" : "for (int j = 0; j < nptm; j++)",
    "info" : "ForStatement[49141-49565]:ForStatement[49141-49565]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49172-49565]:Block[49172-49565]"
  }, {
    "left" : "double sum = ZERO;",
    "right" : "double sum = ZERO;",
    "info" : "VariableDeclarationStatement[49194-49212]:VariableDeclarationStatement[49194-49212]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[49233-49380]:ForStatement[49233-49380]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49263-49380]:Block[49263-49380]"
  }, {
    "left" : "sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);",
    "right" : "sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);",
    "info" : "ExpressionStatement[49289-49358]:ExpressionStatement[49289-49358]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[49401-49547]:ForStatement[49401-49547]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49431-49547]:Block[49431-49547]"
  }, {
    "left" : "work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));",
    "right" : "work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));",
    "info" : "ExpressionStatement[49457-49525]:ExpressionStatement[49457-49525]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[49582-49969]:ForStatement[49582-49969]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49612-49969]:Block[49612-49969]"
  }, {
    "left" : "double sum = ZERO;",
    "right" : "double sum = ZERO;",
    "info" : "VariableDeclarationStatement[49634-49652]:VariableDeclarationStatement[49634-49652]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[49673-49829]:ForStatement[49673-49829]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[49701-49829]:Block[49701-49829]"
  }, {
    "left" : "sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "right" : "sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "info" : "ExpressionStatement[49727-49807]:ExpressionStatement[49727-49807]"
  }, {
    "left" : "work2.setEntry(k, work3.getEntry(k));",
    "right" : "work2.setEntry(k, work3.getEntry(k));",
    "info" : "ExpressionStatement[49850-49887]:ExpressionStatement[49850-49887]"
  }, {
    "left" : "work3.setEntry(k, sum * work3.getEntry(k));",
    "right" : "work3.setEntry(k, sum * work3.getEntry(k));",
    "info" : "ExpressionStatement[49908-49951]:ExpressionStatement[49908-49951]"
  }, {
    "left" : "double gqsq = ZERO;",
    "right" : "double gqsq = ZERO;",
    "info" : "VariableDeclarationStatement[49986-50005]:VariableDeclarationStatement[49986-50005]"
  }, {
    "left" : "double gisq = ZERO;",
    "right" : "double gisq = ZERO;",
    "info" : "VariableDeclarationStatement[50022-50041]:VariableDeclarationStatement[50022-50041]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[50058-51684]:ForStatement[50058-51684]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50086-51684]:Block[50086-51684]"
  }, {
    "left" : "double sum = ZERO;",
    "right" : "double sum = ZERO;",
    "info" : "VariableDeclarationStatement[50108-50126]:VariableDeclarationStatement[50108-50126]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[50147-50379]:ForStatement[50147-50379]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50177-50379]:Block[50177-50379]"
  }, {
    "left" : "sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);",
    "right" : "sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);",
    "info" : "ExpressionStatement[50203-50357]:ExpressionStatement[50203-50357]"
  }, {
    "left" : "if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i))",
    "right" : "if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i))",
    "info" : "IfStatement[50400-51597]:IfStatement[50400-51597]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50472-50874]:Block[50472-50874]"
  }, {
    "left" : "final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));",
    "right" : "final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));",
    "info" : "VariableDeclarationStatement[50586-50660]:VariableDeclarationStatement[50586-50660]"
  }, {
    "left" : "gqsq += d1 * d1;",
    "right" : "gqsq += d1 * d1;",
    "info" : "ExpressionStatement[50685-50701]:ExpressionStatement[50685-50701]"
  }, {
    "left" : "final double d2 = Math.min(ZERO, sum);",
    "right" : "final double d2 = Math.min(ZERO, sum);",
    "info" : "VariableDeclarationStatement[50773-50811]:VariableDeclarationStatement[50773-50811]"
  }, {
    "left" : "gisq += d2 * d2;",
    "right" : "gisq += d2 * d2;",
    "info" : "ExpressionStatement[50836-50852]:ExpressionStatement[50836-50852]"
  }, {
    "left" : "if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i))",
    "right" : "if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i))",
    "info" : "IfStatement[50880-51597]:IfStatement[50880-51597]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[50952-51354]:Block[50952-51354]"
  }, {
    "left" : "final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));",
    "right" : "final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));",
    "info" : "VariableDeclarationStatement[51066-51140]:VariableDeclarationStatement[51066-51140]"
  }, {
    "left" : "gqsq += d1 * d1;",
    "right" : "gqsq += d1 * d1;",
    "info" : "ExpressionStatement[51165-51181]:ExpressionStatement[51165-51181]"
  }, {
    "left" : "final double d2 = Math.max(ZERO, sum);",
    "right" : "final double d2 = Math.max(ZERO, sum);",
    "info" : "VariableDeclarationStatement[51253-51291]:VariableDeclarationStatement[51253-51291]"
  }, {
    "left" : "gisq += d2 * d2;",
    "right" : "gisq += d2 * d2;",
    "info" : "ExpressionStatement[51316-51332]:ExpressionStatement[51316-51332]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[51360-51597]:Block[51360-51597]"
  }, {
    "left" : "final double d1 = gradientAtTrustRegionCenter.getEntry(i);",
    "right" : "final double d1 = gradientAtTrustRegionCenter.getEntry(i);",
    "info" : "VariableDeclarationStatement[51433-51491]:VariableDeclarationStatement[51433-51491]"
  }, {
    "left" : "gqsq += d1 * d1;",
    "right" : "gqsq += d1 * d1;",
    "info" : "ExpressionStatement[51516-51532]:ExpressionStatement[51516-51532]"
  }, {
    "left" : "gisq += sum * sum;",
    "right" : "gisq += sum * sum;",
    "info" : "ExpressionStatement[51557-51575]:ExpressionStatement[51557-51575]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(npt + i, sum);",
    "right" : "lagrangeValuesAtNewPoint.setEntry(npt + i, sum);",
    "info" : "ExpressionStatement[51618-51666]:ExpressionStatement[51618-51666]"
  }, {
    "left" : "++itest;",
    "right" : "++itest;",
    "info" : "ExpressionStatement[51879-51887]:ExpressionStatement[51879-51887]"
  }, {
    "left" : "if (gqsq < TEN * gisq)",
    "right" : "if (gqsq < TEN * gisq)",
    "info" : "IfStatement[51904-51977]:IfStatement[51904-51977]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[51927-51977]:Block[51927-51977]"
  }, {
    "left" : "itest = 0;",
    "right" : "itest = 0;",
    "info" : "ExpressionStatement[51949-51959]:ExpressionStatement[51949-51959]"
  }, {
    "left" : "if (itest >= 3)",
    "right" : "if (itest >= 3)",
    "info" : "IfStatement[51994-52637]:IfStatement[51994-52637]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52010-52637]:Block[52010-52637]"
  }, {
    "left" : "for (int i = 0, max = Math.max(npt, nh); i < max; i++)",
    "right" : "for (int i = 0, max = Math.max(npt, nh); i < max; i++)",
    "info" : "ForStatement[52032-52619]:ForStatement[52032-52619]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52087-52619]:Block[52087-52619]"
  }, {
    "left" : "if (i < n)",
    "right" : "if (i < n)",
    "info" : "IfStatement[52113-52264]:IfStatement[52113-52264]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52124-52264]:Block[52124-52264]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));",
    "right" : "gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));",
    "info" : "ExpressionStatement[52154-52238]:ExpressionStatement[52154-52238]"
  }, {
    "left" : "if (i < npt)",
    "right" : "if (i < npt)",
    "info" : "IfStatement[52289-52422]:IfStatement[52289-52422]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52302-52422]:Block[52302-52422]"
  }, {
    "left" : "modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));",
    "right" : "modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));",
    "info" : "ExpressionStatement[52332-52396]:ExpressionStatement[52332-52396]"
  }, {
    "left" : "if (i < nh)",
    "right" : "if (i < nh)",
    "info" : "IfStatement[52447-52562]:IfStatement[52447-52562]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52459-52562]:Block[52459-52562]"
  }, {
    "left" : "modelSecondDerivativesValues.setEntry(i, ZERO);",
    "right" : "modelSecondDerivativesValues.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[52489-52536]:ExpressionStatement[52489-52536]"
  }, {
    "left" : "itest = 0;",
    "right" : "itest = 0;",
    "info" : "ExpressionStatement[52587-52597]:ExpressionStatement[52587-52597]"
  }, {
    "left" : "if (ntrits == 0)",
    "right" : "if (ntrits == 0)",
    "info" : "IfStatement[52919-52986]:IfStatement[52919-52986]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[52936-52986]:Block[52936-52986]"
  }, {
    "left" : "state = 60;",
    "right" : "state = 60;",
    "info" : "ExpressionStatement[52954-52965]:ExpressionStatement[52954-52965]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[52966-52972]:BreakStatement[52966-52972]"
  }, {
    "left" : "if (f <= fopt + ONE_OVER_TEN * vquad)",
    "right" : "if (f <= fopt + ONE_OVER_TEN * vquad)",
    "info" : "IfStatement[52999-53087]:IfStatement[52999-53087]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53037-53087]:Block[53037-53087]"
  }, {
    "left" : "state = 60;",
    "right" : "state = 60;",
    "info" : "ExpressionStatement[53055-53066]:ExpressionStatement[53055-53066]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[53067-53073]:BreakStatement[53067-53073]"
  }, {
    "left" : "final double d1 = TWO * delta;",
    "right" : "final double d1 = TWO * delta;",
    "info" : "VariableDeclarationStatement[53293-53323]:VariableDeclarationStatement[53293-53323]"
  }, {
    "left" : "final double d2 = TEN * rho;",
    "right" : "final double d2 = TEN * rho;",
    "info" : "VariableDeclarationStatement[53371-53399]:VariableDeclarationStatement[53371-53399]"
  }, {
    "left" : "distsq = Math.max(d1 * d1, d2 * d2);",
    "right" : "distsq = Math.max(d1 * d1, d2 * d2);",
    "info" : "ExpressionStatement[53412-53448]:ExpressionStatement[53412-53448]"
  }, {
    "left" : "case 650:",
    "right" : "case 650:",
    "info" : "SwitchCase[53467-53476]:SwitchCase[53467-53476]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53477-55427]:Block[53477-55427]"
  }, {
    "left" : "printState(650);",
    "right" : "printState(650);",
    "info" : "ExpressionStatement[53491-53507]:ExpressionStatement[53491-53507]"
  }, {
    "left" : "knew = -1;",
    "right" : "knew = -1;",
    "info" : "ExpressionStatement[53527-53537]:ExpressionStatement[53527-53537]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[53550-54003]:ForStatement[53550-54003]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53580-54003]:Block[53580-54003]"
  }, {
    "left" : "double sum = ZERO;",
    "right" : "double sum = ZERO;",
    "info" : "VariableDeclarationStatement[53598-53616]:VariableDeclarationStatement[53598-53616]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[53633-53871]:ForStatement[53633-53871]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53661-53871]:Block[53661-53871]"
  }, {
    "left" : "final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);",
    "right" : "final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);",
    "info" : "VariableDeclarationStatement[53726-53817]:VariableDeclarationStatement[53726-53817]"
  }, {
    "left" : "sum += d1 * d1;",
    "right" : "sum += d1 * d1;",
    "info" : "ExpressionStatement[53838-53853]:ExpressionStatement[53838-53853]"
  }, {
    "left" : "if (sum > distsq)",
    "right" : "if (sum > distsq)",
    "info" : "IfStatement[53888-53989]:IfStatement[53888-53989]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[53906-53989]:Block[53906-53989]"
  }, {
    "left" : "knew = k;",
    "right" : "knew = k;",
    "info" : "ExpressionStatement[53928-53937]:ExpressionStatement[53928-53937]"
  }, {
    "left" : "distsq = sum;",
    "right" : "distsq = sum;",
    "info" : "ExpressionStatement[53958-53971]:ExpressionStatement[53958-53971]"
  }, {
    "left" : "if (knew >= 0)",
    "right" : "if (knew >= 0)",
    "info" : "IfStatement[54389-55024]:IfStatement[54389-55024]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54404-55024]:Block[54404-55024]"
  }, {
    "left" : "final double dist = Math.sqrt(distsq);",
    "right" : "final double dist = Math.sqrt(distsq);",
    "info" : "VariableDeclarationStatement[54422-54460]:VariableDeclarationStatement[54422-54460]"
  }, {
    "left" : "if (ntrits == -1)",
    "right" : "if (ntrits == -1)",
    "info" : "IfStatement[54477-54729]:IfStatement[54477-54729]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54495-54729]:Block[54495-54729]"
  }, {
    "left" : "delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);",
    "right" : "delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);",
    "info" : "ExpressionStatement[54554-54606]:ExpressionStatement[54554-54606]"
  }, {
    "left" : "if (delta <= rho * 1.5)",
    "right" : "if (delta <= rho * 1.5)",
    "info" : "IfStatement[54627-54711]:IfStatement[54627-54711]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[54651-54711]:Block[54651-54711]"
  }, {
    "left" : "delta = rho;",
    "right" : "delta = rho;",
    "info" : "ExpressionStatement[54677-54689]:ExpressionStatement[54677-54689]"
  }, {
    "left" : "ntrits = 0;",
    "right" : "ntrits = 0;",
    "info" : "ExpressionStatement[54746-54757]:ExpressionStatement[54746-54757]"
  }, {
    "left" : "final double d1 = Math.min(ONE_OVER_TEN * dist, delta);",
    "right" : "final double d1 = Math.min(ONE_OVER_TEN * dist, delta);",
    "info" : "VariableDeclarationStatement[54840-54895]:VariableDeclarationStatement[54840-54895]"
  }, {
    "left" : "adelt = Math.max(d1, rho);",
    "right" : "adelt = Math.max(d1, rho);",
    "info" : "ExpressionStatement[54912-54938]:ExpressionStatement[54912-54938]"
  }, {
    "left" : "dsq = adelt * adelt;",
    "right" : "dsq = adelt * adelt;",
    "info" : "ExpressionStatement[54955-54975]:ExpressionStatement[54955-54975]"
  }, {
    "left" : "state = 90;",
    "right" : "state = 90;",
    "info" : "ExpressionStatement[54992-55003]:ExpressionStatement[54992-55003]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[55004-55010]:BreakStatement[55004-55010]"
  }, {
    "left" : "if (ntrits == -1)",
    "right" : "if (ntrits == -1)",
    "info" : "IfStatement[55037-55106]:IfStatement[55037-55106]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55055-55106]:Block[55055-55106]"
  }, {
    "left" : "state = 680;",
    "right" : "state = 680;",
    "info" : "ExpressionStatement[55073-55085]:ExpressionStatement[55073-55085]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[55086-55092]:BreakStatement[55086-55092]"
  }, {
    "left" : "if (ratio > ZERO)",
    "right" : "if (ratio > ZERO)",
    "info" : "IfStatement[55119-55187]:IfStatement[55119-55187]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55137-55187]:Block[55137-55187]"
  }, {
    "left" : "state = 60;",
    "right" : "state = 60;",
    "info" : "ExpressionStatement[55155-55166]:ExpressionStatement[55155-55166]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[55167-55173]:BreakStatement[55167-55173]"
  }, {
    "left" : "if (Math.max(delta, dnorm) > rho)",
    "right" : "if (Math.max(delta, dnorm) > rho)",
    "info" : "IfStatement[55200-55284]:IfStatement[55200-55284]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55234-55284]:Block[55234-55284]"
  }, {
    "left" : "state = 60;",
    "right" : "state = 60;",
    "info" : "ExpressionStatement[55252-55263]:ExpressionStatement[55252-55263]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[55264-55270]:BreakStatement[55264-55270]"
  }, {
    "left" : "case 680:",
    "right" : "case 680:",
    "info" : "SwitchCase[55436-55445]:SwitchCase[55436-55445]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55446-56334]:Block[55446-56334]"
  }, {
    "left" : "printState(680);",
    "right" : "printState(680);",
    "info" : "ExpressionStatement[55460-55476]:ExpressionStatement[55460-55476]"
  }, {
    "left" : "if (rho > stoppingTrustRegionRadius)",
    "right" : "if (rho > stoppingTrustRegionRadius)",
    "info" : "IfStatement[55496-56098]:IfStatement[55496-56098]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55533-56098]:Block[55533-56098]"
  }, {
    "left" : "delta = HALF * rho;",
    "right" : "delta = HALF * rho;",
    "info" : "ExpressionStatement[55551-55570]:ExpressionStatement[55551-55570]"
  }, {
    "left" : "ratio = rho / stoppingTrustRegionRadius;",
    "right" : "ratio = rho / stoppingTrustRegionRadius;",
    "info" : "ExpressionStatement[55587-55627]:ExpressionStatement[55587-55627]"
  }, {
    "left" : "if (ratio <= SIXTEEN)",
    "right" : "if (ratio <= SIXTEEN)",
    "info" : "IfStatement[55644-55933]:IfStatement[55644-55933]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55666-55738]:Block[55666-55738]"
  }, {
    "left" : "rho = stoppingTrustRegionRadius;",
    "right" : "rho = stoppingTrustRegionRadius;",
    "info" : "ExpressionStatement[55688-55720]:ExpressionStatement[55688-55720]"
  }, {
    "left" : "if (ratio <= TWO_HUNDRED_FIFTY)",
    "right" : "if (ratio <= TWO_HUNDRED_FIFTY)",
    "info" : "IfStatement[55744-55933]:IfStatement[55744-55933]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55776-55867]:Block[55776-55867]"
  }, {
    "left" : "rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;",
    "right" : "rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;",
    "info" : "ExpressionStatement[55798-55849]:ExpressionStatement[55798-55849]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[55873-55933]:Block[55873-55933]"
  }, {
    "left" : "rho *= ONE_OVER_TEN;",
    "right" : "rho *= ONE_OVER_TEN;",
    "info" : "ExpressionStatement[55895-55915]:ExpressionStatement[55895-55915]"
  }, {
    "left" : "delta = Math.max(delta, rho);",
    "right" : "delta = Math.max(delta, rho);",
    "info" : "ExpressionStatement[55950-55979]:ExpressionStatement[55950-55979]"
  }, {
    "left" : "ntrits = 0;",
    "right" : "ntrits = 0;",
    "info" : "ExpressionStatement[55996-56007]:ExpressionStatement[55996-56007]"
  }, {
    "left" : "nfsav = getEvaluations();",
    "right" : "nfsav = getEvaluations();",
    "info" : "ExpressionStatement[56024-56049]:ExpressionStatement[56024-56049]"
  }, {
    "left" : "state = 60;",
    "right" : "state = 60;",
    "info" : "ExpressionStatement[56066-56077]:ExpressionStatement[56066-56077]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[56078-56084]:BreakStatement[56078-56084]"
  }, {
    "left" : "if (ntrits == -1)",
    "right" : "if (ntrits == -1)",
    "info" : "IfStatement[56255-56324]:IfStatement[56255-56324]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56273-56324]:Block[56273-56324]"
  }, {
    "left" : "state = 360;",
    "right" : "state = 360;",
    "info" : "ExpressionStatement[56291-56303]:ExpressionStatement[56291-56303]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[56304-56310]:BreakStatement[56304-56310]"
  }, {
    "left" : "case 720:",
    "right" : "case 720:",
    "info" : "SwitchCase[56343-56352]:SwitchCase[56343-56352]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56353-57457]:Block[56353-57457]"
  }, {
    "left" : "printState(720);",
    "right" : "printState(720);",
    "info" : "ExpressionStatement[56367-56383]:ExpressionStatement[56367-56383]"
  }, {
    "left" : "if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave)",
    "right" : "if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave)",
    "info" : "IfStatement[56403-57425]:IfStatement[56403-57425]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56491-57425]:Block[56491-57425]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[56509-57316]:ForStatement[56509-57316]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[56537-57316]:Block[56537-57316]"
  }, {
    "left" : "final double d3 = lowerBound[i];",
    "right" : "final double d3 = lowerBound[i];",
    "info" : "VariableDeclarationStatement[56633-56665]:VariableDeclarationStatement[56633-56665]"
  }, {
    "left" : "final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);",
    "right" : "final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);",
    "info" : "VariableDeclarationStatement[56686-56766]:VariableDeclarationStatement[56686-56766]"
  }, {
    "left" : "final double d1 = Math.max(d3, d4);",
    "right" : "final double d1 = Math.max(d3, d4);",
    "info" : "VariableDeclarationStatement[56787-56822]:VariableDeclarationStatement[56787-56822]"
  }, {
    "left" : "final double d2 = upperBound[i];",
    "right" : "final double d2 = upperBound[i];",
    "info" : "VariableDeclarationStatement[56843-56875]:VariableDeclarationStatement[56843-56875]"
  }, {
    "left" : "currentBest.setEntry(i, Math.min(d1, d2));",
    "right" : "currentBest.setEntry(i, Math.min(d1, d2));",
    "info" : "ExpressionStatement[56896-56938]:ExpressionStatement[56896-56938]"
  }, {
    "left" : "if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i))",
    "right" : "if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i))",
    "info" : "IfStatement[56959-57118]:IfStatement[56959-57118]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57031-57118]:Block[57031-57118]"
  }, {
    "left" : "currentBest.setEntry(i, lowerBound[i]);",
    "right" : "currentBest.setEntry(i, lowerBound[i]);",
    "info" : "ExpressionStatement[57057-57096]:ExpressionStatement[57057-57096]"
  }, {
    "left" : "if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i))",
    "right" : "if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i))",
    "info" : "IfStatement[57139-57298]:IfStatement[57139-57298]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57211-57298]:Block[57211-57298]"
  }, {
    "left" : "currentBest.setEntry(i, upperBound[i]);",
    "right" : "currentBest.setEntry(i, upperBound[i]);",
    "info" : "ExpressionStatement[57237-57276]:ExpressionStatement[57237-57276]"
  }, {
    "left" : "f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);",
    "right" : "f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);",
    "info" : "ExpressionStatement[57333-57411]:ExpressionStatement[57333-57411]"
  }, {
    "left" : "return f;",
    "right" : "return f;",
    "info" : "ReturnStatement[57438-57447]:ReturnStatement[57438-57447]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[57466-57474]:SwitchCase[57466-57474]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[57475-57578]:Block[57475-57578]"
  }, {
    "left" : "throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");",
    "right" : "throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");",
    "info" : "ThrowStatement[57489-57568]:ThrowStatement[57489-57568]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[59866-59873]:Modifier[59866-59873]"
  }, {
    "left" : "double[]",
    "right" : "double[]",
    "info" : "ArrayType[59874-59882]:ArrayType[59874-59882]"
  }, {
    "left" : "altmov",
    "right" : "altmov",
    "info" : "SimpleName[59883-59889]:SimpleName[59883-59889]"
  }, {
    "left" : "int knew",
    "right" : "int knew",
    "info" : "SingleVariableDeclaration[59903-59911]:SingleVariableDeclaration[59903-59911]"
  }, {
    "left" : "double adelt",
    "right" : "double adelt",
    "info" : "SingleVariableDeclaration[59925-59937]:SingleVariableDeclaration[59925-59937]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[59944-72997]:Block[59944-72997]"
  }, {
    "left" : "printMethod();",
    "right" : "printMethod();",
    "info" : "ExpressionStatement[59954-59968]:ExpressionStatement[59954-59968]"
  }, {
    "left" : "final int n = currentBest.getDimension();",
    "right" : "final int n = currentBest.getDimension();",
    "info" : "VariableDeclarationStatement[59985-60026]:VariableDeclarationStatement[59985-60026]"
  }, {
    "left" : "final int npt = numberOfInterpolationPoints;",
    "right" : "final int npt = numberOfInterpolationPoints;",
    "info" : "VariableDeclarationStatement[60035-60079]:VariableDeclarationStatement[60035-60079]"
  }, {
    "left" : "final ArrayRealVector glag = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector glag = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[60089-60141]:VariableDeclarationStatement[60089-60141]"
  }, {
    "left" : "final ArrayRealVector hcol = new ArrayRealVector(npt);",
    "right" : "final ArrayRealVector hcol = new ArrayRealVector(npt);",
    "info" : "VariableDeclarationStatement[60150-60204]:VariableDeclarationStatement[60150-60204]"
  }, {
    "left" : "final ArrayRealVector work1 = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector work1 = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[60214-60267]:VariableDeclarationStatement[60214-60267]"
  }, {
    "left" : "final ArrayRealVector work2 = new ArrayRealVector(n);",
    "right" : "final ArrayRealVector work2 = new ArrayRealVector(n);",
    "info" : "VariableDeclarationStatement[60276-60329]:VariableDeclarationStatement[60276-60329]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[60339-60416]:ForStatement[60339-60416]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60369-60416]:Block[60369-60416]"
  }, {
    "left" : "hcol.setEntry(k, ZERO);",
    "right" : "hcol.setEntry(k, ZERO);",
    "info" : "ExpressionStatement[60383-60406]:ExpressionStatement[60383-60406]"
  }, {
    "left" : "for (int j = 0, max = npt - n - 1; j < max; j++)",
    "right" : "for (int j = 0, max = npt - n - 1; j < max; j++)",
    "info" : "ForStatement[60425-60684]:ForStatement[60425-60684]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60474-60684]:Block[60474-60684]"
  }, {
    "left" : "final double tmp = zMatrix.getEntry(knew, j);",
    "right" : "final double tmp = zMatrix.getEntry(knew, j);",
    "info" : "VariableDeclarationStatement[60488-60533]:VariableDeclarationStatement[60488-60533]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[60546-60674]:ForStatement[60546-60674]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60576-60674]:Block[60576-60674]"
  }, {
    "left" : "hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));",
    "right" : "hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));",
    "info" : "ExpressionStatement[60594-60660]:ExpressionStatement[60594-60660]"
  }, {
    "left" : "final double alpha = hcol.getEntry(knew);",
    "right" : "final double alpha = hcol.getEntry(knew);",
    "info" : "VariableDeclarationStatement[60693-60734]:VariableDeclarationStatement[60693-60734]"
  }, {
    "left" : "final double ha = HALF * alpha;",
    "right" : "final double ha = HALF * alpha;",
    "info" : "VariableDeclarationStatement[60743-60774]:VariableDeclarationStatement[60743-60774]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[60861-60957]:ForStatement[60861-60957]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60889-60957]:Block[60889-60957]"
  }, {
    "left" : "glag.setEntry(i, bMatrix.getEntry(knew, i));",
    "right" : "glag.setEntry(i, bMatrix.getEntry(knew, i));",
    "info" : "ExpressionStatement[60903-60947]:ExpressionStatement[60903-60947]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[60966-61379]:ForStatement[60966-61379]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[60996-61379]:Block[60996-61379]"
  }, {
    "left" : "double tmp = ZERO;",
    "right" : "double tmp = ZERO;",
    "info" : "VariableDeclarationStatement[61010-61028]:VariableDeclarationStatement[61010-61028]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[61041-61181]:ForStatement[61041-61181]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61069-61181]:Block[61069-61181]"
  }, {
    "left" : "tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "right" : "tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);",
    "info" : "ExpressionStatement[61087-61167]:ExpressionStatement[61087-61167]"
  }, {
    "left" : "tmp *= hcol.getEntry(k);",
    "right" : "tmp *= hcol.getEntry(k);",
    "info" : "ExpressionStatement[61194-61218]:ExpressionStatement[61194-61218]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[61231-61369]:ForStatement[61231-61369]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61259-61369]:Block[61259-61369]"
  }, {
    "left" : "glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));",
    "right" : "glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));",
    "info" : "ExpressionStatement[61277-61355]:ExpressionStatement[61277-61355]"
  }, {
    "left" : "double presav = ZERO;",
    "right" : "double presav = ZERO;",
    "info" : "VariableDeclarationStatement[61790-61811]:VariableDeclarationStatement[61790-61811]"
  }, {
    "left" : "double step = Double.NaN;",
    "right" : "double step = Double.NaN;",
    "info" : "VariableDeclarationStatement[61820-61845]:VariableDeclarationStatement[61820-61845]"
  }, {
    "left" : "int ksav = 0;",
    "right" : "int ksav = 0;",
    "info" : "VariableDeclarationStatement[61854-61867]:VariableDeclarationStatement[61854-61867]"
  }, {
    "left" : "int ibdsav = 0;",
    "right" : "int ibdsav = 0;",
    "info" : "VariableDeclarationStatement[61876-61891]:VariableDeclarationStatement[61876-61891]"
  }, {
    "left" : "double stpsav = 0;",
    "right" : "double stpsav = 0;",
    "info" : "VariableDeclarationStatement[61900-61918]:VariableDeclarationStatement[61900-61918]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[61927-66366]:ForStatement[61927-66366]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[61957-66366]:Block[61957-66366]"
  }, {
    "left" : "if (k == trustRegionCenterInterpolationPointIndex)",
    "right" : "if (k == trustRegionCenterInterpolationPointIndex)",
    "info" : "IfStatement[61971-62063]:IfStatement[61971-62063]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62022-62063]:Block[62022-62063]"
  }, {
    "left" : "continue;",
    "right" : "continue;",
    "info" : "ContinueStatement[62040-62049]:ContinueStatement[62040-62049]"
  }, {
    "left" : "double dderiv = ZERO;",
    "right" : "double dderiv = ZERO;",
    "info" : "VariableDeclarationStatement[62076-62097]:VariableDeclarationStatement[62076-62097]"
  }, {
    "left" : "double distsq = ZERO;",
    "right" : "double distsq = ZERO;",
    "info" : "VariableDeclarationStatement[62110-62131]:VariableDeclarationStatement[62110-62131]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[62144-62383]:ForStatement[62144-62383]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62172-62383]:Block[62172-62383]"
  }, {
    "left" : "final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);",
    "right" : "final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);",
    "info" : "VariableDeclarationStatement[62190-62282]:VariableDeclarationStatement[62190-62282]"
  }, {
    "left" : "dderiv += glag.getEntry(i) * tmp;",
    "right" : "dderiv += glag.getEntry(i) * tmp;",
    "info" : "ExpressionStatement[62299-62332]:ExpressionStatement[62299-62332]"
  }, {
    "left" : "distsq += tmp * tmp;",
    "right" : "distsq += tmp * tmp;",
    "info" : "ExpressionStatement[62349-62369]:ExpressionStatement[62349-62369]"
  }, {
    "left" : "double subd = adelt / Math.sqrt(distsq);",
    "right" : "double subd = adelt / Math.sqrt(distsq);",
    "info" : "VariableDeclarationStatement[62396-62436]:VariableDeclarationStatement[62396-62436]"
  }, {
    "left" : "double slbd = -subd;",
    "right" : "double slbd = -subd;",
    "info" : "VariableDeclarationStatement[62449-62469]:VariableDeclarationStatement[62449-62469]"
  }, {
    "left" : "int ilbd = 0;",
    "right" : "int ilbd = 0;",
    "info" : "VariableDeclarationStatement[62482-62495]:VariableDeclarationStatement[62482-62495]"
  }, {
    "left" : "int iubd = 0;",
    "right" : "int iubd = 0;",
    "info" : "VariableDeclarationStatement[62508-62521]:VariableDeclarationStatement[62508-62521]"
  }, {
    "left" : "final double sumin = Math.min(ONE, subd);",
    "right" : "final double sumin = Math.min(ONE, subd);",
    "info" : "VariableDeclarationStatement[62534-62575]:VariableDeclarationStatement[62534-62575]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[62675-64206]:ForStatement[62675-64206]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62703-64206]:Block[62703-64206]"
  }, {
    "left" : "final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);",
    "right" : "final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);",
    "info" : "VariableDeclarationStatement[62721-62813]:VariableDeclarationStatement[62721-62813]"
  }, {
    "left" : "if (tmp > ZERO)",
    "right" : "if (tmp > ZERO)",
    "info" : "IfStatement[62830-64192]:IfStatement[62830-64192]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62846-63508]:Block[62846-63508]"
  }, {
    "left" : "if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "right" : "if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "info" : "IfStatement[62868-63120]:IfStatement[62868-63120]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[62952-63120]:Block[62952-63120]"
  }, {
    "left" : "slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;",
    "right" : "slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;",
    "info" : "ExpressionStatement[62978-63059]:ExpressionStatement[62978-63059]"
  }, {
    "left" : "ilbd = -i - 1;",
    "right" : "ilbd = -i - 1;",
    "info" : "ExpressionStatement[63084-63098]:ExpressionStatement[63084-63098]"
  }, {
    "left" : "if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "right" : "if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "info" : "IfStatement[63141-63490]:IfStatement[63141-63490]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63225-63490]:Block[63225-63490]"
  }, {
    "left" : "subd = Math.max(sumin,\n                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);",
    "right" : "subd = Math.max(sumin,\n                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);",
    "info" : "ExpressionStatement[63292-63430]:ExpressionStatement[63292-63430]"
  }, {
    "left" : "iubd = i + 1;",
    "right" : "iubd = i + 1;",
    "info" : "ExpressionStatement[63455-63468]:ExpressionStatement[63455-63468]"
  }, {
    "left" : "if (tmp < ZERO)",
    "right" : "if (tmp < ZERO)",
    "info" : "IfStatement[63514-64192]:IfStatement[63514-64192]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63530-64192]:Block[63530-64192]"
  }, {
    "left" : "if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "right" : "if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "info" : "IfStatement[63552-63803]:IfStatement[63552-63803]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63636-63803]:Block[63636-63803]"
  }, {
    "left" : "slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;",
    "right" : "slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;",
    "info" : "ExpressionStatement[63662-63743]:ExpressionStatement[63662-63743]"
  }, {
    "left" : "ilbd = i + 1;",
    "right" : "ilbd = i + 1;",
    "info" : "ExpressionStatement[63768-63781]:ExpressionStatement[63768-63781]"
  }, {
    "left" : "if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "right" : "if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i))",
    "info" : "IfStatement[63824-64174]:IfStatement[63824-64174]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[63908-64174]:Block[63908-64174]"
  }, {
    "left" : "subd = Math.max(sumin,\n                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);",
    "right" : "subd = Math.max(sumin,\n                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);",
    "info" : "ExpressionStatement[63975-64113]:ExpressionStatement[63975-64113]"
  }, {
    "left" : "iubd = -i - 1;",
    "right" : "iubd = -i - 1;",
    "info" : "ExpressionStatement[64138-64152]:ExpressionStatement[64138-64152]"
  }, {
    "left" : "step = slbd;",
    "right" : "step = slbd;",
    "info" : "ExpressionStatement[64387-64399]:ExpressionStatement[64387-64399]"
  }, {
    "left" : "int isbd = ilbd;",
    "right" : "int isbd = ilbd;",
    "info" : "VariableDeclarationStatement[64412-64428]:VariableDeclarationStatement[64412-64428]"
  }, {
    "left" : "double vlag = Double.NaN;",
    "right" : "double vlag = Double.NaN;",
    "info" : "VariableDeclarationStatement[64441-64466]:VariableDeclarationStatement[64441-64466]"
  }, {
    "left" : "if (k == knew)",
    "right" : "if (k == knew)",
    "info" : "IfStatement[64479-65962]:IfStatement[64479-65962]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64494-65389]:Block[64494-65389]"
  }, {
    "left" : "final double diff = dderiv - ONE;",
    "right" : "final double diff = dderiv - ONE;",
    "info" : "VariableDeclarationStatement[64512-64545]:VariableDeclarationStatement[64512-64545]"
  }, {
    "left" : "vlag = slbd * (dderiv - slbd * diff);",
    "right" : "vlag = slbd * (dderiv - slbd * diff);",
    "info" : "ExpressionStatement[64562-64599]:ExpressionStatement[64562-64599]"
  }, {
    "left" : "final double d1 = subd * (dderiv - subd * diff);",
    "right" : "final double d1 = subd * (dderiv - subd * diff);",
    "info" : "VariableDeclarationStatement[64616-64664]:VariableDeclarationStatement[64616-64664]"
  }, {
    "left" : "if (Math.abs(d1) > Math.abs(vlag))",
    "right" : "if (Math.abs(d1) > Math.abs(vlag))",
    "info" : "IfStatement[64681-64832]:IfStatement[64681-64832]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[64716-64832]:Block[64716-64832]"
  }, {
    "left" : "step = subd;",
    "right" : "step = subd;",
    "info" : "ExpressionStatement[64738-64750]:ExpressionStatement[64738-64750]"
  }, {
    "left" : "vlag = d1;",
    "right" : "vlag = d1;",
    "info" : "ExpressionStatement[64771-64781]:ExpressionStatement[64771-64781]"
  }, {
    "left" : "isbd = iubd;",
    "right" : "isbd = iubd;",
    "info" : "ExpressionStatement[64802-64814]:ExpressionStatement[64802-64814]"
  }, {
    "left" : "final double d2 = HALF * dderiv;",
    "right" : "final double d2 = HALF * dderiv;",
    "info" : "VariableDeclarationStatement[64849-64881]:VariableDeclarationStatement[64849-64881]"
  }, {
    "left" : "final double d3 = d2 - diff * slbd;",
    "right" : "final double d3 = d2 - diff * slbd;",
    "info" : "VariableDeclarationStatement[64898-64933]:VariableDeclarationStatement[64898-64933]"
  }, {
    "left" : "final double d4 = d2 - diff * subd;",
    "right" : "final double d4 = d2 - diff * subd;",
    "info" : "VariableDeclarationStatement[64950-64985]:VariableDeclarationStatement[64950-64985]"
  }, {
    "left" : "if (d3 * d4 < ZERO)",
    "right" : "if (d3 * d4 < ZERO)",
    "info" : "IfStatement[65002-65285]:IfStatement[65002-65285]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65022-65285]:Block[65022-65285]"
  }, {
    "left" : "final double d5 = d2 * d2 / diff;",
    "right" : "final double d5 = d2 * d2 / diff;",
    "info" : "VariableDeclarationStatement[65044-65077]:VariableDeclarationStatement[65044-65077]"
  }, {
    "left" : "if (Math.abs(d5) > Math.abs(vlag))",
    "right" : "if (Math.abs(d5) > Math.abs(vlag))",
    "info" : "IfStatement[65098-65267]:IfStatement[65098-65267]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65133-65267]:Block[65133-65267]"
  }, {
    "left" : "step = d2 / diff;",
    "right" : "step = d2 / diff;",
    "info" : "ExpressionStatement[65159-65176]:ExpressionStatement[65159-65176]"
  }, {
    "left" : "vlag = d5;",
    "right" : "vlag = d5;",
    "info" : "ExpressionStatement[65201-65211]:ExpressionStatement[65201-65211]"
  }, {
    "left" : "isbd = 0;",
    "right" : "isbd = 0;",
    "info" : "ExpressionStatement[65236-65245]:ExpressionStatement[65236-65245]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65395-65962]:Block[65395-65962]"
  }, {
    "left" : "vlag = slbd * (ONE - slbd);",
    "right" : "vlag = slbd * (ONE - slbd);",
    "info" : "ExpressionStatement[65413-65440]:ExpressionStatement[65413-65440]"
  }, {
    "left" : "final double tmp = subd * (ONE - subd);",
    "right" : "final double tmp = subd * (ONE - subd);",
    "info" : "VariableDeclarationStatement[65457-65496]:VariableDeclarationStatement[65457-65496]"
  }, {
    "left" : "if (Math.abs(tmp) > Math.abs(vlag))",
    "right" : "if (Math.abs(tmp) > Math.abs(vlag))",
    "info" : "IfStatement[65513-65666]:IfStatement[65513-65666]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65549-65666]:Block[65549-65666]"
  }, {
    "left" : "step = subd;",
    "right" : "step = subd;",
    "info" : "ExpressionStatement[65571-65583]:ExpressionStatement[65571-65583]"
  }, {
    "left" : "vlag = tmp;",
    "right" : "vlag = tmp;",
    "info" : "ExpressionStatement[65604-65615]:ExpressionStatement[65604-65615]"
  }, {
    "left" : "isbd = iubd;",
    "right" : "isbd = iubd;",
    "info" : "ExpressionStatement[65636-65648]:ExpressionStatement[65636-65648]"
  }, {
    "left" : "if (subd > HALF)",
    "right" : "if (subd > HALF)",
    "info" : "IfStatement[65683-65916]:IfStatement[65683-65916]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65700-65916]:Block[65700-65916]"
  }, {
    "left" : "if (Math.abs(vlag) < ONE_OVER_FOUR)",
    "right" : "if (Math.abs(vlag) < ONE_OVER_FOUR)",
    "info" : "IfStatement[65722-65898]:IfStatement[65722-65898]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[65758-65898]:Block[65758-65898]"
  }, {
    "left" : "step = HALF;",
    "right" : "step = HALF;",
    "info" : "ExpressionStatement[65784-65796]:ExpressionStatement[65784-65796]"
  }, {
    "left" : "vlag = ONE_OVER_FOUR;",
    "right" : "vlag = ONE_OVER_FOUR;",
    "info" : "ExpressionStatement[65821-65842]:ExpressionStatement[65821-65842]"
  }, {
    "left" : "isbd = 0;",
    "right" : "isbd = 0;",
    "info" : "ExpressionStatement[65867-65876]:ExpressionStatement[65867-65876]"
  }, {
    "left" : "vlag *= dderiv;",
    "right" : "vlag *= dderiv;",
    "info" : "ExpressionStatement[65933-65948]:ExpressionStatement[65933-65948]"
  }, {
    "left" : "final double tmp = step * (ONE - step) * distsq;",
    "right" : "final double tmp = step * (ONE - step) * distsq;",
    "info" : "VariableDeclarationStatement[66058-66106]:VariableDeclarationStatement[66058-66106]"
  }, {
    "left" : "final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);",
    "right" : "final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);",
    "info" : "VariableDeclarationStatement[66119-66186]:VariableDeclarationStatement[66119-66186]"
  }, {
    "left" : "if (predsq > presav)",
    "right" : "if (predsq > presav)",
    "info" : "IfStatement[66199-66356]:IfStatement[66199-66356]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66220-66356]:Block[66220-66356]"
  }, {
    "left" : "presav = predsq;",
    "right" : "presav = predsq;",
    "info" : "ExpressionStatement[66238-66254]:ExpressionStatement[66238-66254]"
  }, {
    "left" : "ksav = k;",
    "right" : "ksav = k;",
    "info" : "ExpressionStatement[66271-66280]:ExpressionStatement[66271-66280]"
  }, {
    "left" : "stpsav = step;",
    "right" : "stpsav = step;",
    "info" : "ExpressionStatement[66297-66311]:ExpressionStatement[66297-66311]"
  }, {
    "left" : "ibdsav = isbd;",
    "right" : "ibdsav = isbd;",
    "info" : "ExpressionStatement[66328-66342]:ExpressionStatement[66328-66342]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[66458-66809]:ForStatement[66458-66809]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66486-66809]:Block[66486-66809]"
  }, {
    "left" : "final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "VariableDeclarationStatement[66500-66644]:VariableDeclarationStatement[66500-66644]"
  }, {
    "left" : "newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                      Math.min(upperDifference.getEntry(i), tmp)));",
    "right" : "newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                      Math.min(upperDifference.getEntry(i), tmp)));",
    "info" : "ExpressionStatement[66657-66799]:ExpressionStatement[66657-66799]"
  }, {
    "left" : "if (ibdsav < 0)",
    "right" : "if (ibdsav < 0)",
    "info" : "IfStatement[66818-66928]:IfStatement[66818-66928]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66834-66928]:Block[66834-66928]"
  }, {
    "left" : "newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));",
    "right" : "newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));",
    "info" : "ExpressionStatement[66848-66918]:ExpressionStatement[66848-66918]"
  }, {
    "left" : "if (ibdsav > 0)",
    "right" : "if (ibdsav > 0)",
    "info" : "IfStatement[66937-67045]:IfStatement[66937-67045]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[66953-67045]:Block[66953-67045]"
  }, {
    "left" : "newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));",
    "right" : "newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));",
    "info" : "ExpressionStatement[66967-67035]:ExpressionStatement[66967-67035]"
  }, {
    "left" : "final double bigstp = adelt + adelt;",
    "right" : "final double bigstp = adelt + adelt;",
    "info" : "VariableDeclarationStatement[67288-67324]:VariableDeclarationStatement[67288-67324]"
  }, {
    "left" : "int iflag = 0;",
    "right" : "int iflag = 0;",
    "info" : "VariableDeclarationStatement[67333-67347]:VariableDeclarationStatement[67333-67347]"
  }, {
    "left" : "double cauchy = Double.NaN;",
    "right" : "double cauchy = Double.NaN;",
    "info" : "VariableDeclarationStatement[67356-67383]:VariableDeclarationStatement[67356-67383]"
  }, {
    "left" : "double csave = ZERO;",
    "right" : "double csave = ZERO;",
    "info" : "VariableDeclarationStatement[67392-67412]:VariableDeclarationStatement[67392-67412]"
  }, {
    "left" : "while (true)",
    "right" : "while (true)",
    "info" : "WhileStatement[67421-72751]:WhileStatement[67421-72751]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67434-72751]:Block[67434-72751]"
  }, {
    "left" : "double wfixsq = ZERO;",
    "right" : "double wfixsq = ZERO;",
    "info" : "VariableDeclarationStatement[67448-67469]:VariableDeclarationStatement[67448-67469]"
  }, {
    "left" : "double ggfree = ZERO;",
    "right" : "double ggfree = ZERO;",
    "info" : "VariableDeclarationStatement[67482-67503]:VariableDeclarationStatement[67482-67503]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[67516-68054]:ForStatement[67516-68054]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67544-68054]:Block[67544-68054]"
  }, {
    "left" : "final double glagValue = glag.getEntry(i);",
    "right" : "final double glagValue = glag.getEntry(i);",
    "info" : "VariableDeclarationStatement[67562-67604]:VariableDeclarationStatement[67562-67604]"
  }, {
    "left" : "work1.setEntry(i, ZERO);",
    "right" : "work1.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[67621-67645]:ExpressionStatement[67621-67645]"
  }, {
    "left" : "if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO ||\n                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO)",
    "right" : "if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO ||\n                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO)",
    "info" : "IfStatement[67662-68040]:IfStatement[67662-68040]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[67878-68040]:Block[67878-68040]"
  }, {
    "left" : "work1.setEntry(i, bigstp);",
    "right" : "work1.setEntry(i, bigstp);",
    "info" : "ExpressionStatement[67900-67926]:ExpressionStatement[67900-67926]"
  }, {
    "left" : "ggfree += glagValue * glagValue;",
    "right" : "ggfree += glagValue * glagValue;",
    "info" : "ExpressionStatement[67990-68022]:ExpressionStatement[67990-68022]"
  }, {
    "left" : "if (ggfree == ZERO)",
    "right" : "if (ggfree == ZERO)",
    "info" : "IfStatement[68067-68155]:IfStatement[68067-68155]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68087-68155]:Block[68087-68155]"
  }, {
    "left" : "return new double[] { alpha, ZERO };",
    "right" : "return new double[] { alpha, ZERO };",
    "info" : "ReturnStatement[68105-68141]:ReturnStatement[68105-68141]"
  }, {
    "left" : "final double tmp1 = adelt * adelt - wfixsq;",
    "right" : "final double tmp1 = adelt * adelt - wfixsq;",
    "info" : "VariableDeclarationStatement[68239-68282]:VariableDeclarationStatement[68239-68282]"
  }, {
    "left" : "if (tmp1 > ZERO)",
    "right" : "if (tmp1 > ZERO)",
    "info" : "IfStatement[68295-69571]:IfStatement[68295-69571]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68312-69571]:Block[68312-69571]"
  }, {
    "left" : "step = Math.sqrt(tmp1 / ggfree);",
    "right" : "step = Math.sqrt(tmp1 / ggfree);",
    "info" : "ExpressionStatement[68330-68362]:ExpressionStatement[68330-68362]"
  }, {
    "left" : "ggfree = ZERO;",
    "right" : "ggfree = ZERO;",
    "info" : "ExpressionStatement[68379-68393]:ExpressionStatement[68379-68393]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[68410-69557]:ForStatement[68410-69557]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68438-69557]:Block[68438-69557]"
  }, {
    "left" : "if (work1.getEntry(i) == bigstp)",
    "right" : "if (work1.getEntry(i) == bigstp)",
    "info" : "IfStatement[68460-69539]:IfStatement[68460-69539]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68493-69539]:Block[68493-69539]"
  }, {
    "left" : "final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);",
    "right" : "final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);",
    "info" : "VariableDeclarationStatement[68519-68601]:VariableDeclarationStatement[68519-68601]"
  }, {
    "left" : "if (tmp2 <= lowerDifference.getEntry(i))",
    "right" : "if (tmp2 <= lowerDifference.getEntry(i))",
    "info" : "IfStatement[68626-69517]:IfStatement[68626-69517]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[68667-68971]:Block[68667-68971]"
  }, {
    "left" : "work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[68697-68782]:ExpressionStatement[68697-68782]"
  }, {
    "left" : "final double d1 = work1.getEntry(i);",
    "right" : "final double d1 = work1.getEntry(i);",
    "info" : "VariableDeclarationStatement[68862-68898]:VariableDeclarationStatement[68862-68898]"
  }, {
    "left" : "wfixsq += d1 * d1;",
    "right" : "wfixsq += d1 * d1;",
    "info" : "ExpressionStatement[68927-68945]:ExpressionStatement[68927-68945]"
  }, {
    "left" : "if (tmp2 >= upperDifference.getEntry(i))",
    "right" : "if (tmp2 >= upperDifference.getEntry(i))",
    "info" : "IfStatement[68977-69517]:IfStatement[68977-69517]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69018-69322]:Block[69018-69322]"
  }, {
    "left" : "work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[69048-69133]:ExpressionStatement[69048-69133]"
  }, {
    "left" : "final double d1 = work1.getEntry(i);",
    "right" : "final double d1 = work1.getEntry(i);",
    "info" : "VariableDeclarationStatement[69213-69249]:VariableDeclarationStatement[69213-69249]"
  }, {
    "left" : "wfixsq += d1 * d1;",
    "right" : "wfixsq += d1 * d1;",
    "info" : "ExpressionStatement[69278-69296]:ExpressionStatement[69278-69296]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69328-69517]:Block[69328-69517]"
  }, {
    "left" : "final double d1 = glag.getEntry(i);",
    "right" : "final double d1 = glag.getEntry(i);",
    "info" : "VariableDeclarationStatement[69409-69444]:VariableDeclarationStatement[69409-69444]"
  }, {
    "left" : "ggfree += d1 * d1;",
    "right" : "ggfree += d1 * d1;",
    "info" : "ExpressionStatement[69473-69491]:ExpressionStatement[69473-69491]"
  }, {
    "left" : "double gw = ZERO;",
    "right" : "double gw = ZERO;",
    "info" : "VariableDeclarationStatement[69718-69735]:VariableDeclarationStatement[69718-69735]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[69748-70692]:ForStatement[69748-70692]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69776-70692]:Block[69776-70692]"
  }, {
    "left" : "final double glagValue = glag.getEntry(i);",
    "right" : "final double glagValue = glag.getEntry(i);",
    "info" : "VariableDeclarationStatement[69794-69836]:VariableDeclarationStatement[69794-69836]"
  }, {
    "left" : "if (work1.getEntry(i) == bigstp)",
    "right" : "if (work1.getEntry(i) == bigstp)",
    "info" : "IfStatement[69853-70625]:IfStatement[69853-70625]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[69886-70243]:Block[69886-70243]"
  }, {
    "left" : "work1.setEntry(i, -step * glagValue);",
    "right" : "work1.setEntry(i, -step * glagValue);",
    "info" : "ExpressionStatement[69908-69945]:ExpressionStatement[69908-69945]"
  }, {
    "left" : "final double min = Math.min(upperDifference.getEntry(i),\n                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));",
    "right" : "final double min = Math.min(upperDifference.getEntry(i),\n                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));",
    "info" : "VariableDeclarationStatement[69966-70128]:VariableDeclarationStatement[69966-70128]"
  }, {
    "left" : "alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));",
    "right" : "alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));",
    "info" : "ExpressionStatement[70149-70225]:ExpressionStatement[70149-70225]"
  }, {
    "left" : "if (work1.getEntry(i) == ZERO)",
    "right" : "if (work1.getEntry(i) == ZERO)",
    "info" : "IfStatement[70249-70625]:IfStatement[70249-70625]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70280-70389]:Block[70280-70389]"
  }, {
    "left" : "alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));",
    "right" : "alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[70302-70371]:ExpressionStatement[70302-70371]"
  }, {
    "left" : "if (glagValue > ZERO)",
    "right" : "if (glagValue > ZERO)",
    "info" : "IfStatement[70395-70625]:IfStatement[70395-70625]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70417-70518]:Block[70417-70518]"
  }, {
    "left" : "alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));",
    "right" : "alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));",
    "info" : "ExpressionStatement[70439-70500]:ExpressionStatement[70439-70500]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[70524-70625]:Block[70524-70625]"
  }, {
    "left" : "alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));",
    "right" : "alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));",
    "info" : "ExpressionStatement[70546-70607]:ExpressionStatement[70546-70607]"
  }, {
    "left" : "gw += glagValue * work1.getEntry(i);",
    "right" : "gw += glagValue * work1.getEntry(i);",
    "info" : "ExpressionStatement[70642-70678]:ExpressionStatement[70642-70678]"
  }, {
    "left" : "double curv = ZERO;",
    "right" : "double curv = ZERO;",
    "info" : "VariableDeclarationStatement[70998-71017]:VariableDeclarationStatement[70998-71017]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[71030-71311]:ForStatement[71030-71311]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71060-71311]:Block[71060-71311]"
  }, {
    "left" : "double tmp = ZERO;",
    "right" : "double tmp = ZERO;",
    "info" : "VariableDeclarationStatement[71078-71096]:VariableDeclarationStatement[71078-71096]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[71113-71243]:ForStatement[71113-71243]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71141-71243]:Block[71141-71243]"
  }, {
    "left" : "tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);",
    "right" : "tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);",
    "info" : "ExpressionStatement[71163-71225]:ExpressionStatement[71163-71225]"
  }, {
    "left" : "curv += hcol.getEntry(k) * tmp * tmp;",
    "right" : "curv += hcol.getEntry(k) * tmp * tmp;",
    "info" : "ExpressionStatement[71260-71297]:ExpressionStatement[71260-71297]"
  }, {
    "left" : "if (iflag == 1)",
    "right" : "if (iflag == 1)",
    "info" : "IfStatement[71324-71385]:IfStatement[71324-71385]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71340-71385]:Block[71340-71385]"
  }, {
    "left" : "curv = -curv;",
    "right" : "curv = -curv;",
    "info" : "ExpressionStatement[71358-71371]:ExpressionStatement[71358-71371]"
  }, {
    "left" : "if (curv > -gw &&\n                curv < -gw * (ONE + Math.sqrt(TWO)))",
    "right" : "if (curv > -gw &&\n                curv < -gw * (ONE + Math.sqrt(TWO)))",
    "info" : "IfStatement[71398-72155]:IfStatement[71398-72155]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71469-72009]:Block[71469-72009]"
  }, {
    "left" : "final double scale = -gw / curv;",
    "right" : "final double scale = -gw / curv;",
    "info" : "VariableDeclarationStatement[71487-71519]:VariableDeclarationStatement[71487-71519]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[71536-71869]:ForStatement[71536-71869]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[71564-71869]:Block[71564-71869]"
  }, {
    "left" : "final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);",
    "right" : "final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);",
    "info" : "VariableDeclarationStatement[71586-71669]:VariableDeclarationStatement[71586-71669]"
  }, {
    "left" : "alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                              Math.min(upperDifference.getEntry(i), tmp)));",
    "right" : "alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                              Math.min(upperDifference.getEntry(i), tmp)));",
    "info" : "ExpressionStatement[71690-71851]:ExpressionStatement[71690-71851]"
  }, {
    "left" : "final double d1 = HALF * gw * scale;",
    "right" : "final double d1 = HALF * gw * scale;",
    "info" : "VariableDeclarationStatement[71925-71961]:VariableDeclarationStatement[71925-71961]"
  }, {
    "left" : "cauchy = d1 * d1;",
    "right" : "cauchy = d1 * d1;",
    "info" : "ExpressionStatement[71978-71995]:ExpressionStatement[71978-71995]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72015-72155]:Block[72015-72155]"
  }, {
    "left" : "final double d1 = gw + HALF * curv;",
    "right" : "final double d1 = gw + HALF * curv;",
    "info" : "VariableDeclarationStatement[72072-72107]:VariableDeclarationStatement[72072-72107]"
  }, {
    "left" : "cauchy = d1 * d1;",
    "right" : "cauchy = d1 * d1;",
    "info" : "ExpressionStatement[72124-72141]:ExpressionStatement[72124-72141]"
  }, {
    "left" : "if (iflag == 0)",
    "right" : "if (iflag == 0)",
    "info" : "IfStatement[72414-72741]:IfStatement[72414-72741]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72430-72697]:Block[72430-72697]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[72448-72624]:ForStatement[72448-72624]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72476-72624]:Block[72476-72624]"
  }, {
    "left" : "glag.setEntry(i, -glag.getEntry(i));",
    "right" : "glag.setEntry(i, -glag.getEntry(i));",
    "info" : "ExpressionStatement[72498-72534]:ExpressionStatement[72498-72534]"
  }, {
    "left" : "work2.setEntry(i, alternativeNewPoint.getEntry(i));",
    "right" : "work2.setEntry(i, alternativeNewPoint.getEntry(i));",
    "info" : "ExpressionStatement[72555-72606]:ExpressionStatement[72555-72606]"
  }, {
    "left" : "csave = cauchy;",
    "right" : "csave = cauchy;",
    "info" : "ExpressionStatement[72641-72656]:ExpressionStatement[72641-72656]"
  }, {
    "left" : "iflag = 1;",
    "right" : "iflag = 1;",
    "info" : "ExpressionStatement[72673-72683]:ExpressionStatement[72673-72683]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72703-72741]:Block[72703-72741]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[72721-72727]:BreakStatement[72721-72727]"
  }, {
    "left" : "if (csave > cauchy)",
    "right" : "if (csave > cauchy)",
    "info" : "IfStatement[72760-72943]:IfStatement[72760-72943]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72780-72943]:Block[72780-72943]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[72794-72905]:ForStatement[72794-72905]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[72822-72905]:Block[72822-72905]"
  }, {
    "left" : "alternativeNewPoint.setEntry(i, work2.getEntry(i));",
    "right" : "alternativeNewPoint.setEntry(i, work2.getEntry(i));",
    "info" : "ExpressionStatement[72840-72891]:ExpressionStatement[72840-72891]"
  }, {
    "left" : "cauchy = csave;",
    "right" : "cauchy = csave;",
    "info" : "ExpressionStatement[72918-72933]:ExpressionStatement[72918-72933]"
  }, {
    "left" : "return new double[] { alpha, cauchy };",
    "right" : "return new double[] { alpha, cauchy };",
    "info" : "ReturnStatement[72953-72991]:ReturnStatement[72953-72991]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[74265-74272]:Modifier[74265-74272]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[74273-74277]:PrimitiveType[74273-74277]"
  }, {
    "left" : "prelim",
    "right" : "prelim",
    "info" : "SimpleName[74278-74284]:SimpleName[74278-74284]"
  }, {
    "left" : "double[] lowerBound",
    "right" : "double[] lowerBound",
    "info" : "SingleVariableDeclaration[74285-74304]:SingleVariableDeclaration[74285-74304]"
  }, {
    "left" : "double[] upperBound",
    "right" : "double[] upperBound",
    "info" : "SingleVariableDeclaration[74330-74349]:SingleVariableDeclaration[74330-74349]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74351-83137]:Block[74351-83151]"
  }, {
    "left" : "printMethod();",
    "right" : "printMethod();",
    "info" : "ExpressionStatement[74361-74375]:ExpressionStatement[74361-74375]"
  }, {
    "left" : "final int n = currentBest.getDimension();",
    "right" : "final int n = currentBest.getDimension();",
    "info" : "VariableDeclarationStatement[74392-74433]:VariableDeclarationStatement[74392-74433]"
  }, {
    "left" : "final int npt = numberOfInterpolationPoints;",
    "right" : "final int npt = numberOfInterpolationPoints;",
    "info" : "VariableDeclarationStatement[74442-74486]:VariableDeclarationStatement[74442-74486]"
  }, {
    "left" : "final int ndim = bMatrix.getRowDimension();",
    "right" : "final int ndim = bMatrix.getRowDimension();",
    "info" : "VariableDeclarationStatement[74495-74538]:VariableDeclarationStatement[74495-74538]"
  }, {
    "left" : "final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;",
    "right" : "final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;",
    "info" : "VariableDeclarationStatement[74548-74621]:VariableDeclarationStatement[74548-74621]"
  }, {
    "left" : "final double recip = 1d / rhosq;",
    "right" : "final double recip = 1d / rhosq;",
    "info" : "VariableDeclarationStatement[74630-74662]:VariableDeclarationStatement[74630-74662]"
  }, {
    "left" : "final int np = n + 1;",
    "right" : "final int np = n + 1;",
    "info" : "VariableDeclarationStatement[74671-74692]:VariableDeclarationStatement[74671-74692]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[74839-75161]:ForStatement[74839-75161]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74867-75161]:Block[74867-75161]"
  }, {
    "left" : "originShift.setEntry(j, currentBest.getEntry(j));",
    "right" : "originShift.setEntry(j, currentBest.getEntry(j));",
    "info" : "ExpressionStatement[74881-74930]:ExpressionStatement[74881-74930]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[74943-75046]:ForStatement[74943-75046]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[74973-75046]:Block[74973-75046]"
  }, {
    "left" : "interpolationPoints.setEntry(k, j, ZERO);",
    "right" : "interpolationPoints.setEntry(k, j, ZERO);",
    "info" : "ExpressionStatement[74991-75032]:ExpressionStatement[74991-75032]"
  }, {
    "left" : "for (int i = 0; i < ndim; i++)",
    "right" : "for (int i = 0; i < ndim; i++)",
    "info" : "ForStatement[75059-75151]:ForStatement[75059-75151]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75090-75151]:Block[75090-75151]"
  }, {
    "left" : "bMatrix.setEntry(i, j, ZERO);",
    "right" : "bMatrix.setEntry(i, j, ZERO);",
    "info" : "ExpressionStatement[75108-75137]:ExpressionStatement[75108-75137]"
  }, {
    "left" : "for (int i = 0, max = n * np / 2; i < max; i++)",
    "right" : "for (int i = 0, max = n * np / 2; i < max; i++)",
    "info" : "ForStatement[75170-75289]:ForStatement[75170-75289]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75218-75289]:Block[75218-75289]"
  }, {
    "left" : "modelSecondDerivativesValues.setEntry(i, ZERO);",
    "right" : "modelSecondDerivativesValues.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[75232-75279]:ExpressionStatement[75232-75279]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[75298-75523]:ForStatement[75298-75523]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75328-75523]:Block[75328-75523]"
  }, {
    "left" : "modelSecondDerivativesParameters.setEntry(k, ZERO);",
    "right" : "modelSecondDerivativesParameters.setEntry(k, ZERO);",
    "info" : "ExpressionStatement[75342-75393]:ExpressionStatement[75342-75393]"
  }, {
    "left" : "for (int j = 0, max = npt - np; j < max; j++)",
    "right" : "for (int j = 0, max = npt - np; j < max; j++)",
    "info" : "ForStatement[75406-75513]:ForStatement[75406-75513]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75452-75513]:Block[75452-75513]"
  }, {
    "left" : "zMatrix.setEntry(k, j, ZERO);",
    "right" : "zMatrix.setEntry(k, j, ZERO);",
    "info" : "ExpressionStatement[75470-75499]:ExpressionStatement[75470-75499]"
  }, {
    "left" : "int ipt = 0;",
    "right" : "int ipt = 0;",
    "info" : "VariableDeclarationStatement[75777-75789]:VariableDeclarationStatement[75777-75789]"
  }, {
    "left" : "int jpt = 0;",
    "right" : "int jpt = 0;",
    "info" : "VariableDeclarationStatement[75798-75810]:VariableDeclarationStatement[75798-75810]"
  }, {
    "left" : "double fbeg = Double.NaN;",
    "right" : "double fbeg = Double.NaN;",
    "info" : "VariableDeclarationStatement[75819-75844]:VariableDeclarationStatement[75819-75844]"
  }, {
    "left" : "do{...}",
    "right" : "do{...}",
    "info" : "DoStatement[75853-83131]:DoStatement[75853-83145]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[75856-83099]:Block[75856-83113]"
  }, {
    "left" : "final int nfm = getEvaluations();",
    "right" : "final int nfm = getEvaluations();",
    "info" : "VariableDeclarationStatement[75870-75903]:VariableDeclarationStatement[75870-75903]"
  }, {
    "left" : "final int nfx = nfm - n;",
    "right" : "final int nfx = nfm - n;",
    "info" : "VariableDeclarationStatement[75916-75940]:VariableDeclarationStatement[75916-75940]"
  }, {
    "left" : "final int nfmm = nfm - 1;",
    "right" : "final int nfmm = nfm - 1;",
    "info" : "VariableDeclarationStatement[75953-75978]:VariableDeclarationStatement[75953-75978]"
  }, {
    "left" : "final int nfxm = nfx - 1;",
    "right" : "final int nfxm = nfx - 1;",
    "info" : "VariableDeclarationStatement[75991-76016]:VariableDeclarationStatement[75991-76016]"
  }, {
    "left" : "double stepa = 0;",
    "right" : "double stepa = 0;",
    "info" : "VariableDeclarationStatement[76029-76046]:VariableDeclarationStatement[76029-76046]"
  }, {
    "left" : "double stepb = 0;",
    "right" : "double stepb = 0;",
    "info" : "VariableDeclarationStatement[76059-76076]:VariableDeclarationStatement[76059-76076]"
  }, {
    "left" : "if (nfm <= 2 * n)",
    "right" : "if (nfm <= 2 * n)",
    "info" : "IfStatement[76089-77947]:IfStatement[76089-77958]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76107-77277]:Block[76107-77277]"
  }, {
    "left" : "if (nfm >= 1 &&\n                    nfm <= n)",
    "right" : "if (nfm >= 1 &&\n                    nfm <= n)",
    "info" : "IfStatement[76125-77263]:IfStatement[76125-77263]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76171-76508]:Block[76171-76508]"
  }, {
    "left" : "stepa = initialTrustRegionRadius;",
    "right" : "stepa = initialTrustRegionRadius;",
    "info" : "ExpressionStatement[76193-76226]:ExpressionStatement[76193-76226]"
  }, {
    "left" : "if (upperDifference.getEntry(nfmm) == ZERO)",
    "right" : "if (upperDifference.getEntry(nfmm) == ZERO)",
    "info" : "IfStatement[76247-76422]:IfStatement[76247-76422]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76291-76422]:Block[76291-76422]"
  }, {
    "left" : "stepa = -stepa;",
    "right" : "stepa = -stepa;",
    "info" : "ExpressionStatement[76317-76332]:ExpressionStatement[76317-76332]"
  }, {
    "left" : "throw new PathIsExploredException();",
    "right" : "throw new PathIsExploredException();",
    "info" : "ThrowStatement[76357-76393]:ThrowStatement[76357-76393]"
  }, {
    "left" : "interpolationPoints.setEntry(nfm, nfmm, stepa);",
    "right" : "interpolationPoints.setEntry(nfm, nfmm, stepa);",
    "info" : "ExpressionStatement[76443-76490]:ExpressionStatement[76443-76490]"
  }, {
    "left" : "if (nfm > n)",
    "right" : "if (nfm > n)",
    "info" : "IfStatement[76514-77263]:IfStatement[76514-77263]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76527-77263]:Block[76527-77263]"
  }, {
    "left" : "stepa = interpolationPoints.getEntry(nfx, nfxm);",
    "right" : "stepa = interpolationPoints.getEntry(nfx, nfxm);",
    "info" : "ExpressionStatement[76549-76597]:ExpressionStatement[76549-76597]"
  }, {
    "left" : "stepb = -initialTrustRegionRadius;",
    "right" : "stepb = -initialTrustRegionRadius;",
    "info" : "ExpressionStatement[76618-76652]:ExpressionStatement[76618-76652]"
  }, {
    "left" : "if (lowerDifference.getEntry(nfxm) == ZERO)",
    "right" : "if (lowerDifference.getEntry(nfxm) == ZERO)",
    "info" : "IfStatement[76673-76914]:IfStatement[76673-76914]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76717-76914]:Block[76717-76914]"
  }, {
    "left" : "stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));",
    "right" : "stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));",
    "info" : "ExpressionStatement[76743-76824]:ExpressionStatement[76743-76824]"
  }, {
    "left" : "throw new PathIsExploredException();",
    "right" : "throw new PathIsExploredException();",
    "info" : "ThrowStatement[76849-76885]:ThrowStatement[76849-76885]"
  }, {
    "left" : "if (upperDifference.getEntry(nfxm) == ZERO)",
    "right" : "if (upperDifference.getEntry(nfxm) == ZERO)",
    "info" : "IfStatement[76935-77177]:IfStatement[76935-77177]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[76979-77177]:Block[76979-77177]"
  }, {
    "left" : "stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));",
    "right" : "stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));",
    "info" : "ExpressionStatement[77005-77087]:ExpressionStatement[77005-77087]"
  }, {
    "left" : "throw new PathIsExploredException();",
    "right" : "throw new PathIsExploredException();",
    "info" : "ThrowStatement[77112-77148]:ThrowStatement[77112-77148]"
  }, {
    "left" : "interpolationPoints.setEntry(nfm, nfxm, stepb);",
    "right" : "interpolationPoints.setEntry(nfm, nfxm, stepb);",
    "info" : "ExpressionStatement[77198-77245]:ExpressionStatement[77198-77245]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[77283-77947]:Block[77283-77958]"
  }, {
    "left" : "final int tmp1 = (nfm - np) / n;",
    "right" : "final int tmp1 = (nfm - np) / n;",
    "info" : "VariableDeclarationStatement[77301-77333]:VariableDeclarationStatement[77301-77333]"
  }, {
    "left" : "jpt = nfm - tmp1 * n - n;",
    "right" : "jpt = nfm - tmp1 * n - n;",
    "info" : "ExpressionStatement[77350-77375]:ExpressionStatement[77350-77375]"
  }, {
    "left" : "ipt = jpt + tmp1;",
    "right" : "ipt = jpt + tmp1;",
    "info" : "ExpressionStatement[77392-77409]:ExpressionStatement[77392-77409]"
  }, {
    "left" : "if (ipt > n)",
    "right" : "if (ipt > n)",
    "info" : "IfStatement[77426-77631]:IfStatement[77426-77634]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[77439-77631]:Block[77439-77634]"
  }, {
    "left" : "final int tmp2 = jpt;",
    "right" : "final int tmp2 = jpt;",
    "info" : "VariableDeclarationStatement[77461-77482]:VariableDeclarationStatement[77461-77482]"
  }, {
    "left" : "jpt = ipt - n;",
    "right" : "jpt = ipt - n;",
    "info" : "ExpressionStatement[77503-77517]:ExpressionStatement[77503-77517]"
  }, {
    "left" : "ipt = tmp2;",
    "right" : "ipt = tmp2;",
    "info" : "ExpressionStatement[77538-77549]:ExpressionStatement[77538-77549]"
  }, {
    "left" : "interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));",
    "right" : "interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));",
    "info" : "ExpressionStatement[77734-77825]:ExpressionStatement[77745-77836]"
  }, {
    "left" : "interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));",
    "right" : "interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));",
    "info" : "ExpressionStatement[77842-77933]:ExpressionStatement[77853-77944]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[78083-78726]:ForStatement[78094-78737]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78111-78726]:Block[78122-78737]"
  }, {
    "left" : "currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));",
    "right" : "currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));",
    "info" : "ExpressionStatement[78129-78374]:ExpressionStatement[78140-78385]"
  }, {
    "left" : "if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j))",
    "right" : "if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j))",
    "info" : "IfStatement[78391-78543]:IfStatement[78402-78554]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78464-78543]:Block[78475-78554]"
  }, {
    "left" : "currentBest.setEntry(j, lowerBound[j]);",
    "right" : "currentBest.setEntry(j, lowerBound[j]);",
    "info" : "ExpressionStatement[78486-78525]:ExpressionStatement[78497-78536]"
  }, {
    "left" : "if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j))",
    "right" : "if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j))",
    "info" : "IfStatement[78560-78712]:IfStatement[78571-78723]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[78633-78712]:Block[78644-78723]"
  }, {
    "left" : "currentBest.setEntry(j, upperBound[j]);",
    "right" : "currentBest.setEntry(j, upperBound[j]);",
    "info" : "ExpressionStatement[78655-78694]:ExpressionStatement[78666-78705]"
  }, {
    "left" : "final double objectiveValue = computeObjectiveValue(currentBest.toArray());",
    "right" : "final double objectiveValue = computeObjectiveValue(currentBest.toArray());",
    "info" : "VariableDeclarationStatement[78740-78815]:VariableDeclarationStatement[78751-78826]"
  }, {
    "left" : "final double f = isMinimize ? objectiveValue : -objectiveValue;",
    "right" : "final double f = isMinimize ? objectiveValue : -objectiveValue;",
    "info" : "VariableDeclarationStatement[78828-78891]:VariableDeclarationStatement[78839-78902]"
  }, {
    "left" : "final int numEval = getEvaluations();",
    "right" : "final int numEval = getEvaluations();",
    "info" : "VariableDeclarationStatement[78904-78941]:VariableDeclarationStatement[78915-78952]"
  }, {
    "left" : "fAtInterpolationPoints.setEntry(nfm, f);",
    "right" : "fAtInterpolationPoints.setEntry(nfm, f);",
    "info" : "ExpressionStatement[78965-79005]:ExpressionStatement[78976-79016]"
  }, {
    "left" : "if (numEval == 1)",
    "right" : "if (numEval == 1)",
    "info" : "IfStatement[79019-79308]:IfStatement[79030-79319]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79037-79140]:Block[79048-79151]"
  }, {
    "left" : "fbeg = f;",
    "right" : "fbeg = f;",
    "info" : "ExpressionStatement[79055-79064]:ExpressionStatement[79066-79075]"
  }, {
    "left" : "trustRegionCenterInterpolationPointIndex = 0;",
    "right" : "trustRegionCenterInterpolationPointIndex = 0;",
    "info" : "ExpressionStatement[79081-79126]:ExpressionStatement[79092-79137]"
  }, {
    "left" : "if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex))",
    "right" : "if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex))",
    "info" : "IfStatement[79146-79308]:IfStatement[79157-79319]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79229-79308]:Block[79240-79319]"
  }, {
    "left" : "trustRegionCenterInterpolationPointIndex = nfm;",
    "right" : "trustRegionCenterInterpolationPointIndex = nfm;",
    "info" : "ExpressionStatement[79247-79294]:ExpressionStatement[79258-79305]"
  }, {
    "left" : "if (numEval <= 2 * n + 1)",
    "right" : "if (numEval <= 2 * n + 1)",
    "info" : "IfStatement[79747-83089]:IfStatement[79758-83103]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79773-82458]:Block[79784-82469]"
  }, {
    "left" : "if (numEval >= 2 &&\n                    numEval <= n + 1)",
    "right" : "if (numEval >= 2 &&\n                    numEval <= n + 1)",
    "info" : "IfStatement[79791-82305]:IfStatement[79802-82316]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79849-80360]:Block[79860-80371]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);",
    "right" : "gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);",
    "info" : "ExpressionStatement[79871-79934]:ExpressionStatement[79882-79945]"
  }, {
    "left" : "if (npt < numEval + n)",
    "right" : "if (npt < numEval + n)",
    "info" : "IfStatement[79955-80342]:IfStatement[79966-80353]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[79978-80342]:Block[79989-80353]"
  }, {
    "left" : "final double oneOverStepA = ONE / stepa;",
    "right" : "final double oneOverStepA = ONE / stepa;",
    "info" : "VariableDeclarationStatement[80004-80044]:VariableDeclarationStatement[80015-80055]"
  }, {
    "left" : "bMatrix.setEntry(0, nfmm, -oneOverStepA);",
    "right" : "bMatrix.setEntry(0, nfmm, -oneOverStepA);",
    "info" : "ExpressionStatement[80069-80110]:ExpressionStatement[80080-80121]"
  }, {
    "left" : "bMatrix.setEntry(nfm, nfmm, oneOverStepA);",
    "right" : "bMatrix.setEntry(nfm, nfmm, oneOverStepA);",
    "info" : "ExpressionStatement[80135-80177]:ExpressionStatement[80146-80188]"
  }, {
    "left" : "bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);",
    "right" : "bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);",
    "info" : "ExpressionStatement[80202-80252]:ExpressionStatement[80213-80263]"
  }, {
    "left" : "throw new PathIsExploredException();",
    "right" : "throw new PathIsExploredException();",
    "info" : "ThrowStatement[80277-80313]:ThrowStatement[80288-80324]"
  }, {
    "left" : "if (numEval >= n + 2)",
    "right" : "if (numEval >= n + 2)",
    "info" : "IfStatement[80366-82305]:IfStatement[80377-82316]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[80388-82305]:Block[80399-82316]"
  }, {
    "left" : "final int ih = nfx * (nfx + 1) / 2 - 1;",
    "right" : "final int ih = nfx * (nfx + 1) / 2 - 1;",
    "info" : "VariableDeclarationStatement[80410-80449]:VariableDeclarationStatement[80421-80460]"
  }, {
    "left" : "final double tmp = (f - fbeg) / stepb;",
    "right" : "final double tmp = (f - fbeg) / stepb;",
    "info" : "VariableDeclarationStatement[80470-80508]:VariableDeclarationStatement[80481-80519]"
  }, {
    "left" : "final double diff = stepb - stepa;",
    "right" : "final double diff = stepb - stepa;",
    "info" : "VariableDeclarationStatement[80529-80563]:VariableDeclarationStatement[80540-80574]"
  }, {
    "left" : "modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);",
    "right" : "modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);",
    "info" : "ExpressionStatement[80584-80691]:ExpressionStatement[80595-80702]"
  }, {
    "left" : "gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);",
    "right" : "gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);",
    "info" : "ExpressionStatement[80712-80830]:ExpressionStatement[80723-80841]"
  }, {
    "left" : "if (stepa * stepb < ZERO)",
    "right" : "if (stepa * stepb < ZERO)",
    "info" : "IfStatement[80851-81536]:IfStatement[80862-81547]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[80877-81536]:Block[80888-81547]"
  }, {
    "left" : "if (f < fAtInterpolationPoints.getEntry(nfm - n))",
    "right" : "if (f < fAtInterpolationPoints.getEntry(nfm - n))",
    "info" : "IfStatement[80903-81514]:IfStatement[80914-81525]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[80953-81514]:Block[80964-81525]"
  }, {
    "left" : "fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));",
    "right" : "fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));",
    "info" : "ExpressionStatement[80983-81062]:ExpressionStatement[80994-81073]"
  }, {
    "left" : "fAtInterpolationPoints.setEntry(nfm - n, f);",
    "right" : "fAtInterpolationPoints.setEntry(nfm - n, f);",
    "info" : "ExpressionStatement[81091-81135]:ExpressionStatement[81102-81146]"
  }, {
    "left" : "if (trustRegionCenterInterpolationPointIndex == nfm)",
    "right" : "if (trustRegionCenterInterpolationPointIndex == nfm)",
    "info" : "IfStatement[81164-81332]:IfStatement[81175-81343]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[81217-81332]:Block[81228-81343]"
  }, {
    "left" : "trustRegionCenterInterpolationPointIndex = nfm - n;",
    "right" : "trustRegionCenterInterpolationPointIndex = nfm - n;",
    "info" : "ExpressionStatement[81251-81302]:ExpressionStatement[81262-81313]"
  }, {
    "left" : "interpolationPoints.setEntry(nfm - n, nfxm, stepb);",
    "right" : "interpolationPoints.setEntry(nfm - n, nfxm, stepb);",
    "info" : "ExpressionStatement[81361-81412]:ExpressionStatement[81372-81423]"
  }, {
    "left" : "interpolationPoints.setEntry(nfm, nfxm, stepa);",
    "right" : "interpolationPoints.setEntry(nfm, nfxm, stepa);",
    "info" : "ExpressionStatement[81441-81488]:ExpressionStatement[81452-81499]"
  }, {
    "left" : "bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));",
    "right" : "bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));",
    "info" : "ExpressionStatement[81557-81619]:ExpressionStatement[81568-81630]"
  }, {
    "left" : "bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));",
    "right" : "bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));",
    "info" : "ExpressionStatement[81640-81721]:ExpressionStatement[81651-81732]"
  }, {
    "left" : "bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));",
    "right" : "bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));",
    "info" : "ExpressionStatement[81742-81866]:ExpressionStatement[81753-81877]"
  }, {
    "left" : "zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));",
    "right" : "zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));",
    "info" : "ExpressionStatement[81887-81947]:ExpressionStatement[81898-81958]"
  }, {
    "left" : "zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);",
    "right" : "zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);",
    "info" : "ExpressionStatement[81968-82021]:ExpressionStatement[81979-82032]"
  }, {
    "left" : "zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));",
    "right" : "zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));",
    "info" : "ExpressionStatement[82163-82287]:ExpressionStatement[82174-82298]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[82464-83089]:Block[82475-83103]"
  }, {
    "left" : "zMatrix.setEntry(0, nfxm, recip);",
    "right" : "zMatrix.setEntry(0, nfxm, recip);",
    "info" : "ExpressionStatement[82482-82515]:ExpressionStatement[82493-82526]"
  }, {
    "left" : "zMatrix.setEntry(nfm, nfxm, recip);",
    "right" : "zMatrix.setEntry(nfm, nfxm, recip);",
    "info" : "ExpressionStatement[82532-82567]:ExpressionStatement[82543-82578]"
  }, {
    "left" : "zMatrix.setEntry(ipt, nfxm, -recip);",
    "right" : "zMatrix.setEntry(ipt, nfxm, -recip);",
    "info" : "ExpressionStatement[82584-82620]:ExpressionStatement[82595-82631]"
  }, {
    "left" : "zMatrix.setEntry(jpt, nfxm, -recip);",
    "right" : "zMatrix.setEntry(jpt, nfxm, -recip);",
    "info" : "ExpressionStatement[82637-82673]:ExpressionStatement[82648-82684]"
  }, {
    "left" : "final int ih = ipt * (ipt - 1) / 2 + jpt - 1;",
    "right" : "final int ih = ipt * (ipt - 1) / 2 + jpt - 1;",
    "info" : "VariableDeclarationStatement[82691-82736]:VariableDeclarationStatement[82702-82747]"
  }, {
    "left" : "final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);",
    "right" : "final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);",
    "info" : "VariableDeclarationStatement[82753-82860]:VariableDeclarationStatement[82764-82871]"
  }, {
    "left" : "modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);",
    "right" : "modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);",
    "info" : "ExpressionStatement[82877-83015]:ExpressionStatement[82888-83026]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[86131-86138]:Modifier[86145-86152]"
  }, {
    "left" : "double[]",
    "right" : "double[]",
    "info" : "ArrayType[86139-86147]:ArrayType[86153-86161]"
  }, {
    "left" : "trsbox",
    "right" : "trsbox",
    "info" : "SimpleName[86148-86154]:SimpleName[86162-86168]"
  }, {
    "left" : "double delta",
    "right" : "double delta",
    "info" : "SingleVariableDeclaration[86168-86180]:SingleVariableDeclaration[86182-86194]"
  }, {
    "left" : "ArrayRealVector gnew",
    "right" : "ArrayRealVector gnew",
    "info" : "SingleVariableDeclaration[86194-86214]:SingleVariableDeclaration[86208-86228]"
  }, {
    "left" : "ArrayRealVector xbdi",
    "right" : "ArrayRealVector xbdi",
    "info" : "SingleVariableDeclaration[86228-86248]:SingleVariableDeclaration[86242-86262]"
  }, {
    "left" : "ArrayRealVector s",
    "right" : "ArrayRealVector s",
    "info" : "SingleVariableDeclaration[86262-86279]:SingleVariableDeclaration[86276-86293]"
  }, {
    "left" : "ArrayRealVector hs",
    "right" : "ArrayRealVector hs",
    "info" : "SingleVariableDeclaration[86293-86311]:SingleVariableDeclaration[86307-86325]"
  }, {
    "left" : "ArrayRealVector hred",
    "right" : "ArrayRealVector hred",
    "info" : "SingleVariableDeclaration[86325-86345]:SingleVariableDeclaration[86339-86359]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[86352-104964]:Block[86366-104978]"
  }, {
    "left" : "printMethod();",
    "right" : "printMethod();",
    "info" : "ExpressionStatement[86362-86376]:ExpressionStatement[86376-86390]"
  }, {
    "left" : "final int n = currentBest.getDimension();",
    "right" : "final int n = currentBest.getDimension();",
    "info" : "VariableDeclarationStatement[86393-86434]:VariableDeclarationStatement[86407-86448]"
  }, {
    "left" : "final int npt = numberOfInterpolationPoints;",
    "right" : "final int npt = numberOfInterpolationPoints;",
    "info" : "VariableDeclarationStatement[86443-86487]:VariableDeclarationStatement[86457-86501]"
  }, {
    "left" : "double dsq = Double.NaN;",
    "right" : "double dsq = Double.NaN;",
    "info" : "VariableDeclarationStatement[86497-86521]:VariableDeclarationStatement[86511-86535]"
  }, {
    "left" : "double crvmin = Double.NaN;",
    "right" : "double crvmin = Double.NaN;",
    "info" : "VariableDeclarationStatement[86530-86557]:VariableDeclarationStatement[86544-86571]"
  }, {
    "left" : "double ds;",
    "right" : "double ds;",
    "info" : "VariableDeclarationStatement[86594-86604]:VariableDeclarationStatement[86608-86618]"
  }, {
    "left" : "int iu;",
    "right" : "int iu;",
    "info" : "VariableDeclarationStatement[86613-86620]:VariableDeclarationStatement[86627-86634]"
  }, {
    "left" : "double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;",
    "right" : "double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;",
    "info" : "VariableDeclarationStatement[86629-86685]:VariableDeclarationStatement[86643-86699]"
  }, {
    "left" : "int iact = -1;",
    "right" : "int iact = -1;",
    "info" : "VariableDeclarationStatement[86694-86708]:VariableDeclarationStatement[86708-86722]"
  }, {
    "left" : "int nact = 0;",
    "right" : "int nact = 0;",
    "info" : "VariableDeclarationStatement[86717-86730]:VariableDeclarationStatement[86731-86744]"
  }, {
    "left" : "double angt = 0, qred;",
    "right" : "double angt = 0, qred;",
    "info" : "VariableDeclarationStatement[86739-86761]:VariableDeclarationStatement[86753-86775]"
  }, {
    "left" : "int isav;",
    "right" : "int isav;",
    "info" : "VariableDeclarationStatement[86770-86779]:VariableDeclarationStatement[86784-86793]"
  }, {
    "left" : "double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;",
    "right" : "double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;",
    "info" : "VariableDeclarationStatement[86788-86857]:VariableDeclarationStatement[86802-86871]"
  }, {
    "left" : "int iterc;",
    "right" : "int iterc;",
    "info" : "VariableDeclarationStatement[86866-86876]:VariableDeclarationStatement[86880-86890]"
  }, {
    "left" : "double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,\n        redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0;",
    "right" : "double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,\n        redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0;",
    "info" : "VariableDeclarationStatement[86885-87014]:VariableDeclarationStatement[86899-87028]"
  }, {
    "left" : "int itcsav = 0;",
    "right" : "int itcsav = 0;",
    "info" : "VariableDeclarationStatement[87023-87038]:VariableDeclarationStatement[87037-87052]"
  }, {
    "left" : "double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;",
    "right" : "double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;",
    "info" : "VariableDeclarationStatement[87047-87101]:VariableDeclarationStatement[87061-87115]"
  }, {
    "left" : "int itermax = 0;",
    "right" : "int itermax = 0;",
    "info" : "VariableDeclarationStatement[87110-87126]:VariableDeclarationStatement[87124-87140]"
  }, {
    "left" : "iterc = 0;",
    "right" : "iterc = 0;",
    "info" : "ExpressionStatement[87678-87688]:ExpressionStatement[87692-87702]"
  }, {
    "left" : "nact = 0;",
    "right" : "nact = 0;",
    "info" : "ExpressionStatement[87697-87706]:ExpressionStatement[87711-87720]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[87715-88452]:ForStatement[87729-88466]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[87743-88452]:Block[87757-88466]"
  }, {
    "left" : "xbdi.setEntry(i, ZERO);",
    "right" : "xbdi.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[87757-87780]:ExpressionStatement[87771-87794]"
  }, {
    "left" : "if (trustRegionCenterOffset.getEntry(i) <= lowerDifference.getEntry(i))",
    "right" : "if (trustRegionCenterOffset.getEntry(i) <= lowerDifference.getEntry(i))",
    "info" : "IfStatement[87793-88243]:IfStatement[87807-88257]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[87865-88018]:Block[87879-88032]"
  }, {
    "left" : "if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO)",
    "right" : "if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO)",
    "info" : "IfStatement[87883-88004]:IfStatement[87897-88018]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[87936-88004]:Block[87950-88018]"
  }, {
    "left" : "xbdi.setEntry(i, MINUS_ONE);",
    "right" : "xbdi.setEntry(i, MINUS_ONE);",
    "info" : "ExpressionStatement[87958-87986]:ExpressionStatement[87972-88000]"
  }, {
    "left" : "if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i))",
    "right" : "if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i))",
    "info" : "IfStatement[88024-88243]:IfStatement[88038-88257]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[88096-88243]:Block[88110-88257]"
  }, {
    "left" : "if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO)",
    "right" : "if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO)",
    "info" : "IfStatement[88114-88229]:IfStatement[88128-88243]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[88167-88229]:Block[88181-88243]"
  }, {
    "left" : "xbdi.setEntry(i, ONE);",
    "right" : "xbdi.setEntry(i, ONE);",
    "info" : "ExpressionStatement[88189-88211]:ExpressionStatement[88203-88225]"
  }, {
    "left" : "if (xbdi.getEntry(i) != ZERO)",
    "right" : "if (xbdi.getEntry(i) != ZERO)",
    "info" : "IfStatement[88256-88325]:IfStatement[88270-88339]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[88286-88325]:Block[88300-88339]"
  }, {
    "left" : "++nact;",
    "right" : "++nact;",
    "info" : "ExpressionStatement[88304-88311]:ExpressionStatement[88318-88325]"
  }, {
    "left" : "trialStepPoint.setEntry(i, ZERO);",
    "right" : "trialStepPoint.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[88338-88371]:ExpressionStatement[88352-88385]"
  }, {
    "left" : "gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i));",
    "right" : "gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i));",
    "info" : "ExpressionStatement[88384-88442]:ExpressionStatement[88398-88456]"
  }, {
    "left" : "delsq = delta * delta;",
    "right" : "delsq = delta * delta;",
    "info" : "ExpressionStatement[88461-88483]:ExpressionStatement[88475-88497]"
  }, {
    "left" : "qred = ZERO;",
    "right" : "qred = ZERO;",
    "info" : "ExpressionStatement[88492-88504]:ExpressionStatement[88506-88518]"
  }, {
    "left" : "crvmin = MINUS_ONE;",
    "right" : "crvmin = MINUS_ONE;",
    "info" : "ExpressionStatement[88513-88532]:ExpressionStatement[88527-88546]"
  }, {
    "left" : "int state = 20;",
    "right" : "int state = 20;",
    "info" : "VariableDeclarationStatement[88939-88954]:VariableDeclarationStatement[88953-88968]"
  }, {
    "left" : "for(;;) {\n            switch (state) {\n        case 20: {\n            printState(20); // XXX\n            beta = ZERO;\n        }\n        case 30: {\n            printState(30); // XXX\n            stepsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) != ZERO) {\n                    s.setEntry(i, ZERO);\n                } else if (beta == ZERO) {\n                    s.setEntry(i, -gnew.getEntry(i));\n                } else {\n                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                }\n                // Computing 2nd power\n                final double d1 = s.getEntry(i);\n                stepsq += d1 * d1;\n            }\n            if (stepsq == ZERO) {\n                state = 190; break;\n            }\n            if (beta == ZERO) {\n                gredsq = stepsq;\n                itermax = iterc + n - nact;\n            }\n            if (gredsq * delsq <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n\n            // Multiply the search direction by the second derivative matrix of Q and\n            // calculate some scalars for the choice of steplength. Then set BLEN to\n            // the length of the the step to the trust region boundary and STPLEN to\n            // the steplength, ignoring the simple bounds.\n\n            state = 210; break;\n        }\n        case 50: {\n            printState(50); // XXX\n            resid = delsq;\n            ds = ZERO;\n            shs = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    final double d1 = trialStepPoint.getEntry(i);\n                    resid -= d1 * d1;\n                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                }\n            }\n            if (resid <= ZERO) {\n                state = 90; break;\n            }\n            temp = Math.sqrt(stepsq * resid + ds * ds);\n            if (ds < ZERO) {\n                blen = (temp - ds) / stepsq;\n            } else {\n                blen = resid / (temp + ds);\n            }\n            stplen = blen;\n            if (shs > ZERO) {\n                // Computing MIN\n                stplen = Math.min(blen, gredsq / shs);\n            }\n\n            // Reduce STPLEN if necessary in order to preserve the simple bounds,\n            // letting IACT be the index of the new constrained variable.\n\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (s.getEntry(i) != ZERO) {\n                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                    if (s.getEntry(i) > ZERO) {\n                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    } else {\n                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    }\n                    if (temp < stplen) {\n                        stplen = temp;\n                        iact = i;\n                    }\n                }\n            }\n\n            // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.\n\n            sdec = ZERO;\n            if (stplen > ZERO) {\n                ++iterc;\n                temp = shs / stepsq;\n                if (iact == -1 && temp > ZERO) {\n                    crvmin = Math.min(crvmin,temp);\n                    if (crvmin == MINUS_ONE) {\n                        crvmin = temp;\n                    }\n                }\n                ggsav = gredsq;\n                gredsq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                    if (xbdi.getEntry(i) == ZERO) {\n                        // Computing 2nd power\n                        final double d1 = gnew.getEntry(i);\n                        gredsq += d1 * d1;\n                    }\n                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                }\n                // Computing MAX\n                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                sdec = Math.max(d1, ZERO);\n                qred += sdec;\n            }\n\n            // Restart the conjugate gradient method if it has hit a new bound.\n\n            if (iact >= 0) {\n                ++nact;\n                xbdi.setEntry(iact, ONE);\n                if (s.getEntry(iact) < ZERO) {\n                    xbdi.setEntry(iact, MINUS_ONE);\n                }\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(iact);\n                delsq -= d1 * d1;\n                if (delsq <= ZERO) {\n                    state = 190; break;\n                }\n                state = 20; break;\n            }\n\n            // If STPLEN is less than BLEN, then either apply another conjugate\n            // gradient iteration or RETURN.\n\n            if (stplen < blen) {\n                if (iterc == itermax) {\n                    state = 190; break;\n                }\n                if (sdec <= qred * .01) {\n                    state = 190; break;\n                }\n                beta = gredsq / ggsav;\n                state = 30; break;\n            }\n        }\n        case 90: {\n            printState(90); // XXX\n            crvmin = ZERO;\n\n            // Prepare for the alternative iteration by calculating some scalars\n            // and by multiplying the reduced D by the second derivative matrix of\n            // Q, where S holds the reduced D in the call of GGMULT.\n\n        }\n        case 100: {\n            printState(100); // XXX\n            if (nact >= n - 1) {\n                state = 190; break;\n            }\n            dredsq = ZERO;\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    dredsq += d1 * d1;\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                    s.setEntry(i, trialStepPoint.getEntry(i));\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            itcsav = iterc;\n            state = 210; break;\n            // Let the search direction S be a linear combination of the reduced D\n            // and the reduced G that is orthogonal to the reduced D.\n        }\n        case 120: {\n            printState(120); // XXX\n            ++iterc;\n            temp = gredsq * dredsq - dredg * dredg;\n            if (temp <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n            temp = Math.sqrt(temp);\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            sredg = -temp;\n\n            // By considering the simple bounds on the variables, calculate an upper\n            // bound on the tangent of half the angle of the alternative iteration,\n            // namely ANGBD, except that, if already a free variable has reached a\n            // bound, there is a branch back to label 100 after fixing that variable.\n\n            angbd = ONE;\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                    if (tempa <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, MINUS_ONE);\n                        state = 100; break;\n                    } else if (tempb <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, ONE);\n                        state = 100; break;\n                    }\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    // Computing 2nd power\n                    double d2 = s.getEntry(i);\n                    ssq = d1 * d1 + d2 * d2;\n                    // Computing 2nd power\n                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) - s.getEntry(i);\n                        if (angbd * temp > tempa) {\n                            angbd = tempa / temp;\n                            iact = i;\n                            xsav = MINUS_ONE;\n                        }\n                    }\n                    // Computing 2nd power\n                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) + s.getEntry(i);\n                        if (angbd * temp > tempb) {\n                            angbd = tempb / temp;\n                            iact = i;\n                            xsav = ONE;\n                        }\n                    }\n                }\n            }\n\n            // Calculate HHD and some curvatures for the alternative iteration.\n\n            state = 210; break;\n        }\n        case 150: {\n            printState(150); // XXX\n            shs = ZERO;\n            dhs = ZERO;\n            dhd = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                }\n            }\n\n            // Seek the greatest reduction in Q for a range of equally spaced values\n            // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of\n            // the alternative iteration.\n\n            redmax = ZERO;\n            isav = -1;\n            redsav = ZERO;\n            iu = (int) (angbd * 17. + 3.1);\n            for (int i = 0; i < iu; i++) {\n                angt = angbd * i / iu;\n                sth = (angt + angt) / (ONE + angt * angt);\n                temp = shs + angt * (angt * dhd - dhs - dhs);\n                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                if (rednew > redmax) {\n                    redmax = rednew;\n                    isav = i;\n                    rdprev = redsav;\n                } else if (i == isav + 1) {\n                    rdnext = rednew;\n                }\n                redsav = rednew;\n            }\n\n            // Return if the reduction is zero. Otherwise, set the sine and cosine\n            // of the angle of the alternative iteration, and calculate SDEC.\n\n            if (isav < 0) {\n                state = 190; break;\n            }\n            if (isav < iu) {\n                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n                angt = angbd * (isav + HALF * temp) / iu;\n            }\n            cth = (ONE - angt * angt) / (ONE + angt * angt);\n            sth = (angt + angt) / (ONE + angt * angt);\n            temp = shs + angt * (angt * dhd - dhs - dhs);\n            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n            if (sdec <= ZERO) {\n                state = 190; break;\n            }\n\n            // Update GNEW, D and HRED. If the angle of the alternative iteration\n            // is restricted by a bound on a free variable, that variable is fixed\n            // at the bound.\n\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                if (xbdi.getEntry(i) == ZERO) {\n                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    final double d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                }\n                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n            }\n            qred += sdec;\n            if (iact >= 0 && isav == iu) {\n                ++nact;\n                xbdi.setEntry(iact, xsav);\n                state = 100; break;\n            }\n\n            // If SDEC is sufficiently small, then RETURN after setting XNEW to\n            // XOPT+D, giving careful attention to the bounds.\n\n            if (sdec > qred * .01) {\n                state = 120; break;\n            }\n        }\n        case 190: {\n            printState(190); // XXX\n            dsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                // Computing MAX\n                // Computing MIN\n                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));\n                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                if (xbdi.getEntry(i) == MINUS_ONE) {\n                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                }\n                if (xbdi.getEntry(i) == ONE) {\n                    newPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(i);\n                dsq += d1 * d1;\n            }\n            return new double[] { dsq, crvmin };\n            // The following instructions multiply the current S-vector by the second\n            // derivative matrix of the quadratic model, putting the product in HS.\n            // They are reached from three different parts of the software above and\n            // they can be regarded as an external subroutine.\n        }\n        case 210: {\n            printState(210); // XXX\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                hs.setEntry(j, ZERO);\n                for (int i = 0; i <= j; i++) {\n                    if (i < j) {\n                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n                    }\n                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                    ih++;\n                }\n            }\n            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n            for (int k = 0; k < npt; k++) {\n                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n            if (crvmin != ZERO) {\n                state = 50; break;\n            }\n            if (iterc > itcsav) {\n                state = 150; break;\n            }\n            for (int i = 0; i < n; i++) {\n                hred.setEntry(i, hs.getEntry(i));\n            }\n            state = 120; break;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n        }}\n        })",
    "right" : "for(;;) {\n            switch (state) {\n        case 20: {\n            printState(20); // XXX\n            beta = ZERO;\n        }\n        case 30: {\n            printState(30); // XXX\n            stepsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) != ZERO) {\n                    s.setEntry(i, ZERO);\n                } else if (beta == ZERO) {\n                    s.setEntry(i, -gnew.getEntry(i));\n                } else {\n                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                }\n                // Computing 2nd power\n                final double d1 = s.getEntry(i);\n                stepsq += d1 * d1;\n            }\n            if (stepsq == ZERO) {\n                state = 190; break;\n            }\n            if (beta == ZERO) {\n                gredsq = stepsq;\n                itermax = iterc + n - nact;\n            }\n            if (gredsq * delsq <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n\n            // Multiply the search direction by the second derivative matrix of Q and\n            // calculate some scalars for the choice of steplength. Then set BLEN to\n            // the length of the the step to the trust region boundary and STPLEN to\n            // the steplength, ignoring the simple bounds.\n\n            state = 210; break;\n        }\n        case 50: {\n            printState(50); // XXX\n            resid = delsq;\n            ds = ZERO;\n            shs = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    final double d1 = trialStepPoint.getEntry(i);\n                    resid -= d1 * d1;\n                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                }\n            }\n            if (resid <= ZERO) {\n                state = 90; break;\n            }\n            temp = Math.sqrt(stepsq * resid + ds * ds);\n            if (ds < ZERO) {\n                blen = (temp - ds) / stepsq;\n            } else {\n                blen = resid / (temp + ds);\n            }\n            stplen = blen;\n            if (shs > ZERO) {\n                // Computing MIN\n                stplen = Math.min(blen, gredsq / shs);\n            }\n\n            // Reduce STPLEN if necessary in order to preserve the simple bounds,\n            // letting IACT be the index of the new constrained variable.\n\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (s.getEntry(i) != ZERO) {\n                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                    if (s.getEntry(i) > ZERO) {\n                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    } else {\n                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    }\n                    if (temp < stplen) {\n                        stplen = temp;\n                        iact = i;\n                    }\n                }\n            }\n\n            // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.\n\n            sdec = ZERO;\n            if (stplen > ZERO) {\n                ++iterc;\n                temp = shs / stepsq;\n                if (iact == -1 && temp > ZERO) {\n                    crvmin = Math.min(crvmin,temp);\n                    if (crvmin == MINUS_ONE) {\n                        crvmin = temp;\n                    }\n                }\n                ggsav = gredsq;\n                gredsq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                    if (xbdi.getEntry(i) == ZERO) {\n                        // Computing 2nd power\n                        final double d1 = gnew.getEntry(i);\n                        gredsq += d1 * d1;\n                    }\n                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                }\n                // Computing MAX\n                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                sdec = Math.max(d1, ZERO);\n                qred += sdec;\n            }\n\n            // Restart the conjugate gradient method if it has hit a new bound.\n\n            if (iact >= 0) {\n                ++nact;\n                xbdi.setEntry(iact, ONE);\n                if (s.getEntry(iact) < ZERO) {\n                    xbdi.setEntry(iact, MINUS_ONE);\n                }\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(iact);\n                delsq -= d1 * d1;\n                if (delsq <= ZERO) {\n                    state = 190; break;\n                }\n                state = 20; break;\n            }\n\n            // If STPLEN is less than BLEN, then either apply another conjugate\n            // gradient iteration or RETURN.\n\n            if (stplen < blen) {\n                if (iterc == itermax) {\n                    state = 190; break;\n                }\n                if (sdec <= qred * .01) {\n                    state = 190; break;\n                }\n                beta = gredsq / ggsav;\n                state = 30; break;\n            }\n        }\n        case 90: {\n            printState(90); // XXX\n            crvmin = ZERO;\n\n            // Prepare for the alternative iteration by calculating some scalars\n            // and by multiplying the reduced D by the second derivative matrix of\n            // Q, where S holds the reduced D in the call of GGMULT.\n\n        }\n        case 100: {\n            printState(100); // XXX\n            if (nact >= n - 1) {\n                state = 190; break;\n            }\n            dredsq = ZERO;\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    dredsq += d1 * d1;\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                    s.setEntry(i, trialStepPoint.getEntry(i));\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            itcsav = iterc;\n            state = 210; break;\n            // Let the search direction S be a linear combination of the reduced D\n            // and the reduced G that is orthogonal to the reduced D.\n        }\n        case 120: {\n            printState(120); // XXX\n            ++iterc;\n            temp = gredsq * dredsq - dredg * dredg;\n            if (temp <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n            temp = Math.sqrt(temp);\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            sredg = -temp;\n\n            // By considering the simple bounds on the variables, calculate an upper\n            // bound on the tangent of half the angle of the alternative iteration,\n            // namely ANGBD, except that, if already a free variable has reached a\n            // bound, there is a branch back to label 100 after fixing that variable.\n\n            angbd = ONE;\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                    if (tempa <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, MINUS_ONE);\n                        state = 100; break;\n                    } else if (tempb <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, ONE);\n                        state = 100; break;\n                    }\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    // Computing 2nd power\n                    double d2 = s.getEntry(i);\n                    ssq = d1 * d1 + d2 * d2;\n                    // Computing 2nd power\n                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) - s.getEntry(i);\n                        if (angbd * temp > tempa) {\n                            angbd = tempa / temp;\n                            iact = i;\n                            xsav = MINUS_ONE;\n                        }\n                    }\n                    // Computing 2nd power\n                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) + s.getEntry(i);\n                        if (angbd * temp > tempb) {\n                            angbd = tempb / temp;\n                            iact = i;\n                            xsav = ONE;\n                        }\n                    }\n                }\n            }\n\n            // Calculate HHD and some curvatures for the alternative iteration.\n\n            state = 210; break;\n        }\n        case 150: {\n            printState(150); // XXX\n            shs = ZERO;\n            dhs = ZERO;\n            dhd = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                }\n            }\n\n            // Seek the greatest reduction in Q for a range of equally spaced values\n            // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of\n            // the alternative iteration.\n\n            redmax = ZERO;\n            isav = -1;\n            redsav = ZERO;\n            iu = (int) (angbd * 17. + 3.1);\n            for (int i = 0; i < iu; i++) {\n                angt = angbd * i / iu;\n                sth = (angt + angt) / (ONE + angt * angt);\n                temp = shs + angt * (angt * dhd - dhs - dhs);\n                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                if (rednew > redmax) {\n                    redmax = rednew;\n                    isav = i;\n                    rdprev = redsav;\n                } else if (i == isav + 1) {\n                    rdnext = rednew;\n                }\n                redsav = rednew;\n            }\n\n            // Return if the reduction is zero. Otherwise, set the sine and cosine\n            // of the angle of the alternative iteration, and calculate SDEC.\n\n            if (isav < 0) {\n                state = 190; break;\n            }\n            if (isav < iu) {\n                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n                angt = angbd * (isav + HALF * temp) / iu;\n            }\n            cth = (ONE - angt * angt) / (ONE + angt * angt);\n            sth = (angt + angt) / (ONE + angt * angt);\n            temp = shs + angt * (angt * dhd - dhs - dhs);\n            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n            if (sdec <= ZERO) {\n                state = 190; break;\n            }\n\n            // Update GNEW, D and HRED. If the angle of the alternative iteration\n            // is restricted by a bound on a free variable, that variable is fixed\n            // at the bound.\n\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                if (xbdi.getEntry(i) == ZERO) {\n                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    final double d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                }\n                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n            }\n            qred += sdec;\n            if (iact >= 0 && isav == iu) {\n                ++nact;\n                xbdi.setEntry(iact, xsav);\n                state = 100; break;\n            }\n\n            // If SDEC is sufficiently small, then RETURN after setting XNEW to\n            // XOPT+D, giving careful attention to the bounds.\n\n            if (sdec > qred * .01) {\n                state = 120; break;\n            }\n        }\n        case 190: {\n            printState(190); // XXX\n            dsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                // Computing MAX\n                // Computing MIN\n                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));\n                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                if (xbdi.getEntry(i) == MINUS_ONE) {\n                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                }\n                if (xbdi.getEntry(i) == ONE) {\n                    newPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(i);\n                dsq += d1 * d1;\n            }\n            return new double[] { dsq, crvmin };\n            // The following instructions multiply the current S-vector by the second\n            // derivative matrix of the quadratic model, putting the product in HS.\n            // They are reached from three different parts of the software above and\n            // they can be regarded as an external subroutine.\n        }\n        case 210: {\n            printState(210); // XXX\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                hs.setEntry(j, ZERO);\n                for (int i = 0; i <= j; i++) {\n                    if (i < j) {\n                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n                    }\n                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                    ih++;\n                }\n            }\n            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n            for (int k = 0; k < npt; k++) {\n                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n            if (crvmin != ZERO) {\n                state = 50; break;\n            }\n            if (iterc > itcsav) {\n                state = 150; break;\n            }\n            for (int i = 0; i < n; i++) {\n                hred.setEntry(i, hs.getEntry(i));\n            }\n            state = 120; break;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n        }}\n        })",
    "info" : "ForStatement[88963-104958]:ForStatement[88977-104972]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[88971-104958]:Block[88985-104972]"
  }, {
    "left" : "switch (state) {\n        case 20: {\n            printState(20); // XXX\n            beta = ZERO;\n        }\n        case 30: {\n            printState(30); // XXX\n            stepsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) != ZERO) {\n                    s.setEntry(i, ZERO);\n                } else if (beta == ZERO) {\n                    s.setEntry(i, -gnew.getEntry(i));\n                } else {\n                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                }\n                // Computing 2nd power\n                final double d1 = s.getEntry(i);\n                stepsq += d1 * d1;\n            }\n            if (stepsq == ZERO) {\n                state = 190; break;\n            }\n            if (beta == ZERO) {\n                gredsq = stepsq;\n                itermax = iterc + n - nact;\n            }\n            if (gredsq * delsq <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n\n            // Multiply the search direction by the second derivative matrix of Q and\n            // calculate some scalars for the choice of steplength. Then set BLEN to\n            // the length of the the step to the trust region boundary and STPLEN to\n            // the steplength, ignoring the simple bounds.\n\n            state = 210; break;\n        }\n        case 50: {\n            printState(50); // XXX\n            resid = delsq;\n            ds = ZERO;\n            shs = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    final double d1 = trialStepPoint.getEntry(i);\n                    resid -= d1 * d1;\n                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                }\n            }\n            if (resid <= ZERO) {\n                state = 90; break;\n            }\n            temp = Math.sqrt(stepsq * resid + ds * ds);\n            if (ds < ZERO) {\n                blen = (temp - ds) / stepsq;\n            } else {\n                blen = resid / (temp + ds);\n            }\n            stplen = blen;\n            if (shs > ZERO) {\n                // Computing MIN\n                stplen = Math.min(blen, gredsq / shs);\n            }\n\n            // Reduce STPLEN if necessary in order to preserve the simple bounds,\n            // letting IACT be the index of the new constrained variable.\n\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (s.getEntry(i) != ZERO) {\n                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                    if (s.getEntry(i) > ZERO) {\n                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    } else {\n                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    }\n                    if (temp < stplen) {\n                        stplen = temp;\n                        iact = i;\n                    }\n                }\n            }\n\n            // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.\n\n            sdec = ZERO;\n            if (stplen > ZERO) {\n                ++iterc;\n                temp = shs / stepsq;\n                if (iact == -1 && temp > ZERO) {\n                    crvmin = Math.min(crvmin,temp);\n                    if (crvmin == MINUS_ONE) {\n                        crvmin = temp;\n                    }\n                }\n                ggsav = gredsq;\n                gredsq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                    if (xbdi.getEntry(i) == ZERO) {\n                        // Computing 2nd power\n                        final double d1 = gnew.getEntry(i);\n                        gredsq += d1 * d1;\n                    }\n                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                }\n                // Computing MAX\n                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                sdec = Math.max(d1, ZERO);\n                qred += sdec;\n            }\n\n            // Restart the conjugate gradient method if it has hit a new bound.\n\n            if (iact >= 0) {\n                ++nact;\n                xbdi.setEntry(iact, ONE);\n                if (s.getEntry(iact) < ZERO) {\n                    xbdi.setEntry(iact, MINUS_ONE);\n                }\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(iact);\n                delsq -= d1 * d1;\n                if (delsq <= ZERO) {\n                    state = 190; break;\n                }\n                state = 20; break;\n            }\n\n            // If STPLEN is less than BLEN, then either apply another conjugate\n            // gradient iteration or RETURN.\n\n            if (stplen < blen) {\n                if (iterc == itermax) {\n                    state = 190; break;\n                }\n                if (sdec <= qred * .01) {\n                    state = 190; break;\n                }\n                beta = gredsq / ggsav;\n                state = 30; break;\n            }\n        }\n        case 90: {\n            printState(90); // XXX\n            crvmin = ZERO;\n\n            // Prepare for the alternative iteration by calculating some scalars\n            // and by multiplying the reduced D by the second derivative matrix of\n            // Q, where S holds the reduced D in the call of GGMULT.\n\n        }\n        case 100: {\n            printState(100); // XXX\n            if (nact >= n - 1) {\n                state = 190; break;\n            }\n            dredsq = ZERO;\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    dredsq += d1 * d1;\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                    s.setEntry(i, trialStepPoint.getEntry(i));\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            itcsav = iterc;\n            state = 210; break;\n            // Let the search direction S be a linear combination of the reduced D\n            // and the reduced G that is orthogonal to the reduced D.\n        }\n        case 120: {\n            printState(120); // XXX\n            ++iterc;\n            temp = gredsq * dredsq - dredg * dredg;\n            if (temp <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n            temp = Math.sqrt(temp);\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            sredg = -temp;\n\n            // By considering the simple bounds on the variables, calculate an upper\n            // bound on the tangent of half the angle of the alternative iteration,\n            // namely ANGBD, except that, if already a free variable has reached a\n            // bound, there is a branch back to label 100 after fixing that variable.\n\n            angbd = ONE;\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                    if (tempa <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, MINUS_ONE);\n                        state = 100; break;\n                    } else if (tempb <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, ONE);\n                        state = 100; break;\n                    }\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    // Computing 2nd power\n                    double d2 = s.getEntry(i);\n                    ssq = d1 * d1 + d2 * d2;\n                    // Computing 2nd power\n                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) - s.getEntry(i);\n                        if (angbd * temp > tempa) {\n                            angbd = tempa / temp;\n                            iact = i;\n                            xsav = MINUS_ONE;\n                        }\n                    }\n                    // Computing 2nd power\n                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) + s.getEntry(i);\n                        if (angbd * temp > tempb) {\n                            angbd = tempb / temp;\n                            iact = i;\n                            xsav = ONE;\n                        }\n                    }\n                }\n            }\n\n            // Calculate HHD and some curvatures for the alternative iteration.\n\n            state = 210; break;\n        }\n        case 150: {\n            printState(150); // XXX\n            shs = ZERO;\n            dhs = ZERO;\n            dhd = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                }\n            }\n\n            // Seek the greatest reduction in Q for a range of equally spaced values\n            // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of\n            // the alternative iteration.\n\n            redmax = ZERO;\n            isav = -1;\n            redsav = ZERO;\n            iu = (int) (angbd * 17. + 3.1);\n            for (int i = 0; i < iu; i++) {\n                angt = angbd * i / iu;\n                sth = (angt + angt) / (ONE + angt * angt);\n                temp = shs + angt * (angt * dhd - dhs - dhs);\n                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                if (rednew > redmax) {\n                    redmax = rednew;\n                    isav = i;\n                    rdprev = redsav;\n                } else if (i == isav + 1) {\n                    rdnext = rednew;\n                }\n                redsav = rednew;\n            }\n\n            // Return if the reduction is zero. Otherwise, set the sine and cosine\n            // of the angle of the alternative iteration, and calculate SDEC.\n\n            if (isav < 0) {\n                state = 190; break;\n            }\n            if (isav < iu) {\n                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n                angt = angbd * (isav + HALF * temp) / iu;\n            }\n            cth = (ONE - angt * angt) / (ONE + angt * angt);\n            sth = (angt + angt) / (ONE + angt * angt);\n            temp = shs + angt * (angt * dhd - dhs - dhs);\n            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n            if (sdec <= ZERO) {\n                state = 190; break;\n            }\n\n            // Update GNEW, D and HRED. If the angle of the alternative iteration\n            // is restricted by a bound on a free variable, that variable is fixed\n            // at the bound.\n\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                if (xbdi.getEntry(i) == ZERO) {\n                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    final double d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                }\n                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n            }\n            qred += sdec;\n            if (iact >= 0 && isav == iu) {\n                ++nact;\n                xbdi.setEntry(iact, xsav);\n                state = 100; break;\n            }\n\n            // If SDEC is sufficiently small, then RETURN after setting XNEW to\n            // XOPT+D, giving careful attention to the bounds.\n\n            if (sdec > qred * .01) {\n                state = 120; break;\n            }\n        }\n        case 190: {\n            printState(190); // XXX\n            dsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                // Computing MAX\n                // Computing MIN\n                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));\n                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                if (xbdi.getEntry(i) == MINUS_ONE) {\n                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                }\n                if (xbdi.getEntry(i) == ONE) {\n                    newPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(i);\n                dsq += d1 * d1;\n            }\n            return new double[] { dsq, crvmin };\n            // The following instructions multiply the current S-vector by the second\n            // derivative matrix of the quadratic model, putting the product in HS.\n            // They are reached from three different parts of the software above and\n            // they can be regarded as an external subroutine.\n        }\n        case 210: {\n            printState(210); // XXX\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                hs.setEntry(j, ZERO);\n                for (int i = 0; i <= j; i++) {\n                    if (i < j) {\n                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n                    }\n                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                    ih++;\n                }\n            }\n            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n            for (int k = 0; k < npt; k++) {\n                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n            if (crvmin != ZERO) {\n                state = 50; break;\n            }\n            if (iterc > itcsav) {\n                state = 150; break;\n            }\n            for (int i = 0; i < n; i++) {\n                hred.setEntry(i, hs.getEntry(i));\n            }\n            state = 120; break;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n        }}",
    "right" : "switch (state) {\n        case 20: {\n            printState(20); // XXX\n            beta = ZERO;\n        }\n        case 30: {\n            printState(30); // XXX\n            stepsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) != ZERO) {\n                    s.setEntry(i, ZERO);\n                } else if (beta == ZERO) {\n                    s.setEntry(i, -gnew.getEntry(i));\n                } else {\n                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                }\n                // Computing 2nd power\n                final double d1 = s.getEntry(i);\n                stepsq += d1 * d1;\n            }\n            if (stepsq == ZERO) {\n                state = 190; break;\n            }\n            if (beta == ZERO) {\n                gredsq = stepsq;\n                itermax = iterc + n - nact;\n            }\n            if (gredsq * delsq <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n\n            // Multiply the search direction by the second derivative matrix of Q and\n            // calculate some scalars for the choice of steplength. Then set BLEN to\n            // the length of the the step to the trust region boundary and STPLEN to\n            // the steplength, ignoring the simple bounds.\n\n            state = 210; break;\n        }\n        case 50: {\n            printState(50); // XXX\n            resid = delsq;\n            ds = ZERO;\n            shs = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    final double d1 = trialStepPoint.getEntry(i);\n                    resid -= d1 * d1;\n                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                }\n            }\n            if (resid <= ZERO) {\n                state = 90; break;\n            }\n            temp = Math.sqrt(stepsq * resid + ds * ds);\n            if (ds < ZERO) {\n                blen = (temp - ds) / stepsq;\n            } else {\n                blen = resid / (temp + ds);\n            }\n            stplen = blen;\n            if (shs > ZERO) {\n                // Computing MIN\n                stplen = Math.min(blen, gredsq / shs);\n            }\n\n            // Reduce STPLEN if necessary in order to preserve the simple bounds,\n            // letting IACT be the index of the new constrained variable.\n\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (s.getEntry(i) != ZERO) {\n                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                    if (s.getEntry(i) > ZERO) {\n                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    } else {\n                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    }\n                    if (temp < stplen) {\n                        stplen = temp;\n                        iact = i;\n                    }\n                }\n            }\n\n            // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.\n\n            sdec = ZERO;\n            if (stplen > ZERO) {\n                ++iterc;\n                temp = shs / stepsq;\n                if (iact == -1 && temp > ZERO) {\n                    crvmin = Math.min(crvmin,temp);\n                    if (crvmin == MINUS_ONE) {\n                        crvmin = temp;\n                    }\n                }\n                ggsav = gredsq;\n                gredsq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                    if (xbdi.getEntry(i) == ZERO) {\n                        // Computing 2nd power\n                        final double d1 = gnew.getEntry(i);\n                        gredsq += d1 * d1;\n                    }\n                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                }\n                // Computing MAX\n                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                sdec = Math.max(d1, ZERO);\n                qred += sdec;\n            }\n\n            // Restart the conjugate gradient method if it has hit a new bound.\n\n            if (iact >= 0) {\n                ++nact;\n                xbdi.setEntry(iact, ONE);\n                if (s.getEntry(iact) < ZERO) {\n                    xbdi.setEntry(iact, MINUS_ONE);\n                }\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(iact);\n                delsq -= d1 * d1;\n                if (delsq <= ZERO) {\n                    state = 190; break;\n                }\n                state = 20; break;\n            }\n\n            // If STPLEN is less than BLEN, then either apply another conjugate\n            // gradient iteration or RETURN.\n\n            if (stplen < blen) {\n                if (iterc == itermax) {\n                    state = 190; break;\n                }\n                if (sdec <= qred * .01) {\n                    state = 190; break;\n                }\n                beta = gredsq / ggsav;\n                state = 30; break;\n            }\n        }\n        case 90: {\n            printState(90); // XXX\n            crvmin = ZERO;\n\n            // Prepare for the alternative iteration by calculating some scalars\n            // and by multiplying the reduced D by the second derivative matrix of\n            // Q, where S holds the reduced D in the call of GGMULT.\n\n        }\n        case 100: {\n            printState(100); // XXX\n            if (nact >= n - 1) {\n                state = 190; break;\n            }\n            dredsq = ZERO;\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    dredsq += d1 * d1;\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                    s.setEntry(i, trialStepPoint.getEntry(i));\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            itcsav = iterc;\n            state = 210; break;\n            // Let the search direction S be a linear combination of the reduced D\n            // and the reduced G that is orthogonal to the reduced D.\n        }\n        case 120: {\n            printState(120); // XXX\n            ++iterc;\n            temp = gredsq * dredsq - dredg * dredg;\n            if (temp <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n            temp = Math.sqrt(temp);\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            sredg = -temp;\n\n            // By considering the simple bounds on the variables, calculate an upper\n            // bound on the tangent of half the angle of the alternative iteration,\n            // namely ANGBD, except that, if already a free variable has reached a\n            // bound, there is a branch back to label 100 after fixing that variable.\n\n            angbd = ONE;\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                    if (tempa <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, MINUS_ONE);\n                        state = 100; break;\n                    } else if (tempb <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, ONE);\n                        state = 100; break;\n                    }\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    // Computing 2nd power\n                    double d2 = s.getEntry(i);\n                    ssq = d1 * d1 + d2 * d2;\n                    // Computing 2nd power\n                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) - s.getEntry(i);\n                        if (angbd * temp > tempa) {\n                            angbd = tempa / temp;\n                            iact = i;\n                            xsav = MINUS_ONE;\n                        }\n                    }\n                    // Computing 2nd power\n                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) + s.getEntry(i);\n                        if (angbd * temp > tempb) {\n                            angbd = tempb / temp;\n                            iact = i;\n                            xsav = ONE;\n                        }\n                    }\n                }\n            }\n\n            // Calculate HHD and some curvatures for the alternative iteration.\n\n            state = 210; break;\n        }\n        case 150: {\n            printState(150); // XXX\n            shs = ZERO;\n            dhs = ZERO;\n            dhd = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                }\n            }\n\n            // Seek the greatest reduction in Q for a range of equally spaced values\n            // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of\n            // the alternative iteration.\n\n            redmax = ZERO;\n            isav = -1;\n            redsav = ZERO;\n            iu = (int) (angbd * 17. + 3.1);\n            for (int i = 0; i < iu; i++) {\n                angt = angbd * i / iu;\n                sth = (angt + angt) / (ONE + angt * angt);\n                temp = shs + angt * (angt * dhd - dhs - dhs);\n                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                if (rednew > redmax) {\n                    redmax = rednew;\n                    isav = i;\n                    rdprev = redsav;\n                } else if (i == isav + 1) {\n                    rdnext = rednew;\n                }\n                redsav = rednew;\n            }\n\n            // Return if the reduction is zero. Otherwise, set the sine and cosine\n            // of the angle of the alternative iteration, and calculate SDEC.\n\n            if (isav < 0) {\n                state = 190; break;\n            }\n            if (isav < iu) {\n                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n                angt = angbd * (isav + HALF * temp) / iu;\n            }\n            cth = (ONE - angt * angt) / (ONE + angt * angt);\n            sth = (angt + angt) / (ONE + angt * angt);\n            temp = shs + angt * (angt * dhd - dhs - dhs);\n            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n            if (sdec <= ZERO) {\n                state = 190; break;\n            }\n\n            // Update GNEW, D and HRED. If the angle of the alternative iteration\n            // is restricted by a bound on a free variable, that variable is fixed\n            // at the bound.\n\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                if (xbdi.getEntry(i) == ZERO) {\n                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    final double d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                }\n                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n            }\n            qred += sdec;\n            if (iact >= 0 && isav == iu) {\n                ++nact;\n                xbdi.setEntry(iact, xsav);\n                state = 100; break;\n            }\n\n            // If SDEC is sufficiently small, then RETURN after setting XNEW to\n            // XOPT+D, giving careful attention to the bounds.\n\n            if (sdec > qred * .01) {\n                state = 120; break;\n            }\n        }\n        case 190: {\n            printState(190); // XXX\n            dsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                // Computing MAX\n                // Computing MIN\n                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));\n                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                if (xbdi.getEntry(i) == MINUS_ONE) {\n                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                }\n                if (xbdi.getEntry(i) == ONE) {\n                    newPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(i);\n                dsq += d1 * d1;\n            }\n            return new double[] { dsq, crvmin };\n            // The following instructions multiply the current S-vector by the second\n            // derivative matrix of the quadratic model, putting the product in HS.\n            // They are reached from three different parts of the software above and\n            // they can be regarded as an external subroutine.\n        }\n        case 210: {\n            printState(210); // XXX\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                hs.setEntry(j, ZERO);\n                for (int i = 0; i <= j; i++) {\n                    if (i < j) {\n                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n                    }\n                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                    ih++;\n                }\n            }\n            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n            for (int k = 0; k < npt; k++) {\n                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n            if (crvmin != ZERO) {\n                state = 50; break;\n            }\n            if (iterc > itcsav) {\n                state = 150; break;\n            }\n            for (int i = 0; i < n; i++) {\n                hred.setEntry(i, hs.getEntry(i));\n            }\n            state = 120; break;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n        }}",
    "info" : "SwitchStatement[88985-104948]:SwitchStatement[88999-104962]"
  }, {
    "left" : "case 20:",
    "right" : "case 20:",
    "info" : "SwitchCase[89010-89018]:SwitchCase[89024-89032]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89019-89090]:Block[89033-89104]"
  }, {
    "left" : "printState(20);",
    "right" : "printState(20);",
    "info" : "ExpressionStatement[89033-89048]:ExpressionStatement[89047-89062]"
  }, {
    "left" : "beta = ZERO;",
    "right" : "beta = ZERO;",
    "info" : "ExpressionStatement[89068-89080]:ExpressionStatement[89082-89094]"
  }, {
    "left" : "case 30:",
    "right" : "case 30:",
    "info" : "SwitchCase[89099-89107]:SwitchCase[89113-89121]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89108-90327]:Block[89122-90341]"
  }, {
    "left" : "printState(30);",
    "right" : "printState(30);",
    "info" : "ExpressionStatement[89122-89137]:ExpressionStatement[89136-89151]"
  }, {
    "left" : "stepsq = ZERO;",
    "right" : "stepsq = ZERO;",
    "info" : "ExpressionStatement[89157-89171]:ExpressionStatement[89171-89185]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[89184-89655]:ForStatement[89198-89669]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89212-89655]:Block[89226-89669]"
  }, {
    "left" : "if (xbdi.getEntry(i) != ZERO)",
    "right" : "if (xbdi.getEntry(i) != ZERO)",
    "info" : "IfStatement[89230-89518]:IfStatement[89244-89532]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89260-89320]:Block[89274-89334]"
  }, {
    "left" : "s.setEntry(i, ZERO);",
    "right" : "s.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[89282-89302]:ExpressionStatement[89296-89316]"
  }, {
    "left" : "if (beta == ZERO)",
    "right" : "if (beta == ZERO)",
    "info" : "IfStatement[89326-89518]:IfStatement[89340-89532]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89344-89417]:Block[89358-89431]"
  }, {
    "left" : "s.setEntry(i, -gnew.getEntry(i));",
    "right" : "s.setEntry(i, -gnew.getEntry(i));",
    "info" : "ExpressionStatement[89366-89399]:ExpressionStatement[89380-89413]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89423-89518]:Block[89437-89532]"
  }, {
    "left" : "s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));",
    "right" : "s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));",
    "info" : "ExpressionStatement[89445-89500]:ExpressionStatement[89459-89514]"
  }, {
    "left" : "final double d1 = s.getEntry(i);",
    "right" : "final double d1 = s.getEntry(i);",
    "info" : "VariableDeclarationStatement[89574-89606]:VariableDeclarationStatement[89588-89620]"
  }, {
    "left" : "stepsq += d1 * d1;",
    "right" : "stepsq += d1 * d1;",
    "info" : "ExpressionStatement[89623-89641]:ExpressionStatement[89637-89655]"
  }, {
    "left" : "if (stepsq == ZERO)",
    "right" : "if (stepsq == ZERO)",
    "info" : "IfStatement[89668-89739]:IfStatement[89682-89753]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89688-89739]:Block[89702-89753]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[89706-89718]:ExpressionStatement[89720-89732]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[89719-89725]:BreakStatement[89733-89739]"
  }, {
    "left" : "if (beta == ZERO)",
    "right" : "if (beta == ZERO)",
    "info" : "IfStatement[89752-89862]:IfStatement[89766-89876]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89770-89862]:Block[89784-89876]"
  }, {
    "left" : "gredsq = stepsq;",
    "right" : "gredsq = stepsq;",
    "info" : "ExpressionStatement[89788-89804]:ExpressionStatement[89802-89818]"
  }, {
    "left" : "itermax = iterc + n - nact;",
    "right" : "itermax = iterc + n - nact;",
    "info" : "ExpressionStatement[89821-89848]:ExpressionStatement[89835-89862]"
  }, {
    "left" : "if (gredsq * delsq <= qred * 1e-4 * qred)",
    "right" : "if (gredsq * delsq <= qred * 1e-4 * qred)",
    "info" : "IfStatement[89875-89968]:IfStatement[89889-89982]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[89917-89968]:Block[89931-89982]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[89935-89947]:ExpressionStatement[89949-89961]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[89948-89954]:BreakStatement[89962-89968]"
  }, {
    "left" : "state = 210;",
    "right" : "state = 210;",
    "info" : "ExpressionStatement[90298-90310]:ExpressionStatement[90312-90324]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[90311-90317]:BreakStatement[90325-90331]"
  }, {
    "left" : "case 50:",
    "right" : "case 50:",
    "info" : "SwitchCase[90336-90344]:SwitchCase[90350-90358]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[90345-94295]:Block[90359-94309]"
  }, {
    "left" : "printState(50);",
    "right" : "printState(50);",
    "info" : "ExpressionStatement[90359-90374]:ExpressionStatement[90373-90388]"
  }, {
    "left" : "resid = delsq;",
    "right" : "resid = delsq;",
    "info" : "ExpressionStatement[90394-90408]:ExpressionStatement[90408-90422]"
  }, {
    "left" : "ds = ZERO;",
    "right" : "ds = ZERO;",
    "info" : "ExpressionStatement[90421-90431]:ExpressionStatement[90435-90445]"
  }, {
    "left" : "shs = ZERO;",
    "right" : "shs = ZERO;",
    "info" : "ExpressionStatement[90444-90455]:ExpressionStatement[90458-90469]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[90468-90853]:ForStatement[90482-90867]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[90496-90853]:Block[90510-90867]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ZERO)",
    "right" : "if (xbdi.getEntry(i) == ZERO)",
    "info" : "IfStatement[90514-90839]:IfStatement[90528-90853]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[90544-90839]:Block[90558-90853]"
  }, {
    "left" : "final double d1 = trialStepPoint.getEntry(i);",
    "right" : "final double d1 = trialStepPoint.getEntry(i);",
    "info" : "VariableDeclarationStatement[90609-90654]:VariableDeclarationStatement[90623-90668]"
  }, {
    "left" : "resid -= d1 * d1;",
    "right" : "resid -= d1 * d1;",
    "info" : "ExpressionStatement[90675-90692]:ExpressionStatement[90689-90706]"
  }, {
    "left" : "ds += s.getEntry(i) * trialStepPoint.getEntry(i);",
    "right" : "ds += s.getEntry(i) * trialStepPoint.getEntry(i);",
    "info" : "ExpressionStatement[90713-90762]:ExpressionStatement[90727-90776]"
  }, {
    "left" : "shs += s.getEntry(i) * hs.getEntry(i);",
    "right" : "shs += s.getEntry(i) * hs.getEntry(i);",
    "info" : "ExpressionStatement[90783-90821]:ExpressionStatement[90797-90835]"
  }, {
    "left" : "if (resid <= ZERO)",
    "right" : "if (resid <= ZERO)",
    "info" : "IfStatement[90866-90935]:IfStatement[90880-90949]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[90885-90935]:Block[90899-90949]"
  }, {
    "left" : "state = 90;",
    "right" : "state = 90;",
    "info" : "ExpressionStatement[90903-90914]:ExpressionStatement[90917-90928]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[90915-90921]:BreakStatement[90929-90935]"
  }, {
    "left" : "temp = Math.sqrt(stepsq * resid + ds * ds);",
    "right" : "temp = Math.sqrt(stepsq * resid + ds * ds);",
    "info" : "ExpressionStatement[90948-90991]:ExpressionStatement[90962-91005]"
  }, {
    "left" : "if (ds < ZERO)",
    "right" : "if (ds < ZERO)",
    "info" : "IfStatement[91004-91144]:IfStatement[91018-91158]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91019-91079]:Block[91033-91093]"
  }, {
    "left" : "blen = (temp - ds) / stepsq;",
    "right" : "blen = (temp - ds) / stepsq;",
    "info" : "ExpressionStatement[91037-91065]:ExpressionStatement[91051-91079]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91085-91144]:Block[91099-91158]"
  }, {
    "left" : "blen = resid / (temp + ds);",
    "right" : "blen = resid / (temp + ds);",
    "info" : "ExpressionStatement[91103-91130]:ExpressionStatement[91117-91144]"
  }, {
    "left" : "stplen = blen;",
    "right" : "stplen = blen;",
    "info" : "ExpressionStatement[91157-91171]:ExpressionStatement[91171-91185]"
  }, {
    "left" : "if (shs > ZERO)",
    "right" : "if (shs > ZERO)",
    "info" : "IfStatement[91184-91303]:IfStatement[91198-91317]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91200-91303]:Block[91214-91317]"
  }, {
    "left" : "stplen = Math.min(blen, gredsq / shs);",
    "right" : "stplen = Math.min(blen, gredsq / shs);",
    "info" : "ExpressionStatement[91251-91289]:ExpressionStatement[91265-91303]"
  }, {
    "left" : "iact = -1;",
    "right" : "iact = -1;",
    "info" : "ExpressionStatement[91474-91484]:ExpressionStatement[91488-91498]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[91497-92101]:ForStatement[91511-92115]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91525-92101]:Block[91539-92115]"
  }, {
    "left" : "if (s.getEntry(i) != ZERO)",
    "right" : "if (s.getEntry(i) != ZERO)",
    "info" : "IfStatement[91543-92087]:IfStatement[91557-92101]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91570-92087]:Block[91584-92101]"
  }, {
    "left" : "xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);",
    "right" : "xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);",
    "info" : "ExpressionStatement[91592-91664]:ExpressionStatement[91606-91678]"
  }, {
    "left" : "if (s.getEntry(i) > ZERO)",
    "right" : "if (s.getEntry(i) > ZERO)",
    "info" : "IfStatement[91685-91933]:IfStatement[91699-91947]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91711-91819]:Block[91725-91833]"
  }, {
    "left" : "temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);",
    "right" : "temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);",
    "info" : "ExpressionStatement[91737-91797]:ExpressionStatement[91751-91811]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91825-91933]:Block[91839-91947]"
  }, {
    "left" : "temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);",
    "right" : "temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);",
    "info" : "ExpressionStatement[91851-91911]:ExpressionStatement[91865-91925]"
  }, {
    "left" : "if (temp < stplen)",
    "right" : "if (temp < stplen)",
    "info" : "IfStatement[91954-92069]:IfStatement[91968-92083]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[91973-92069]:Block[91987-92083]"
  }, {
    "left" : "stplen = temp;",
    "right" : "stplen = temp;",
    "info" : "ExpressionStatement[91999-92013]:ExpressionStatement[92013-92027]"
  }, {
    "left" : "iact = i;",
    "right" : "iact = i;",
    "info" : "ExpressionStatement[92038-92047]:ExpressionStatement[92052-92061]"
  }, {
    "left" : "sdec = ZERO;",
    "right" : "sdec = ZERO;",
    "info" : "ExpressionStatement[92201-92213]:ExpressionStatement[92215-92227]"
  }, {
    "left" : "if (stplen > ZERO)",
    "right" : "if (stplen > ZERO)",
    "info" : "IfStatement[92226-93263]:IfStatement[92240-93277]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[92245-93263]:Block[92259-93277]"
  }, {
    "left" : "++iterc;",
    "right" : "++iterc;",
    "info" : "ExpressionStatement[92263-92271]:ExpressionStatement[92277-92285]"
  }, {
    "left" : "temp = shs / stepsq;",
    "right" : "temp = shs / stepsq;",
    "info" : "ExpressionStatement[92288-92308]:ExpressionStatement[92302-92322]"
  }, {
    "left" : "if (iact == -1 && temp > ZERO)",
    "right" : "if (iact == -1 && temp > ZERO)",
    "info" : "IfStatement[92325-92535]:IfStatement[92339-92549]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[92356-92535]:Block[92370-92549]"
  }, {
    "left" : "crvmin = Math.min(crvmin,temp);",
    "right" : "crvmin = Math.min(crvmin,temp);",
    "info" : "ExpressionStatement[92378-92409]:ExpressionStatement[92392-92423]"
  }, {
    "left" : "if (crvmin == MINUS_ONE)",
    "right" : "if (crvmin == MINUS_ONE)",
    "info" : "IfStatement[92430-92517]:IfStatement[92444-92531]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[92455-92517]:Block[92469-92531]"
  }, {
    "left" : "crvmin = temp;",
    "right" : "crvmin = temp;",
    "info" : "ExpressionStatement[92481-92495]:ExpressionStatement[92495-92509]"
  }, {
    "left" : "ggsav = gredsq;",
    "right" : "ggsav = gredsq;",
    "info" : "ExpressionStatement[92552-92567]:ExpressionStatement[92566-92581]"
  }, {
    "left" : "gredsq = ZERO;",
    "right" : "gredsq = ZERO;",
    "info" : "ExpressionStatement[92584-92598]:ExpressionStatement[92598-92612]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[92615-93069]:ForStatement[92629-93083]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[92643-93069]:Block[92657-93083]"
  }, {
    "left" : "gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));",
    "right" : "gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));",
    "info" : "ExpressionStatement[92665-92726]:ExpressionStatement[92679-92740]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ZERO)",
    "right" : "if (xbdi.getEntry(i) == ZERO)",
    "info" : "IfStatement[92747-92950]:IfStatement[92761-92964]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[92777-92950]:Block[92791-92964]"
  }, {
    "left" : "final double d1 = gnew.getEntry(i);",
    "right" : "final double d1 = gnew.getEntry(i);",
    "info" : "VariableDeclarationStatement[92850-92885]:VariableDeclarationStatement[92864-92899]"
  }, {
    "left" : "gredsq += d1 * d1;",
    "right" : "gredsq += d1 * d1;",
    "info" : "ExpressionStatement[92910-92928]:ExpressionStatement[92924-92942]"
  }, {
    "left" : "trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));",
    "right" : "trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));",
    "info" : "ExpressionStatement[92971-93051]:ExpressionStatement[92985-93065]"
  }, {
    "left" : "final double d1 = stplen * (ggsav - HALF * stplen * shs);",
    "right" : "final double d1 = stplen * (ggsav - HALF * stplen * shs);",
    "info" : "VariableDeclarationStatement[93119-93176]:VariableDeclarationStatement[93133-93190]"
  }, {
    "left" : "sdec = Math.max(d1, ZERO);",
    "right" : "sdec = Math.max(d1, ZERO);",
    "info" : "ExpressionStatement[93193-93219]:ExpressionStatement[93207-93233]"
  }, {
    "left" : "qred += sdec;",
    "right" : "qred += sdec;",
    "info" : "ExpressionStatement[93236-93249]:ExpressionStatement[93250-93263]"
  }, {
    "left" : "if (iact >= 0)",
    "right" : "if (iact >= 0)",
    "info" : "IfStatement[93358-93839]:IfStatement[93372-93853]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[93373-93839]:Block[93387-93853]"
  }, {
    "left" : "++nact;",
    "right" : "++nact;",
    "info" : "ExpressionStatement[93391-93398]:ExpressionStatement[93405-93412]"
  }, {
    "left" : "xbdi.setEntry(iact, ONE);",
    "right" : "xbdi.setEntry(iact, ONE);",
    "info" : "ExpressionStatement[93415-93440]:ExpressionStatement[93429-93454]"
  }, {
    "left" : "if (s.getEntry(iact) < ZERO)",
    "right" : "if (s.getEntry(iact) < ZERO)",
    "info" : "IfStatement[93457-93557]:IfStatement[93471-93571]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[93486-93557]:Block[93500-93571]"
  }, {
    "left" : "xbdi.setEntry(iact, MINUS_ONE);",
    "right" : "xbdi.setEntry(iact, MINUS_ONE);",
    "info" : "ExpressionStatement[93508-93539]:ExpressionStatement[93522-93553]"
  }, {
    "left" : "final double d1 = trialStepPoint.getEntry(iact);",
    "right" : "final double d1 = trialStepPoint.getEntry(iact);",
    "info" : "VariableDeclarationStatement[93613-93661]:VariableDeclarationStatement[93627-93675]"
  }, {
    "left" : "delsq -= d1 * d1;",
    "right" : "delsq -= d1 * d1;",
    "info" : "ExpressionStatement[93678-93695]:ExpressionStatement[93692-93709]"
  }, {
    "left" : "if (delsq <= ZERO)",
    "right" : "if (delsq <= ZERO)",
    "info" : "IfStatement[93712-93790]:IfStatement[93726-93804]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[93731-93790]:Block[93745-93804]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[93753-93765]:ExpressionStatement[93767-93779]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[93766-93772]:BreakStatement[93780-93786]"
  }, {
    "left" : "state = 20;",
    "right" : "state = 20;",
    "info" : "ExpressionStatement[93807-93818]:ExpressionStatement[93821-93832]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[93819-93825]:BreakStatement[93833-93839]"
  }, {
    "left" : "if (stplen < blen)",
    "right" : "if (stplen < blen)",
    "info" : "IfStatement[93979-94285]:IfStatement[93993-94299]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[93998-94285]:Block[94012-94299]"
  }, {
    "left" : "if (iterc == itermax)",
    "right" : "if (iterc == itermax)",
    "info" : "IfStatement[94016-94097]:IfStatement[94030-94111]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[94038-94097]:Block[94052-94111]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[94060-94072]:ExpressionStatement[94074-94086]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[94073-94079]:BreakStatement[94087-94093]"
  }, {
    "left" : "if (sdec <= qred * .01)",
    "right" : "if (sdec <= qred * .01)",
    "info" : "IfStatement[94114-94197]:IfStatement[94128-94211]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[94138-94197]:Block[94152-94211]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[94160-94172]:ExpressionStatement[94174-94186]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[94173-94179]:BreakStatement[94187-94193]"
  }, {
    "left" : "beta = gredsq / ggsav;",
    "right" : "beta = gredsq / ggsav;",
    "info" : "ExpressionStatement[94214-94236]:ExpressionStatement[94228-94250]"
  }, {
    "left" : "state = 30;",
    "right" : "state = 30;",
    "info" : "ExpressionStatement[94253-94264]:ExpressionStatement[94267-94278]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[94265-94271]:BreakStatement[94279-94285]"
  }, {
    "left" : "case 90:",
    "right" : "case 90:",
    "info" : "SwitchCase[94304-94312]:SwitchCase[94318-94326]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[94313-94621]:Block[94327-94635]"
  }, {
    "left" : "printState(90);",
    "right" : "printState(90);",
    "info" : "ExpressionStatement[94327-94342]:ExpressionStatement[94341-94356]"
  }, {
    "left" : "crvmin = ZERO;",
    "right" : "crvmin = ZERO;",
    "info" : "ExpressionStatement[94362-94376]:ExpressionStatement[94376-94390]"
  }, {
    "left" : "case 100:",
    "right" : "case 100:",
    "info" : "SwitchCase[94630-94639]:SwitchCase[94644-94653]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[94640-95657]:Block[94654-95671]"
  }, {
    "left" : "printState(100);",
    "right" : "printState(100);",
    "info" : "ExpressionStatement[94654-94670]:ExpressionStatement[94668-94684]"
  }, {
    "left" : "if (nact >= n - 1)",
    "right" : "if (nact >= n - 1)",
    "info" : "IfStatement[94690-94760]:IfStatement[94704-94774]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[94709-94760]:Block[94723-94774]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[94727-94739]:ExpressionStatement[94741-94753]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[94740-94746]:BreakStatement[94754-94760]"
  }, {
    "left" : "dredsq = ZERO;",
    "right" : "dredsq = ZERO;",
    "info" : "ExpressionStatement[94773-94787]:ExpressionStatement[94787-94801]"
  }, {
    "left" : "dredg = ZERO;",
    "right" : "dredg = ZERO;",
    "info" : "ExpressionStatement[94800-94813]:ExpressionStatement[94814-94827]"
  }, {
    "left" : "gredsq = ZERO;",
    "right" : "gredsq = ZERO;",
    "info" : "ExpressionStatement[94826-94840]:ExpressionStatement[94840-94854]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[94853-95434]:ForStatement[94867-95448]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[94881-95434]:Block[94895-95448]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ZERO)",
    "right" : "if (xbdi.getEntry(i) == ZERO)",
    "info" : "IfStatement[94899-95420]:IfStatement[94913-95434]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[94929-95354]:Block[94943-95368]"
  }, {
    "left" : "double d1 = trialStepPoint.getEntry(i);",
    "right" : "double d1 = trialStepPoint.getEntry(i);",
    "info" : "VariableDeclarationStatement[94994-95033]:VariableDeclarationStatement[95008-95047]"
  }, {
    "left" : "dredsq += d1 * d1;",
    "right" : "dredsq += d1 * d1;",
    "info" : "ExpressionStatement[95054-95072]:ExpressionStatement[95068-95086]"
  }, {
    "left" : "dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);",
    "right" : "dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);",
    "info" : "ExpressionStatement[95093-95148]:ExpressionStatement[95107-95162]"
  }, {
    "left" : "d1 = gnew.getEntry(i);",
    "right" : "d1 = gnew.getEntry(i);",
    "info" : "ExpressionStatement[95212-95234]:ExpressionStatement[95226-95248]"
  }, {
    "left" : "gredsq += d1 * d1;",
    "right" : "gredsq += d1 * d1;",
    "info" : "ExpressionStatement[95255-95273]:ExpressionStatement[95269-95287]"
  }, {
    "left" : "s.setEntry(i, trialStepPoint.getEntry(i));",
    "right" : "s.setEntry(i, trialStepPoint.getEntry(i));",
    "info" : "ExpressionStatement[95294-95336]:ExpressionStatement[95308-95350]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[95360-95420]:Block[95374-95434]"
  }, {
    "left" : "s.setEntry(i, ZERO);",
    "right" : "s.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[95382-95402]:ExpressionStatement[95396-95416]"
  }, {
    "left" : "itcsav = iterc;",
    "right" : "itcsav = iterc;",
    "info" : "ExpressionStatement[95447-95462]:ExpressionStatement[95461-95476]"
  }, {
    "left" : "state = 210;",
    "right" : "state = 210;",
    "info" : "ExpressionStatement[95475-95487]:ExpressionStatement[95489-95501]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[95488-95494]:BreakStatement[95502-95508]"
  }, {
    "left" : "case 120:",
    "right" : "case 120:",
    "info" : "SwitchCase[95666-95675]:SwitchCase[95680-95689]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[95676-98746]:Block[95690-98760]"
  }, {
    "left" : "printState(120);",
    "right" : "printState(120);",
    "info" : "ExpressionStatement[95690-95706]:ExpressionStatement[95704-95720]"
  }, {
    "left" : "++iterc;",
    "right" : "++iterc;",
    "info" : "ExpressionStatement[95726-95734]:ExpressionStatement[95740-95748]"
  }, {
    "left" : "temp = gredsq * dredsq - dredg * dredg;",
    "right" : "temp = gredsq * dredsq - dredg * dredg;",
    "info" : "ExpressionStatement[95747-95786]:ExpressionStatement[95761-95800]"
  }, {
    "left" : "if (temp <= qred * 1e-4 * qred)",
    "right" : "if (temp <= qred * 1e-4 * qred)",
    "info" : "IfStatement[95799-95882]:IfStatement[95813-95896]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[95831-95882]:Block[95845-95896]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[95849-95861]:ExpressionStatement[95863-95875]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[95862-95868]:BreakStatement[95876-95882]"
  }, {
    "left" : "temp = Math.sqrt(temp);",
    "right" : "temp = Math.sqrt(temp);",
    "info" : "ExpressionStatement[95895-95918]:ExpressionStatement[95909-95932]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[95931-96214]:ForStatement[95945-96228]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[95959-96214]:Block[95973-96228]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ZERO)",
    "right" : "if (xbdi.getEntry(i) == ZERO)",
    "info" : "IfStatement[95977-96200]:IfStatement[95991-96214]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[96007-96134]:Block[96021-96148]"
  }, {
    "left" : "s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);",
    "right" : "s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);",
    "info" : "ExpressionStatement[96029-96116]:ExpressionStatement[96043-96130]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[96140-96200]:Block[96154-96214]"
  }, {
    "left" : "s.setEntry(i, ZERO);",
    "right" : "s.setEntry(i, ZERO);",
    "info" : "ExpressionStatement[96162-96182]:ExpressionStatement[96176-96196]"
  }, {
    "left" : "sredg = -temp;",
    "right" : "sredg = -temp;",
    "info" : "ExpressionStatement[96227-96241]:ExpressionStatement[96241-96255]"
  }, {
    "left" : "angbd = ONE;",
    "right" : "angbd = ONE;",
    "info" : "ExpressionStatement[96594-96606]:ExpressionStatement[96608-96620]"
  }, {
    "left" : "iact = -1;",
    "right" : "iact = -1;",
    "info" : "ExpressionStatement[96619-96629]:ExpressionStatement[96633-96643]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[96642-98622]:ForStatement[96656-98636]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[96670-98622]:Block[96684-98636]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ZERO)",
    "right" : "if (xbdi.getEntry(i) == ZERO)",
    "info" : "IfStatement[96688-98608]:IfStatement[96702-98622]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[96718-98608]:Block[96732-98622]"
  }, {
    "left" : "tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);",
    "right" : "tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);",
    "info" : "ExpressionStatement[96740-96843]:ExpressionStatement[96754-96857]"
  }, {
    "left" : "tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);",
    "right" : "tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);",
    "info" : "ExpressionStatement[96864-96967]:ExpressionStatement[96878-96981]"
  }, {
    "left" : "if (tempa <= ZERO)",
    "right" : "if (tempa <= ZERO)",
    "info" : "IfStatement[96988-97330]:IfStatement[97002-97344]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[97007-97159]:Block[97021-97173]"
  }, {
    "left" : "++nact;",
    "right" : "++nact;",
    "info" : "ExpressionStatement[97033-97040]:ExpressionStatement[97047-97054]"
  }, {
    "left" : "xbdi.setEntry(i, MINUS_ONE);",
    "right" : "xbdi.setEntry(i, MINUS_ONE);",
    "info" : "ExpressionStatement[97065-97093]:ExpressionStatement[97079-97107]"
  }, {
    "left" : "state = 100;",
    "right" : "state = 100;",
    "info" : "ExpressionStatement[97118-97130]:ExpressionStatement[97132-97144]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[97131-97137]:BreakStatement[97145-97151]"
  }, {
    "left" : "if (tempb <= ZERO)",
    "right" : "if (tempb <= ZERO)",
    "info" : "IfStatement[97165-97330]:IfStatement[97179-97344]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[97184-97330]:Block[97198-97344]"
  }, {
    "left" : "++nact;",
    "right" : "++nact;",
    "info" : "ExpressionStatement[97210-97217]:ExpressionStatement[97224-97231]"
  }, {
    "left" : "xbdi.setEntry(i, ONE);",
    "right" : "xbdi.setEntry(i, ONE);",
    "info" : "ExpressionStatement[97242-97264]:ExpressionStatement[97256-97278]"
  }, {
    "left" : "state = 100;",
    "right" : "state = 100;",
    "info" : "ExpressionStatement[97289-97301]:ExpressionStatement[97303-97315]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[97302-97308]:BreakStatement[97316-97322]"
  }, {
    "left" : "double d1 = trialStepPoint.getEntry(i);",
    "right" : "double d1 = trialStepPoint.getEntry(i);",
    "info" : "VariableDeclarationStatement[97394-97433]:VariableDeclarationStatement[97408-97447]"
  }, {
    "left" : "double d2 = s.getEntry(i);",
    "right" : "double d2 = s.getEntry(i);",
    "info" : "VariableDeclarationStatement[97497-97523]:VariableDeclarationStatement[97511-97537]"
  }, {
    "left" : "ssq = d1 * d1 + d2 * d2;",
    "right" : "ssq = d1 * d1 + d2 * d2;",
    "info" : "ExpressionStatement[97544-97568]:ExpressionStatement[97558-97582]"
  }, {
    "left" : "d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);",
    "right" : "d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);",
    "info" : "ExpressionStatement[97632-97703]:ExpressionStatement[97646-97717]"
  }, {
    "left" : "temp = ssq - d1 * d1;",
    "right" : "temp = ssq - d1 * d1;",
    "info" : "ExpressionStatement[97724-97745]:ExpressionStatement[97738-97759]"
  }, {
    "left" : "if (temp > ZERO)",
    "right" : "if (temp > ZERO)",
    "info" : "IfStatement[97766-98082]:IfStatement[97780-98096]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[97783-98082]:Block[97797-98096]"
  }, {
    "left" : "temp = Math.sqrt(temp) - s.getEntry(i);",
    "right" : "temp = Math.sqrt(temp) - s.getEntry(i);",
    "info" : "ExpressionStatement[97809-97848]:ExpressionStatement[97823-97862]"
  }, {
    "left" : "if (angbd * temp > tempa)",
    "right" : "if (angbd * temp > tempa)",
    "info" : "IfStatement[97873-98060]:IfStatement[97887-98074]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[97899-98060]:Block[97913-98074]"
  }, {
    "left" : "angbd = tempa / temp;",
    "right" : "angbd = tempa / temp;",
    "info" : "ExpressionStatement[97929-97950]:ExpressionStatement[97943-97964]"
  }, {
    "left" : "iact = i;",
    "right" : "iact = i;",
    "info" : "ExpressionStatement[97979-97988]:ExpressionStatement[97993-98002]"
  }, {
    "left" : "xsav = MINUS_ONE;",
    "right" : "xsav = MINUS_ONE;",
    "info" : "ExpressionStatement[98017-98034]:ExpressionStatement[98031-98048]"
  }, {
    "left" : "d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);",
    "right" : "d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);",
    "info" : "ExpressionStatement[98146-98217]:ExpressionStatement[98160-98231]"
  }, {
    "left" : "temp = ssq - d1 * d1;",
    "right" : "temp = ssq - d1 * d1;",
    "info" : "ExpressionStatement[98238-98259]:ExpressionStatement[98252-98273]"
  }, {
    "left" : "if (temp > ZERO)",
    "right" : "if (temp > ZERO)",
    "info" : "IfStatement[98280-98590]:IfStatement[98294-98604]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[98297-98590]:Block[98311-98604]"
  }, {
    "left" : "temp = Math.sqrt(temp) + s.getEntry(i);",
    "right" : "temp = Math.sqrt(temp) + s.getEntry(i);",
    "info" : "ExpressionStatement[98323-98362]:ExpressionStatement[98337-98376]"
  }, {
    "left" : "if (angbd * temp > tempb)",
    "right" : "if (angbd * temp > tempb)",
    "info" : "IfStatement[98387-98568]:IfStatement[98401-98582]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[98413-98568]:Block[98427-98582]"
  }, {
    "left" : "angbd = tempb / temp;",
    "right" : "angbd = tempb / temp;",
    "info" : "ExpressionStatement[98443-98464]:ExpressionStatement[98457-98478]"
  }, {
    "left" : "iact = i;",
    "right" : "iact = i;",
    "info" : "ExpressionStatement[98493-98502]:ExpressionStatement[98507-98516]"
  }, {
    "left" : "xsav = ONE;",
    "right" : "xsav = ONE;",
    "info" : "ExpressionStatement[98531-98542]:ExpressionStatement[98545-98556]"
  }, {
    "left" : "state = 210;",
    "right" : "state = 210;",
    "info" : "ExpressionStatement[98717-98729]:ExpressionStatement[98731-98743]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[98730-98736]:BreakStatement[98744-98750]"
  }, {
    "left" : "case 150:",
    "right" : "case 150:",
    "info" : "SwitchCase[98755-98764]:SwitchCase[98769-98778]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[98765-102155]:Block[98779-102169]"
  }, {
    "left" : "printState(150);",
    "right" : "printState(150);",
    "info" : "ExpressionStatement[98779-98795]:ExpressionStatement[98793-98809]"
  }, {
    "left" : "shs = ZERO;",
    "right" : "shs = ZERO;",
    "info" : "ExpressionStatement[98815-98826]:ExpressionStatement[98829-98840]"
  }, {
    "left" : "dhs = ZERO;",
    "right" : "dhs = ZERO;",
    "info" : "ExpressionStatement[98839-98850]:ExpressionStatement[98853-98864]"
  }, {
    "left" : "dhd = ZERO;",
    "right" : "dhd = ZERO;",
    "info" : "ExpressionStatement[98863-98874]:ExpressionStatement[98877-98888]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[98887-99201]:ForStatement[98901-99215]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[98915-99201]:Block[98929-99215]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ZERO)",
    "right" : "if (xbdi.getEntry(i) == ZERO)",
    "info" : "IfStatement[98933-99187]:IfStatement[98947-99201]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[98963-99187]:Block[98977-99201]"
  }, {
    "left" : "shs += s.getEntry(i) * hs.getEntry(i);",
    "right" : "shs += s.getEntry(i) * hs.getEntry(i);",
    "info" : "ExpressionStatement[98985-99023]:ExpressionStatement[98999-99037]"
  }, {
    "left" : "dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);",
    "right" : "dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);",
    "info" : "ExpressionStatement[99044-99095]:ExpressionStatement[99058-99109]"
  }, {
    "left" : "dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);",
    "right" : "dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);",
    "info" : "ExpressionStatement[99116-99169]:ExpressionStatement[99130-99183]"
  }, {
    "left" : "redmax = ZERO;",
    "right" : "redmax = ZERO;",
    "info" : "ExpressionStatement[99427-99441]:ExpressionStatement[99441-99455]"
  }, {
    "left" : "isav = -1;",
    "right" : "isav = -1;",
    "info" : "ExpressionStatement[99454-99464]:ExpressionStatement[99468-99478]"
  }, {
    "left" : "redsav = ZERO;",
    "right" : "redsav = ZERO;",
    "info" : "ExpressionStatement[99477-99491]:ExpressionStatement[99491-99505]"
  }, {
    "left" : "iu = (int) (angbd * 17. + 3.1);",
    "right" : "iu = (int) (angbd * 17. + 3.1);",
    "info" : "ExpressionStatement[99504-99535]:ExpressionStatement[99518-99549]"
  }, {
    "left" : "for (int i = 0; i < iu; i++)",
    "right" : "for (int i = 0; i < iu; i++)",
    "info" : "ForStatement[99548-100102]:ForStatement[99562-100116]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[99577-100102]:Block[99591-100116]"
  }, {
    "left" : "angt = angbd * i / iu;",
    "right" : "angt = angbd * i / iu;",
    "info" : "ExpressionStatement[99595-99617]:ExpressionStatement[99609-99631]"
  }, {
    "left" : "sth = (angt + angt) / (ONE + angt * angt);",
    "right" : "sth = (angt + angt) / (ONE + angt * angt);",
    "info" : "ExpressionStatement[99634-99676]:ExpressionStatement[99648-99690]"
  }, {
    "left" : "temp = shs + angt * (angt * dhd - dhs - dhs);",
    "right" : "temp = shs + angt * (angt * dhd - dhs - dhs);",
    "info" : "ExpressionStatement[99693-99738]:ExpressionStatement[99707-99752]"
  }, {
    "left" : "rednew = sth * (angt * dredg - sredg - HALF * sth * temp);",
    "right" : "rednew = sth * (angt * dredg - sredg - HALF * sth * temp);",
    "info" : "ExpressionStatement[99755-99813]:ExpressionStatement[99769-99827]"
  }, {
    "left" : "if (rednew > redmax)",
    "right" : "if (rednew > redmax)",
    "info" : "IfStatement[99830-100055]:IfStatement[99844-100069]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[99851-99974]:Block[99865-99988]"
  }, {
    "left" : "redmax = rednew;",
    "right" : "redmax = rednew;",
    "info" : "ExpressionStatement[99873-99889]:ExpressionStatement[99887-99903]"
  }, {
    "left" : "isav = i;",
    "right" : "isav = i;",
    "info" : "ExpressionStatement[99910-99919]:ExpressionStatement[99924-99933]"
  }, {
    "left" : "rdprev = redsav;",
    "right" : "rdprev = redsav;",
    "info" : "ExpressionStatement[99940-99956]:ExpressionStatement[99954-99970]"
  }, {
    "left" : "if (i == isav + 1)",
    "right" : "if (i == isav + 1)",
    "info" : "IfStatement[99980-100055]:IfStatement[99994-100069]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[99999-100055]:Block[100013-100069]"
  }, {
    "left" : "rdnext = rednew;",
    "right" : "rdnext = rednew;",
    "info" : "ExpressionStatement[100021-100037]:ExpressionStatement[100035-100051]"
  }, {
    "left" : "redsav = rednew;",
    "right" : "redsav = rednew;",
    "info" : "ExpressionStatement[100072-100088]:ExpressionStatement[100086-100102]"
  }, {
    "left" : "if (isav < 0)",
    "right" : "if (isav < 0)",
    "info" : "IfStatement[100278-100343]:IfStatement[100292-100357]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[100292-100343]:Block[100306-100357]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[100310-100322]:ExpressionStatement[100324-100336]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[100323-100329]:BreakStatement[100337-100343]"
  }, {
    "left" : "if (isav < iu)",
    "right" : "if (isav < iu)",
    "info" : "IfStatement[100356-100524]:IfStatement[100370-100538]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[100371-100524]:Block[100385-100538]"
  }, {
    "left" : "temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);",
    "right" : "temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);",
    "info" : "ExpressionStatement[100389-100452]:ExpressionStatement[100403-100466]"
  }, {
    "left" : "angt = angbd * (isav + HALF * temp) / iu;",
    "right" : "angt = angbd * (isav + HALF * temp) / iu;",
    "info" : "ExpressionStatement[100469-100510]:ExpressionStatement[100483-100524]"
  }, {
    "left" : "cth = (ONE - angt * angt) / (ONE + angt * angt);",
    "right" : "cth = (ONE - angt * angt) / (ONE + angt * angt);",
    "info" : "ExpressionStatement[100537-100585]:ExpressionStatement[100551-100599]"
  }, {
    "left" : "sth = (angt + angt) / (ONE + angt * angt);",
    "right" : "sth = (angt + angt) / (ONE + angt * angt);",
    "info" : "ExpressionStatement[100598-100640]:ExpressionStatement[100612-100654]"
  }, {
    "left" : "temp = shs + angt * (angt * dhd - dhs - dhs);",
    "right" : "temp = shs + angt * (angt * dhd - dhs - dhs);",
    "info" : "ExpressionStatement[100653-100698]:ExpressionStatement[100667-100712]"
  }, {
    "left" : "sdec = sth * (angt * dredg - sredg - HALF * sth * temp);",
    "right" : "sdec = sth * (angt * dredg - sredg - HALF * sth * temp);",
    "info" : "ExpressionStatement[100711-100767]:ExpressionStatement[100725-100781]"
  }, {
    "left" : "if (sdec <= ZERO)",
    "right" : "if (sdec <= ZERO)",
    "info" : "IfStatement[100780-100849]:IfStatement[100794-100863]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[100798-100849]:Block[100812-100863]"
  }, {
    "left" : "state = 190;",
    "right" : "state = 190;",
    "info" : "ExpressionStatement[100816-100828]:ExpressionStatement[100830-100842]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[100829-100835]:BreakStatement[100843-100849]"
  }, {
    "left" : "dredg = ZERO;",
    "right" : "dredg = ZERO;",
    "info" : "ExpressionStatement[101058-101071]:ExpressionStatement[101072-101085]"
  }, {
    "left" : "gredsq = ZERO;",
    "right" : "gredsq = ZERO;",
    "info" : "ExpressionStatement[101084-101098]:ExpressionStatement[101098-101112]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[101111-101727]:ForStatement[101125-101741]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[101139-101727]:Block[101153-101741]"
  }, {
    "left" : "gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));",
    "right" : "gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));",
    "info" : "ExpressionStatement[101157-101248]:ExpressionStatement[101171-101262]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ZERO)",
    "right" : "if (xbdi.getEntry(i) == ZERO)",
    "info" : "IfStatement[101265-101632]:IfStatement[101279-101646]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[101295-101632]:Block[101309-101646]"
  }, {
    "left" : "trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));",
    "right" : "trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));",
    "info" : "ExpressionStatement[101317-101400]:ExpressionStatement[101331-101414]"
  }, {
    "left" : "dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);",
    "right" : "dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);",
    "info" : "ExpressionStatement[101421-101476]:ExpressionStatement[101435-101490]"
  }, {
    "left" : "final double d1 = gnew.getEntry(i);",
    "right" : "final double d1 = gnew.getEntry(i);",
    "info" : "VariableDeclarationStatement[101540-101575]:VariableDeclarationStatement[101554-101589]"
  }, {
    "left" : "gredsq += d1 * d1;",
    "right" : "gredsq += d1 * d1;",
    "info" : "ExpressionStatement[101596-101614]:ExpressionStatement[101610-101628]"
  }, {
    "left" : "hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));",
    "right" : "hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));",
    "info" : "ExpressionStatement[101649-101713]:ExpressionStatement[101663-101727]"
  }, {
    "left" : "qred += sdec;",
    "right" : "qred += sdec;",
    "info" : "ExpressionStatement[101740-101753]:ExpressionStatement[101754-101767]"
  }, {
    "left" : "if (iact >= 0 && isav == iu)",
    "right" : "if (iact >= 0 && isav == iu)",
    "info" : "IfStatement[101766-101913]:IfStatement[101780-101927]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[101795-101913]:Block[101809-101927]"
  }, {
    "left" : "++nact;",
    "right" : "++nact;",
    "info" : "ExpressionStatement[101813-101820]:ExpressionStatement[101827-101834]"
  }, {
    "left" : "xbdi.setEntry(iact, xsav);",
    "right" : "xbdi.setEntry(iact, xsav);",
    "info" : "ExpressionStatement[101837-101863]:ExpressionStatement[101851-101877]"
  }, {
    "left" : "state = 100;",
    "right" : "state = 100;",
    "info" : "ExpressionStatement[101880-101892]:ExpressionStatement[101894-101906]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[101893-101899]:BreakStatement[101907-101913]"
  }, {
    "left" : "if (sdec > qred * .01)",
    "right" : "if (sdec > qred * .01)",
    "info" : "IfStatement[102071-102145]:IfStatement[102085-102159]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[102094-102145]:Block[102108-102159]"
  }, {
    "left" : "state = 120;",
    "right" : "state = 120;",
    "info" : "ExpressionStatement[102112-102124]:ExpressionStatement[102126-102138]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[102125-102131]:BreakStatement[102139-102145]"
  }, {
    "left" : "case 190:",
    "right" : "case 190:",
    "info" : "SwitchCase[102164-102173]:SwitchCase[102178-102187]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[102174-103515]:Block[102188-103529]"
  }, {
    "left" : "printState(190);",
    "right" : "printState(190);",
    "info" : "ExpressionStatement[102188-102204]:ExpressionStatement[102202-102218]"
  }, {
    "left" : "dsq = ZERO;",
    "right" : "dsq = ZERO;",
    "info" : "ExpressionStatement[102224-102235]:ExpressionStatement[102238-102249]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[102248-103138]:ForStatement[102262-103152]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[102276-103138]:Block[102290-103152]"
  }, {
    "left" : "final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));",
    "right" : "final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));",
    "info" : "VariableDeclarationStatement[102360-102527]:VariableDeclarationStatement[102374-102541]"
  }, {
    "left" : "newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));",
    "right" : "newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));",
    "info" : "ExpressionStatement[102544-102609]:ExpressionStatement[102558-102623]"
  }, {
    "left" : "if (xbdi.getEntry(i) == MINUS_ONE)",
    "right" : "if (xbdi.getEntry(i) == MINUS_ONE)",
    "info" : "IfStatement[102626-102751]:IfStatement[102640-102765]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[102661-102751]:Block[102675-102765]"
  }, {
    "left" : "newPoint.setEntry(i, lowerDifference.getEntry(i));",
    "right" : "newPoint.setEntry(i, lowerDifference.getEntry(i));",
    "info" : "ExpressionStatement[102683-102733]:ExpressionStatement[102697-102747]"
  }, {
    "left" : "if (xbdi.getEntry(i) == ONE)",
    "right" : "if (xbdi.getEntry(i) == ONE)",
    "info" : "IfStatement[102768-102887]:IfStatement[102782-102901]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[102797-102887]:Block[102811-102901]"
  }, {
    "left" : "newPoint.setEntry(i, upperDifference.getEntry(i));",
    "right" : "newPoint.setEntry(i, upperDifference.getEntry(i));",
    "info" : "ExpressionStatement[102819-102869]:ExpressionStatement[102833-102883]"
  }, {
    "left" : "trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "right" : "trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));",
    "info" : "ExpressionStatement[102904-102991]:ExpressionStatement[102918-103005]"
  }, {
    "left" : "final double d1 = trialStepPoint.getEntry(i);",
    "right" : "final double d1 = trialStepPoint.getEntry(i);",
    "info" : "VariableDeclarationStatement[103047-103092]:VariableDeclarationStatement[103061-103106]"
  }, {
    "left" : "dsq += d1 * d1;",
    "right" : "dsq += d1 * d1;",
    "info" : "ExpressionStatement[103109-103124]:ExpressionStatement[103123-103138]"
  }, {
    "left" : "return new double[] { dsq, crvmin };",
    "right" : "return new double[] { dsq, crvmin };",
    "info" : "ReturnStatement[103151-103187]:ReturnStatement[103165-103201]"
  }, {
    "left" : "case 210:",
    "right" : "case 210:",
    "info" : "SwitchCase[103524-103533]:SwitchCase[103538-103547]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[103534-104826]:Block[103548-104840]"
  }, {
    "left" : "printState(210);",
    "right" : "printState(210);",
    "info" : "ExpressionStatement[103548-103564]:ExpressionStatement[103562-103578]"
  }, {
    "left" : "int ih = 0;",
    "right" : "int ih = 0;",
    "info" : "VariableDeclarationStatement[103584-103595]:VariableDeclarationStatement[103598-103609]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[103608-104063]:ForStatement[103622-104077]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[103636-104063]:Block[103650-104077]"
  }, {
    "left" : "hs.setEntry(j, ZERO);",
    "right" : "hs.setEntry(j, ZERO);",
    "info" : "ExpressionStatement[103654-103675]:ExpressionStatement[103668-103689]"
  }, {
    "left" : "for (int i = 0; i <= j; i++)",
    "right" : "for (int i = 0; i <= j; i++)",
    "info" : "ForStatement[103692-104049]:ForStatement[103706-104063]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[103721-104049]:Block[103735-104063]"
  }, {
    "left" : "if (i < j)",
    "right" : "if (i < j)",
    "info" : "IfStatement[103743-103893]:IfStatement[103757-103907]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[103754-103893]:Block[103768-103907]"
  }, {
    "left" : "hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));",
    "right" : "hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));",
    "info" : "ExpressionStatement[103780-103871]:ExpressionStatement[103794-103885]"
  }, {
    "left" : "hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));",
    "right" : "hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));",
    "info" : "ExpressionStatement[103914-104005]:ExpressionStatement[103928-104019]"
  }, {
    "left" : "ih++;",
    "right" : "ih++;",
    "info" : "ExpressionStatement[104026-104031]:ExpressionStatement[104040-104045]"
  }, {
    "left" : "final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);",
    "right" : "final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);",
    "info" : "VariableDeclarationStatement[104076-104176]:VariableDeclarationStatement[104090-104190]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[104189-104511]:ForStatement[104203-104525]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[104219-104511]:Block[104233-104525]"
  }, {
    "left" : "if (modelSecondDerivativesParameters.getEntry(k) != ZERO)",
    "right" : "if (modelSecondDerivativesParameters.getEntry(k) != ZERO)",
    "info" : "IfStatement[104237-104497]:IfStatement[104251-104511]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[104295-104497]:Block[104309-104511]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[104317-104479]:ForStatement[104331-104493]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[104345-104479]:Block[104359-104493]"
  }, {
    "left" : "hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));",
    "right" : "hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));",
    "info" : "ExpressionStatement[104371-104457]:ExpressionStatement[104385-104471]"
  }, {
    "left" : "if (crvmin != ZERO)",
    "right" : "if (crvmin != ZERO)",
    "info" : "IfStatement[104524-104594]:IfStatement[104538-104608]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[104544-104594]:Block[104558-104608]"
  }, {
    "left" : "state = 50;",
    "right" : "state = 50;",
    "info" : "ExpressionStatement[104562-104573]:ExpressionStatement[104576-104587]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[104574-104580]:BreakStatement[104588-104594]"
  }, {
    "left" : "if (iterc > itcsav)",
    "right" : "if (iterc > itcsav)",
    "info" : "IfStatement[104607-104678]:IfStatement[104621-104692]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[104627-104678]:Block[104641-104692]"
  }, {
    "left" : "state = 150;",
    "right" : "state = 150;",
    "info" : "ExpressionStatement[104645-104657]:ExpressionStatement[104659-104671]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[104658-104664]:BreakStatement[104672-104678]"
  }, {
    "left" : "for (int i = 0; i < n; i++)",
    "right" : "for (int i = 0; i < n; i++)",
    "info" : "ForStatement[104691-104784]:ForStatement[104705-104798]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[104719-104784]:Block[104733-104798]"
  }, {
    "left" : "hred.setEntry(i, hs.getEntry(i));",
    "right" : "hred.setEntry(i, hs.getEntry(i));",
    "info" : "ExpressionStatement[104737-104770]:ExpressionStatement[104751-104784]"
  }, {
    "left" : "state = 120;",
    "right" : "state = 120;",
    "info" : "ExpressionStatement[104797-104809]:ExpressionStatement[104811-104823]"
  }, {
    "left" : "break;",
    "right" : "break;",
    "info" : "BreakStatement[104810-104816]:BreakStatement[104824-104830]"
  }, {
    "left" : "default:",
    "right" : "default:",
    "info" : "SwitchCase[104835-104843]:SwitchCase[104849-104857]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[104844-104947]:Block[104858-104961]"
  }, {
    "left" : "throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");",
    "right" : "throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");",
    "info" : "ThrowStatement[104858-104937]:ThrowStatement[104872-104951]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[105795-105802]:Modifier[105809-105816]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[105803-105807]:PrimitiveType[105817-105821]"
  }, {
    "left" : "update",
    "right" : "update",
    "info" : "SimpleName[105808-105814]:SimpleName[105822-105828]"
  }, {
    "left" : "double beta",
    "right" : "double beta",
    "info" : "SingleVariableDeclaration[105828-105839]:SingleVariableDeclaration[105842-105853]"
  }, {
    "left" : "double denom",
    "right" : "double denom",
    "info" : "SingleVariableDeclaration[105853-105865]:SingleVariableDeclaration[105867-105879]"
  }, {
    "left" : "int knew",
    "right" : "int knew",
    "info" : "SingleVariableDeclaration[105879-105887]:SingleVariableDeclaration[105893-105901]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[105894-109102]:Block[105908-109116]"
  }, {
    "left" : "printMethod();",
    "right" : "printMethod();",
    "info" : "ExpressionStatement[105904-105918]:ExpressionStatement[105918-105932]"
  }, {
    "left" : "final int n = currentBest.getDimension();",
    "right" : "final int n = currentBest.getDimension();",
    "info" : "VariableDeclarationStatement[105935-105976]:VariableDeclarationStatement[105949-105990]"
  }, {
    "left" : "final int npt = numberOfInterpolationPoints;",
    "right" : "final int npt = numberOfInterpolationPoints;",
    "info" : "VariableDeclarationStatement[105985-106029]:VariableDeclarationStatement[105999-106043]"
  }, {
    "left" : "final int nptm = npt - n - 1;",
    "right" : "final int nptm = npt - n - 1;",
    "info" : "VariableDeclarationStatement[106038-106067]:VariableDeclarationStatement[106052-106081]"
  }, {
    "left" : "final ArrayRealVector work = new ArrayRealVector(npt + n);",
    "right" : "final ArrayRealVector work = new ArrayRealVector(npt + n);",
    "info" : "VariableDeclarationStatement[106134-106192]:VariableDeclarationStatement[106148-106206]"
  }, {
    "left" : "double ztest = ZERO;",
    "right" : "double ztest = ZERO;",
    "info" : "VariableDeclarationStatement[106202-106222]:VariableDeclarationStatement[106216-106236]"
  }, {
    "left" : "for (int k = 0; k < npt; k++)",
    "right" : "for (int k = 0; k < npt; k++)",
    "info" : "ForStatement[106231-106439]:ForStatement[106245-106453]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[106261-106439]:Block[106275-106453]"
  }, {
    "left" : "for (int j = 0; j < nptm; j++)",
    "right" : "for (int j = 0; j < nptm; j++)",
    "info" : "ForStatement[106275-106429]:ForStatement[106289-106443]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[106306-106429]:Block[106320-106443]"
  }, {
    "left" : "ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j)));",
    "right" : "ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j)));",
    "info" : "ExpressionStatement[106357-106415]:ExpressionStatement[106371-106429]"
  }, {
    "left" : "ztest *= 1e-20;",
    "right" : "ztest *= 1e-20;",
    "info" : "ExpressionStatement[106448-106463]:ExpressionStatement[106462-106477]"
  }, {
    "left" : "for (int j = 1; j < nptm; j++)",
    "right" : "for (int j = 1; j < nptm; j++)",
    "info" : "ForStatement[106548-107456]:ForStatement[106562-107470]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[106579-107456]:Block[106593-107470]"
  }, {
    "left" : "final double d1 = zMatrix.getEntry(knew, j);",
    "right" : "final double d1 = zMatrix.getEntry(knew, j);",
    "info" : "VariableDeclarationStatement[106593-106637]:VariableDeclarationStatement[106607-106651]"
  }, {
    "left" : "if (Math.abs(d1) > ztest)",
    "right" : "if (Math.abs(d1) > ztest)",
    "info" : "IfStatement[106650-107401]:IfStatement[106664-107415]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[106676-107401]:Block[106690-107415]"
  }, {
    "left" : "final double d2 = zMatrix.getEntry(knew, 0);",
    "right" : "final double d2 = zMatrix.getEntry(knew, 0);",
    "info" : "VariableDeclarationStatement[106733-106777]:VariableDeclarationStatement[106747-106791]"
  }, {
    "left" : "final double d3 = zMatrix.getEntry(knew, j);",
    "right" : "final double d3 = zMatrix.getEntry(knew, j);",
    "info" : "VariableDeclarationStatement[106833-106877]:VariableDeclarationStatement[106847-106891]"
  }, {
    "left" : "final double d4 = Math.sqrt(d2 * d2 + d3 * d3);",
    "right" : "final double d4 = Math.sqrt(d2 * d2 + d3 * d3);",
    "info" : "VariableDeclarationStatement[106894-106941]:VariableDeclarationStatement[106908-106955]"
  }, {
    "left" : "final double d5 = zMatrix.getEntry(knew, 0) / d4;",
    "right" : "final double d5 = zMatrix.getEntry(knew, 0) / d4;",
    "info" : "VariableDeclarationStatement[106958-107007]:VariableDeclarationStatement[106972-107021]"
  }, {
    "left" : "final double d6 = zMatrix.getEntry(knew, j) / d4;",
    "right" : "final double d6 = zMatrix.getEntry(knew, j) / d4;",
    "info" : "VariableDeclarationStatement[107024-107073]:VariableDeclarationStatement[107038-107087]"
  }, {
    "left" : "for (int i = 0; i < npt; i++)",
    "right" : "for (int i = 0; i < npt; i++)",
    "info" : "ForStatement[107090-107387]:ForStatement[107104-107401]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[107120-107387]:Block[107134-107401]"
  }, {
    "left" : "final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j);",
    "right" : "final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j);",
    "info" : "VariableDeclarationStatement[107142-107218]:VariableDeclarationStatement[107156-107232]"
  }, {
    "left" : "zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0));",
    "right" : "zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0));",
    "info" : "ExpressionStatement[107239-107321]:ExpressionStatement[107253-107335]"
  }, {
    "left" : "zMatrix.setEntry(i, 0, d7);",
    "right" : "zMatrix.setEntry(i, 0, d7);",
    "info" : "ExpressionStatement[107342-107369]:ExpressionStatement[107356-107383]"
  }, {
    "left" : "zMatrix.setEntry(knew, j, ZERO);",
    "right" : "zMatrix.setEntry(knew, j, ZERO);",
    "info" : "ExpressionStatement[107414-107446]:ExpressionStatement[107428-107460]"
  }, {
    "left" : "for (int i = 0; i < npt; i++)",
    "right" : "for (int i = 0; i < npt; i++)",
    "info" : "ForStatement[107610-107733]:ForStatement[107624-107747]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[107640-107733]:Block[107654-107747]"
  }, {
    "left" : "work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0));",
    "right" : "work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0));",
    "info" : "ExpressionStatement[107654-107723]:ExpressionStatement[107668-107737]"
  }, {
    "left" : "final double alpha = work.getEntry(knew);",
    "right" : "final double alpha = work.getEntry(knew);",
    "info" : "VariableDeclarationStatement[107742-107783]:VariableDeclarationStatement[107756-107797]"
  }, {
    "left" : "final double tau = lagrangeValuesAtNewPoint.getEntry(knew);",
    "right" : "final double tau = lagrangeValuesAtNewPoint.getEntry(knew);",
    "info" : "VariableDeclarationStatement[107792-107851]:VariableDeclarationStatement[107806-107865]"
  }, {
    "left" : "lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE);",
    "right" : "lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE);",
    "info" : "ExpressionStatement[107860-107947]:ExpressionStatement[107874-107961]"
  }, {
    "left" : "final double sqrtDenom = Math.sqrt(denom);",
    "right" : "final double sqrtDenom = Math.sqrt(denom);",
    "info" : "VariableDeclarationStatement[108000-108042]:VariableDeclarationStatement[108014-108056]"
  }, {
    "left" : "final double d1 = tau / sqrtDenom;",
    "right" : "final double d1 = tau / sqrtDenom;",
    "info" : "VariableDeclarationStatement[108051-108085]:VariableDeclarationStatement[108065-108099]"
  }, {
    "left" : "final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom;",
    "right" : "final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom;",
    "info" : "VariableDeclarationStatement[108094-108150]:VariableDeclarationStatement[108108-108164]"
  }, {
    "left" : "for (int i = 0; i < npt; i++)",
    "right" : "for (int i = 0; i < npt; i++)",
    "info" : "ForStatement[108159-108335]:ForStatement[108173-108349]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[108189-108335]:Block[108203-108349]"
  }, {
    "left" : "zMatrix.setEntry(i, 0,\n                          d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i));",
    "right" : "zMatrix.setEntry(i, 0,\n                          d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i));",
    "info" : "ExpressionStatement[108203-108325]:ExpressionStatement[108217-108339]"
  }, {
    "left" : "for (int j = 0; j < n; j++)",
    "right" : "for (int j = 0; j < n; j++)",
    "info" : "ForStatement[108390-109096]:ForStatement[108404-109110]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[108418-109096]:Block[108432-109110]"
  }, {
    "left" : "final int jp = npt + j;",
    "right" : "final int jp = npt + j;",
    "info" : "VariableDeclarationStatement[108432-108455]:VariableDeclarationStatement[108446-108469]"
  }, {
    "left" : "work.setEntry(jp, bMatrix.getEntry(knew, j));",
    "right" : "work.setEntry(jp, bMatrix.getEntry(knew, j));",
    "info" : "ExpressionStatement[108468-108513]:ExpressionStatement[108482-108527]"
  }, {
    "left" : "final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom;",
    "right" : "final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom;",
    "info" : "VariableDeclarationStatement[108526-108626]:VariableDeclarationStatement[108540-108640]"
  }, {
    "left" : "final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom;",
    "right" : "final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom;",
    "info" : "VariableDeclarationStatement[108639-108739]:VariableDeclarationStatement[108653-108753]"
  }, {
    "left" : "for (int i = 0; i <= jp; i++)",
    "right" : "for (int i = 0; i <= jp; i++)",
    "info" : "ForStatement[108752-109086]:ForStatement[108766-109100]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[108782-109086]:Block[108796-109100]"
  }, {
    "left" : "bMatrix.setEntry(i, j,\n                              bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i));",
    "right" : "bMatrix.setEntry(i, j,\n                              bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i));",
    "info" : "ExpressionStatement[108800-108945]:ExpressionStatement[108814-108959]"
  }, {
    "left" : "if (i >= npt)",
    "right" : "if (i >= npt)",
    "info" : "IfStatement[108962-109072]:IfStatement[108976-109086]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[108976-109072]:Block[108990-109086]"
  }, {
    "left" : "bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j));",
    "right" : "bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j));",
    "info" : "ExpressionStatement[108998-109054]:ExpressionStatement[109012-109068]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[109336-109343]:Modifier[109350-109357]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[109344-109348]:PrimitiveType[109358-109362]"
  }, {
    "left" : "setup",
    "right" : "setup",
    "info" : "SimpleName[109349-109354]:SimpleName[109363-109368]"
  }, {
    "left" : "double[] lowerBound",
    "right" : "double[] lowerBound",
    "info" : "SingleVariableDeclaration[109355-109374]:SingleVariableDeclaration[109369-109388]"
  }, {
    "left" : "double[] upperBound",
    "right" : "double[] upperBound",
    "info" : "SingleVariableDeclaration[109399-109418]:SingleVariableDeclaration[109413-109432]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[109420-112162]:Block[109434-112176]"
  }, {
    "left" : "printMethod();",
    "right" : "printMethod();",
    "info" : "ExpressionStatement[109430-109444]:ExpressionStatement[109444-109458]"
  }, {
    "left" : "double[] init = getStartPoint();",
    "right" : "double[] init = getStartPoint();",
    "info" : "VariableDeclarationStatement[109461-109493]:VariableDeclarationStatement[109475-109507]"
  }, {
    "left" : "final int dimension = init.length;",
    "right" : "final int dimension = init.length;",
    "info" : "VariableDeclarationStatement[109502-109536]:VariableDeclarationStatement[109516-109550]"
  }, {
    "left" : "if (dimension < MINIMUM_PROBLEM_DIMENSION)",
    "right" : "if (dimension < MINIMUM_PROBLEM_DIMENSION)",
    "info" : "IfStatement[109582-109729]:IfStatement[109596-109743]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[109625-109729]:Block[109639-109743]"
  }, {
    "left" : "throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);",
    "right" : "throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);",
    "info" : "ThrowStatement[109639-109719]:ThrowStatement[109653-109733]"
  }, {
    "left" : "final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };",
    "right" : "final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };",
    "info" : "VariableDeclarationStatement[109787-109874]:VariableDeclarationStatement[109801-109888]"
  }, {
    "left" : "if (numberOfInterpolationPoints < nPointsInterval[0] ||\n            numberOfInterpolationPoints > nPointsInterval[1])",
    "right" : "if (numberOfInterpolationPoints < nPointsInterval[0] ||\n            numberOfInterpolationPoints > nPointsInterval[1])",
    "info" : "IfStatement[109883-110299]:IfStatement[109897-110313]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[110001-110299]:Block[110015-110313]"
  }, {
    "left" : "throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\n                                          numberOfInterpolationPoints,\n                                          nPointsInterval[0],\n                                          nPointsInterval[1]);",
    "right" : "throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\n                                          numberOfInterpolationPoints,\n                                          nPointsInterval[0],\n                                          nPointsInterval[1]);",
    "info" : "ThrowStatement[110015-110289]:ThrowStatement[110029-110303]"
  }, {
    "left" : "boundDifference = new double[dimension];",
    "right" : "boundDifference = new double[dimension];",
    "info" : "ExpressionStatement[110350-110390]:ExpressionStatement[110364-110404]"
  }, {
    "left" : "double requiredMinDiff = 2 * initialTrustRegionRadius;",
    "right" : "double requiredMinDiff = 2 * initialTrustRegionRadius;",
    "info" : "VariableDeclarationStatement[110400-110454]:VariableDeclarationStatement[110414-110468]"
  }, {
    "left" : "double minDiff = Double.POSITIVE_INFINITY;",
    "right" : "double minDiff = Double.POSITIVE_INFINITY;",
    "info" : "VariableDeclarationStatement[110463-110505]:VariableDeclarationStatement[110477-110519]"
  }, {
    "left" : "for (int i = 0; i < dimension; i++)",
    "right" : "for (int i = 0; i < dimension; i++)",
    "info" : "ForStatement[110514-110686]:ForStatement[110528-110700]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[110550-110686]:Block[110564-110700]"
  }, {
    "left" : "boundDifference[i] = upperBound[i] - lowerBound[i];",
    "right" : "boundDifference[i] = upperBound[i] - lowerBound[i];",
    "info" : "ExpressionStatement[110564-110615]:ExpressionStatement[110578-110629]"
  }, {
    "left" : "minDiff = Math.min(minDiff, boundDifference[i]);",
    "right" : "minDiff = Math.min(minDiff, boundDifference[i]);",
    "info" : "ExpressionStatement[110628-110676]:ExpressionStatement[110642-110690]"
  }, {
    "left" : "if (minDiff < requiredMinDiff)",
    "right" : "if (minDiff < requiredMinDiff)",
    "info" : "IfStatement[110695-110791]:IfStatement[110709-110805]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[110726-110791]:Block[110740-110805]"
  }, {
    "left" : "initialTrustRegionRadius = minDiff / 3.0;",
    "right" : "initialTrustRegionRadius = minDiff / 3.0;",
    "info" : "ExpressionStatement[110740-110781]:ExpressionStatement[110754-110795]"
  }, {
    "left" : "bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\n                                           dimension);",
    "right" : "bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\n                                           dimension);",
    "info" : "ExpressionStatement[110872-111002]:ExpressionStatement[110886-111016]"
  }, {
    "left" : "zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                           numberOfInterpolationPoints - dimension - 1);",
    "right" : "zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                           numberOfInterpolationPoints - dimension - 1);",
    "info" : "ExpressionStatement[111011-111163]:ExpressionStatement[111025-111177]"
  }, {
    "left" : "interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                                       dimension);",
    "right" : "interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                                       dimension);",
    "info" : "ExpressionStatement[111172-111314]:ExpressionStatement[111186-111328]"
  }, {
    "left" : "originShift = new ArrayRealVector(dimension);",
    "right" : "originShift = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111323-111368]:ExpressionStatement[111337-111382]"
  }, {
    "left" : "fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);",
    "right" : "fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);",
    "info" : "ExpressionStatement[111377-111451]:ExpressionStatement[111391-111465]"
  }, {
    "left" : "trustRegionCenterOffset = new ArrayRealVector(dimension);",
    "right" : "trustRegionCenterOffset = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111460-111517]:ExpressionStatement[111474-111531]"
  }, {
    "left" : "gradientAtTrustRegionCenter = new ArrayRealVector(dimension);",
    "right" : "gradientAtTrustRegionCenter = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111526-111587]:ExpressionStatement[111540-111601]"
  }, {
    "left" : "lowerDifference = new ArrayRealVector(dimension);",
    "right" : "lowerDifference = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111596-111645]:ExpressionStatement[111610-111659]"
  }, {
    "left" : "upperDifference = new ArrayRealVector(dimension);",
    "right" : "upperDifference = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111654-111703]:ExpressionStatement[111668-111717]"
  }, {
    "left" : "modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);",
    "right" : "modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);",
    "info" : "ExpressionStatement[111712-111796]:ExpressionStatement[111726-111810]"
  }, {
    "left" : "newPoint = new ArrayRealVector(dimension);",
    "right" : "newPoint = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111805-111847]:ExpressionStatement[111819-111861]"
  }, {
    "left" : "alternativeNewPoint = new ArrayRealVector(dimension);",
    "right" : "alternativeNewPoint = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111856-111909]:ExpressionStatement[111870-111923]"
  }, {
    "left" : "trialStepPoint = new ArrayRealVector(dimension);",
    "right" : "trialStepPoint = new ArrayRealVector(dimension);",
    "info" : "ExpressionStatement[111918-111966]:ExpressionStatement[111932-111980]"
  }, {
    "left" : "lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);",
    "right" : "lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);",
    "info" : "ExpressionStatement[111975-112063]:ExpressionStatement[111989-112077]"
  }, {
    "left" : "modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);",
    "right" : "modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);",
    "info" : "ExpressionStatement[112072-112156]:ExpressionStatement[112086-112170]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[112405-112412]:Modifier[112419-112426]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[112413-112419]:Modifier[112427-112433]"
  }, {
    "left" : "double[]",
    "right" : "double[]",
    "info" : "ArrayType[112420-112428]:ArrayType[112434-112442]"
  }, {
    "left" : "fillNewArray",
    "right" : "fillNewArray",
    "info" : "SimpleName[112429-112441]:SimpleName[112443-112455]"
  }, {
    "left" : "int n",
    "right" : "int n",
    "info" : "SingleVariableDeclaration[112442-112447]:SingleVariableDeclaration[112456-112461]"
  }, {
    "left" : "double value",
    "right" : "double value",
    "info" : "SingleVariableDeclaration[112490-112502]:SingleVariableDeclaration[112504-112516]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[112504-112599]:Block[112518-112613]"
  }, {
    "left" : "double[] ds = new double[n];",
    "right" : "double[] ds = new double[n];",
    "info" : "VariableDeclarationStatement[112514-112542]:VariableDeclarationStatement[112528-112556]"
  }, {
    "left" : "Arrays.fill(ds, value);",
    "right" : "Arrays.fill(ds, value);",
    "info" : "ExpressionStatement[112551-112574]:ExpressionStatement[112565-112588]"
  }, {
    "left" : "return ds;",
    "right" : "return ds;",
    "info" : "ReturnStatement[112583-112593]:ReturnStatement[112597-112607]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[112656-112663]:Modifier[112670-112677]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[112664-112670]:Modifier[112678-112684]"
  }, {
    "left" : "String",
    "right" : "String",
    "info" : "SimpleType[112671-112677]:SimpleType[112685-112691]"
  }, {
    "left" : "caller",
    "right" : "caller",
    "info" : "SimpleName[112678-112684]:SimpleName[112692-112698]"
  }, {
    "left" : "int n",
    "right" : "int n",
    "info" : "SingleVariableDeclaration[112685-112690]:SingleVariableDeclaration[112699-112704]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[112692-112932]:Block[112706-112946]"
  }, {
    "left" : "final Throwable t = new Throwable();",
    "right" : "final Throwable t = new Throwable();",
    "info" : "VariableDeclarationStatement[112702-112738]:VariableDeclarationStatement[112716-112752]"
  }, {
    "left" : "final StackTraceElement[] elements = t.getStackTrace();",
    "right" : "final StackTraceElement[] elements = t.getStackTrace();",
    "info" : "VariableDeclarationStatement[112747-112802]:VariableDeclarationStatement[112761-112816]"
  }, {
    "left" : "final StackTraceElement e = elements[n];",
    "right" : "final StackTraceElement e = elements[n];",
    "info" : "VariableDeclarationStatement[112811-112851]:VariableDeclarationStatement[112825-112865]"
  }, {
    "left" : "return e.getMethodName() + \" (at line \" + e.getLineNumber() + \")\";",
    "right" : "return e.getMethodName() + \" (at line \" + e.getLineNumber() + \")\";",
    "info" : "ReturnStatement[112860-112926]:ReturnStatement[112874-112940]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[112988-112995]:Modifier[113002-113009]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[112996-113002]:Modifier[113010-113016]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[113003-113007]:PrimitiveType[113017-113021]"
  }, {
    "left" : "printState",
    "right" : "printState",
    "info" : "SimpleName[113008-113018]:SimpleName[113022-113032]"
  }, {
    "left" : "int s",
    "right" : "int s",
    "info" : "SingleVariableDeclaration[113019-113024]:SingleVariableDeclaration[113033-113038]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[113026-113099]:Block[113040-113113]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[113155-113162]:Modifier[113169-113176]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[113163-113169]:Modifier[113177-113183]"
  }, {
    "left" : "void",
    "right" : "void",
    "info" : "PrimitiveType[113170-113174]:PrimitiveType[113184-113188]"
  }, {
    "left" : "printMethod",
    "right" : "printMethod",
    "info" : "SimpleName[113175-113186]:SimpleName[113189-113200]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[113189-113245]:Block[113203-113259]"
  }, {
    "left" : "private",
    "right" : "private",
    "info" : "Modifier[113425-113432]:Modifier[113439-113446]"
  }, {
    "left" : "static",
    "right" : "static",
    "info" : "Modifier[113433-113439]:Modifier[113447-113453]"
  }, {
    "left" : "class",
    "right" : "class",
    "info" : "TYPE_DECLARATION_KIND[113440-113445]:TYPE_DECLARATION_KIND[113454-113459]"
  }, {
    "left" : "PathIsExploredException",
    "right" : "PathIsExploredException",
    "info" : "SimpleName[113709-113732]:SimpleName[113723-113746]"
  }, {
    "left" : "{}",
    "right" : "{}",
    "info" : "Block[113735-113817]:Block[113749-113831]"
  }, {
    "left" : "super(PATH_IS_EXPLORED + \" \" + BOBYQAOptimizer.caller(3));",
    "right" : "super(PATH_IS_EXPLORED + \" \" + BOBYQAOptimizer.caller(3));",
    "info" : "SuperConstructorInvocation[113749-113807]:SuperConstructorInvocation[113763-113821]"
  } ]
}