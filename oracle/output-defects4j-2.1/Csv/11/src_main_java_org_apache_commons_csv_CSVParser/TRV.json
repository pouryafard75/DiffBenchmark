{
  "intraFileMappings" : {
    "matchedElements" : [
 {
      "left" : "public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException",
      "right" : "public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException",
      "info" : "MethodDeclaration[4493-5712]:MethodDeclaration[4493-5712]"
    }, {
      "left" : "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
      "right" : "public static CSVParser parse(final String string, final CSVFormat format) throws IOException",
      "info" : "MethodDeclaration[5718-6462]:MethodDeclaration[5718-6462]"
    }, {
      "left" : "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
      "right" : "public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException",
      "info" : "MethodDeclaration[6468-7553]:MethodDeclaration[6468-7553]"
    }, {
      "left" : "private final CSVFormat format;",
      "right" : "private final CSVFormat format;",
      "info" : "FieldDeclaration[7618-7649]:FieldDeclaration[7618-7649]"
    }, {
      "left" : "private final Map<String, Integer> headerMap;",
      "right" : "private final Map<String, Integer> headerMap;",
      "info" : "FieldDeclaration[7655-7755]:FieldDeclaration[7655-7755]"
    }, {
      "left" : "private final Lexer lexer;",
      "right" : "private final Lexer lexer;",
      "info" : "FieldDeclaration[7761-7787]:FieldDeclaration[7761-7787]"
    }, {
      "left" : "private final List<String> record = new ArrayList<String>();",
      "right" : "private final List<String> record = new ArrayList<String>();",
      "info" : "FieldDeclaration[7793-7931]:FieldDeclaration[7793-7931]"
    }, {
      "left" : "private long recordNumber;",
      "right" : "private long recordNumber;",
      "info" : "FieldDeclaration[7937-7963]:FieldDeclaration[7937-7963]"
    }, {
      "left" : "private final Token reusableToken = new Token();",
      "right" : "private final Token reusableToken = new Token();",
      "info" : "FieldDeclaration[7969-8017]:FieldDeclaration[7969-8017]"
    }, {
      "left" : "public CSVParser(final Reader reader, final CSVFormat format) throws IOException",
      "right" : "public CSVParser(final Reader reader, final CSVFormat format) throws IOException",
      "info" : "MethodDeclaration[8023-9092]:MethodDeclaration[8023-9092]"
    }, {
      "left" : "private void addRecordValue()",
      "right" : "private void addRecordValue()",
      "info" : "MethodDeclaration[9098-9443]:MethodDeclaration[9098-9443]"
    }, {
      "left" : "public void close() throws IOException",
      "right" : "public void close() throws IOException",
      "info" : "MethodDeclaration[9449-9688]:MethodDeclaration[9449-9688]"
    }, {
      "left" : "public long getCurrentLineNumber()",
      "right" : "public long getCurrentLineNumber()",
      "info" : "MethodDeclaration[9694-10079]:MethodDeclaration[9694-10079]"
    }, {
      "left" : "public Map<String, Integer> getHeaderMap()",
      "right" : "public Map<String, Integer> getHeaderMap()",
      "info" : "MethodDeclaration[10085-10489]:MethodDeclaration[10085-10489]"
    }, {
      "left" : "public long getRecordNumber()",
      "right" : "public long getRecordNumber()",
      "info" : "MethodDeclaration[10495-10859]:MethodDeclaration[10495-10859]"
    }, {
      "left" : "public List<CSVRecord> getRecords() throws IOException",
      "right" : "public List<CSVRecord> getRecords() throws IOException",
      "info" : "MethodDeclaration[10865-11396]:MethodDeclaration[10865-11396]"
    }, {
      "left" : "public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException",
      "right" : "public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException",
      "info" : "MethodDeclaration[11402-12178]:MethodDeclaration[11402-12178]"
    }, {
      "left" : "public boolean isClosed()",
      "right" : "public boolean isClosed()",
      "info" : "MethodDeclaration[14056-14127]:MethodDeclaration[14074-14145]"
    }, {
      "left" : "public Iterator<CSVRecord> iterator()",
      "right" : "public Iterator<CSVRecord> iterator()",
      "info" : "MethodDeclaration[14133-15922]:MethodDeclaration[14151-15940]"
    }, {
      "left" : "private CSVRecord current;",
      "right" : "private CSVRecord current;",
      "info" : "FieldDeclaration[14494-14520]:FieldDeclaration[14512-14538]"
    }, {
      "left" : "private CSVRecord getNextRecord()",
      "right" : "private CSVRecord getNextRecord()",
      "info" : "MethodDeclaration[14534-14848]:MethodDeclaration[14552-14866]"
    }, {
      "left" : "public boolean hasNext()",
      "right" : "public boolean hasNext()",
      "info" : "MethodDeclaration[14862-15168]:MethodDeclaration[14880-15186]"
    }, {
      "left" : "public CSVRecord next()",
      "right" : "public CSVRecord next()",
      "info" : "MethodDeclaration[15182-15796]:MethodDeclaration[15200-15814]"
    }, {
      "left" : "public void remove()",
      "right" : "public void remove()",
      "info" : "MethodDeclaration[15810-15905]:MethodDeclaration[15828-15923]"
    }, {
      "left" : "CSVRecord nextRecord() throws IOException",
      "right" : "CSVRecord nextRecord() throws IOException",
      "info" : "MethodDeclaration[15928-17887]:MethodDeclaration[15946-17905]"
    } ],
    "mappings" : [
 {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[5474-5712]:Block[5474-5712]"
    }, {
      "left" : "Assertions.notNull(file, \"file\");",
      "right" : "Assertions.notNull(file, \"file\");",
      "info" : "ExpressionStatement[5484-5517]:ExpressionStatement[5484-5517]"
    }, {
      "left" : "Assertions.notNull(format, \"format\");",
      "right" : "Assertions.notNull(format, \"format\");",
      "info" : "ExpressionStatement[5526-5563]:ExpressionStatement[5526-5563]"
    }, {
      "left" : "return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);",
      "right" : "return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);",
      "info" : "ReturnStatement[5618-5706]:ReturnStatement[5618-5706]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[6298-6462]:Block[6298-6462]"
    }, {
      "left" : "Assertions.notNull(string, \"string\");",
      "right" : "Assertions.notNull(string, \"string\");",
      "info" : "ExpressionStatement[6308-6345]:ExpressionStatement[6308-6345]"
    }, {
      "left" : "Assertions.notNull(format, \"format\");",
      "right" : "Assertions.notNull(format, \"format\");",
      "info" : "ExpressionStatement[6354-6391]:ExpressionStatement[6354-6391]"
    }, {
      "left" : "return new CSVParser(new StringReader(string), format);",
      "right" : "return new CSVParser(new StringReader(string), format);",
      "info" : "ReturnStatement[6401-6456]:ReturnStatement[6401-6456]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[7323-7553]:Block[7323-7553]"
    }, {
      "left" : "Assertions.notNull(url, \"url\");",
      "right" : "Assertions.notNull(url, \"url\");",
      "info" : "ExpressionStatement[7333-7364]:ExpressionStatement[7333-7364]"
    }, {
      "left" : "Assertions.notNull(charset, \"charset\");",
      "right" : "Assertions.notNull(charset, \"charset\");",
      "info" : "ExpressionStatement[7373-7412]:ExpressionStatement[7373-7412]"
    }, {
      "left" : "Assertions.notNull(format, \"format\");",
      "right" : "Assertions.notNull(format, \"format\");",
      "info" : "ExpressionStatement[7421-7458]:ExpressionStatement[7421-7458]"
    }, {
      "left" : "return new CSVParser(new InputStreamReader(url.openStream(), charset), format);",
      "right" : "return new CSVParser(new InputStreamReader(url.openStream(), charset), format);",
      "info" : "ReturnStatement[7468-7547]:ReturnStatement[7468-7547]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[8836-9092]:Block[8836-9092]"
    }, {
      "left" : "Assertions.notNull(reader, \"reader\");",
      "right" : "Assertions.notNull(reader, \"reader\");",
      "info" : "ExpressionStatement[8846-8883]:ExpressionStatement[8846-8883]"
    }, {
      "left" : "Assertions.notNull(format, \"format\");",
      "right" : "Assertions.notNull(format, \"format\");",
      "info" : "ExpressionStatement[8892-8929]:ExpressionStatement[8892-8929]"
    }, {
      "left" : "this.format = format;",
      "right" : "this.format = format;",
      "info" : "ExpressionStatement[8939-8960]:ExpressionStatement[8939-8960]"
    }, {
      "left" : "this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
      "right" : "this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));",
      "info" : "ExpressionStatement[8969-9036]:ExpressionStatement[8969-9036]"
    }, {
      "left" : "this.headerMap = this.initializeHeader();",
      "right" : "this.headerMap = this.initializeHeader();",
      "info" : "ExpressionStatement[9045-9086]:ExpressionStatement[9045-9086]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9128-9443]:Block[9128-9443]"
    }, {
      "left" : "final String input = this.reusableToken.content.toString();",
      "right" : "final String input = this.reusableToken.content.toString();",
      "info" : "VariableDeclarationStatement[9138-9197]:VariableDeclarationStatement[9138-9197]"
    }, {
      "left" : "final String nullString = this.format.getNullString();",
      "right" : "final String nullString = this.format.getNullString();",
      "info" : "VariableDeclarationStatement[9206-9260]:VariableDeclarationStatement[9206-9260]"
    }, {
      "left" : "if (nullString == null)",
      "right" : "if (nullString == null)",
      "info" : "IfStatement[9269-9437]:IfStatement[9269-9437]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9293-9340]:Block[9293-9340]"
    }, {
      "left" : "this.record.add(input);",
      "right" : "this.record.add(input);",
      "info" : "ExpressionStatement[9307-9330]:ExpressionStatement[9307-9330]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9346-9437]:Block[9346-9437]"
    }, {
      "left" : "this.record.add(input.equalsIgnoreCase(nullString) ? null : input);",
      "right" : "this.record.add(input.equalsIgnoreCase(nullString) ? null : input);",
      "info" : "ExpressionStatement[9360-9427]:ExpressionStatement[9360-9427]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9605-9688]:Block[9605-9688]"
    }, {
      "left" : "if (this.lexer != null)",
      "right" : "if (this.lexer != null)",
      "info" : "IfStatement[9615-9682]:IfStatement[9615-9682]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[9639-9682]:Block[9639-9682]"
    }, {
      "left" : "this.lexer.close();",
      "right" : "this.lexer.close();",
      "info" : "ExpressionStatement[9653-9672]:ExpressionStatement[9653-9672]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10022-10079]:Block[10022-10079]"
    }, {
      "left" : "return this.lexer.getCurrentLineNumber();",
      "right" : "return this.lexer.getCurrentLineNumber();",
      "info" : "ReturnStatement[10032-10073]:ReturnStatement[10032-10073]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10383-10489]:Block[10383-10489]"
    }, {
      "left" : "return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);",
      "right" : "return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);",
      "info" : "ReturnStatement[10393-10483]:ReturnStatement[10393-10483]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[10818-10859]:Block[10818-10859]"
    }, {
      "left" : "return this.recordNumber;",
      "right" : "return this.recordNumber;",
      "info" : "ReturnStatement[10828-10853]:ReturnStatement[10828-10853]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[11334-11396]:Block[11334-11396]"
    }, {
      "left" : "return getRecords(new ArrayList<CSVRecord>());",
      "right" : "return getRecords(new ArrayList<CSVRecord>());",
      "info" : "ReturnStatement[11344-11390]:ReturnStatement[11344-11390]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12032-12178]:Block[12032-12178]"
    }, {
      "left" : "CSVRecord rec;",
      "right" : "CSVRecord rec;",
      "info" : "VariableDeclarationStatement[12042-12056]:VariableDeclarationStatement[12042-12056]"
    }, {
      "left" : "while ((rec = this.nextRecord()) != null)",
      "right" : "while ((rec = this.nextRecord()) != null)",
      "info" : "WhileStatement[12065-12148]:WhileStatement[12065-12148]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[12107-12148]:Block[12107-12148]"
    }, {
      "left" : "records.add(rec);",
      "right" : "records.add(rec);",
      "info" : "ExpressionStatement[12121-12138]:ExpressionStatement[12121-12138]"
    }, {
      "left" : "return records;",
      "right" : "return records;",
      "info" : "ReturnStatement[12157-12172]:ReturnStatement[12157-12172]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14082-14127]:Block[14100-14145]"
    }, {
      "left" : "return this.lexer.isClosed();",
      "right" : "return this.lexer.isClosed();",
      "info" : "ReturnStatement[14092-14121]:ReturnStatement[14110-14139]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14437-15922]:Block[14455-15940]"
    }, {
      "left" : "return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };",
      "right" : "return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };",
      "info" : "ReturnStatement[14447-15916]:ReturnStatement[14465-15934]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14568-14848]:Block[14586-14866]"
    }, {
      "left" : "try{...}",
      "right" : "try{...}",
      "info" : "TryStatement[14586-14834]:TryStatement[14604-14852]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14590-14665]:Block[14608-14683]"
    }, {
      "left" : "return CSVParser.this.nextRecord();",
      "right" : "return CSVParser.this.nextRecord();",
      "info" : "ReturnStatement[14612-14647]:ReturnStatement[14630-14665]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14694-14834]:Block[14712-14852]"
    }, {
      "left" : "throw new RuntimeException(e);",
      "right" : "throw new RuntimeException(e);",
      "info" : "ThrowStatement[14786-14816]:ThrowStatement[14804-14834]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14887-15168]:Block[14905-15186]"
    }, {
      "left" : "if (CSVParser.this.isClosed())",
      "right" : "if (CSVParser.this.isClosed())",
      "info" : "IfStatement[14905-14989]:IfStatement[14923-15007]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[14936-14989]:Block[14954-15007]"
    }, {
      "left" : "return false;",
      "right" : "return false;",
      "info" : "ReturnStatement[14958-14971]:ReturnStatement[14976-14989]"
    }, {
      "left" : "if (this.current == null)",
      "right" : "if (this.current == null)",
      "info" : "IfStatement[15006-15108]:IfStatement[15024-15126]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15032-15108]:Block[15050-15126]"
    }, {
      "left" : "this.current = this.getNextRecord();",
      "right" : "this.current = this.getNextRecord();",
      "info" : "ExpressionStatement[15054-15090]:ExpressionStatement[15072-15108]"
    }, {
      "left" : "return this.current != null;",
      "right" : "return this.current != null;",
      "info" : "ReturnStatement[15126-15154]:ReturnStatement[15144-15172]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15206-15796]:Block[15224-15814]"
    }, {
      "left" : "if (CSVParser.this.isClosed())",
      "right" : "if (CSVParser.this.isClosed())",
      "info" : "IfStatement[15224-15357]:IfStatement[15242-15375]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15255-15357]:Block[15273-15375]"
    }, {
      "left" : "throw new NoSuchElementException(\"CSVParser has been closed\");",
      "right" : "throw new NoSuchElementException(\"CSVParser has been closed\");",
      "info" : "ThrowStatement[15277-15339]:ThrowStatement[15295-15357]"
    }, {
      "left" : "CSVRecord next = this.current;",
      "right" : "CSVRecord next = this.current;",
      "info" : "VariableDeclarationStatement[15374-15404]:VariableDeclarationStatement[15392-15422]"
    }, {
      "left" : "this.current = null;",
      "right" : "this.current = null;",
      "info" : "ExpressionStatement[15421-15441]:ExpressionStatement[15439-15459]"
    }, {
      "left" : "if (next == null)",
      "right" : "if (next == null)",
      "info" : "IfStatement[15459-15752]:IfStatement[15477-15770]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15477-15752]:Block[15495-15770]"
    }, {
      "left" : "next = this.getNextRecord();",
      "right" : "next = this.getNextRecord();",
      "info" : "ExpressionStatement[15553-15581]:ExpressionStatement[15571-15599]"
    }, {
      "left" : "if (next == null)",
      "right" : "if (next == null)",
      "info" : "IfStatement[15602-15734]:IfStatement[15620-15752]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15620-15734]:Block[15638-15752]"
    }, {
      "left" : "throw new NoSuchElementException(\"No more CSV records available\");",
      "right" : "throw new NoSuchElementException(\"No more CSV records available\");",
      "info" : "ThrowStatement[15646-15712]:ThrowStatement[15664-15730]"
    }, {
      "left" : "return next;",
      "right" : "return next;",
      "info" : "ReturnStatement[15770-15782]:ReturnStatement[15788-15800]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[15831-15905]:Block[15849-15923]"
    }, {
      "left" : "throw new UnsupportedOperationException();",
      "right" : "throw new UnsupportedOperationException();",
      "info" : "ThrowStatement[15849-15891]:ThrowStatement[15867-15909]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16252-17887]:Block[16270-17905]"
    }, {
      "left" : "CSVRecord result = null;",
      "right" : "CSVRecord result = null;",
      "info" : "VariableDeclarationStatement[16262-16286]:VariableDeclarationStatement[16280-16304]"
    }, {
      "left" : "this.record.clear();",
      "right" : "this.record.clear();",
      "info" : "ExpressionStatement[16295-16315]:ExpressionStatement[16313-16333]"
    }, {
      "left" : "StringBuilder sb = null;",
      "right" : "StringBuilder sb = null;",
      "info" : "VariableDeclarationStatement[16324-16348]:VariableDeclarationStatement[16342-16366]"
    }, {
      "left" : "do{...}",
      "right" : "do{...}",
      "info" : "DoStatement[16357-17553]:DoStatement[16375-17571]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16360-17511]:Block[16378-17529]"
    }, {
      "left" : "this.reusableToken.reset();",
      "right" : "this.reusableToken.reset();",
      "info" : "ExpressionStatement[16374-16401]:ExpressionStatement[16392-16419]"
    }, {
      "left" : "this.lexer.nextToken(this.reusableToken);",
      "right" : "this.lexer.nextToken(this.reusableToken);",
      "info" : "ExpressionStatement[16414-16455]:ExpressionStatement[16432-16473]"
    }, {
      "left" : "switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }",
      "right" : "switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }",
      "info" : "SwitchStatement[16468-17501]:SwitchStatement[16486-17519]"
    }, {
      "left" : "case TOKEN:",
      "right" : "case TOKEN:",
      "info" : "SwitchCase[16515-16526]:SwitchCase[16533-16544]"
    }, {
      "left" : "this.addRecordValue();",
      "right" : "this.addRecordValue();",
      "info" : "ExpressionStatement[16543-16565]:ExpressionStatement[16561-16583]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16582-16588]:BreakStatement[16600-16606]"
    }, {
      "left" : "case EORECORD:",
      "right" : "case EORECORD:",
      "info" : "SwitchCase[16601-16615]:SwitchCase[16619-16633]"
    }, {
      "left" : "this.addRecordValue();",
      "right" : "this.addRecordValue();",
      "info" : "ExpressionStatement[16632-16654]:ExpressionStatement[16650-16672]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16671-16677]:BreakStatement[16689-16695]"
    }, {
      "left" : "case EOF:",
      "right" : "case EOF:",
      "info" : "SwitchCase[16690-16699]:SwitchCase[16708-16717]"
    }, {
      "left" : "if (this.reusableToken.isReady)",
      "right" : "if (this.reusableToken.isReady)",
      "info" : "IfStatement[16716-16810]:IfStatement[16734-16828]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[16748-16810]:Block[16766-16828]"
    }, {
      "left" : "this.addRecordValue();",
      "right" : "this.addRecordValue();",
      "info" : "ExpressionStatement[16770-16792]:ExpressionStatement[16788-16810]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[16827-16833]:BreakStatement[16845-16851]"
    }, {
      "left" : "case INVALID:",
      "right" : "case INVALID:",
      "info" : "SwitchCase[16846-16859]:SwitchCase[16864-16877]"
    }, {
      "left" : "throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");",
      "right" : "throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");",
      "info" : "ThrowStatement[16876-16967]:ThrowStatement[16894-16985]"
    }, {
      "left" : "case COMMENT:",
      "right" : "case COMMENT:",
      "info" : "SwitchCase[16980-16993]:SwitchCase[16998-17011]"
    }, {
      "left" : "if (sb == null)",
      "right" : "if (sb == null)",
      "info" : "IfStatement[17031-17215]:IfStatement[17049-17233]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17047-17145]:Block[17065-17163]"
    }, {
      "left" : "sb = new StringBuilder();",
      "right" : "sb = new StringBuilder();",
      "info" : "ExpressionStatement[17102-17127]:ExpressionStatement[17120-17145]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17151-17215]:Block[17169-17233]"
    }, {
      "left" : "sb.append(Constants.LF);",
      "right" : "sb.append(Constants.LF);",
      "info" : "ExpressionStatement[17173-17197]:ExpressionStatement[17191-17215]"
    }, {
      "left" : "sb.append(this.reusableToken.content);",
      "right" : "sb.append(this.reusableToken.content);",
      "info" : "ExpressionStatement[17232-17270]:ExpressionStatement[17250-17288]"
    }, {
      "left" : "this.reusableToken.type = TOKEN;",
      "right" : "this.reusableToken.type = TOKEN;",
      "info" : "ExpressionStatement[17287-17319]:ExpressionStatement[17305-17337]"
    }, {
      "left" : "break;",
      "right" : "break;",
      "info" : "BreakStatement[17358-17364]:BreakStatement[17376-17382]"
    }, {
      "left" : "default:",
      "right" : "default:",
      "info" : "SwitchCase[17377-17385]:SwitchCase[17395-17403]"
    }, {
      "left" : "throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);",
      "right" : "throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);",
      "info" : "ThrowStatement[17402-17487]:ThrowStatement[17420-17505]"
    }, {
      "left" : "if (!this.record.isEmpty())",
      "right" : "if (!this.record.isEmpty())",
      "info" : "IfStatement[17563-17858]:IfStatement[17581-17876]"
    }, {
      "left" : "{}",
      "right" : "{}",
      "info" : "Block[17591-17858]:Block[17609-17876]"
    }, {
      "left" : "this.recordNumber++;",
      "right" : "this.recordNumber++;",
      "info" : "ExpressionStatement[17605-17625]:ExpressionStatement[17623-17643]"
    }, {
      "left" : "final String comment = sb == null ? null : sb.toString();",
      "right" : "final String comment = sb == null ? null : sb.toString();",
      "info" : "VariableDeclarationStatement[17638-17695]:VariableDeclarationStatement[17656-17713]"
    }, {
      "left" : "result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);",
      "right" : "result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);",
      "info" : "ExpressionStatement[17708-17848]:ExpressionStatement[17726-17866]"
    }, {
      "left" : "return result;",
      "right" : "return result;",
      "info" : "ReturnStatement[17867-17881]:ReturnStatement[17885-17899]"
    } ]
  },
  "interFileMappings" : { }
}